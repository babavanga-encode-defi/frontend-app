"use client";
var e5 = Object.defineProperty;
var t5 = (e, t, r) => t in e ? e5(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Le = (e, t, r) => t5(e, typeof t != "symbol" ? t + "" : t, r);
import { createContext as r5, useCallback as rr, useSyncExternalStore as n5, useContext as i5, useMemo as Ya, useState as o5, useEffect as s5 } from "react";
import { jsx as S, jsxs as Ne } from "react/jsx-runtime";
function a5(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(n, i);
          o && Object.defineProperty(e, i, o.get ? o : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
let rf = Symbol("clean"), Nr = [], Mn = 0;
const Ta = 4;
let Ja = 0, sc = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let o = Mn + Ta; o < Nr.length; )
          Nr[o] === n ? Nr.splice(o, Ta) : o += Ta;
        let i = t.indexOf(n);
        ~i && (t.splice(i, 1), --r.lc || r.off());
      };
    },
    notify(n, i) {
      Ja++;
      let o = !Nr.length;
      for (let s of t)
        Nr.push(
          s,
          r.value,
          n,
          i
        );
      if (o) {
        for (Mn = 0; Mn < Nr.length; Mn += Ta)
          Nr[Mn](
            Nr[Mn + 1],
            Nr[Mn + 2],
            Nr[Mn + 3]
          );
        Nr.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let i = r.value;
      i !== n && (r.value = n, r.notify(i));
    },
    subscribe(n) {
      let i = r.listen(n);
      return n(r.value), i;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[rf] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
const c5 = 3, u5 = 5, Eo = 6, Ca = 10;
let V1 = (e, t, r, n) => (e.events = e.events || {}, e.events[r + Ca] || (e.events[r + Ca] = n((i) => {
  e.events[r].reduceRight((o, s) => (s(o), o), {
    shared: {},
    ...i
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let i = e.events[r], o = i.indexOf(t);
  i.splice(o, 1), i.length || (delete e.events[r], e.events[r + Ca](), delete e.events[r + Ca]);
}), l5 = (e, t) => V1(e, t, c5, (r) => {
  let n = e.notify;
  return e.notify = (i, o) => {
    let s;
    if (r({ abort: () => {
      s = !0;
    }, changed: o, oldValue: i }), !s) return n(i, o);
  }, () => {
    e.notify = n;
  };
}), f5 = 1e3, W1 = (e, t) => V1(e, (n) => {
  let i = t(n);
  i && e.events[Eo].push(i);
}, u5, (n) => {
  let i = e.listen;
  e.listen = (...s) => (!e.lc && !e.active && (e.active = !0, n()), i(...s));
  let o = e.off;
  if (e.events[Eo] = [], e.off = () => {
    o(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = !1;
        for (let s of e.events[Eo]) s();
        e.events[Eo] = [];
      }
    }, f5);
  }, process.env.NODE_ENV !== "production") {
    let s = e[rf];
    e[rf] = () => {
      for (let a of e.events[Eo]) a();
      e.events[Eo] = [], e.active = !1, s();
    };
  }
  return () => {
    e.listen = i, e.off = o;
  };
}), d5 = (e, t, r) => {
  Array.isArray(e) || (e = [e]);
  let n, i, o = () => {
    if (i === Ja) return;
    i = Ja;
    let f = e.map((l) => l.get());
    if (!n || f.some((l, h) => l !== n[h])) {
      n = f;
      let l = t(...f);
      l && l.then && l.t ? l.then((h) => {
        n === f && s.set(h);
      }) : (s.set(l), i = Ja);
    }
  }, s = sc(void 0), a = s.get;
  s.get = () => (o(), a());
  let c, u = () => {
    clearTimeout(c), c = setTimeout(o);
  };
  return W1(s, () => {
    let f = e.map((l) => l.listen(u));
    return o(), () => {
      for (let l of f) l();
    };
  }), s;
}, h5 = (e, t) => d5(e, t), G1 = (e) => {
  e.listen(() => {
  });
};
function lr(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((i, o, s) => {
    n.has(s) && r(i, o, s);
  });
}
let Z1 = (e = {}) => {
  let t = sc(e);
  return t.setKey = function(r, n) {
    let i = t.value;
    typeof n > "u" && r in t.value ? (t.value = { ...t.value }, delete t.value[r], t.notify(i, r)) : t.value[r] !== n && (t.value = {
      ...t.value,
      [r]: n
    }, t.notify(i, r));
  }, t;
};
const ji = "oyl", gi = "unisat", Ri = "glittr", mi = "xverse", bi = "phantom", Di = "leather", kn = "magic-eden", Mi = "okx", Ki = "wizz", yi = "orange", wi = "op_net", vi = "sparrow", Ss = "p2tr", p5 = "p2pkh", g5 = "p2sh-p2wpkh", nf = "p2wpkh", w$ = "p2psh", m5 = "p2wsh", X1 = "p2sh";
var Xe;
(function(e) {
  e.LEATHER = "leather", e.MAGIC_EDEN = "magic-eden", e.OKX = "okx", e.OP_NET = "op_net", e.ORANGE = "orange", e.OYL = "oyl", e.SPARROW = "sparrow", e.PHANTOM = "phantom", e.UNISAT = "unisat", e.WIZZ = "wizz", e.XVERSE = "xverse", e.GLITTR = "glittr";
})(Xe || (Xe = {}));
const v$ = {
  [Xe.LEATHER]: {
    name: Xe.LEATHER,
    url: "https://leather.io/install-extension"
  },
  [Xe.MAGIC_EDEN]: {
    name: Xe.MAGIC_EDEN,
    url: "https://wallet.magiceden.io/"
  },
  [Xe.OKX]: {
    name: Xe.OKX,
    url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge"
  },
  [Xe.OP_NET]: {
    name: Xe.OP_NET,
    url: "https://opnet.org/"
  },
  [Xe.ORANGE]: {
    name: Xe.ORANGE,
    url: "https://www.orangewallet.com/"
  },
  [Xe.OYL]: {
    name: Xe.OYL,
    url: "https://www.oyl.io/#get-wallet"
  },
  [Xe.PHANTOM]: {
    name: Xe.PHANTOM,
    url: "https://phantom.app/download"
  },
  [Xe.SPARROW]: {
    name: Xe.SPARROW,
    url: "https://sparrowwallet.com/"
  },
  [Xe.UNISAT]: {
    name: Xe.UNISAT,
    url: "https://unisat.io/download"
  },
  [Xe.WIZZ]: {
    name: Xe.WIZZ,
    url: "https://wizzwallet.io/#extension"
  },
  [Xe.XVERSE]: {
    name: Xe.XVERSE,
    url: "https://www.xverse.app/download"
  },
  [Xe.GLITTR]: {
    name: Xe.GLITTR,
    url: "https://glittr.fi"
  }
}, il = "defaultWallet", Gr = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
}, b5 = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function y5(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return !1;
  const t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
  const r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function w5(e) {
  if (e.length < 8) throw new Error("DER sequence length is too short");
  if (e.length > 72) throw new Error("DER sequence length is too long");
  if (e[0] !== 48) throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2)
    throw new Error("DER sequence length is invalid");
  if (e[2] !== 2) throw new Error("Expected DER integer");
  const t = e[3];
  if (t === 0) throw new Error("R length is zero");
  if (5 + t >= e.length) throw new Error("R length is too long");
  if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
  const r = e[5 + t];
  if (r === 0) throw new Error("S length is zero");
  if (6 + t + r !== e.length) throw new Error("S length is invalid");
  if (e[4] & 128) throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128) throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.slice(4, 4 + t),
    s: e.slice(6 + t)
  };
}
function v5(e, t) {
  const r = e.length, n = t.length;
  if (r === 0) throw new Error("R length is zero");
  if (n === 0) throw new Error("S length is zero");
  if (r > 33) throw new Error("R length is too long");
  if (n > 33) throw new Error("S length is too long");
  if (e[0] & 128) throw new Error("R value is negative");
  if (t[0] & 128) throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128))
    throw new Error("R value excessively padded");
  if (n > 1 && t[0] === 0 && !(t[1] & 128))
    throw new Error("S value excessively padded");
  const i = new Uint8Array(6 + r + n);
  return i[0] = 48, i[1] = i.length - 2, i[2] = 2, i[3] = e.length, i.set(e, 4), i[4 + r] = 2, i[5 + r] = t.length, i.set(t, 6 + r), i;
}
const Ve = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
}, Y1 = {};
for (const e of Object.keys(Ve)) {
  const t = Ve[e];
  Y1[t] = e;
}
const ac = "0123456789abcdefABCDEF", cc = ac.split("").map((e) => e.codePointAt(0)), uc = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = ac.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), J1 = new TextEncoder(), Q1 = new TextDecoder();
function x5(e) {
  return Q1.decode(e);
}
function E5(e) {
  return J1.encode(e);
}
function ut(e) {
  const t = e.reduce((i, o) => i + o.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
function me(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? S5(t) : A5(t);
}
function A5(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += ac[uc[cc[e[r] >> 4]]], t += ac[uc[cc[e[r] & 15]]];
  return t;
}
function S5(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = cc[e[r] >> 4], t[r * 2 + 1] = cc[e[r] & 15];
  return Q1.decode(t);
}
function Rn(e) {
  const t = J1.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const i = uc[t[n * 2]], o = uc[t[n * 2 + 1]];
    if (i === void 0 || o === void 0)
      break;
    r[n] = i << 4 | o;
  }
  return n === r.length ? r : r.slice(0, n);
}
function _5(e) {
  return btoa(String.fromCharCode(...e));
}
function ep(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
function Q(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function gr(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function k5(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function ta(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function T5(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function $n(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function C5(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Qo(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function tp(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function rp(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function P5(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? n : n - 4294967296;
  } else {
    const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? n : n - 4294967296;
  }
}
function np(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let n = 0n;
  if (r === "LE")
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
  {
    let i = 0n;
    return i = (i << 8n) + BigInt(e[t]), i = (i << 8n) + BigInt(e[t + 1]), i = (i << 8n) + BigInt(e[t + 2]), i = (i << 8n) + BigInt(e[t + 3]), i = (i << 8n) + BigInt(e[t + 4]), i = (i << 8n) + BigInt(e[t + 5]), i = (i << 8n) + BigInt(e[t + 6]), i = (i << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? i : i - 0x10000000000000000n;
  }
}
function ip(e) {
  return e < Ve.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function I5(e, t, r) {
  const n = ip(t);
  return n === 1 ? gr(e, r, t) : n === 2 ? (gr(e, r, Ve.OP_PUSHDATA1), gr(e, r + 1, t)) : n === 3 ? (gr(e, r, Ve.OP_PUSHDATA2), k5(e, r + 1, t, "LE")) : (gr(e, r, Ve.OP_PUSHDATA4), ta(e, r + 1, t, "LE")), n;
}
function B5(e, t) {
  const r = $n(e, t);
  let n, i;
  if (r < Ve.OP_PUSHDATA1)
    n = r, i = 1;
  else if (r === Ve.OP_PUSHDATA1) {
    if (t + 2 > e.length) return null;
    n = $n(e, t + 1), i = 2;
  } else if (r === Ve.OP_PUSHDATA2) {
    if (t + 3 > e.length) return null;
    n = C5(e, t + 1, "LE"), i = 3;
  } else {
    if (t + 5 > e.length) return null;
    if (r !== Ve.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    n = Qo(e, t + 1, "LE"), i = 5;
  }
  return {
    opcode: r,
    number: n,
    size: i
  };
}
function O5(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function $5(e) {
  let t = Math.abs(e);
  const r = O5(t), n = new Uint8Array(r), i = e < 0;
  for (let o = 0; o < r; ++o)
    gr(n, o, t & 255), t >>= 8;
  return n[r - 1] & 128 ? gr(n, r - 1, i ? 128 : 0) : i && (n[r - 1] |= 128), n;
}
var bn;
function N5(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? (bn == null ? void 0 : bn.lang),
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (bn == null ? void 0 : bn.abortEarly),
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (bn == null ? void 0 : bn.abortPipeEarly)
  };
}
var ol;
function U5(e) {
  return ol == null ? void 0 : ol.get(e);
}
var sl;
function F5(e) {
  return sl == null ? void 0 : sl.get(e);
}
var al;
function H5(e, t) {
  var r;
  return (r = al == null ? void 0 : al.get(e)) == null ? void 0 : r.get(t);
}
function Bs(e) {
  var r, n;
  const t = typeof e;
  return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function Wt(e, t, r, n, i) {
  const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? Bs(o), c = {
    kind: e.kind,
    type: e.type,
    input: o,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: i == null ? void 0 : i.path,
    issues: i == null ? void 0 : i.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", f = (i == null ? void 0 : i.message) ?? // @ts-expect-error
  e.message ?? H5(e.reference, c.lang) ?? (u ? F5(c.lang) : null) ?? n.message ?? U5(c.lang);
  f && (c.message = typeof f == "function" ? f(c) : f), u && (r.typed = !1), r.issues ? r.issues.push(c) : r.issues = [c];
}
function R5(e, t) {
  const r = [...new Set(e)];
  return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var L5 = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(r) {
    super(r[0].message);
    /**
     * The error issues.
     */
    Le(this, "issues");
    this.name = "ValiError", this.issues = r;
  }
};
function op(e, t) {
  return {
    kind: "validation",
    type: "every_item",
    reference: op,
    async: !1,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.every(this.requirement) && Wt(this, "item", r, n), r;
    }
  };
}
function id(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: id,
    async: !1,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && Wt(this, "integer", t, r), t;
    }
  };
}
function sp(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: sp,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && Wt(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function Xc(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: Xc,
    async: !1,
    expects: `<=${e instanceof Date ? e.toJSON() : Bs(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && Wt(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Bs(r.value)
      }), r;
    }
  };
}
function Yc(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: Yc,
    async: !1,
    expects: `>=${e instanceof Date ? e.toJSON() : Bs(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && Wt(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Bs(r.value)
      }), r;
    }
  };
}
function ap(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: ap,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && Wt(this, "format", r, n), r;
    }
  };
}
function od(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function Jc(e, t) {
  return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
}
function cp() {
  return {
    kind: "schema",
    type: "any",
    reference: cp,
    expects: "any",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
function ir(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: ir,
    expects: "Array",
    async: !1,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        for (let s = 0; s < i.length; s++) {
          const a = i[s], c = this.item._run({ typed: !1, value: a }, n);
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const f of c.issues)
              f.path ? f.path.unshift(u) : f.path = [u], (o = r.issues) == null || o.push(f);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
      } else
        Wt(this, "type", r, n);
      return r;
    }
  };
}
function up(e) {
  return {
    kind: "schema",
    type: "bigint",
    reference: up,
    expects: "bigint",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "bigint" ? t.typed = !0 : Wt(this, "type", t, r), t;
    }
  };
}
function Kr(e, t) {
  return {
    kind: "schema",
    type: "custom",
    reference: Kr,
    expects: "unknown",
    async: !1,
    check: e,
    message: t,
    _run(r, n) {
      return this.check(r.value) ? r.typed = !0 : Wt(this, "type", r, n), r;
    }
  };
}
function Qc(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: Qc,
    expects: e.name,
    async: !1,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = !0 : Wt(this, "type", r, n), r;
    }
  };
}
function of(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullable",
    reference: of,
    expects: `(${e.expects} | null)`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return n.value === null && ("default" in this && (n.value = od(
        this,
        n,
        i
      )), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function lp(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: lp,
    expects: `(${e.expects} | null | undefined)`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = od(
        this,
        n,
        i
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function nr(e) {
  return {
    kind: "schema",
    type: "number",
    reference: nr,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : Wt(this, "type", t, r), t;
    }
  };
}
function xt(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: xt,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const f of c.issues)
              f.path ? f.path.unshift(u) : f.path = [u], (o = r.issues) == null || o.push(f);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
      } else
        Wt(this, "type", r, n);
      return r;
    }
  };
}
function lc(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: lc,
    expects: `(${e.expects} | undefined)`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return n.value === void 0 && ("default" in this && (n.value = od(
        this,
        n,
        i
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function uo(e) {
  return {
    kind: "schema",
    type: "string",
    reference: uo,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : Wt(this, "type", t, r), t;
    }
  };
}
function sn(e, t) {
  return {
    kind: "schema",
    type: "tuple",
    reference: sn,
    expects: "Array",
    async: !1,
    items: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        for (let s = 0; s < this.items.length; s++) {
          const a = i[s], c = this.items[s]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const f of c.issues)
              f.path ? f.path.unshift(u) : f.path = [u], (o = r.issues) == null || o.push(f);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
      } else
        Wt(this, "type", r, n);
      return r;
    }
  };
}
function Vh(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function sd(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: sd,
    expects: R5(
      e.map((r) => r.expects),
      "|"
    ),
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      let i, o, s;
      for (const a of this.options) {
        const c = a._run(
          { typed: !1, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            o ? o.push(c) : o = [c];
          else {
            i = c;
            break;
          }
        else
          s ? s.push(c) : s = [c];
      }
      if (i)
        return i;
      if (o) {
        if (o.length === 1)
          return o[0];
        Wt(this, "type", r, n, {
          issues: Vh(o)
        }), r.typed = !0;
      } else {
        if ((s == null ? void 0 : s.length) === 1)
          return s[0];
        Wt(this, "type", r, n, {
          issues: Vh(s)
        });
      }
      return r;
    }
  };
}
function ot(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    N5(r)
  );
  if (n.issues)
    throw new L5(n.issues);
  return n.value;
}
function Ai(e, t) {
  const r = {};
  for (const n in e.entries)
    r[n] = lc(e.entries[n]);
  return { ...e, entries: r };
}
function es(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = !1;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
const Wh = new Uint8Array(32), Gh = Rn(
  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
), Pt = (e) => es(Qc(Uint8Array), sp(e));
function Os(e, t) {
  return e.length !== t.length ? !1 : e.every((r, n) => Q(r, t[n]) === 0);
}
function Lr(e) {
  if (!(e instanceof Uint8Array) || e.length < 33) return !1;
  const t = e[0], r = e.slice(1, 33);
  if (Q(Wh, r) === 0 || Q(r, Gh) >= 0) return !1;
  if ((t === 2 || t === 3) && e.length === 33)
    return !0;
  const n = e.slice(33);
  return Q(Wh, n) === 0 || Q(n, Gh) >= 0 ? !1 : t === 4 && e.length === 65;
}
const Qa = 254;
function ad(e) {
  return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? !1 : e.version !== void 0 ? (e.version & Qa) === e.version : !0;
}
function fp(e) {
  return Array.isArray(e) ? e.length !== 2 ? !1 : e.every((t) => fp(t)) : ad(e);
}
const z5 = Pt(32), j5 = Pt(20), Zh = Pt(32), qe = Qc(Uint8Array);
es(uo(), ap(/^([0-9a-f]{2})+$/i));
const D5 = es(
  nr(),
  id(),
  Yc(0),
  Xc(255)
), Sn = es(
  nr(),
  id(),
  Yc(0),
  Xc(4294967295)
), cl = es(
  up(),
  Yc(0n),
  Xc(0x7fffffffffffffffn)
), Xh = (e) => xt(
  Object.entries(e).reduce(
    (t, r) => ({ ...t, [r[0]]: lp(r[1]) }),
    {}
  )
), Yh = new Uint8Array(1);
function Jh(e) {
  let t = 0;
  for (; e[t] === 0; ) ++t;
  return t === e.length ? Yh : (e = e.slice(t), e[0] & 128 ? ut([Yh, e]) : e);
}
function Qh(e) {
  e[0] === 0 && (e = e.slice(1));
  const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
  return t.set(e, r), t;
}
function M5(e) {
  const t = $n(e, e.length - 1);
  if (!ud(t))
    throw new Error("Invalid hashType " + t);
  const r = w5(e.subarray(0, -1)), n = Qh(r.r), i = Qh(r.s);
  return { signature: ut([n, i]), hashType: t };
}
function K5(e, t) {
  if (ot(
    xt({
      signature: Pt(64),
      hashType: D5
    }),
    { signature: e, hashType: t }
  ), !ud(t))
    throw new Error("Invalid hashType " + t);
  const r = new Uint8Array(1);
  gr(r, 0, t);
  const n = Jh(e.slice(0, 32)), i = Jh(e.slice(32, 64));
  return ut([v5(n, i), r]);
}
const q5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: M5,
  encode: K5
}, Symbol.toStringTag, { value: "Module" })), dp = Ve.OP_RESERVED, hp = ir(sd([Qc(Uint8Array), nr()]));
function V5(e) {
  return Jc(nr(), e) && (e === Ve.OP_0 || e >= Ve.OP_1 && e <= Ve.OP_16 || e === Ve.OP_1NEGATE);
}
function pp(e) {
  return Jc(qe, e) || V5(e);
}
function cd(e) {
  return Jc(es(cp(), op(pp)), e);
}
function gp(e) {
  return e.length - e.filter(pp).length;
}
function fc(e) {
  if (e.length === 0) return Ve.OP_0;
  if (e.length === 1) {
    if (e[0] >= 1 && e[0] <= 16) return dp + e[0];
    if (e[0] === 129) return Ve.OP_1NEGATE;
  }
}
function mp(e) {
  return e instanceof Uint8Array;
}
function W5(e) {
  return Jc(hp, e);
}
function dc(e) {
  return e instanceof Uint8Array;
}
function or(e) {
  if (mp(e)) return e;
  ot(hp, e);
  const t = e.reduce((i, o) => dc(o) ? o.length === 1 && fc(o) !== void 0 ? i + 1 : i + ip(o.length) + o.length : i + 1, 0), r = new Uint8Array(t);
  let n = 0;
  if (e.forEach((i) => {
    if (dc(i)) {
      const o = fc(i);
      if (o !== void 0) {
        gr(r, n, o), n += 1;
        return;
      }
      n += I5(r, i.length, n), r.set(i, n), n += i.length;
    } else
      gr(r, n, i), n += 1;
  }), n !== r.length) throw new Error("Could not decode chunks");
  return r;
}
function at(e) {
  if (W5(e)) return e;
  ot(qe, e);
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const n = e[r];
    if (n > Ve.OP_0 && n <= Ve.OP_PUSHDATA4) {
      const i = B5(e, r);
      if (i === null || (r += i.size, r + i.number > e.length)) return null;
      const o = e.slice(r, r + i.number);
      r += i.number;
      const s = fc(o);
      s !== void 0 ? t.push(s) : t.push(o);
    } else
      t.push(n), r += 1;
  }
  return t;
}
function G5(e) {
  if (mp(e) && (e = at(e)), !e)
    throw new Error("Could not convert invalid chunks to ASM");
  return e.map((t) => {
    if (dc(t)) {
      const r = fc(t);
      if (r === void 0) return me(t);
      t = r;
    }
    return Y1[t];
  }).join(" ");
}
function Z5(e) {
  return e = at(e), ot(Kr(cd), e), e.map((t) => dc(t) ? t : t === Ve.OP_0 ? new Uint8Array(0) : $5(t - dp));
}
function X5(e) {
  return Lr(e);
}
function ud(e) {
  const t = e & -129;
  return t > 0 && t < 4;
}
function Nn(e) {
  return !(e instanceof Uint8Array) || !ud(e[e.length - 1]) ? !1 : y5(e.slice(0, -1));
}
const _s = q5;
function le(e, t, r) {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !0,
    get() {
      const n = r.call(this);
      return this[t] = n, n;
    },
    set(n) {
      Object.defineProperty(this, t, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
      });
    }
  });
}
function Pr(e) {
  let t;
  return () => (t !== void 0 || (t = e()), t);
}
const ko = Ve, Pa = ko.OP_RESERVED;
function eu(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {});
  function r(c) {
    return Nn(c) || (t.allowIncomplete && c === ko.OP_0) !== void 0;
  }
  ot(
    Ai(
      xt({
        network: xt({}),
        m: nr(),
        n: nr(),
        output: qe,
        pubkeys: ir(Kr(Lr), "Received invalid pubkey"),
        signatures: ir(
          Kr(r),
          "Expected signature to be of type isAcceptableSignature"
        ),
        input: qe
      })
    ),
    e
  );
  const i = { network: e.network || Gr };
  let o = [], s = !1;
  function a(c) {
    s || (s = !0, o = at(c), i.m = o[0] - Pa, i.n = o[o.length - 2] - Pa, i.pubkeys = o.slice(1, -2));
  }
  if (le(i, "output", () => {
    if (e.m && i.n && e.pubkeys)
      return or(
        [].concat(
          Pa + e.m,
          e.pubkeys,
          Pa + i.n,
          ko.OP_CHECKMULTISIG
        )
      );
  }), le(i, "m", () => {
    if (i.output)
      return a(i.output), i.m;
  }), le(i, "n", () => {
    if (i.pubkeys)
      return i.pubkeys.length;
  }), le(i, "pubkeys", () => {
    if (e.output)
      return a(e.output), i.pubkeys;
  }), le(i, "signatures", () => {
    if (e.input)
      return at(e.input).slice(1);
  }), le(i, "input", () => {
    if (e.signatures)
      return or([ko.OP_0].concat(e.signatures));
  }), le(i, "witness", () => {
    if (i.input)
      return [];
  }), le(i, "name", () => {
    if (!(!i.m || !i.n))
      return `p2ms(${i.m} of ${i.n})`;
  }), t.validate) {
    if (e.output) {
      if (a(e.output), ot(nr(), o[0], { message: "Output is invalid" }), ot(nr(), o[o.length - 2], {
        message: "Output is invalid"
      }), o[o.length - 1] !== ko.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (i.m <= 0 || i.n > 16 || i.m > i.n || i.n !== o.length - 3)
        throw new TypeError("Output is invalid");
      if (!i.pubkeys.every((c) => Lr(c)))
        throw new TypeError("Output is invalid");
      if (e.m !== void 0 && e.m !== i.m) throw new TypeError("m mismatch");
      if (e.n !== void 0 && e.n !== i.n) throw new TypeError("n mismatch");
      if (e.pubkeys && !Os(e.pubkeys, i.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (e.pubkeys) {
      if (e.n !== void 0 && e.n !== e.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (i.n = e.pubkeys.length, i.n < i.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (e.signatures) {
      if (e.signatures.length < i.m)
        throw new TypeError("Not enough signatures provided");
      if (e.signatures.length > i.m)
        throw new TypeError("Too many signatures provided");
    }
    if (e.input) {
      if (e.input[0] !== ko.OP_0) throw new TypeError("Input is invalid");
      if (i.signatures.length === 0 || !i.signatures.every(r))
        throw new TypeError("Input has invalid signature(s)");
      if (e.signatures && !Os(e.signatures, i.signatures))
        throw new TypeError("Signature mismatch");
      if (e.m !== void 0 && e.m !== e.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(i, e);
}
const e0 = Ve;
function bp(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), ot(
    Ai(
      xt({
        network: xt({}),
        output: qe,
        pubkey: Kr(Lr, "invalid pubkey"),
        signature: Kr(
          Nn,
          "Expected signature to be of type isCanonicalScriptSignature"
        ),
        input: qe
      })
    ),
    e
  );
  const r = Pr(() => at(e.input)), i = { name: "p2pk", network: e.network || Gr };
  if (le(i, "output", () => {
    if (e.pubkey)
      return or([e.pubkey, e0.OP_CHECKSIG]);
  }), le(i, "pubkey", () => {
    if (e.output)
      return e.output.slice(1, -1);
  }), le(i, "signature", () => {
    if (e.input)
      return r()[0];
  }), le(i, "input", () => {
    if (e.signature)
      return or([e.signature]);
  }), le(i, "witness", () => {
    if (i.input)
      return [];
  }), t.validate) {
    if (e.output) {
      if (e.output[e.output.length - 1] !== e0.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!Lr(i.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (e.pubkey && Q(e.pubkey, i.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
    }
    if (e.signature && e.input && Q(e.input, i.input) !== 0)
      throw new TypeError("Signature mismatch");
    if (e.input) {
      if (r().length !== 1) throw new TypeError("Input is invalid");
      if (!Nn(i.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(i, e);
}
function t0(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function Y5(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function tu(e, ...t) {
  if (!Y5(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function J5(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  t0(e.outputLen), t0(e.blockLen);
}
function hc(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Q5(e, t) {
  tu(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const Ao = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ul = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Jr = (e, t) => e << 32 - t | e >>> t, Ia = (e, t) => e << t | e >>> 32 - t >>> 0;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function ew(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function ld(e) {
  return typeof e == "string" && (e = ew(e)), tu(e), e;
}
function tw(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    tu(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const o = e[n];
    r.set(o, i), i += o.length;
  }
  return r;
}
let yp = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function fd(e) {
  const t = (n) => e().update(ld(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function rw(e = 32) {
  if (Ao && typeof Ao.getRandomValues == "function")
    return Ao.getRandomValues(new Uint8Array(e));
  if (Ao && typeof Ao.randomBytes == "function")
    return Ao.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function nw(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
const iw = (e, t, r) => e & t ^ ~e & r, ow = (e, t, r) => e & t ^ e & r ^ t & r;
let dd = class extends yp {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = ul(this.buffer);
  }
  update(t) {
    hc(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = ld(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const c = ul(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    hc(this), Q5(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let l = s; l < i; l++)
      r[l] = 0;
    nw(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const a = ul(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++)
      a.setUint32(4 * l, f[l], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
  }
};
const sw = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), wp = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((e, t) => t)), aw = /* @__PURE__ */ wp.map((e) => (9 * e + 5) % 16);
let hd = [wp], pd = [aw];
for (let e = 0; e < 4; e++)
  for (let t of [hd, pd])
    t.push(t[e].map((r) => sw[r]));
const vp = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e)), cw = /* @__PURE__ */ hd.map((e, t) => e.map((r) => vp[t][r])), uw = /* @__PURE__ */ pd.map((e, t) => e.map((r) => vp[t][r])), lw = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), fw = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function r0(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const Ba = /* @__PURE__ */ new Uint32Array(16);
let dw = class extends dd {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
    return [t, r, n, i, o];
  }
  set(t, r, n, i, o) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4)
      Ba[m] = t.getUint32(r, !0);
    let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, c = a, u = this.h3 | 0, f = u, l = this.h4 | 0, h = l;
    for (let m = 0; m < 5; m++) {
      const y = 4 - m, b = lw[m], g = fw[m], v = hd[m], _ = pd[m], x = cw[m], k = uw[m];
      for (let P = 0; P < 16; P++) {
        const I = Ia(n + r0(m, o, a, u) + Ba[v[P]] + b, x[P]) + l | 0;
        n = l, l = u, u = Ia(a, 10) | 0, a = o, o = I;
      }
      for (let P = 0; P < 16; P++) {
        const I = Ia(i + r0(y, s, c, f) + Ba[_[P]] + g, k[P]) + h | 0;
        i = h, h = f, f = Ia(c, 10) | 0, c = s, s = I;
      }
    }
    this.set(this.h1 + a + f | 0, this.h2 + u + h | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + c | 0);
  }
  roundClean() {
    Ba.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
const xp = /* @__PURE__ */ fd(() => new dw()), hw = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Kn = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), qn = /* @__PURE__ */ new Uint32Array(64);
let pw = class extends dd {
  constructor() {
    super(64, 32, 8, !1), this.A = Kn[0] | 0, this.B = Kn[1] | 0, this.C = Kn[2] | 0, this.D = Kn[3] | 0, this.E = Kn[4] | 0, this.F = Kn[5] | 0, this.G = Kn[6] | 0, this.H = Kn[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: c } = this;
    return [t, r, n, i, o, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      qn[l] = t.getUint32(r, !1);
    for (let l = 16; l < 64; l++) {
      const h = qn[l - 15], m = qn[l - 2], y = Jr(h, 7) ^ Jr(h, 18) ^ h >>> 3, b = Jr(m, 17) ^ Jr(m, 19) ^ m >>> 10;
      qn[l] = b + qn[l - 7] + y + qn[l - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: a, F: c, G: u, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const h = Jr(a, 6) ^ Jr(a, 11) ^ Jr(a, 25), m = f + h + iw(a, c, u) + hw[l] + qn[l] | 0, b = (Jr(n, 2) ^ Jr(n, 13) ^ Jr(n, 22)) + ow(n, i, o) | 0;
      f = u, u = c, c = a, a = s + m | 0, s = o, o = i, i = n, n = m + b | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, s, a, c, u, f);
  }
  roundClean() {
    qn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const Ut = /* @__PURE__ */ fd(() => new pw());
function In(e) {
  return xp(Ut(e));
}
function Fi(e) {
  return Ut(Ut(e));
}
const gw = {
  "BIP0340/challenge": Uint8Array.from([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": Uint8Array.from([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": Uint8Array.from([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: Uint8Array.from([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: Uint8Array.from([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: Uint8Array.from([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: Uint8Array.from([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": Uint8Array.from([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": Uint8Array.from([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function ru(e, t) {
  return Ut(ut([gw[e], t]));
}
function mw(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let u = 0; u < t.length; u++)
    t[u] = 255;
  for (let u = 0; u < e.length; u++) {
    const f = e.charAt(u), l = f.charCodeAt(0);
    if (t[l] !== 255)
      throw new TypeError(f + " is ambiguous");
    t[l] = u;
  }
  const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function s(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u.length === 0)
      return "";
    let f = 0, l = 0, h = 0;
    const m = u.length;
    for (; h !== m && u[h] === 0; )
      h++, f++;
    const y = (m - h) * o + 1 >>> 0, b = new Uint8Array(y);
    for (; h !== m; ) {
      let _ = u[h], x = 0;
      for (let k = y - 1; (_ !== 0 || x < l) && k !== -1; k--, x++)
        _ += 256 * b[k] >>> 0, b[k] = _ % r >>> 0, _ = _ / r >>> 0;
      if (_ !== 0)
        throw new Error("Non-zero carry");
      l = x, h++;
    }
    let g = y - l;
    for (; g !== y && b[g] === 0; )
      g++;
    let v = n.repeat(f);
    for (; g < y; ++g)
      v += e.charAt(b[g]);
    return v;
  }
  function a(u) {
    if (typeof u != "string")
      throw new TypeError("Expected String");
    if (u.length === 0)
      return new Uint8Array();
    let f = 0, l = 0, h = 0;
    for (; u[f] === n; )
      l++, f++;
    const m = (u.length - f) * i + 1 >>> 0, y = new Uint8Array(m);
    for (; u[f]; ) {
      let _ = t[u.charCodeAt(f)];
      if (_ === 255)
        return;
      let x = 0;
      for (let k = m - 1; (_ !== 0 || x < h) && k !== -1; k--, x++)
        _ += r * y[k] >>> 0, y[k] = _ % 256 >>> 0, _ = _ / 256 >>> 0;
      if (_ !== 0)
        throw new Error("Non-zero carry");
      h = x, f++;
    }
    let b = m - h;
    for (; b !== m && y[b] === 0; )
      b++;
    const g = new Uint8Array(l + (m - b));
    let v = l;
    for (; b !== m; )
      g[v++] = y[b++];
    return g;
  }
  function c(u) {
    const f = a(u);
    if (f)
      return f;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: a,
    decode: c
  };
}
var bw = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const ll = mw(bw);
function yw(e) {
  function t(o) {
    var s = Uint8Array.from(o), a = e(s), c = s.length + 4, u = new Uint8Array(c);
    return u.set(s, 0), u.set(a.subarray(0, 4), s.length), ll.encode(u);
  }
  function r(o) {
    var s = o.slice(0, -4), a = o.slice(-4), c = e(s);
    if (!(a[0] ^ c[0] | a[1] ^ c[1] | a[2] ^ c[2] | a[3] ^ c[3]))
      return s;
  }
  function n(o) {
    var s = ll.decodeUnsafe(o);
    if (s != null)
      return r(s);
  }
  function i(o) {
    var s = ll.decode(o), a = r(s);
    if (a == null)
      throw new Error("Invalid checksum");
    return a;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: n
  };
}
function ww(e) {
  return Ut(Ut(e));
}
const Ho = yw(ww), Vn = Ve;
function ra(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), ot(
    Ai(
      xt({
        network: xt({}),
        address: uo(),
        hash: j5,
        output: Pt(25),
        pubkey: Kr(Lr),
        signature: Kr(Nn),
        input: qe
      })
    ),
    e
  );
  const r = Pr(() => {
    const s = Ho.decode(e.address), a = $n(s, 0), c = s.slice(1);
    return { version: a, hash: c };
  }), n = Pr(() => at(e.input)), i = e.network || Gr, o = { name: "p2pkh", network: i };
  if (le(o, "address", () => {
    if (!o.hash) return;
    const s = new Uint8Array(21);
    return gr(s, 0, i.pubKeyHash), s.set(o.hash, 1), Ho.encode(s);
  }), le(o, "hash", () => {
    if (e.output) return e.output.slice(3, 23);
    if (e.address) return r().hash;
    if (e.pubkey || o.pubkey) return In(e.pubkey || o.pubkey);
  }), le(o, "output", () => {
    if (o.hash)
      return or([
        Vn.OP_DUP,
        Vn.OP_HASH160,
        o.hash,
        Vn.OP_EQUALVERIFY,
        Vn.OP_CHECKSIG
      ]);
  }), le(o, "pubkey", () => {
    if (e.input)
      return n()[1];
  }), le(o, "signature", () => {
    if (e.input)
      return n()[0];
  }), le(o, "input", () => {
    if (e.pubkey && e.signature)
      return or([e.signature, e.pubkey]);
  }), le(o, "witness", () => {
    if (o.input)
      return [];
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (r().version !== i.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r().hash.length !== 20) throw new TypeError("Invalid address");
      s = r().hash;
    }
    if (e.hash) {
      if (s.length > 0 && Q(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 25 || e.output[0] !== Vn.OP_DUP || e.output[1] !== Vn.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== Vn.OP_EQUALVERIFY || e.output[24] !== Vn.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const a = e.output.slice(3, 23);
      if (s.length > 0 && Q(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.pubkey) {
      const a = In(e.pubkey);
      if (s.length > 0 && Q(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.input) {
      const a = n();
      if (a.length !== 2) throw new TypeError("Input is invalid");
      if (!Nn(a[0]))
        throw new TypeError("Input has invalid signature");
      if (!Lr(a[1])) throw new TypeError("Input has invalid pubkey");
      if (e.signature && Q(e.signature, a[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && Q(e.pubkey, a[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const c = In(a[1]);
      if (s.length > 0 && Q(s, c) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(o, e);
}
const hs = Ve;
function ts(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), ot(
    Ai(
      xt({
        network: xt({}),
        address: uo(),
        hash: Pt(20),
        output: Pt(23),
        redeem: Ai(
          xt({
            network: xt({}),
            output: qe,
            input: qe,
            witness: ir(qe)
          })
        ),
        input: qe,
        witness: ir(qe)
      })
    ),
    e
  );
  let r = e.network;
  r || (r = e.redeem && e.redeem.network || Gr);
  const n = { network: r }, i = Pr(() => {
    const a = Ho.decode(e.address), c = $n(a, 0), u = a.slice(1);
    return { version: c, hash: u };
  }), o = Pr(() => at(e.input)), s = Pr(() => {
    const a = o(), c = a[a.length - 1];
    return {
      network: r,
      output: c === hs.OP_FALSE ? Uint8Array.from([]) : c,
      input: or(a.slice(0, -1)),
      witness: e.witness || []
    };
  });
  if (le(n, "address", () => {
    if (!n.hash) return;
    const a = new Uint8Array(21);
    return gr(a, 0, n.network.scriptHash), a.set(n.hash, 1), Ho.encode(a);
  }), le(n, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return i().hash;
    if (n.redeem && n.redeem.output) return In(n.redeem.output);
  }), le(n, "output", () => {
    if (n.hash)
      return or([hs.OP_HASH160, n.hash, hs.OP_EQUAL]);
  }), le(n, "redeem", () => {
    if (e.input)
      return s();
  }), le(n, "input", () => {
    if (!(!e.redeem || !e.redeem.input || !e.redeem.output))
      return or(
        [].concat(at(e.redeem.input), e.redeem.output)
      );
  }), le(n, "witness", () => {
    if (n.redeem && n.redeem.witness) return n.redeem.witness;
    if (n.input) return [];
  }), le(n, "name", () => {
    const a = ["p2sh"];
    return n.redeem !== void 0 && n.redeem.name !== void 0 && a.push(n.redeem.name), a.join("-");
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (i().version !== r.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (i().hash.length !== 20) throw new TypeError("Invalid address");
      a = i().hash;
    }
    if (e.hash) {
      if (a.length > 0 && Q(a, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      a = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 23 || e.output[0] !== hs.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== hs.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const u = e.output.slice(2, 22);
      if (a.length > 0 && Q(a, u) !== 0)
        throw new TypeError("Hash mismatch");
      a = u;
    }
    const c = (u) => {
      if (u.output) {
        const f = at(u.output);
        if (!f || f.length < 1)
          throw new TypeError("Redeem.output too short");
        if (u.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (gp(f) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const l = In(u.output);
        if (a.length > 0 && Q(a, l) !== 0)
          throw new TypeError("Hash mismatch");
        a = l;
      }
      if (u.input) {
        const f = u.input.length > 0, l = u.witness && u.witness.length > 0;
        if (!f && !l) throw new TypeError("Empty input");
        if (f && l)
          throw new TypeError("Input and witness provided");
        if (f) {
          const h = at(u.input);
          if (!cd(h))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (e.input) {
      const u = o();
      if (!u || u.length < 1) throw new TypeError("Input too short");
      if (!(s().output instanceof Uint8Array))
        throw new TypeError("Input is invalid");
      c(s());
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== r)
        throw new TypeError("Network mismatch");
      if (e.input) {
        const u = s();
        if (e.redeem.output && Q(e.redeem.output, u.output) !== 0)
          throw new TypeError("Redeem.output mismatch");
        if (e.redeem.input && Q(e.redeem.input, u.input) !== 0)
          throw new TypeError("Redeem.input mismatch");
      }
      c(e.redeem);
    }
    if (e.witness && e.redeem && e.redeem.witness && !Os(e.redeem.witness, e.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(n, e);
}
var we = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vw(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function xw(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var $s = {};
Object.defineProperty($s, "__esModule", { value: !0 });
var Ns = $s.bech32m = mr = $s.bech32 = void 0;
const pc = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Ep = {};
for (let e = 0; e < pc.length; e++) {
  const t = pc.charAt(e);
  Ep[t] = e;
}
function Oo(e) {
  const t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function n0(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + e + ")";
    t = Oo(t) ^ n >> 5;
  }
  t = Oo(t);
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    t = Oo(t) ^ n & 31;
  }
  return t;
}
function gd(e, t, r, n) {
  let i = 0, o = 0;
  const s = (1 << r) - 1, a = [];
  for (let c = 0; c < e.length; ++c)
    for (i = i << t | e[c], o += t; o >= r; )
      o -= r, a.push(i >> o & s);
  if (n)
    o > 0 && a.push(i << r - o & s);
  else {
    if (o >= t)
      return "Excess padding";
    if (i << r - o & s)
      return "Non-zero padding";
  }
  return a;
}
function Ew(e) {
  return gd(e, 8, 5, !0);
}
function Aw(e) {
  const t = gd(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
}
function Sw(e) {
  const t = gd(e, 5, 8, !1);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function Ap(e) {
  let t;
  e === "bech32" ? t = 1 : t = 734539939;
  function r(s, a, c) {
    if (c = c || 90, s.length + 7 + a.length > c)
      throw new TypeError("Exceeds length limit");
    s = s.toLowerCase();
    let u = n0(s);
    if (typeof u == "string")
      throw new Error(u);
    let f = s + "1";
    for (let l = 0; l < a.length; ++l) {
      const h = a[l];
      if (h >> 5)
        throw new Error("Non 5-bit word");
      u = Oo(u) ^ h, f += pc.charAt(h);
    }
    for (let l = 0; l < 6; ++l)
      u = Oo(u);
    u ^= t;
    for (let l = 0; l < 6; ++l) {
      const h = u >> (5 - l) * 5 & 31;
      f += pc.charAt(h);
    }
    return f;
  }
  function n(s, a) {
    if (a = a || 90, s.length < 8)
      return s + " too short";
    if (s.length > a)
      return "Exceeds length limit";
    const c = s.toLowerCase(), u = s.toUpperCase();
    if (s !== c && s !== u)
      return "Mixed-case string " + s;
    s = c;
    const f = s.lastIndexOf("1");
    if (f === -1)
      return "No separator character for " + s;
    if (f === 0)
      return "Missing prefix for " + s;
    const l = s.slice(0, f), h = s.slice(f + 1);
    if (h.length < 6)
      return "Data too short";
    let m = n0(l);
    if (typeof m == "string")
      return m;
    const y = [];
    for (let b = 0; b < h.length; ++b) {
      const g = h.charAt(b), v = Ep[g];
      if (v === void 0)
        return "Unknown character " + g;
      m = Oo(m) ^ v, !(b + 6 >= h.length) && y.push(v);
    }
    return m !== t ? "Invalid checksum for " + s : { prefix: l, words: y };
  }
  function i(s, a) {
    const c = n(s, a);
    if (typeof c == "object")
      return c;
  }
  function o(s, a) {
    const c = n(s, a);
    if (typeof c == "object")
      return c;
    throw new Error(c);
  }
  return {
    decodeUnsafe: i,
    decode: o,
    encode: r,
    toWords: Ew,
    fromWordsUnsafe: Aw,
    fromWords: Sw
  };
}
var mr = $s.bech32 = Ap("bech32");
Ns = $s.bech32m = Ap("bech32m");
const i0 = Ve, _w = new Uint8Array(0);
function na(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), ot(
    Ai(
      xt({
        address: uo(),
        hash: Pt(20),
        input: Pt(0),
        network: xt({}),
        output: Pt(22),
        pubkey: Kr(Lr, "Not a valid pubkey"),
        signature: Kr(Nn),
        witness: ir(qe)
      })
    ),
    e
  );
  const r = Pr(() => {
    const o = mr.decode(e.address), s = o.words.shift(), a = mr.fromWords(o.words);
    return {
      version: s,
      prefix: o.prefix,
      data: Uint8Array.from(a)
    };
  }), n = e.network || Gr, i = { name: "p2wpkh", network: n };
  if (le(i, "address", () => {
    if (!i.hash) return;
    const o = mr.toWords(i.hash);
    return o.unshift(0), mr.encode(n.bech32, o);
  }), le(i, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return r().data;
    if (e.pubkey || i.pubkey) return In(e.pubkey || i.pubkey);
  }), le(i, "output", () => {
    if (i.hash)
      return or([i0.OP_0, i.hash]);
  }), le(i, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.witness)
      return e.witness[1];
  }), le(i, "signature", () => {
    if (e.witness)
      return e.witness[0];
  }), le(i, "input", () => {
    if (i.witness)
      return _w;
  }), le(i, "witness", () => {
    if (e.pubkey && e.signature)
      return [e.signature, e.pubkey];
  }), t.validate) {
    let o = Uint8Array.from([]);
    if (e.address) {
      if (n && n.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 20)
        throw new TypeError("Invalid address data");
      o = r().data;
    }
    if (e.hash) {
      if (o.length > 0 && Q(o, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      o = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 22 || e.output[0] !== i0.OP_0 || e.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (o.length > 0 && Q(o, e.output.slice(2)) !== 0)
        throw new TypeError("Hash mismatch");
      o = e.output.slice(2);
    }
    if (e.pubkey) {
      const s = In(e.pubkey);
      if (o.length > 0 && Q(o, s) !== 0)
        throw new TypeError("Hash mismatch");
      if (o = s, !Lr(e.pubkey) || e.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (e.witness) {
      if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!Nn(e.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!Lr(e.witness[1]) || e.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (e.signature && Q(e.signature, e.witness[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && Q(e.pubkey, e.witness[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const s = In(e.witness[1]);
      if (o.length > 0 && Q(o, s) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(i, e);
}
const o0 = Ve, fl = new Uint8Array(0);
function Oa(e) {
  return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && Lr(e));
}
function ia(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), ot(
    Xh({
      network: xt({}),
      address: uo(),
      hash: z5,
      output: Pt(34),
      redeem: Xh({
        input: qe,
        network: xt({}),
        output: qe,
        witness: ir(qe)
      }),
      input: Pt(0),
      witness: ir(qe)
    }),
    e
  );
  const r = Pr(() => {
    const s = mr.decode(e.address), a = s.words.shift(), c = mr.fromWords(s.words);
    return {
      version: a,
      prefix: s.prefix,
      data: Uint8Array.from(c)
    };
  }), n = Pr(() => at(e.redeem.input));
  let i = e.network;
  i || (i = e.redeem && e.redeem.network || Gr);
  const o = { network: i };
  if (le(o, "address", () => {
    if (!o.hash) return;
    const s = mr.toWords(o.hash);
    return s.unshift(0), mr.encode(i.bech32, s);
  }), le(o, "hash", () => {
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (o.redeem && o.redeem.output) return Ut(o.redeem.output);
  }), le(o, "output", () => {
    if (o.hash)
      return or([o0.OP_0, o.hash]);
  }), le(o, "redeem", () => {
    if (e.witness)
      return {
        output: e.witness[e.witness.length - 1],
        input: fl,
        witness: e.witness.slice(0, -1)
      };
  }), le(o, "input", () => {
    if (o.witness)
      return fl;
  }), le(o, "witness", () => {
    if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
      const s = Z5(n());
      return o.redeem = Object.assign({ witness: s }, e.redeem), o.redeem.input = fl, [].concat(s, e.redeem.output);
    }
    if (e.redeem && e.redeem.output && e.redeem.witness)
      return [].concat(e.redeem.witness, e.redeem.output);
  }), le(o, "name", () => {
    const s = ["p2wsh"];
    return o.redeem !== void 0 && o.redeem.name !== void 0 && s.push(o.redeem.name), s.join("-");
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (r().prefix !== i.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      s = r().data;
    }
    if (e.hash) {
      if (s.length > 0 && Q(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== o0.OP_0 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const a = e.output.slice(2);
      if (s.length > 0 && Q(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== i)
        throw new TypeError("Network mismatch");
      if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (e.redeem.output) {
        const a = at(e.redeem.output);
        if (!a || a.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (e.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (gp(a) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const c = Ut(e.redeem.output);
        if (s.length > 0 && Q(s, c) !== 0)
          throw new TypeError("Hash mismatch");
        s = c;
      }
      if (e.redeem.input && !cd(n()))
        throw new TypeError("Non push-only scriptSig");
      if (e.witness && e.redeem.witness && !Os(e.witness, e.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (e.redeem.input && n().some(Oa) || e.redeem.output && (at(e.redeem.output) || []).some(
        Oa
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (e.witness && e.witness.length > 0) {
      const a = e.witness[e.witness.length - 1];
      if (e.redeem && e.redeem.output && Q(e.redeem.output, a) !== 0)
        throw new TypeError("Witness and redeem.output mismatch");
      if (e.witness.some(Oa) || (at(a) || []).some(Oa))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(o, e);
}
const ks = {};
function Sp(e) {
  e ? e !== ks.eccLib && (kw(e), ks.eccLib = e) : ks.eccLib = e;
}
function sf() {
  if (!ks.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return ks.eccLib;
}
const yn = (e) => Rn(e);
function kw(e) {
  Ar(typeof e.isXOnlyPoint == "function"), Ar(
    e.isXOnlyPoint(
      yn("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), Ar(
    e.isXOnlyPoint(
      yn("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), Ar(
    e.isXOnlyPoint(
      yn("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), Ar(
    e.isXOnlyPoint(
      yn("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), Ar(
    !e.isXOnlyPoint(
      yn("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), Ar(
    !e.isXOnlyPoint(
      yn("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), Ar(typeof e.xOnlyPointAddTweak == "function"), Tw.forEach((t) => {
    const r = e.xOnlyPointAddTweak(yn(t.pubkey), yn(t.tweak));
    t.result === null ? Ar(r === null) : (Ar(r !== null), Ar(r.parity === t.parity), Ar(Q(r.xOnlyPubkey, yn(t.result)) === 0));
  });
}
function Ar(e) {
  if (!e) throw new Error("ecc library invalid");
}
const Tw = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
], _p = "0123456789abcdefABCDEF";
_p.split("").map((e) => e.codePointAt(0));
const s0 = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = _p.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), kp = new TextEncoder();
new TextDecoder();
function Cw(e) {
  return kp.encode(e);
}
function Pw(e) {
  const t = e.reduce((i, o) => i + o.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
function Iw(e) {
  const t = kp.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const i = s0[t[n * 2]], o = s0[t[n * 2 + 1]];
    if (i === void 0 || o === void 0)
      break;
    r[n] = i << 4 | o;
  }
  return n === r.length ? r : r.slice(0, n);
}
function wn(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function a0(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  e[t] = r;
}
function Bw(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Hi(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function Ow(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function $w(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function To(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function Nw(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
const Uw = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function Fw(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function Tp(e) {
  typeof e == "number" ? Fw(e) : Uw(e);
}
function Si(e, t, r) {
  Tp(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(Ir(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), Bw(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), Hi(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), Ow(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function rs(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = $w(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = To(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = Nw(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function Ir(e) {
  return Tp(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
const Hw = 9007199254740991;
function Rw(e, t) {
  if (typeof e != "number" && typeof e != "bigint")
    throw new Error("cannot write a non-number as a number");
  if (e < 0 && e < BigInt(0))
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t && e > BigInt(t))
    throw new Error("RangeError: value out of range");
  if (Math.floor(Number(e)) !== Number(e))
    throw new Error("value has a fractional component");
}
function md(e) {
  if (e.length < 1) return e;
  let t = e.length - 1, r = 0;
  for (let n = 0; n < e.length / 2; n++)
    r = e[n], e[n] = e[t], e[t] = r, t--;
  return e;
}
function c0(e) {
  const t = new Uint8Array(e.length);
  return t.set(e), t;
}
class qt {
  constructor(t, r = 0) {
    Le(this, "buffer");
    Le(this, "offset");
    this.buffer = t, this.offset = r, ot(sn([qe, Sn]), [
      t,
      r
    ]);
  }
  static withCapacity(t) {
    return new qt(new Uint8Array(t));
  }
  writeUInt8(t) {
    this.offset = gr(this.buffer, this.offset, t);
  }
  writeInt32(t) {
    this.offset = tp(this.buffer, this.offset, t, "LE");
  }
  writeInt64(t) {
    this.offset = rp(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeUInt32(t) {
    this.offset = ta(this.buffer, this.offset, t, "LE");
  }
  writeUInt64(t) {
    this.offset = T5(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeVarInt(t) {
    const { bytes: r } = Si(t, this.buffer, this.offset);
    this.offset += r;
  }
  writeSlice(t) {
    if (this.buffer.length < this.offset + t.length)
      throw new Error("Cannot write slice out of bounds");
    this.buffer.set(t, this.offset), this.offset += t.length;
  }
  writeVarSlice(t) {
    this.writeVarInt(t.length), this.writeSlice(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length), t.forEach((r) => this.writeVarSlice(r));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
class Lw {
  constructor(t, r = 0) {
    Le(this, "buffer");
    Le(this, "offset");
    this.buffer = t, this.offset = r, ot(sn([qe, Sn]), [
      t,
      r
    ]);
  }
  readUInt8() {
    const t = $n(this.buffer, this.offset);
    return this.offset++, t;
  }
  readInt32() {
    const t = P5(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readUInt32() {
    const t = Qo(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readInt64() {
    const t = np(this.buffer, this.offset, "LE");
    return this.offset += 8, t;
  }
  readVarInt() {
    const { bigintValue: t, bytes: r } = rs(this.buffer, this.offset);
    return this.offset += r, t;
  }
  readSlice(t) {
    Rw(t, Hw);
    const r = Number(t);
    if (this.buffer.length < this.offset + r)
      throw new Error("Cannot read slice out of bounds");
    const n = this.buffer.slice(this.offset, this.offset + r);
    return this.offset += r, n;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let n = 0; n < t; n++) r.push(this.readVarSlice());
    return r;
  }
}
const Cp = 192, zw = 128, jw = (e) => "left" in e && "right" in e;
function af(e, t) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const r = (e.length - 33) / 32;
  let n = t;
  for (let i = 0; i < r; i++) {
    const o = e.slice(33 + 32 * i, 65 + 32 * i);
    Q(n, o) < 0 ? n = uf(n, o) : n = uf(o, n);
  }
  return n;
}
function cf(e) {
  if (ad(e)) return { hash: Pn(e) };
  const t = [cf(e[0]), cf(e[1])];
  t.sort((i, o) => Q(i.hash, o.hash));
  const [r, n] = t;
  return {
    hash: uf(r.hash, n.hash),
    left: r,
    right: n
  };
}
function gc(e, t) {
  if (jw(e)) {
    const r = gc(e.left, t);
    if (r !== void 0) return [...r, e.right.hash];
    const n = gc(e.right, t);
    if (n !== void 0) return [...n, e.left.hash];
  } else if (Q(e.hash, t) === 0)
    return [];
}
function Pn(e) {
  const t = e.version || Cp;
  return ru(
    "TapLeaf",
    ut([Uint8Array.from([t]), Mw(e.output)])
  );
}
function Dw(e, t) {
  return ru(
    "TapTweak",
    ut(t ? [e, t] : [e])
  );
}
function $a(e, t) {
  if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
  const r = Dw(e, t), n = sf().xOnlyPointAddTweak(e, r);
  return !n || n.xOnlyPubkey === null ? null : {
    parity: n.parity,
    x: Uint8Array.from(n.xOnlyPubkey)
  };
}
function uf(e, t) {
  return ru("TapBranch", ut([e, t]));
}
function Mw(e) {
  const t = Ir(e.length), r = new Uint8Array(t);
  return Si(e.length, r), ut([r, e]);
}
const u0 = Ve, l0 = 1, Kw = 80;
function oa(e, t) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: !0 }, t || {}), ot(
    Ai(
      xt({
        address: uo(),
        input: Pt(0),
        network: xt({}),
        output: Pt(34),
        internalPubkey: Pt(32),
        hash: Pt(32),
        // merkle root hash, the tweak
        pubkey: Pt(32),
        // tweaked with `hash` from `internalPubkey`
        signature: sd([
          Pt(64),
          Pt(65)
        ]),
        witness: ir(qe),
        scriptTree: Kr(fp, "Taptree is not of type isTaptree"),
        redeem: Ai(
          xt({
            output: qe,
            // tapleaf script
            redeemVersion: nr(),
            // tapleaf version
            witness: ir(qe)
          })
        ),
        redeemVersion: nr()
      })
    ),
    e
  );
  const r = Pr(() => bd(e.address)), n = Pr(() => {
    if (!(!e.witness || !e.witness.length))
      return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === Kw ? e.witness.slice(0, -1) : e.witness.slice();
  }), i = Pr(() => {
    if (e.scriptTree) return cf(e.scriptTree);
    if (e.hash) return { hash: e.hash };
  }), o = e.network || Gr, s = { name: "p2tr", network: o };
  if (le(s, "address", () => {
    if (!s.pubkey) return;
    const a = Ns.toWords(s.pubkey);
    return a.unshift(l0), Ns.encode(o.bech32, a);
  }), le(s, "hash", () => {
    const a = i();
    if (a) return a.hash;
    const c = n();
    if (c && c.length > 1) {
      const u = c[c.length - 1], f = u[0] & Qa, l = c[c.length - 2], h = Pn({ output: l, version: f });
      return af(u, h);
    }
    return null;
  }), le(s, "output", () => {
    if (s.pubkey)
      return or([u0.OP_1, s.pubkey]);
  }), le(s, "redeemVersion", () => e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : Cp), le(s, "redeem", () => {
    const a = n();
    if (!(!a || a.length < 2))
      return {
        output: a[a.length - 2],
        witness: a.slice(0, -2),
        redeemVersion: a[a.length - 1][0] & Qa
      };
  }), le(s, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (s.internalPubkey) {
      const a = $a(s.internalPubkey, s.hash);
      if (a) return a.x;
    }
  }), le(s, "internalPubkey", () => {
    if (e.internalPubkey) return e.internalPubkey;
    const a = n();
    if (a && a.length > 1)
      return a[a.length - 1].slice(1, 33);
  }), le(s, "signature", () => {
    if (e.signature) return e.signature;
    const a = n();
    if (!(!a || a.length !== 1))
      return a[0];
  }), le(s, "witness", () => {
    if (e.witness) return e.witness;
    const a = i();
    if (a && e.redeem && e.redeem.output && e.internalPubkey) {
      const c = Pn({
        output: e.redeem.output,
        version: s.redeemVersion
      }), u = gc(a, c);
      if (!u) return;
      const f = $a(e.internalPubkey, a.hash);
      if (!f) return;
      const l = ut(
        [
          Uint8Array.from([s.redeemVersion | f.parity]),
          e.internalPubkey
        ].concat(u)
      );
      return [e.redeem.output, l];
    }
    if (e.signature) return [e.signature];
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (o && o.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== l0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      a = r().data;
    }
    if (e.pubkey) {
      if (a.length > 0 && Q(a, e.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = e.pubkey;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== u0.OP_1 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      if (a.length > 0 && Q(a, e.output.slice(2)) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = e.output.slice(2);
    }
    if (e.internalPubkey) {
      const f = $a(e.internalPubkey, s.hash);
      if (a.length > 0 && Q(a, f.x) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = f.x;
    }
    if (a && a.length && !sf().isXOnlyPoint(a))
      throw new TypeError("Invalid pubkey for p2tr");
    const c = i();
    if (e.hash && c && Q(e.hash, c.hash) !== 0)
      throw new TypeError("Hash mismatch");
    if (e.redeem && e.redeem.output && c) {
      const f = Pn({
        output: e.redeem.output,
        version: s.redeemVersion
      });
      if (!gc(c, f))
        throw new TypeError("Redeem script not in tree");
    }
    const u = n();
    if (e.redeem && s.redeem) {
      if (e.redeem.redeemVersion && e.redeem.redeemVersion !== s.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (e.redeem.output) {
        if (at(e.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (s.redeem.output && Q(e.redeem.output, s.redeem.output) !== 0)
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (e.redeem.witness && s.redeem.witness && !Os(e.redeem.witness, s.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (u && u.length)
      if (u.length === 1) {
        if (e.signature && Q(e.signature, u[0]) !== 0)
          throw new TypeError("Signature mismatch");
      } else {
        const f = u[u.length - 1];
        if (f.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${f.length}, expected min 33.`
          );
        if ((f.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${f.length} is incorrect!`
          );
        const l = (f.length - 33) / 32;
        if (l > 128)
          throw new TypeError(
            `The script path is too long. Got ${l}, expected max 128.`
          );
        const h = f.slice(1, 33);
        if (e.internalPubkey && Q(e.internalPubkey, h) !== 0)
          throw new TypeError("Internal pubkey mismatch");
        if (!sf().isXOnlyPoint(h))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const m = f[0] & Qa, y = u[u.length - 2], b = Pn({ output: y, version: m }), g = af(f, b), v = $a(h, g);
        if (!v)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (a.length && Q(a, v.x) !== 0)
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (v.parity !== (f[0] & 1))
          throw new Error("Incorrect parity");
      }
  }
  return Object.assign(s, e);
}
const Pp = 40, Ip = 2, Bp = 16, Op = 2, $p = 80, Np = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function qw(e, t) {
  const r = e.slice(2);
  if (r.length < Ip || r.length > Pp)
    throw new TypeError("Invalid program length for segwit address");
  const n = e[0] - $p;
  if (n < Op || n > Bp)
    throw new TypeError("Invalid version for segwit address");
  if (e[1] !== r.length)
    throw new TypeError("Invalid script for segwit address");
  return console.warn(Np), Vw(r, n, t.bech32);
}
function Up(e) {
  const t = Ho.decode(e);
  if (t.length < 21) throw new TypeError(e + " is too short");
  if (t.length > 21) throw new TypeError(e + " is too long");
  const r = $n(t, 0), n = t.slice(1);
  return { version: r, hash: n };
}
function bd(e) {
  let t, r;
  try {
    t = mr.decode(e);
  } catch {
  }
  if (t) {
    if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
  } else if (t = Ns.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
  const n = mr.fromWords(t.words.slice(1));
  return {
    version: r,
    prefix: t.prefix,
    data: Uint8Array.from(n)
  };
}
function Vw(e, t, r) {
  const n = mr.toWords(e);
  return n.unshift(t), t === 0 ? mr.encode(r, n) : Ns.encode(r, n);
}
function sa(e, t) {
  t = t || Gr;
  try {
    return ra({ output: e, network: t }).address;
  } catch {
  }
  try {
    return ts({ output: e, network: t }).address;
  } catch {
  }
  try {
    return na({ output: e, network: t }).address;
  } catch {
  }
  try {
    return ia({ output: e, network: t }).address;
  } catch {
  }
  try {
    return oa({ output: e, network: t }).address;
  } catch {
  }
  try {
    return qw(e, t);
  } catch {
  }
  throw new Error(G5(e) + " has no matching Address");
}
function yd(e, t) {
  t = t || Gr;
  let r, n;
  try {
    r = Up(e);
  } catch {
  }
  if (r) {
    if (r.version === t.pubKeyHash)
      return ra({ hash: r.hash }).output;
    if (r.version === t.scriptHash)
      return ts({ hash: r.hash }).output;
  } else {
    try {
      n = bd(e);
    } catch {
    }
    if (n) {
      if (n.prefix !== t.bech32)
        throw new Error(e + " has an invalid prefix");
      if (n.version === 0) {
        if (n.data.length === 20)
          return na({ hash: n.data }).output;
        if (n.data.length === 32)
          return ia({ hash: n.data }).output;
      } else if (n.version === 1) {
        if (n.data.length === 32)
          return oa({ pubkey: n.data }).output;
      } else if (n.version >= Op && n.version <= Bp && n.data.length >= Ip && n.data.length <= Pp)
        return console.warn(Np), or([
          n.version + $p,
          n.data
        ]);
    }
  }
  throw new Error(e + " has no matching Script");
}
function on(e) {
  const t = e.length;
  return Ir(t) + t;
}
function Ww(e) {
  const t = e.length;
  return Ir(t) + e.reduce((r, n) => r + on(n), 0);
}
const di = new Uint8Array(0), f0 = [], dl = Rn(
  "0000000000000000000000000000000000000000000000000000000000000000"
), d0 = Rn(
  "0000000000000000000000000000000000000000000000000000000000000001"
), Gw = Rn("ffffffffffffffff"), Zw = {
  script: di,
  valueBuffer: Gw
};
function Xw(e) {
  return e.value !== void 0;
}
const $e = class $e {
  constructor() {
    Le(this, "version", 1);
    Le(this, "locktime", 0);
    Le(this, "ins", []);
    Le(this, "outs", []);
  }
  static fromBuffer(t, r) {
    const n = new Lw(t), i = new $e();
    i.version = n.readInt32();
    const o = n.readUInt8(), s = n.readUInt8();
    let a = !1;
    o === $e.ADVANCED_TRANSACTION_MARKER && s === $e.ADVANCED_TRANSACTION_FLAG ? a = !0 : n.offset -= 2;
    const c = n.readVarInt();
    for (let f = 0; f < c; ++f)
      i.ins.push({
        hash: n.readSlice(32),
        index: n.readUInt32(),
        script: n.readVarSlice(),
        sequence: n.readUInt32(),
        witness: f0
      });
    const u = n.readVarInt();
    for (let f = 0; f < u; ++f)
      i.outs.push({
        value: n.readInt64(),
        script: n.readVarSlice()
      });
    if (a) {
      for (let f = 0; f < c; ++f)
        i.ins[f].witness = n.readVector();
      if (!i.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (i.locktime = n.readUInt32(), r) return i;
    if (n.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return i;
  }
  static fromHex(t) {
    return $e.fromBuffer(Rn(t), !1);
  }
  static isCoinbaseHash(t) {
    ot(Zh, t);
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && $e.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(t, r, n, i) {
    return ot(
      sn([
        Zh,
        Sn,
        of(lc(Sn)),
        of(lc(qe))
      ]),
      [t, r, n, i]
    ), n == null && (n = $e.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: i || di,
      sequence: n,
      witness: f0
    }) - 1;
  }
  addOutput(t, r) {
    return ot(sn([qe, cl]), [
      t,
      r
    ]), this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(!1), r = this.byteLength(!0);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = !0) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + Ir(this.ins.length) + Ir(this.outs.length) + this.ins.reduce((n, i) => n + 40 + on(i.script), 0) + this.outs.reduce((n, i) => n + 8 + on(i.script), 0) + (r ? this.ins.reduce((n, i) => n + Ww(i.witness), 0) : 0);
  }
  clone() {
    const t = new $e();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(t, r, n) {
    if (ot(sn([Sn, qe, nr()]), [
      t,
      r,
      n
    ]), t >= this.ins.length) return d0;
    const i = or(
      at(r).filter((a) => a !== Ve.OP_CODESEPARATOR)
    ), o = this.clone();
    if ((n & 31) === $e.SIGHASH_NONE)
      o.outs = [], o.ins.forEach((a, c) => {
        c !== t && (a.sequence = 0);
      });
    else if ((n & 31) === $e.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return d0;
      o.outs.length = t + 1;
      for (let a = 0; a < t; a++)
        o.outs[a] = Zw;
      o.ins.forEach((a, c) => {
        c !== t && (a.sequence = 0);
      });
    }
    n & $e.SIGHASH_ANYONECANPAY ? (o.ins = [o.ins[t]], o.ins[0].script = i) : (o.ins.forEach((a) => {
      a.script = di;
    }), o.ins[t].script = i);
    const s = new Uint8Array(o.byteLength(!1) + 4);
    return tp(s, s.length - 4, n, "LE"), o.__toBuffer(s, 0, !1), Fi(s);
  }
  hashForWitnessV1(t, r, n, i, o, s) {
    if (ot(
      sn([
        Sn,
        ir(qe),
        ir(cl),
        Sn
      ]),
      [t, r, n, i]
    ), n.length !== this.ins.length || r.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const a = i === $e.SIGHASH_DEFAULT ? $e.SIGHASH_ALL : i & $e.SIGHASH_OUTPUT_MASK, u = (i & $e.SIGHASH_INPUT_MASK) === $e.SIGHASH_ANYONECANPAY, f = a === $e.SIGHASH_NONE, l = a === $e.SIGHASH_SINGLE;
    let h = di, m = di, y = di, b = di, g = di;
    if (!u) {
      let k = qt.withCapacity(36 * this.ins.length);
      this.ins.forEach((P) => {
        k.writeSlice(P.hash), k.writeUInt32(P.index);
      }), h = Ut(k.end()), k = qt.withCapacity(8 * this.ins.length), n.forEach((P) => k.writeInt64(P)), m = Ut(k.end()), k = qt.withCapacity(
        r.map(on).reduce((P, I) => P + I)
      ), r.forEach(
        (P) => k.writeVarSlice(P)
      ), y = Ut(k.end()), k = qt.withCapacity(4 * this.ins.length), this.ins.forEach((P) => k.writeUInt32(P.sequence)), b = Ut(k.end());
    }
    if (f || l) {
      if (l && t < this.outs.length) {
        const k = this.outs[t], P = qt.withCapacity(
          8 + on(k.script)
        );
        P.writeInt64(k.value), P.writeVarSlice(k.script), g = Ut(P.end());
      }
    } else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const k = this.outs.map((I) => 8 + on(I.script)).reduce((I, R) => I + R), P = qt.withCapacity(k);
      this.outs.forEach((I) => {
        P.writeInt64(I.value), P.writeVarSlice(I.script);
      }), g = Ut(P.end());
    }
    const v = (o ? 2 : 0) + (s ? 1 : 0), _ = 174 - (u ? 49 : 0) - (f ? 32 : 0) + (s ? 32 : 0) + (o ? 37 : 0), x = qt.withCapacity(_);
    if (x.writeUInt8(i), x.writeInt32(this.version), x.writeUInt32(this.locktime), x.writeSlice(h), x.writeSlice(m), x.writeSlice(y), x.writeSlice(b), f || l || x.writeSlice(g), x.writeUInt8(v), u) {
      const k = this.ins[t];
      x.writeSlice(k.hash), x.writeUInt32(k.index), x.writeInt64(n[t]), x.writeVarSlice(r[t]), x.writeUInt32(k.sequence);
    } else
      x.writeUInt32(t);
    if (s) {
      const k = qt.withCapacity(on(s));
      k.writeVarSlice(s), x.writeSlice(Ut(k.end()));
    }
    return l && x.writeSlice(g), o && (x.writeSlice(o), x.writeUInt8(0), x.writeUInt32(4294967295)), ru(
      "TapSighash",
      ut([Uint8Array.from([0]), x.end()])
    );
  }
  hashForWitnessV0(t, r, n, i) {
    ot(
      sn([
        Sn,
        qe,
        cl,
        Sn
      ]),
      [t, r, n, i]
    );
    let o = Uint8Array.from([]), s, a = dl, c = dl, u = dl;
    if (i & $e.SIGHASH_ANYONECANPAY || (o = new Uint8Array(36 * this.ins.length), s = new qt(o, 0), this.ins.forEach((l) => {
      s.writeSlice(l.hash), s.writeUInt32(l.index);
    }), c = Fi(o)), !(i & $e.SIGHASH_ANYONECANPAY) && (i & 31) !== $e.SIGHASH_SINGLE && (i & 31) !== $e.SIGHASH_NONE && (o = new Uint8Array(4 * this.ins.length), s = new qt(o, 0), this.ins.forEach((l) => {
      s.writeUInt32(l.sequence);
    }), u = Fi(o)), (i & 31) !== $e.SIGHASH_SINGLE && (i & 31) !== $e.SIGHASH_NONE) {
      const l = this.outs.reduce((h, m) => h + 8 + on(m.script), 0);
      o = new Uint8Array(l), s = new qt(o, 0), this.outs.forEach((h) => {
        s.writeInt64(h.value), s.writeVarSlice(h.script);
      }), a = Fi(o);
    } else if ((i & 31) === $e.SIGHASH_SINGLE && t < this.outs.length) {
      const l = this.outs[t];
      o = new Uint8Array(8 + on(l.script)), s = new qt(o, 0), s.writeInt64(l.value), s.writeVarSlice(l.script), a = Fi(o);
    }
    o = new Uint8Array(156 + on(r)), s = new qt(o, 0);
    const f = this.ins[t];
    return s.writeInt32(this.version), s.writeSlice(c), s.writeSlice(u), s.writeSlice(f.hash), s.writeUInt32(f.index), s.writeVarSlice(r), s.writeInt64(n), s.writeUInt32(f.sequence), s.writeSlice(a), s.writeUInt32(this.locktime), s.writeUInt32(i), Fi(o);
  }
  getHash(t) {
    return t && this.isCoinbase() ? new Uint8Array(32) : Fi(this.__toBuffer(void 0, void 0, t));
  }
  getId() {
    return me(md(this.getHash(!1)));
  }
  toBuffer(t, r) {
    return this.__toBuffer(t, r, !0);
  }
  toHex() {
    return me(this.toBuffer(void 0, void 0));
  }
  setInputScript(t, r) {
    ot(sn([nr(), qe]), [t, r]), this.ins[t].script = r;
  }
  setWitness(t, r) {
    ot(sn([nr(), ir(qe)]), [
      t,
      r
    ]), this.ins[t].witness = r;
  }
  __toBuffer(t, r, n = !1) {
    t || (t = new Uint8Array(this.byteLength(n)));
    const i = new qt(t, r || 0);
    i.writeInt32(this.version);
    const o = n && this.hasWitnesses();
    return o && (i.writeUInt8($e.ADVANCED_TRANSACTION_MARKER), i.writeUInt8($e.ADVANCED_TRANSACTION_FLAG)), i.writeVarInt(this.ins.length), this.ins.forEach((s) => {
      i.writeSlice(s.hash), i.writeUInt32(s.index), i.writeVarSlice(s.script), i.writeUInt32(s.sequence);
    }), i.writeVarInt(this.outs.length), this.outs.forEach((s) => {
      Xw(s) ? i.writeInt64(s.value) : i.writeSlice(s.valueBuffer), i.writeVarSlice(s.script);
    }), o && this.ins.forEach((s) => {
      i.writeVector(s.witness);
    }), i.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, i.offset) : t;
  }
};
Le($e, "DEFAULT_SEQUENCE", 4294967295), Le($e, "SIGHASH_DEFAULT", 0), Le($e, "SIGHASH_ALL", 1), Le($e, "SIGHASH_NONE", 2), Le($e, "SIGHASH_SINGLE", 3), Le($e, "SIGHASH_ANYONECANPAY", 128), Le($e, "SIGHASH_OUTPUT_MASK", 3), Le($e, "SIGHASH_INPUT_MASK", 128), Le($e, "ADVANCED_TRANSACTION_MARKER", 0), Le($e, "ADVANCED_TRANSACTION_FLAG", 1);
let st = $e;
var ln;
(function(e) {
  e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(ln || (ln = {}));
var oe;
(function(e) {
  e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(oe || (oe = {}));
var gt;
(function(e) {
  e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(gt || (gt = {}));
const Yw = (e) => [...Array(e).keys()];
function Jw(e) {
  if (e.key[0] !== ln.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + me(e.key)
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + me(e.key)
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), r = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const n of Yw(e.value.length / 4 - 1)) {
    const i = Qo(e.value, n * 4 + 4, "LE"), o = !!(i & 2147483648), s = i & 2147483647;
    r.path += "/" + s.toString(10) + (o ? "'" : "");
  }
  return r;
}
function Qw(e) {
  const t = new Uint8Array([ln.GLOBAL_XPUB]), r = ut([t, e.extendedPubkey]), n = e.path.split("/"), i = new Uint8Array(n.length * 4);
  i.set(e.masterFingerprint, 0);
  let o = 4;
  return n.slice(1).forEach((s) => {
    const a = s.slice(-1) === "'";
    let c = 2147483647 & parseInt(a ? s.slice(0, -1) : s, 10);
    a && (c += 2147483648), ta(i, o, c, "LE"), o += 4;
  }), {
    key: r,
    value: i
  };
}
const e3 = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function t3(e) {
  const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
  return t instanceof Uint8Array && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function r3(e, t, r) {
  const n = me(t.extendedPubkey);
  return r.has(n) ? !1 : (r.add(n), e.filter((i) => Q(i.extendedPubkey, t.extendedPubkey)).length === 0);
}
const n3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: r3,
  check: t3,
  decode: Jw,
  encode: Qw,
  expected: e3
}, Symbol.toStringTag, { value: "Module" }));
function i3(e) {
  return {
    key: new Uint8Array([ln.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
const o3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encode: i3
}, Symbol.toStringTag, { value: "Module" }));
function s3(e) {
  if (e.key[0] !== oe.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + me(e.key)
    );
  return e.value;
}
function a3(e) {
  return {
    key: new Uint8Array([oe.FINAL_SCRIPTSIG]),
    value: e
  };
}
const c3 = "Uint8Array";
function u3(e) {
  return e instanceof Uint8Array;
}
function l3(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
const f3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: l3,
  check: u3,
  decode: s3,
  encode: a3,
  expected: c3
}, Symbol.toStringTag, { value: "Module" }));
function d3(e) {
  if (e.key[0] !== oe.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + me(e.key)
    );
  return e.value;
}
function h3(e) {
  return {
    key: new Uint8Array([oe.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
const p3 = "Uint8Array";
function g3(e) {
  return e instanceof Uint8Array;
}
function m3(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
const b3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: m3,
  check: g3,
  decode: d3,
  encode: h3,
  expected: p3
}, Symbol.toStringTag, { value: "Module" }));
function y3(e) {
  if (e.key[0] !== oe.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + me(e.key)
    );
  return e.value;
}
function w3(e) {
  return {
    key: new Uint8Array([oe.NON_WITNESS_UTXO]),
    value: e
  };
}
const v3 = "Uint8Array";
function x3(e) {
  return e instanceof Uint8Array;
}
function E3(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
const A3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: E3,
  check: x3,
  decode: y3,
  encode: w3,
  expected: v3
}, Symbol.toStringTag, { value: "Module" }));
function S3(e) {
  if (e.key[0] !== oe.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + me(e.key)
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + me(e.key)
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
function _3(e) {
  const t = new Uint8Array([oe.PARTIAL_SIG]);
  return {
    key: ut([t, e.pubkey]),
    value: e.signature
  };
}
const k3 = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function T3(e) {
  return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && C3(e.signature);
}
function C3(e) {
  if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return !1;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return !1;
  const r = e[3 + t + 2];
  return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function P3(e, t, r) {
  const n = me(t.pubkey);
  return r.has(n) ? !1 : (r.add(n), e.filter((i) => Q(i.pubkey, t.pubkey) === 0).length === 0);
}
const I3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: P3,
  check: T3,
  decode: S3,
  encode: _3,
  expected: k3
}, Symbol.toStringTag, { value: "Module" }));
function B3(e) {
  if (e.key[0] !== oe.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + me(e.key)
    );
  return x5(e.value);
}
function O3(e) {
  return {
    key: new Uint8Array([oe.POR_COMMITMENT]),
    value: E5(e)
  };
}
const $3 = "string";
function N3(e) {
  return typeof e == "string";
}
function U3(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
const F3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: U3,
  check: N3,
  decode: B3,
  encode: O3,
  expected: $3
}, Symbol.toStringTag, { value: "Module" }));
function H3(e) {
  if (e.key[0] !== oe.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + me(e.key)
    );
  return Number(Qo(e.value, 0, "LE"));
}
function R3(e) {
  const t = Uint8Array.from([oe.SIGHASH_TYPE]), r = new Uint8Array(4);
  return ta(r, 0, e, "LE"), {
    key: t,
    value: r
  };
}
const L3 = "number";
function z3(e) {
  return typeof e == "number";
}
function j3(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
const D3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: j3,
  check: z3,
  decode: H3,
  encode: R3,
  expected: L3
}, Symbol.toStringTag, { value: "Module" }));
function M3(e) {
  if (e.key[0] !== oe.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + me(e.key)
    );
  if (!Fp(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
function K3(e) {
  return { key: Uint8Array.from([oe.TAP_KEY_SIG]), value: e };
}
const q3 = "Uint8Array";
function Fp(e) {
  return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function V3(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
const W3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: V3,
  check: Fp,
  decode: M3,
  encode: K3,
  expected: q3
}, Symbol.toStringTag, { value: "Module" }));
function G3(e) {
  if (e.key[0] !== oe.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + me(e.key)
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + me(e.key)
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + me(e.key)
    );
  const r = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: r, leafVersion: t };
}
function Z3(e) {
  const t = Uint8Array.from([oe.TAP_LEAF_SCRIPT]), r = Uint8Array.from([e.leafVersion]);
  return {
    key: ut([t, e.controlBlock]),
    value: ut([e.script, r])
  };
}
const X3 = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function Y3(e) {
  return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function J3(e, t, r) {
  const n = me(t.controlBlock);
  return r.has(n) ? !1 : (r.add(n), e.filter((i) => Q(i.controlBlock, t.controlBlock) === 0).length === 0);
}
const Q3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: J3,
  check: Y3,
  decode: G3,
  encode: Z3,
  expected: X3
}, Symbol.toStringTag, { value: "Module" }));
function e8(e) {
  if (e.key[0] !== oe.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + me(e.key)
    );
  if (!Hp(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
function t8(e) {
  return { key: Uint8Array.from([oe.TAP_MERKLE_ROOT]), value: e };
}
const r8 = "Uint8Array";
function Hp(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function n8(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
const i8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: n8,
  check: Hp,
  decode: e8,
  encode: t8,
  expected: r8
}, Symbol.toStringTag, { value: "Module" }));
function o8(e) {
  if (e.key[0] !== oe.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + me(e.key)
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + me(e.key)
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + me(e.key)
    );
  const t = e.key.slice(1, 33), r = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: r,
    signature: e.value
  };
}
function s8(e) {
  const t = Uint8Array.from([oe.TAP_SCRIPT_SIG]);
  return {
    key: ut([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
const a8 = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function c8(e) {
  return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function u8(e, t, r) {
  const n = me(t.pubkey) + me(t.leafHash);
  return r.has(n) ? !1 : (r.add(n), e.filter(
    (i) => Q(i.pubkey, t.pubkey) === 0 && Q(i.leafHash, t.leafHash) === 0
  ).length === 0);
}
const l8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: u8,
  check: c8,
  decode: o8,
  encode: s8,
  expected: a8
}, Symbol.toStringTag, { value: "Module" }));
function f8(e) {
  if (e.key[0] !== oe.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + me(e.key)
    );
  const t = np(e.value, 0, "LE");
  let r = 8;
  const { numberValue: n, bytes: i } = rs(
    e.value,
    r
  );
  r += i;
  const o = e.value.slice(r);
  if (o.length !== n)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: o,
    value: t
  };
}
function d8(e) {
  const { script: t, value: r } = e, n = Ir(t.length), i = new Uint8Array(8 + n + t.length);
  return rp(i, 0, BigInt(r), "LE"), Si(t.length, i, 8), i.set(t, 8 + n), {
    key: Uint8Array.from([oe.WITNESS_UTXO]),
    value: i
  };
}
const h8 = "{ script: Uint8Array; value: bigint; }";
function p8(e) {
  return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function g8(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
const m8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: g8,
  check: p8,
  decode: f8,
  encode: d8,
  expected: h8
}, Symbol.toStringTag, { value: "Module" }));
function b8(e) {
  if (e.key[0] !== gt.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + me(e.key)
    );
  let t = 0;
  const r = [];
  for (; t < e.value.length; ) {
    const n = e.value[t++], i = e.value[t++], { numberValue: o, bytes: s } = rs(
      e.value,
      t
    );
    t += s, r.push({
      depth: n,
      leafVersion: i,
      script: e.value.slice(t, t + o)
    }), t += o;
  }
  return { leaves: r };
}
function y8(e) {
  const t = Uint8Array.from([gt.TAP_TREE]), r = [].concat(
    ...e.leaves.map((n) => [
      Uint8Array.of(n.depth, n.leafVersion),
      Si(BigInt(n.script.length)).buffer,
      n.script
    ])
  );
  return {
    key: t,
    value: ut(r)
  };
}
const w8 = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function v8(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array
  );
}
function x8(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
const E8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: x8,
  check: v8,
  decode: b8,
  encode: y8,
  expected: w8
}, Symbol.toStringTag, { value: "Module" })), A8 = (e) => [...Array(e).keys()], S8 = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function wd(e, t = S8) {
  function r(a) {
    if (a.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + me(a.key)
      );
    const c = a.key.slice(1);
    if (!t(c))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + me(a.key)
      );
    if (a.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const u = {
      masterFingerprint: a.value.slice(0, 4),
      pubkey: c,
      path: "m"
    };
    for (const f of A8(a.value.length / 4 - 1)) {
      const l = Qo(a.value, f * 4 + 4, "LE"), h = !!(l & 2147483648), m = l & 2147483647;
      u.path += "/" + m.toString(10) + (h ? "'" : "");
    }
    return u;
  }
  function n(a) {
    const c = Uint8Array.from([e]), u = ut([c, a.pubkey]), f = a.path.split("/"), l = new Uint8Array(f.length * 4);
    l.set(a.masterFingerprint, 0);
    let h = 4;
    return f.slice(1).forEach((m) => {
      const y = m.slice(-1) === "'";
      let b = 2147483647 & parseInt(y ? m.slice(0, -1) : m, 10);
      y && (b += 2147483648), ta(l, h, b, "LE"), h += 4;
    }), {
      key: u,
      value: l
    };
  }
  const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function o(a) {
    return a.pubkey instanceof Uint8Array && a.masterFingerprint instanceof Uint8Array && typeof a.path == "string" && t(a.pubkey) && a.masterFingerprint.length === 4;
  }
  function s(a, c, u) {
    const f = me(c.pubkey);
    return u.has(f) ? !1 : (u.add(f), a.filter((l) => Q(l.pubkey, c.pubkey) === 0).length === 0);
  }
  return {
    decode: r,
    encode: n,
    check: o,
    expected: i,
    canAddToArray: s
  };
}
function vd(e) {
  return t;
  function t(r) {
    let n;
    if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![2, 3, 4].includes(n[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + me(r.key)
      );
    return n;
  }
}
function Rp(e) {
  function t(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + me(s.key)
      );
    return s.value;
  }
  function r(s) {
    return {
      key: Uint8Array.from([e]),
      value: s
    };
  }
  const n = "Uint8Array";
  function i(s) {
    return s instanceof Uint8Array;
  }
  function o(s, a) {
    return !!s && !!a && s.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: i,
    expected: n,
    canAdd: o
  };
}
const _8 = (e) => e.length === 32;
function Lp(e) {
  const t = wd(e, _8);
  function r(s) {
    const { numberValue: a, bytes: c } = rs(
      s.value
    ), u = t.decode({
      key: s.key,
      value: s.value.slice(c + Number(a) * 32)
    }), f = new Array(Number(a));
    for (let l = 0, h = c; l < a; l++, h += 32)
      f[l] = s.value.slice(h, h + 32);
    return { ...u, leafHashes: f };
  }
  function n(s) {
    const a = t.encode(s), c = Ir(s.leafHashes.length), u = new Uint8Array(c);
    Si(s.leafHashes.length, u);
    const f = ut([u, ...s.leafHashes, a.value]);
    return { ...a, value: f };
  }
  const i = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function o(s) {
    return Array.isArray(s.leafHashes) && s.leafHashes.every(
      (a) => a instanceof Uint8Array && a.length === 32
    ) && t.check(s);
  }
  return {
    decode: r,
    encode: n,
    check: o,
    expected: i,
    canAddToArray: t.canAddToArray
  };
}
function zp(e) {
  function t(s) {
    if (s.key[0] !== e || s.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + me(s.key)
      );
    if (s.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return s.value;
  }
  function r(s) {
    return { key: Uint8Array.from([e]), value: s };
  }
  const n = "Uint8Array";
  function i(s) {
    return s instanceof Uint8Array && s.length === 32;
  }
  function o(s, a) {
    return !!s && !!a && s.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: i,
    expected: n,
    canAdd: o
  };
}
function jp(e) {
  function t(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + me(s.key)
      );
    return s.value;
  }
  function r(s) {
    return {
      key: Uint8Array.from([e]),
      value: s
    };
  }
  const n = "Uint8Array";
  function i(s) {
    return s instanceof Uint8Array;
  }
  function o(s, a) {
    return !!s && !!a && s.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: i,
    expected: n,
    canAdd: o
  };
}
const xd = {
  unsignedTx: o3,
  globalXpub: n3,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: vd([])
}, Tt = {
  nonWitnessUtxo: A3,
  partialSig: I3,
  sighashType: D3,
  finalScriptSig: f3,
  finalScriptWitness: b3,
  porCommitment: F3,
  witnessUtxo: m8,
  bip32Derivation: wd(oe.BIP32_DERIVATION),
  redeemScript: Rp(oe.REDEEM_SCRIPT),
  witnessScript: jp(oe.WITNESS_SCRIPT),
  checkPubkey: vd([
    oe.PARTIAL_SIG,
    oe.BIP32_DERIVATION
  ]),
  tapKeySig: W3,
  tapScriptSig: l8,
  tapLeafScript: Q3,
  tapBip32Derivation: Lp(
    oe.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: zp(oe.TAP_INTERNAL_KEY),
  tapMerkleRoot: i8
}, _n = {
  bip32Derivation: wd(gt.BIP32_DERIVATION),
  redeemScript: Rp(gt.REDEEM_SCRIPT),
  witnessScript: jp(gt.WITNESS_SCRIPT),
  checkPubkey: vd([gt.BIP32_DERIVATION]),
  tapBip32Derivation: Lp(
    gt.TAP_BIP32_DERIVATION
  ),
  tapTree: E8,
  tapInternalKey: zp(gt.TAP_INTERNAL_KEY)
}, k8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  globals: xd,
  inputs: Tt,
  outputs: _n
}, Symbol.toStringTag, { value: "Module" })), mc = (e) => [...Array(e).keys()];
function h0(e) {
  const t = e.map(T8);
  return t.push(Uint8Array.from([0])), ut(t);
}
function T8(e) {
  const t = e.key.length, r = e.value.length, n = Ir(t), i = Ir(r), o = new Uint8Array(n + t + i + r);
  return Si(t, o, 0), o.set(e.key, n), Si(r, o, n + t), o.set(e.value, n + t + i), o;
}
function C8(e, t) {
  let r = 0;
  function n() {
    const { numberValue: g, bytes: v } = rs(e, r);
    r += v;
    const _ = e.slice(r, r + Number(g));
    return r += Number(g), _;
  }
  function i() {
    const g = Qo(e, r, "BE");
    return r += 4, g;
  }
  function o() {
    const g = $n(e, r);
    return r += 1, g;
  }
  function s() {
    const g = n(), v = n();
    return {
      key: g,
      value: v
    };
  }
  function a() {
    if (r >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const g = $n(e, r) === 0;
    return g && r++, g;
  }
  if (i() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (o() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const c = [], u = {};
  for (; !a(); ) {
    const g = s(), v = me(g.key);
    if (u[v])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + v
      );
    u[v] = 1, c.push(g);
  }
  const f = c.filter(
    (g) => g.key[0] === ln.UNSIGNED_TX
  );
  if (f.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const l = t(f[0].value), { inputCount: h, outputCount: m } = l.getInputOutputCounts(), y = [], b = [];
  for (const g of mc(h)) {
    const v = {}, _ = [];
    for (; !a(); ) {
      const x = s(), k = me(x.key);
      if (v[k])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + g + " key " + k
        );
      v[k] = 1, _.push(x);
    }
    y.push(_);
  }
  for (const g of mc(m)) {
    const v = {}, _ = [];
    for (; !a(); ) {
      const x = s(), k = me(x.key);
      if (v[k])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + g + " key " + k
        );
      v[k] = 1, _.push(x);
    }
    b.push(_);
  }
  return Dp(l, {
    globalMapKeyVals: c,
    inputKeyVals: y,
    outputKeyVals: b
  });
}
function Kt(e, t, r) {
  if (Q(t, Uint8Array.from([r])))
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${e} key: ${me(t)}`
    );
}
function Dp(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
  const i = {
    unsignedTx: e
  };
  let o = 0;
  for (const f of t)
    switch (f.key[0]) {
      case ln.UNSIGNED_TX:
        if (Kt("global", f.key, ln.UNSIGNED_TX), o > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        o++;
        break;
      case ln.GLOBAL_XPUB:
        i.globalXpub === void 0 && (i.globalXpub = []), i.globalXpub.push(xd.globalXpub.decode(f));
        break;
      default:
        i.unknownKeyVals || (i.unknownKeyVals = []), i.unknownKeyVals.push(f);
    }
  const s = r.length, a = n.length, c = [], u = [];
  for (const f of mc(s)) {
    const l = {};
    for (const h of r[f])
      switch (Tt.checkPubkey(h), h.key[0]) {
        case oe.NON_WITNESS_UTXO:
          if (Kt("input", h.key, oe.NON_WITNESS_UTXO), l.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          l.nonWitnessUtxo = Tt.nonWitnessUtxo.decode(h);
          break;
        case oe.WITNESS_UTXO:
          if (Kt("input", h.key, oe.WITNESS_UTXO), l.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          l.witnessUtxo = Tt.witnessUtxo.decode(h);
          break;
        case oe.PARTIAL_SIG:
          l.partialSig === void 0 && (l.partialSig = []), l.partialSig.push(Tt.partialSig.decode(h));
          break;
        case oe.SIGHASH_TYPE:
          if (Kt("input", h.key, oe.SIGHASH_TYPE), l.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          l.sighashType = Tt.sighashType.decode(h);
          break;
        case oe.REDEEM_SCRIPT:
          if (Kt("input", h.key, oe.REDEEM_SCRIPT), l.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          l.redeemScript = Tt.redeemScript.decode(h);
          break;
        case oe.WITNESS_SCRIPT:
          if (Kt("input", h.key, oe.WITNESS_SCRIPT), l.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          l.witnessScript = Tt.witnessScript.decode(h);
          break;
        case oe.BIP32_DERIVATION:
          l.bip32Derivation === void 0 && (l.bip32Derivation = []), l.bip32Derivation.push(
            Tt.bip32Derivation.decode(h)
          );
          break;
        case oe.FINAL_SCRIPTSIG:
          Kt("input", h.key, oe.FINAL_SCRIPTSIG), l.finalScriptSig = Tt.finalScriptSig.decode(h);
          break;
        case oe.FINAL_SCRIPTWITNESS:
          Kt("input", h.key, oe.FINAL_SCRIPTWITNESS), l.finalScriptWitness = Tt.finalScriptWitness.decode(
            h
          );
          break;
        case oe.POR_COMMITMENT:
          Kt("input", h.key, oe.POR_COMMITMENT), l.porCommitment = Tt.porCommitment.decode(h);
          break;
        case oe.TAP_KEY_SIG:
          Kt("input", h.key, oe.TAP_KEY_SIG), l.tapKeySig = Tt.tapKeySig.decode(h);
          break;
        case oe.TAP_SCRIPT_SIG:
          l.tapScriptSig === void 0 && (l.tapScriptSig = []), l.tapScriptSig.push(Tt.tapScriptSig.decode(h));
          break;
        case oe.TAP_LEAF_SCRIPT:
          l.tapLeafScript === void 0 && (l.tapLeafScript = []), l.tapLeafScript.push(Tt.tapLeafScript.decode(h));
          break;
        case oe.TAP_BIP32_DERIVATION:
          l.tapBip32Derivation === void 0 && (l.tapBip32Derivation = []), l.tapBip32Derivation.push(
            Tt.tapBip32Derivation.decode(h)
          );
          break;
        case oe.TAP_INTERNAL_KEY:
          Kt("input", h.key, oe.TAP_INTERNAL_KEY), l.tapInternalKey = Tt.tapInternalKey.decode(h);
          break;
        case oe.TAP_MERKLE_ROOT:
          Kt("input", h.key, oe.TAP_MERKLE_ROOT), l.tapMerkleRoot = Tt.tapMerkleRoot.decode(h);
          break;
        default:
          l.unknownKeyVals || (l.unknownKeyVals = []), l.unknownKeyVals.push(h);
      }
    c.push(l);
  }
  for (const f of mc(a)) {
    const l = {};
    for (const h of n[f])
      switch (_n.checkPubkey(h), h.key[0]) {
        case gt.REDEEM_SCRIPT:
          if (Kt("output", h.key, gt.REDEEM_SCRIPT), l.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          l.redeemScript = _n.redeemScript.decode(h);
          break;
        case gt.WITNESS_SCRIPT:
          if (Kt("output", h.key, gt.WITNESS_SCRIPT), l.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          l.witnessScript = _n.witnessScript.decode(h);
          break;
        case gt.BIP32_DERIVATION:
          l.bip32Derivation === void 0 && (l.bip32Derivation = []), l.bip32Derivation.push(
            _n.bip32Derivation.decode(h)
          );
          break;
        case gt.TAP_INTERNAL_KEY:
          Kt("output", h.key, gt.TAP_INTERNAL_KEY), l.tapInternalKey = _n.tapInternalKey.decode(h);
          break;
        case gt.TAP_TREE:
          Kt("output", h.key, gt.TAP_TREE), l.tapTree = _n.tapTree.decode(h);
          break;
        case gt.TAP_BIP32_DERIVATION:
          l.tapBip32Derivation === void 0 && (l.tapBip32Derivation = []), l.tapBip32Derivation.push(
            _n.tapBip32Derivation.decode(h)
          );
          break;
        default:
          l.unknownKeyVals || (l.unknownKeyVals = []), l.unknownKeyVals.push(h);
      }
    u.push(l);
  }
  return { globalMap: i, inputs: c, outputs: u };
}
function P8({ globalMap: e, inputs: t, outputs: r }) {
  const { globalKeyVals: n, inputKeyVals: i, outputKeyVals: o } = lf({
    globalMap: e,
    inputs: t,
    outputs: r
  }), s = h0(n), a = (l) => l.length === 0 ? [Uint8Array.from([0])] : l.map(h0), c = a(i), u = a(o), f = new Uint8Array(5);
  return f.set([112, 115, 98, 116, 255], 0), ut(
    [f, s].concat(c, u)
  );
}
const I8 = (e, t) => Q(e.key, t.key);
function hl(e, t) {
  const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((o, [s, a]) => {
    if (s === "unknownKeyVals") return o;
    const c = t[s];
    if (c === void 0) return o;
    const u = (Array.isArray(a) ? a : [a]).map(
      c.encode
    );
    return u.map((l) => me(l.key)).forEach((l) => {
      if (r.has(l))
        throw new Error("Serialize Error: Duplicate key: " + l);
      r.add(l);
    }), o.concat(u);
  }, []), i = e.unknownKeyVals ? e.unknownKeyVals.filter((o) => !r.has(me(o.key))) : [];
  return n.concat(i).sort(I8);
}
function lf({ globalMap: e, inputs: t, outputs: r }) {
  return {
    globalKeyVals: hl(e, xd),
    inputKeyVals: t.map((n) => hl(n, Tt)),
    outputKeyVals: r.map((n) => hl(n, _n))
  };
}
function B8(e) {
  const t = e[0], r = lf(t), n = e.slice(1);
  if (n.length === 0) throw new Error("Combine: Nothing to combine");
  const i = p0(t);
  if (i === void 0)
    throw new Error("Combine: Self missing transaction");
  const o = So(r.globalKeyVals), s = r.inputKeyVals.map(So), a = r.outputKeyVals.map(So);
  for (const c of n) {
    const u = p0(c);
    if (u === void 0 || Q(u.toBuffer(), i.toBuffer()) !== 0)
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const f = lf(c);
    So(f.globalKeyVals).forEach(
      pl(
        o,
        r.globalKeyVals,
        f.globalKeyVals
      )
    ), f.inputKeyVals.map(So).forEach(
      (y, b) => y.forEach(
        pl(
          s[b],
          r.inputKeyVals[b],
          f.inputKeyVals[b]
        )
      )
    ), f.outputKeyVals.map(So).forEach(
      (y, b) => y.forEach(
        pl(
          a[b],
          r.outputKeyVals[b],
          f.outputKeyVals[b]
        )
      )
    );
  }
  return Dp(i, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
}
function pl(e, t, r) {
  return (n) => {
    if (e.has(n)) return;
    const i = r.filter((o) => me(o.key) === n)[0];
    t.push(i), e.add(n);
  };
}
function p0(e) {
  return e.globalMap.unsignedTx;
}
function So(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    const n = me(r.key);
    if (t.has(n))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(n);
  }), t;
}
function jt(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No input #${t}`);
  return r;
}
function Us(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No output #${t}`);
  return r;
}
function gl(e, t, r) {
  if (e.key[0] < r)
    throw new Error(
      "Use the method for your specific key instead of addUnknownKeyVal*"
    );
  if (t && t.filter((n) => Q(n.key, e.key) === 0).length !== 0)
    throw new Error(`Duplicate Key: ${me(e.key)}`);
}
function ml(e) {
  let t = 0;
  return Object.keys(e).forEach((r) => {
    Number(isNaN(Number(r))) && t++;
  }), t;
}
function O8(e, t) {
  let r = !1;
  if (t.nonWitnessUtxo || t.witnessUtxo) {
    const n = !!t.redeemScript, i = !!t.witnessScript, o = !n || !!t.finalScriptSig, s = !i || !!t.finalScriptWitness, a = !!t.finalScriptSig || !!t.finalScriptWitness;
    r = o && s && a;
  }
  if (r === !1)
    throw new Error(
      `Input #${e} has too much or too little data to clean`
    );
}
function g0(e, t, r, n) {
  throw new Error(
    `Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`
  );
}
function Ed(e) {
  return (t, r) => {
    for (const n of Object.keys(t)) {
      const i = t[n], { canAdd: o, canAddToArray: s, check: a, expected: c } = (
        // @ts-ignore
        k8[e + "s"][n] || {}
      ), u = !!s;
      if (a)
        if (u) {
          if (!Array.isArray(i) || // @ts-ignore
          r[n] && !Array.isArray(r[n]))
            throw new Error(`Key type ${n} must be an array`);
          i.every(a) || g0(e, n, c, i);
          const f = r[n] || [], l = /* @__PURE__ */ new Set();
          if (!i.every((h) => s(f, h, l)))
            throw new Error("Can not add duplicate data to array");
          r[n] = f.concat(i);
        } else {
          if (a(i) || g0(e, n, c, i), !o(r, i))
            throw new Error(`Can not add duplicate data to ${e}`);
          r[n] = i;
        }
    }
  };
}
const $8 = Ed("global"), Mp = Ed("input"), Kp = Ed("output");
function N8(e, t) {
  const r = e.length - 1, n = jt(e, r);
  Mp(t, n);
}
function U8(e, t) {
  const r = e.length - 1, n = Us(e, r);
  Kp(t, n);
}
let m0 = class {
  constructor(t) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: t
    };
  }
  static fromBase64(t, r) {
    const n = ep(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r) {
    const n = Rn(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r) {
    const n = C8(t, r), i = new this(n.globalMap.unsignedTx);
    return Object.assign(i, n), i;
  }
  toBase64() {
    const t = this.toBuffer();
    return _5(t);
  }
  toHex() {
    const t = this.toBuffer();
    return me(t);
  }
  toBuffer() {
    return P8(this);
  }
  updateGlobal(t) {
    return $8(t, this.globalMap), this;
  }
  updateInput(t, r) {
    const n = jt(this.inputs, t);
    return Mp(r, n), this;
  }
  updateOutput(t, r) {
    const n = Us(this.outputs, t);
    return Kp(r, n), this;
  }
  addUnknownKeyValToGlobal(t) {
    return gl(
      t,
      this.globalMap.unknownKeyVals,
      ml(ln)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    const n = jt(this.inputs, t);
    return gl(r, n.unknownKeyVals, ml(oe)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    const n = Us(this.outputs, t);
    return gl(r, n.unknownKeyVals, ml(gt)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
  }
  addInput(t) {
    this.globalMap.unsignedTx.addInput(t), this.inputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], n = this.inputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (i) => this.addUnknownKeyValToInput(n, i)
    ), N8(this.inputs, t), this;
  }
  addOutput(t) {
    this.globalMap.unsignedTx.addOutput(t), this.outputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], n = this.outputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (i) => this.addUnknownKeyValToOutput(n, i)
    ), U8(this.outputs, t), this;
  }
  clearFinalizedInput(t) {
    const r = jt(this.inputs, t);
    O8(t, r);
    for (const n of Object.keys(r))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(n) || delete r[n];
    return this;
  }
  combine(...t) {
    const r = B8([this].concat(t));
    return Object.assign(this, r), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function lo(e) {
  return (t) => {
    try {
      return e({ output: t }), !0;
    } catch {
      return !1;
    }
  };
}
const F8 = lo(eu), H8 = lo(bp), R8 = lo(ra), nu = lo(na), b0 = lo(ia), qp = lo(ts), Vp = lo(oa);
function bc(e) {
  let t = new Uint8Array(0);
  function r(s) {
    t = ut([t, s]);
  }
  function n(s) {
    const a = t.length, c = Ir(s);
    t = ut([t, new Uint8Array(c)]), Si(s, t, a);
  }
  function i(s) {
    n(s.length), r(s);
  }
  function o(s) {
    n(s.length), s.forEach(i);
  }
  return o(e), t;
}
function Wp(e, t) {
  const r = In(e), n = e.slice(1, 33), i = at(t);
  if (i === null) throw new Error("Unknown script error");
  return i.findIndex((o) => typeof o == "number" ? !1 : Q(e, o) === 0 || Q(r, o) === 0 || Q(n, o) === 0);
}
function iu(e, t) {
  return Wp(e, t) !== -1;
}
function L8(e, t) {
  return z8(e).some(
    (n) => Gp(n, _s.decode, t)
  );
}
function Gp(e, t, r) {
  const { hashType: n } = t(e), i = [];
  switch (n & st.SIGHASH_ANYONECANPAY && i.push("addInput"), n & 31) {
    case st.SIGHASH_ALL:
      break;
    case st.SIGHASH_SINGLE:
    case st.SIGHASH_NONE:
      i.push("addOutput"), i.push("setInputSequence");
      break;
  }
  return i.indexOf(r) === -1;
}
function z8(e) {
  let t = [];
  if ((e.partialSig || []).length === 0) {
    if (!e.finalScriptSig && !e.finalScriptWitness) return [];
    t = j8(e);
  } else
    t = e.partialSig;
  return t.map((r) => r.signature);
}
function j8(e) {
  const t = e.finalScriptSig ? at(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? at(e.finalScriptWitness) || [] : [];
  return t.concat(r).filter((n) => n instanceof Uint8Array && Nn(n)).map((n) => ({ signature: n }));
}
const Ts = (e) => e.length === 32 ? e : e.slice(1, 33);
function y0(e, t, r) {
  const n = t4(
    t,
    e,
    r
  );
  try {
    const o = Q8(t, n).concat(n.script).concat(n.controlBlock);
    return { finalScriptWitness: bc(o) };
  } catch (i) {
    throw new Error(`Can not finalize taproot input #${e}: ${i}`);
  }
}
function Na(e, t) {
  const r = t ? Uint8Array.from([t]) : Uint8Array.from([]);
  return ut([e, r]);
}
function Fr(e) {
  return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && Vp(e.witnessUtxo.script));
}
function bl(e, t) {
  return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function w0(e, t, r) {
  X8(e, t, r), J8(e, t, r);
}
function v0(e, t, r) {
  Y8(e, t, r), D8(e, t);
}
function D8(e, t) {
  if (!t.tapTree && !t.tapInternalKey) return;
  const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
  if (r) {
    const { script: i } = e, o = M8(r, n);
    if (i && Q(o, i) !== 0)
      throw new Error("Error adding output. Script or address mismatch.");
  }
}
function M8(e, t) {
  const r = t && K8(t.leaves), { output: n } = oa({
    internalPubkey: e,
    scriptTree: r
  });
  return n;
}
function K8(e = []) {
  return e.length === 1 && e[0].depth === 0 ? {
    output: e[0].script,
    version: e[0].leafVersion
  } : Z8(e);
}
function q8(e, t) {
  return W8(e).some(
    (n) => Gp(n, V8, t)
  );
}
function V8(e) {
  return {
    signature: e.slice(0, 64),
    hashType: e.slice(64)[0] || st.SIGHASH_DEFAULT
  };
}
function W8(e) {
  const t = [];
  if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r) => r.signature)), !t.length) {
    const r = G8(e.finalScriptWitness);
    r && t.push(r);
  }
  return t;
}
function G8(e) {
  if (!e) return;
  const t = e.slice(2);
  if (t.length === 64 || t.length === 65) return t;
}
function Z8(e) {
  let t;
  for (const r of e)
    if (t = ff(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
  return t;
}
function ff(e, t, r = 0) {
  if (r > zw) throw new Error("Max taptree depth exceeded.");
  if (e.depth === r)
    return t ? void 0 : {
      output: e.script,
      version: e.leafVersion
    };
  if (ad(t)) return;
  const n = ff(e, t && t[0], r + 1);
  if (n) return [n, t && t[1]];
  const i = ff(e, t && t[1], r + 1);
  if (i) return [t && t[0], i];
}
function X8(e, t, r) {
  const n = Fr(e) && $o(t), i = $o(e) && Fr(t), o = e === t && Fr(t) && $o(t);
  if (n || i || o)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function Y8(e, t, r) {
  const n = bl(e) && $o(t), i = $o(e) && bl(t), o = e === t && bl(t) && $o(t);
  if (n || i || o)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function J8(e, t, r) {
  if (t.tapMerkleRoot) {
    const n = (t.tapLeafScript || []).every(
      (o) => yl(o, t.tapMerkleRoot)
    ), i = (e.tapLeafScript || []).every(
      (o) => yl(o, t.tapMerkleRoot)
    );
    if (!n || !i)
      throw new Error(
        `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
      );
  } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every(
    (i) => yl(i, e.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
    );
}
function yl(e, t) {
  if (!t) return !0;
  const r = Pn({
    output: e.script,
    version: e.leafVersion
  }), n = af(e.controlBlock, r);
  return Q(n, t) === 0;
}
function Q8(e, t) {
  const r = Pn({
    output: t.script,
    version: t.leafVersion
  });
  return (e.tapScriptSig || []).filter((n) => Q(n.leafHash, r) === 0).map((n) => e4(t.script, n)).sort((n, i) => i.positionInScript - n.positionInScript).map((n) => n.signature);
}
function e4(e, t) {
  return Object.assign(
    {
      positionInScript: Wp(t.pubkey, e)
    },
    t
  );
}
function t4(e, t, r) {
  if (!e.tapScriptSig || !e.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${t}. No tapleaf script signature provided.`
    );
  const n = (e.tapLeafScript || []).sort((i, o) => i.controlBlock.length - o.controlBlock.length).find(
    (i) => r4(i, e.tapScriptSig, r)
  );
  if (!n)
    throw new Error(
      `Can not finalize taproot input #${t}. Signature for tapleaf script not found.`
    );
  return n;
}
function r4(e, t, r) {
  const n = Pn({
    output: e.script,
    version: e.leafVersion
  });
  return (!r || Q(n, r) === 0) && t.find((o) => Q(o.leafHash, n) === 0) !== void 0;
}
function $o(e) {
  return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
const n4 = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: Gr,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Qe {
  constructor(t = {}, r = new m0(new Zp())) {
    Le(this, "data");
    Le(this, "__CACHE");
    Le(this, "opts");
    this.data = r, this.opts = Object.assign({}, n4, t), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const n = (i, o, s, a) => Object.defineProperty(i, o, {
      enumerable: s,
      writable: a
    });
    n(this, "__CACHE", !1, !0), n(this, "opts", !1, !0);
  }
  static fromBase64(t, r = {}) {
    const n = ep(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r = {}) {
    const n = Rn(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r = {}) {
    const n = m0.fromBuffer(t, i4), i = new Qe(r, n);
    return u4(i.__CACHE.__TX, i.__CACHE), i;
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((t) => ({
      hash: c0(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((t) => {
      let r;
      try {
        r = sa(t.script, this.opts.network);
      } catch {
      }
      return {
        script: c0(t.script),
        value: t.value,
        address: r
      };
    });
  }
  combine(...t) {
    return this.data.combine(...t.map((r) => r.data)), this;
  }
  clone() {
    const t = Qe.fromBuffer(this.data.toBuffer());
    return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
  }
  setMaximumFeeRate(t) {
    Ua(t), this.opts.maximumFeeRate = t;
  }
  setVersion(t) {
    Ua(t), ps(this.data.inputs, "setVersion");
    const r = this.__CACHE;
    return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(t) {
    Ua(t), ps(this.data.inputs, "setLocktime");
    const r = this.__CACHE;
    return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(t, r) {
    Ua(r), ps(this.data.inputs, "setInputSequence");
    const n = this.__CACHE;
    if (n.__TX.ins.length <= t)
      throw new Error("Input index too high");
    return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
  }
  addInputs(t) {
    return t.forEach((r) => this.addInput(r)), this;
  }
  addInput(t) {
    if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    w0(t, t, "addInput"), ps(this.data.inputs, "addInput"), t.witnessScript && yc(t.witnessScript);
    const r = this.__CACHE;
    this.data.addInput(t);
    const n = r.__TX.ins[r.__TX.ins.length - 1];
    Jp(r, n);
    const i = this.data.inputs.length - 1, o = this.data.inputs[i];
    return o.nonWitnessUtxo && hf(this.__CACHE, o, i), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(t) {
    return t.forEach((r) => this.addOutput(r)), this;
  }
  addOutput(t) {
    if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    ps(this.data.inputs, "addOutput");
    const { address: r } = t;
    if (typeof r == "string") {
      const { network: i } = this.opts, o = yd(r, i);
      t = Object.assign({}, t, { script: o });
    }
    v0(t, t, "addOutput");
    const n = this.__CACHE;
    return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(t) {
    if (!this.data.inputs.every(Xp)) throw new Error("Not finalized");
    const r = this.__CACHE;
    if (t || s4(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
    const n = r.__TX.clone();
    return ig(this.data.inputs, n, r, !0), n;
  }
  getFeeRate() {
    return _0(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return _0("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return jt(this.data.inputs, 0), gs(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, r) {
    const n = jt(this.data.inputs, t);
    return Fr(n) ? this._finalizeTaprootInput(
      t,
      n,
      void 0,
      r
    ) : this._finalizeInput(t, n, r);
  }
  finalizeTaprootInput(t, r, n = y0) {
    const i = jt(this.data.inputs, t);
    if (Fr(i))
      return this._finalizeTaprootInput(
        t,
        i,
        r,
        n
      );
    throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
  }
  _finalizeInput(t, r, n = l4) {
    const { script: i, isP2SH: o, isP2WSH: s, isSegwit: a } = p4(
      t,
      r,
      this.__CACHE
    );
    if (!i) throw new Error(`No script found for input #${t}`);
    a4(r);
    const { finalScriptSig: c, finalScriptWitness: u } = n(
      t,
      r,
      i,
      a,
      o,
      s
    );
    if (c && this.data.updateInput(t, { finalScriptSig: c }), u && this.data.updateInput(t, { finalScriptWitness: u }), !c && !u)
      throw new Error(`Unknown error finalizing input #${t}`);
    return this.data.clearFinalizedInput(t), this;
  }
  _finalizeTaprootInput(t, r, n, i = y0) {
    if (!r.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${t}. Missing withness utxo.`
      );
    if (r.tapKeySig) {
      const o = oa({
        output: r.witnessUtxo.script,
        signature: r.tapKeySig
      }), s = bc(o.witness);
      this.data.updateInput(t, { finalScriptWitness: s });
    } else {
      const { finalScriptWitness: o } = i(
        t,
        r,
        n
      );
      this.data.updateInput(t, { finalScriptWitness: o });
    }
    return this.data.clearFinalizedInput(t), this;
  }
  getInputType(t) {
    const r = jt(this.data.inputs, t), n = og(t, r, this.__CACHE), i = su(
      n,
      t,
      "input",
      r.redeemScript || w4(r.finalScriptSig),
      r.witnessScript || v4(r.finalScriptWitness)
    ), o = i.type === "raw" ? "" : i.type + "-", s = ag(i.meaningfulScript);
    return o + s;
  }
  inputHasPubkey(t, r) {
    const n = jt(this.data.inputs, t);
    return b4(r, n, t, this.__CACHE);
  }
  inputHasHDKey(t, r) {
    const n = jt(this.data.inputs, t), i = E0(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(i);
  }
  outputHasPubkey(t, r) {
    const n = Us(this.data.outputs, t);
    return y4(r, n, t, this.__CACHE);
  }
  outputHasHDKey(t, r) {
    const n = Us(this.data.outputs, t), i = E0(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(i);
  }
  validateSignaturesOfAllInputs(t) {
    return jt(this.data.inputs, 0), gs(this.data.inputs.length).map(
      (n) => this.validateSignaturesOfInput(n, t)
    ).reduce((n, i) => i === !0 && n, !0);
  }
  validateSignaturesOfInput(t, r, n) {
    const i = this.data.inputs[t];
    return Fr(i) ? this.validateSignaturesOfTaprootInput(
      t,
      r,
      n
    ) : this._validateSignaturesOfInput(t, r, n);
  }
  _validateSignaturesOfInput(t, r, n) {
    const i = this.data.inputs[t], o = (i || {}).partialSig;
    if (!i || !o || o.length < 1)
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    const s = n ? o.filter((l) => Q(l.pubkey, n) === 0) : o;
    if (s.length < 1) throw new Error("No signatures for this pubkey");
    const a = [];
    let c, u, f;
    for (const l of s) {
      const h = _s.decode(l.signature), { hash: m, script: y } = f !== h.hashType ? eg(
        t,
        Object.assign({}, i, { sighashType: h.hashType }),
        this.__CACHE,
        !0
      ) : { hash: c, script: u };
      f = h.hashType, c = m, u = y, Yp(l.pubkey, y, "verify"), a.push(r(l.pubkey, m, h.signature));
    }
    return a.every((l) => l === !0);
  }
  validateSignaturesOfTaprootInput(t, r, n) {
    const i = this.data.inputs[t], o = (i || {}).tapKeySig, s = (i || {}).tapScriptSig;
    if (!i && !o && !(s && !s.length))
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    n = n && Ts(n);
    const a = n ? df(
      t,
      i,
      this.data.inputs,
      n,
      this.__CACHE
    ) : d4(
      t,
      i,
      this.data.inputs,
      this.__CACHE
    );
    if (!a.length) throw new Error("No signatures for this pubkey");
    const c = a.find((f) => !f.leafHash);
    let u = 0;
    if (o && c) {
      if (!r(
        c.pubkey,
        c.hash,
        T0(o)
      )) return !1;
      u++;
    }
    if (s)
      for (const f of s) {
        const l = a.find(
          (h) => Q(h.pubkey, f.pubkey) === 0
        );
        if (l) {
          if (!r(
            f.pubkey,
            l.hash,
            T0(f.signature)
          )) return !1;
          u++;
        }
      }
    return u > 0;
  }
  signAllInputsHD(t, r = [st.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const n = [];
    for (const i of gs(this.data.inputs.length))
      try {
        this.signInputHD(i, t, r), n.push(!0);
      } catch {
        n.push(!1);
      }
    if (n.every((i) => i === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(t, r = [st.SIGHASH_ALL]) {
    return new Promise((n, i) => {
      if (!t || !t.publicKey || !t.fingerprint)
        return i(new Error("Need HDSigner to sign input"));
      const o = [], s = [];
      for (const a of gs(this.data.inputs.length))
        s.push(
          this.signInputHDAsync(a, t, r).then(
            () => {
              o.push(!0);
            },
            () => {
              o.push(!1);
            }
          )
        );
      return Promise.all(s).then(() => {
        if (o.every((a) => a === !1))
          return i(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInputHD(t, r, n = [st.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return C0(t, this.data.inputs, r).forEach((o) => this.signInput(t, o, n)), this;
  }
  signInputHDAsync(t, r, n = [st.SIGHASH_ALL]) {
    return new Promise((i, o) => {
      if (!r || !r.publicKey || !r.fingerprint)
        return o(new Error("Need HDSigner to sign input"));
      const a = C0(t, this.data.inputs, r).map(
        (c) => this.signInputAsync(t, c, n)
      );
      return Promise.all(a).then(() => {
        i();
      }).catch(o);
    });
  }
  signAllInputs(t, r) {
    if (!t || !t.publicKey)
      throw new Error("Need Signer to sign input");
    const n = [];
    for (const i of gs(this.data.inputs.length))
      try {
        this.signInput(i, t, r), n.push(!0);
      } catch {
        n.push(!1);
      }
    if (n.every((i) => i === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(t, r) {
    return new Promise((n, i) => {
      if (!t || !t.publicKey)
        return i(new Error("Need Signer to sign input"));
      const o = [], s = [];
      for (const [a] of this.data.inputs.entries())
        s.push(
          this.signInputAsync(a, t, r).then(
            () => {
              o.push(!0);
            },
            () => {
              o.push(!1);
            }
          )
        );
      return Promise.all(s).then(() => {
        if (o.every((a) => a === !1))
          return i(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInput(t, r, n) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const i = jt(this.data.inputs, t);
    return Fr(i) ? this._signTaprootInput(
      t,
      i,
      r,
      void 0,
      n
    ) : this._signInput(t, r, n);
  }
  signTaprootInput(t, r, n, i) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const o = jt(this.data.inputs, t);
    if (Fr(o))
      return this._signTaprootInput(
        t,
        o,
        r,
        n,
        i
      );
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  _signInput(t, r, n = [st.SIGHASH_ALL]) {
    const { hash: i, sighashType: o } = k0(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    ), s = [
      {
        pubkey: r.publicKey,
        signature: _s.encode(r.sign(i), o)
      }
    ];
    return this.data.updateInput(t, { partialSig: s }), this;
  }
  _signTaprootInput(t, r, n, i, o = [st.SIGHASH_DEFAULT]) {
    const s = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      i,
      o
    ), a = s.filter((u) => !u.leafHash).map(
      (u) => Na(
        n.signSchnorr(u.hash),
        r.sighashType
      )
    )[0], c = s.filter((u) => !!u.leafHash).map((u) => ({
      pubkey: Ts(n.publicKey),
      signature: Na(
        n.signSchnorr(u.hash),
        r.sighashType
      ),
      leafHash: u.leafHash
    }));
    return a && this.data.updateInput(t, { tapKeySig: a }), c.length && this.data.updateInput(t, { tapScriptSig: c }), this;
  }
  signInputAsync(t, r, n) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const i = jt(this.data.inputs, t);
      return Fr(i) ? this._signTaprootInputAsync(
        t,
        i,
        r,
        void 0,
        n
      ) : this._signInputAsync(t, r, n);
    });
  }
  signTaprootInputAsync(t, r, n, i) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const o = jt(this.data.inputs, t);
      if (Fr(o))
        return this._signTaprootInputAsync(
          t,
          o,
          r,
          n,
          i
        );
      throw new Error(`Input #${t} is not of type Taproot.`);
    });
  }
  _signInputAsync(t, r, n = [st.SIGHASH_ALL]) {
    const { hash: i, sighashType: o } = k0(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    );
    return Promise.resolve(r.sign(i)).then((s) => {
      const a = [
        {
          pubkey: r.publicKey,
          signature: _s.encode(s, o)
        }
      ];
      this.data.updateInput(t, { partialSig: a });
    });
  }
  async _signTaprootInputAsync(t, r, n, i, o = [st.SIGHASH_DEFAULT]) {
    const s = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      i,
      o
    ), a = [], c = s.filter((f) => !f.leafHash)[0];
    if (c) {
      const f = Promise.resolve(
        n.signSchnorr(c.hash)
      ).then((l) => ({ tapKeySig: Na(l, r.sighashType) }));
      a.push(f);
    }
    const u = s.filter((f) => !!f.leafHash);
    if (u.length) {
      const f = u.map((l) => Promise.resolve(n.signSchnorr(l.hash)).then(
        (h) => ({ tapScriptSig: [
          {
            pubkey: Ts(n.publicKey),
            signature: Na(
              h,
              r.sighashType
            ),
            leafHash: l.leafHash
          }
        ] })
      ));
      a.push(...f);
    }
    return Promise.all(a).then((f) => {
      f.forEach((l) => this.data.updateInput(t, l));
    });
  }
  checkTaprootHashesForSig(t, r, n, i, o) {
    if (typeof n.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${t}.`
      );
    const s = df(
      t,
      r,
      this.data.inputs,
      n.publicKey,
      this.__CACHE,
      i,
      o
    );
    if (!s || !s.length)
      throw new Error(
        `Can not sign for input #${t} with the key ${me(n.publicKey)}`
      );
    return s;
  }
  toBuffer() {
    return wl(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return wl(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return wl(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, r) {
    return r.witnessScript && yc(r.witnessScript), w0(
      this.data.inputs[t],
      r,
      "updateInput"
    ), this.data.updateInput(t, r), r.nonWitnessUtxo && hf(
      this.__CACHE,
      this.data.inputs[t],
      t
    ), this;
  }
  updateOutput(t, r) {
    const n = this.data.outputs[t];
    return v0(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    return this.data.addUnknownKeyValToInput(t, r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    return this.data.addUnknownKeyValToOutput(t, r), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
}
const i4 = (e) => new Zp(e);
class Zp {
  constructor(t = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    Le(this, "tx");
    this.tx = st.fromBuffer(t), c4(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const r = typeof t.hash == "string" ? md(Rn(t.hash)) : t.hash;
    this.tx.addInput(r, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function o4(e, t, r) {
  switch (r) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return x0(1, e.partialSig);
    case "multisig":
      const n = eu({ output: t });
      return x0(n.m, e.partialSig, n.pubkeys);
    default:
      return !1;
  }
}
function wl(e) {
  if (e.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function x0(e, t, r) {
  if (!t) return !1;
  let n;
  if (r ? n = r.map((i) => {
    const o = x4(i);
    return t.find(
      (s) => Q(s.pubkey, o) === 0
    );
  }).filter((i) => !!i) : n = t, n.length > e) throw new Error("Too many signatures");
  return n.length === e;
}
function Xp(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function E0(e) {
  return (t) => !(Q(e.fingerprint, t.masterFingerprint) || Q(e.derivePath(t.path).publicKey, t.pubkey));
}
function Ua(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function s4(e, t, r) {
  const n = t.__FEE_RATE || e.getFeeRate(), i = t.__EXTRACTED_TX.virtualSize(), o = n * i;
  if (n >= r.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(o / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${i} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function ps(e, t) {
  e.forEach((r) => {
    if (Fr(r) ? q8(r, t) : L8(r, t))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function a4(e) {
  if (!e.sighashType || !e.partialSig) return;
  const { partialSig: t, sighashType: r } = e;
  t.forEach((n) => {
    const { hashType: i } = _s.decode(n.signature);
    if (r !== i)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function Yp(e, t, r) {
  if (!iu(e, t))
    throw new Error(
      `Can not ${r} for this input with the key ${me(e)}`
    );
}
function c4(e) {
  if (!e.ins.every(
    (r) => r.script && r.script.length === 0 && r.witness && r.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function u4(e, t) {
  e.ins.forEach((r) => {
    Jp(t, r);
  });
}
function Jp(e, t) {
  const r = me(md(Uint8Array.from(t.hash))) + ":" + t.index;
  if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
  e.__TX_IN_CACHE[r] = 1;
}
function Qp(e, t) {
  return (r, n, i, o) => {
    const s = e({
      redeem: { output: i }
    }).output;
    if (Q(n, s))
      throw new Error(
        `${t} for ${o} #${r} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const A0 = Qp(ts, "Redeem script"), S0 = Qp(
  ia,
  "Witness script"
);
function _0(e, t, r, n) {
  if (!r.every(Xp))
    throw new Error(`PSBT must be finalized to calculate ${t}`);
  if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
  if (e === "__FEE" && n.__FEE) return n.__FEE;
  let i, o = !0;
  if (n.__EXTRACTED_TX ? (i = n.__EXTRACTED_TX, o = !1) : i = n.__TX.clone(), ig(r, i, n, o), e === "__FEE_RATE") return n.__FEE_RATE;
  if (e === "__FEE") return n.__FEE;
}
function l4(e, t, r, n, i, o) {
  const s = ag(r);
  if (!o4(t, r, s))
    throw new Error(`Can not finalize input #${e}`);
  return f4(
    r,
    s,
    t.partialSig,
    n,
    i,
    o
  );
}
function f4(e, t, r, n, i, o) {
  let s, a;
  const c = h4(e, t, r), u = o ? ia({ redeem: c }) : null, f = i ? ts({ redeem: u || c }) : null;
  return n ? (u ? a = bc(u.witness) : a = bc(c.witness), f && (s = f.input)) : f ? s = f.input : s = c.input, {
    finalScriptSig: s,
    finalScriptWitness: a
  };
}
function k0(e, t, r, n, i) {
  const o = jt(e, t), { hash: s, sighashType: a, script: c } = eg(
    t,
    o,
    n,
    !1,
    i
  );
  return Yp(r, c, "sign"), {
    hash: s,
    sighashType: a
  };
}
function eg(e, t, r, n, i) {
  const o = r.__TX, s = t.sighashType || st.SIGHASH_ALL;
  rg(s, i);
  let a, c;
  if (t.nonWitnessUtxo) {
    const l = ou(
      r,
      t,
      e
    ), h = o.ins[e].hash, m = l.getHash();
    if (Q(h, m) !== 0)
      throw new Error(
        `Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`
      );
    const y = o.ins[e].index;
    c = l.outs[y];
  } else if (t.witnessUtxo)
    c = t.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: u, type: f } = su(
    c.script,
    e,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(f) >= 0)
    a = o.hashForWitnessV0(
      e,
      u,
      c.value,
      s
    );
  else if (nu(u)) {
    const l = ra({
      hash: u.slice(2)
    }).output;
    a = o.hashForWitnessV0(
      e,
      l,
      c.value,
      s
    );
  } else {
    if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${e} has witnessUtxo but non-segwit script: ${me(u)}`
      );
    !n && r.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), a = o.hashForSignature(
      e,
      u,
      s
    );
  }
  return {
    script: u,
    sighashType: s,
    hash: a
  };
}
function d4(e, t, r, n) {
  const i = [];
  if (t.tapInternalKey) {
    const s = tg(e, t, n);
    s && i.push(s);
  }
  if (t.tapScriptSig) {
    const s = t.tapScriptSig.map((a) => a.pubkey);
    i.push(...s);
  }
  return i.map(
    (s) => df(e, t, r, s, n)
  ).flat();
}
function tg(e, t, r) {
  const { script: n } = Ad(e, t, r);
  return Vp(n) ? n.subarray(2, 34) : null;
}
function T0(e) {
  return e.length === 64 ? e : e.subarray(0, 64);
}
function df(e, t, r, n, i, o, s) {
  const a = i.__TX, c = t.sighashType || st.SIGHASH_DEFAULT;
  rg(c, s);
  const u = r.map(
    (y, b) => Ad(b, y, i)
  ), f = u.map((y) => y.script), l = u.map((y) => y.value), h = [];
  if (t.tapInternalKey && !o) {
    const y = tg(e, t, i) || Uint8Array.from([]);
    if (Q(Ts(n), y) === 0) {
      const b = a.hashForWitnessV1(
        e,
        f,
        l,
        c
      );
      h.push({ pubkey: n, hash: b });
    }
  }
  const m = (t.tapLeafScript || []).filter((y) => iu(n, y.script)).map((y) => {
    const b = Pn({
      output: y.script,
      version: y.leafVersion
    });
    return Object.assign({ hash: b }, y);
  }).filter(
    (y) => !o || Q(o, y.hash) === 0
  ).map((y) => {
    const b = a.hashForWitnessV1(
      e,
      f,
      l,
      c,
      y.hash
    );
    return {
      pubkey: n,
      hash: b,
      leafHash: y.hash
    };
  });
  return h.concat(m);
}
function rg(e, t) {
  if (t && t.indexOf(e) < 0) {
    const r = m4(e);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`
    );
  }
}
function h4(e, t, r) {
  let n;
  switch (t) {
    case "multisig":
      const i = g4(e, r);
      n = eu({
        output: e,
        signatures: i
      });
      break;
    case "pubkey":
      n = bp({
        output: e,
        signature: r[0].signature
      });
      break;
    case "pubkeyhash":
      n = ra({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
    case "witnesspubkeyhash":
      n = na({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
  }
  return n;
}
function p4(e, t, r) {
  const n = r.__TX, i = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (i.isP2SH = !!t.redeemScript, i.isP2WSH = !!t.witnessScript, t.witnessScript)
    i.script = t.witnessScript;
  else if (t.redeemScript)
    i.script = t.redeemScript;
  else if (t.nonWitnessUtxo) {
    const o = ou(
      r,
      t,
      e
    ), s = n.ins[e].index;
    i.script = o.outs[s].script;
  } else t.witnessUtxo && (i.script = t.witnessUtxo.script);
  return (t.witnessScript || nu(i.script)) && (i.isSegwit = !0), i;
}
function C0(e, t, r) {
  const n = jt(t, e);
  if (!n.bip32Derivation || n.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const i = n.bip32Derivation.map((s) => {
    if (Q(s.masterFingerprint, r.fingerprint) === 0)
      return s;
  }).filter((s) => !!s);
  if (i.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return i.map((s) => {
    const a = r.derivePath(s.path);
    if (Q(s.pubkey, a.publicKey) !== 0)
      throw new Error("pubkey did not match bip32Derivation");
    return a;
  });
}
function g4(e, t) {
  return eu({ output: e }).pubkeys.map((n) => (t.filter((i) => Q(i.pubkey, n) === 0)[0] || {}).signature).filter((n) => !!n);
}
function ng(e) {
  let t = 0;
  function r(s) {
    return t += s, e.slice(t - s, t);
  }
  function n() {
    const s = rs(e, t);
    return t += Ir(s.bigintValue), s.numberValue;
  }
  function i() {
    return r(n());
  }
  function o() {
    const s = n(), a = [];
    for (let c = 0; c < s; c++) a.push(i());
    return a;
  }
  return o();
}
function m4(e) {
  let t = e & st.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case st.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case st.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case st.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function hf(e, t, r) {
  e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
  const n = st.fromBuffer(t.nonWitnessUtxo);
  e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
  const i = e, o = r;
  delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const s = i.__NON_WITNESS_UTXO_BUF_CACHE[o], a = i.__NON_WITNESS_UTXO_TX_CACHE[o];
      if (s !== void 0)
        return s;
      {
        const c = a.toBuffer();
        return i.__NON_WITNESS_UTXO_BUF_CACHE[o] = c, c;
      }
    },
    set(s) {
      i.__NON_WITNESS_UTXO_BUF_CACHE[o] = s;
    }
  });
}
function ig(e, t, r, n) {
  let i = 0n;
  e.forEach((c, u) => {
    if (n && c.finalScriptSig && (t.ins[u].script = c.finalScriptSig), n && c.finalScriptWitness && (t.ins[u].witness = ng(
      c.finalScriptWitness
    )), c.witnessUtxo)
      i += c.witnessUtxo.value;
    else if (c.nonWitnessUtxo) {
      const f = ou(r, c, u), l = t.ins[u].index, h = f.outs[l];
      i += h.value;
    }
  });
  const o = t.outs.reduce((c, u) => c + u.value, 0n), s = i - o;
  if (s < 0)
    throw new Error("Outputs are spending more than Inputs");
  const a = t.virtualSize();
  r.__FEE = s, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(s / BigInt(a)));
}
function ou(e, t, r) {
  const n = e.__NON_WITNESS_UTXO_TX_CACHE;
  return n[r] || hf(e, t, r), n[r];
}
function og(e, t, r) {
  const { script: n } = Ad(e, t, r);
  return n;
}
function Ad(e, t, r) {
  if (t.witnessUtxo !== void 0)
    return {
      script: t.witnessUtxo.script,
      value: t.witnessUtxo.value
    };
  if (t.nonWitnessUtxo !== void 0) {
    const i = ou(
      r,
      t,
      e
    ).outs[r.__TX.ins[e].index];
    return { script: i.script, value: i.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function b4(e, t, r, n) {
  const i = og(r, t, n), { meaningfulScript: o } = su(
    i,
    r,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  return iu(e, o);
}
function y4(e, t, r, n) {
  const i = n.__TX.outs[r].script, { meaningfulScript: o } = su(
    i,
    r,
    "output",
    t.redeemScript,
    t.witnessScript
  );
  return iu(e, o);
}
function w4(e) {
  if (!e) return;
  const t = at(e);
  if (!t) return;
  const r = t[t.length - 1];
  if (!(!(r instanceof Uint8Array) || sg(r) || E4(r) || !at(r)))
    return r;
}
function v4(e) {
  if (!e) return;
  const t = ng(e), r = t[t.length - 1];
  if (!(sg(r) || !at(r)))
    return r;
}
function x4(e) {
  if (e.length === 65) {
    const t = e[64] & 1, r = e.slice(0, 33);
    return r[0] = 2 | t, r;
  }
  return e.slice();
}
function sg(e) {
  return e.length === 33 && X5(e);
}
function E4(e) {
  return Nn(e);
}
function su(e, t, r, n, i) {
  const o = qp(e), s = o && n && b0(n), a = b0(e);
  if (o && n === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((a || s) && i === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let c;
  return s ? (c = i, A0(t, e, n, r), S0(t, n, i, r), yc(c)) : a ? (c = i, S0(t, e, i, r), yc(c)) : o ? (c = n, A0(t, e, n, r)) : c = e, {
    meaningfulScript: c,
    type: s ? "p2sh-p2wsh" : o ? "p2sh" : a ? "p2wsh" : "raw"
  };
}
function yc(e) {
  if (nu(e) || qp(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function ag(e) {
  return nu(e) ? "witnesspubkeyhash" : R8(e) ? "pubkeyhash" : F8(e) ? "multisig" : H8(e) ? "pubkey" : "nonstandard";
}
function gs(e) {
  return [...Array(e).keys()];
}
let cg = class extends yp {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, J5(t);
    const n = ld(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, o = new Uint8Array(i);
    o.set(n.length > i ? t.create().update(n).digest() : n);
    for (let s = 0; s < o.length; s++)
      o[s] ^= 54;
    this.iHash.update(o), this.oHash = t.create();
    for (let s = 0; s < o.length; s++)
      o[s] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return hc(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    hc(this), tu(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const Sd = (e, t, r) => new cg(e, t).update(r).digest();
Sd.create = (e, t) => new cg(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _d = /* @__PURE__ */ BigInt(0), au = /* @__PURE__ */ BigInt(1), A4 = /* @__PURE__ */ BigInt(2);
function eo(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function aa(e) {
  if (!eo(e))
    throw new Error("Uint8Array expected");
}
function Ro(e, t) {
  if (typeof t != "boolean")
    throw new Error(`${e} must be valid boolean, got "${t}".`);
}
const S4 = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Lo(e) {
  aa(e);
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += S4[e[r]];
  return t;
}
function Po(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function kd(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const vn = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function P0(e) {
  if (e >= vn._0 && e <= vn._9)
    return e - vn._0;
  if (e >= vn._A && e <= vn._F)
    return e - (vn._A - 10);
  if (e >= vn._a && e <= vn._f)
    return e - (vn._a - 10);
}
function zo(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let i = 0, o = 0; i < r; i++, o += 2) {
    const s = P0(e.charCodeAt(o)), a = P0(e.charCodeAt(o + 1));
    if (s === void 0 || a === void 0) {
      const c = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + o);
    }
    n[i] = s * 16 + a;
  }
  return n;
}
function Zi(e) {
  return kd(Lo(e));
}
function Td(e) {
  return aa(e), kd(Lo(Uint8Array.from(e).reverse()));
}
function jo(e, t) {
  return zo(e.toString(16).padStart(t * 2, "0"));
}
function Cd(e, t) {
  return jo(e, t).reverse();
}
function _4(e) {
  return zo(Po(e));
}
function Ur(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = zo(t);
    } catch (o) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
  else if (eo(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const i = n.length;
  if (typeof r == "number" && i !== r)
    throw new Error(`${e} expected ${r} bytes, got ${i}`);
  return n;
}
function Fs(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    aa(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const o = e[n];
    r.set(o, i), i += o.length;
  }
  return r;
}
function k4(e, t) {
  if (e.length !== t.length)
    return !1;
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r |= e[n] ^ t[n];
  return r === 0;
}
function T4(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
const vl = (e) => typeof e == "bigint" && _d <= e;
function cu(e, t, r) {
  return vl(e) && vl(t) && vl(r) && t <= e && e < r;
}
function Xi(e, t, r, n) {
  if (!cu(t, r, n))
    throw new Error(`expected valid ${e}: ${r} <= n < ${n}, got ${typeof t} ${t}`);
}
function ug(e) {
  let t;
  for (t = 0; e > _d; e >>= au, t += 1)
    ;
  return t;
}
function C4(e, t) {
  return e >> BigInt(t) & au;
}
function P4(e, t, r) {
  return e | (r ? au : _d) << BigInt(t);
}
const Pd = (e) => (A4 << BigInt(e - 1)) - au, xl = (e) => new Uint8Array(e), I0 = (e) => Uint8Array.from(e);
function lg(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = xl(e), i = xl(e), o = 0;
  const s = () => {
    n.fill(1), i.fill(0), o = 0;
  }, a = (...l) => r(i, n, ...l), c = (l = xl()) => {
    i = a(I0([0]), l), n = a(), l.length !== 0 && (i = a(I0([1]), l), n = a());
  }, u = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let l = 0;
    const h = [];
    for (; l < t; ) {
      n = a();
      const m = n.slice();
      h.push(m), l += n.length;
    }
    return Fs(...h);
  };
  return (l, h) => {
    s(), c(l);
    let m;
    for (; !(m = h(u())); )
      c();
    return s(), m;
  };
}
const I4 = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || eo(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function ca(e, t, r = {}) {
  const n = (i, o, s) => {
    const a = I4[o];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${o}", expected function`);
    const c = e[i];
    if (!(s && c === void 0) && !a(c, e))
      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`);
  };
  for (const [i, o] of Object.entries(t))
    n(i, o, !1);
  for (const [i, o] of Object.entries(r))
    n(i, o, !0);
  return e;
}
const B4 = () => {
  throw new Error("not implemented");
};
function pf(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const i = t.get(r);
    if (i !== void 0)
      return i;
    const o = e(r, ...n);
    return t.set(r, o), o;
  };
}
const O4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange: Xi,
  abool: Ro,
  abytes: aa,
  bitGet: C4,
  bitLen: ug,
  bitMask: Pd,
  bitSet: P4,
  bytesToHex: Lo,
  bytesToNumberBE: Zi,
  bytesToNumberLE: Td,
  concatBytes: Fs,
  createHmacDrbg: lg,
  ensureBytes: Ur,
  equalBytes: k4,
  hexToBytes: zo,
  hexToNumber: kd,
  inRange: cu,
  isBytes: eo,
  memoized: pf,
  notImplemented: B4,
  numberToBytesBE: jo,
  numberToBytesLE: Cd,
  numberToHexUnpadded: Po,
  numberToVarBytesBE: _4,
  utf8ToBytes: T4,
  validateObject: ca
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ft = BigInt(0), mt = BigInt(1), Li = BigInt(2), $4 = BigInt(3), gf = BigInt(4), B0 = BigInt(5), O0 = BigInt(8);
BigInt(9);
BigInt(16);
function Zt(e, t) {
  const r = e % t;
  return r >= Ft ? r : t + r;
}
function N4(e, t, r) {
  if (r <= Ft || t < Ft)
    throw new Error("Expected power/modulo > 0");
  if (r === mt)
    return Ft;
  let n = mt;
  for (; t > Ft; )
    t & mt && (n = n * e % r), e = e * e % r, t >>= mt;
  return n;
}
function Sr(e, t, r) {
  let n = e;
  for (; t-- > Ft; )
    n *= n, n %= r;
  return n;
}
function mf(e, t) {
  if (e === Ft || t <= Ft)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Zt(e, t), n = t, i = Ft, o = mt;
  for (; r !== Ft; ) {
    const a = n / r, c = n % r, u = i - o * a;
    n = r, r = c, i = o, o = u;
  }
  if (n !== mt)
    throw new Error("invert: does not exist");
  return Zt(i, t);
}
function U4(e) {
  const t = (e - mt) / Li;
  let r, n, i;
  for (r = e - mt, n = 0; r % Li === Ft; r /= Li, n++)
    ;
  for (i = Li; i < e && N4(i, t, e) !== e - mt; i++)
    ;
  if (n === 1) {
    const s = (e + mt) / gf;
    return function(c, u) {
      const f = c.pow(u, s);
      if (!c.eql(c.sqr(f), u))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const o = (r + mt) / Li;
  return function(a, c) {
    if (a.pow(c, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, f = a.pow(a.mul(a.ONE, i), r), l = a.pow(c, o), h = a.pow(c, r);
    for (; !a.eql(h, a.ONE); ) {
      if (a.eql(h, a.ZERO))
        return a.ZERO;
      let m = 1;
      for (let b = a.sqr(h); m < u && !a.eql(b, a.ONE); m++)
        b = a.sqr(b);
      const y = a.pow(f, mt << BigInt(u - m - 1));
      f = a.sqr(y), l = a.mul(l, y), h = a.mul(h, f), u = m;
    }
    return l;
  };
}
function F4(e) {
  if (e % gf === $4) {
    const t = (e + mt) / gf;
    return function(n, i) {
      const o = n.pow(i, t);
      if (!n.eql(n.sqr(o), i))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % O0 === B0) {
    const t = (e - B0) / O0;
    return function(n, i) {
      const o = n.mul(i, Li), s = n.pow(o, t), a = n.mul(i, s), c = n.mul(n.mul(a, Li), s), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return U4(e);
}
const H4 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function R4(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = H4.reduce((n, i) => (n[i] = "function", n), t);
  return ca(e, r);
}
function L4(e, t, r) {
  if (r < Ft)
    throw new Error("Expected power > 0");
  if (r === Ft)
    return e.ONE;
  if (r === mt)
    return t;
  let n = e.ONE, i = t;
  for (; r > Ft; )
    r & mt && (n = e.mul(n, i)), i = e.sqr(i), r >>= mt;
  return n;
}
function z4(e, t) {
  const r = new Array(t.length), n = t.reduce((o, s, a) => e.is0(s) ? o : (r[a] = o, e.mul(o, s)), e.ONE), i = e.inv(n);
  return t.reduceRight((o, s, a) => e.is0(s) ? o : (r[a] = e.mul(o, r[a]), e.mul(o, s)), i), r;
}
function fg(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function Id(e, t, r = !1, n = {}) {
  if (e <= Ft)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: o } = fg(e, t);
  if (o > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = F4(e), a = Object.freeze({
    ORDER: e,
    BITS: i,
    BYTES: o,
    MASK: Pd(i),
    ZERO: Ft,
    ONE: mt,
    create: (c) => Zt(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return Ft <= c && c < e;
    },
    is0: (c) => c === Ft,
    isOdd: (c) => (c & mt) === mt,
    neg: (c) => Zt(-c, e),
    eql: (c, u) => c === u,
    sqr: (c) => Zt(c * c, e),
    add: (c, u) => Zt(c + u, e),
    sub: (c, u) => Zt(c - u, e),
    mul: (c, u) => Zt(c * u, e),
    pow: (c, u) => L4(a, c, u),
    div: (c, u) => Zt(c * mf(u, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => mf(c, e),
    sqrt: n.sqrt || ((c) => s(a, c)),
    invertBatch: (c) => z4(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, f) => f ? u : c,
    toBytes: (c) => r ? Cd(c, o) : jo(c, o),
    fromBytes: (c) => {
      if (c.length !== o)
        throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);
      return r ? Td(c) : Zi(c);
    }
  });
  return Object.freeze(a);
}
function dg(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function hg(e) {
  const t = dg(e);
  return t + Math.ceil(t / 2);
}
function j4(e, t, r = !1) {
  const n = e.length, i = dg(t), o = hg(t);
  if (n < 16 || n < o || n > 1024)
    throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);
  const s = r ? Zi(e) : Td(e), a = Zt(s, t - mt) + mt;
  return r ? Cd(a, i) : jo(a, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const D4 = BigInt(0), El = BigInt(1), Al = /* @__PURE__ */ new WeakMap(), $0 = /* @__PURE__ */ new WeakMap();
function M4(e, t) {
  const r = (o, s) => {
    const a = s.negate();
    return o ? a : s;
  }, n = (o) => {
    if (!Number.isSafeInteger(o) || o <= 0 || o > t)
      throw new Error(`Wrong window size=${o}, should be [1..${t}]`);
  }, i = (o) => {
    n(o);
    const s = Math.ceil(t / o) + 1, a = 2 ** (o - 1);
    return { windows: s, windowSize: a };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(o, s) {
      let a = e.ZERO, c = o;
      for (; s > D4; )
        s & El && (a = a.add(c)), c = c.double(), s >>= El;
      return a;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(o, s) {
      const { windows: a, windowSize: c } = i(s), u = [];
      let f = o, l = f;
      for (let h = 0; h < a; h++) {
        l = f, u.push(l);
        for (let m = 1; m < c; m++)
          l = l.add(f), u.push(l);
        f = l.double();
      }
      return u;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(o, s, a) {
      const { windows: c, windowSize: u } = i(o);
      let f = e.ZERO, l = e.BASE;
      const h = BigInt(2 ** o - 1), m = 2 ** o, y = BigInt(o);
      for (let b = 0; b < c; b++) {
        const g = b * u;
        let v = Number(a & h);
        a >>= y, v > u && (v -= m, a += El);
        const _ = g, x = g + Math.abs(v) - 1, k = b % 2 !== 0, P = v < 0;
        v === 0 ? l = l.add(r(k, s[_])) : f = f.add(r(P, s[x]));
      }
      return { p: f, f: l };
    },
    wNAFCached(o, s, a) {
      const c = $0.get(o) || 1;
      let u = Al.get(o);
      return u || (u = this.precomputeWindow(o, c), c !== 1 && Al.set(o, a(u))), this.wNAF(c, u, s);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(o, s) {
      n(s), $0.set(o, s), Al.delete(o);
    }
  };
}
function K4(e, t, r, n) {
  if (!Array.isArray(r) || !Array.isArray(n) || n.length !== r.length)
    throw new Error("arrays of points and scalars must have equal length");
  n.forEach((f, l) => {
    if (!t.isValid(f))
      throw new Error(`wrong scalar at index ${l}`);
  }), r.forEach((f, l) => {
    if (!(f instanceof e))
      throw new Error(`wrong point at index ${l}`);
  });
  const i = ug(BigInt(r.length)), o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, s = (1 << o) - 1, a = new Array(s + 1).fill(e.ZERO), c = Math.floor((t.BITS - 1) / o) * o;
  let u = e.ZERO;
  for (let f = c; f >= 0; f -= o) {
    a.fill(e.ZERO);
    for (let h = 0; h < n.length; h++) {
      const m = n[h], y = Number(m >> BigInt(f) & BigInt(s));
      a[y] = a[y].add(r[h]);
    }
    let l = e.ZERO;
    for (let h = a.length - 1, m = e.ZERO; h > 0; h--)
      m = m.add(a[h]), l = l.add(m);
    if (u = u.add(l), f !== 0)
      for (let h = 0; h < o; h++)
        u = u.double();
  }
  return u;
}
function pg(e) {
  return R4(e.Fp), ca(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...fg(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function N0(e) {
  e.lowS !== void 0 && Ro("lowS", e.lowS), e.prehash !== void 0 && Ro("prehash", e.prehash);
}
function q4(e) {
  const t = pg(e);
  ca(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: i } = t;
  if (r) {
    if (!n.eql(i, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: V4, hexToBytes: W4 } = O4, Tn = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = Tn;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, i = Po(n);
      if (i.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const o = n > 127 ? Po(i.length / 2 | 128) : "";
      return `${Po(e)}${o}${i}${t}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = Tn;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const i = t[n++], o = !!(i & 128);
      let s = 0;
      if (!o)
        s = i;
      else {
        const c = i & 127;
        if (!c)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const u = t.subarray(n, n + c);
        if (u.length !== c)
          throw new r("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const f of u)
          s = s << 8 | f;
        if (n += c, s < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const a = t.subarray(n, n + s);
      if (a.length !== s)
        throw new r("tlv.decode: wrong value length");
      return { v: a, l: t.subarray(n + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = Tn;
      if (e < Cn)
        throw new t("integer: negative integers are not allowed");
      let r = Po(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected assertion");
      return r;
    },
    decode(e) {
      const { Err: t } = Tn;
      if (e[0] & 128)
        throw new t("Invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return V4(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = Tn, i = typeof e == "string" ? W4(e) : e;
    aa(i);
    const { v: o, l: s } = n.decode(48, i);
    if (s.length)
      throw new t("Invalid signature: left bytes after parsing");
    const { v: a, l: c } = n.decode(2, o), { v: u, l: f } = n.decode(2, c);
    if (f.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: r.decode(a), s: r.decode(u) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = Tn, n = `${t.encode(2, r.encode(e.r))}${t.encode(2, r.encode(e.s))}`;
    return t.encode(48, n);
  }
}, Cn = BigInt(0), $t = BigInt(1);
BigInt(2);
const U0 = BigInt(3);
BigInt(4);
function G4(e) {
  const t = q4(e), { Fp: r } = t, n = Id(t.n, t.nBitLength), i = t.toBytes || ((b, g, v) => {
    const _ = g.toAffine();
    return Fs(Uint8Array.from([4]), r.toBytes(_.x), r.toBytes(_.y));
  }), o = t.fromBytes || ((b) => {
    const g = b.subarray(1), v = r.fromBytes(g.subarray(0, r.BYTES)), _ = r.fromBytes(g.subarray(r.BYTES, 2 * r.BYTES));
    return { x: v, y: _ };
  });
  function s(b) {
    const { a: g, b: v } = t, _ = r.sqr(b), x = r.mul(_, b);
    return r.add(r.add(x, r.mul(b, g)), v);
  }
  if (!r.eql(r.sqr(t.Gy), s(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(b) {
    return cu(b, $t, t.n);
  }
  function c(b) {
    const { allowedPrivateKeyLengths: g, nByteLength: v, wrapPrivateKey: _, n: x } = t;
    if (g && typeof b != "bigint") {
      if (eo(b) && (b = Lo(b)), typeof b != "string" || !g.includes(b.length))
        throw new Error("Invalid key");
      b = b.padStart(v * 2, "0");
    }
    let k;
    try {
      k = typeof b == "bigint" ? b : Zi(Ur("private key", b, v));
    } catch {
      throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof b}`);
    }
    return _ && (k = Zt(k, x)), Xi("private key", k, $t, x), k;
  }
  function u(b) {
    if (!(b instanceof h))
      throw new Error("ProjectivePoint expected");
  }
  const f = pf((b, g) => {
    const { px: v, py: _, pz: x } = b;
    if (r.eql(x, r.ONE))
      return { x: v, y: _ };
    const k = b.is0();
    g == null && (g = k ? r.ONE : r.inv(x));
    const P = r.mul(v, g), I = r.mul(_, g), R = r.mul(x, g);
    if (k)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql(R, r.ONE))
      throw new Error("invZ was invalid");
    return { x: P, y: I };
  }), l = pf((b) => {
    if (b.is0()) {
      if (t.allowInfinityPoint && !r.is0(b.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: g, y: v } = b.toAffine();
    if (!r.isValid(g) || !r.isValid(v))
      throw new Error("bad point: x or y not FE");
    const _ = r.sqr(v), x = s(g);
    if (!r.eql(_, x))
      throw new Error("bad point: equation left != right");
    if (!b.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class h {
    constructor(g, v, _) {
      if (this.px = g, this.py = v, this.pz = _, g == null || !r.isValid(g))
        throw new Error("x required");
      if (v == null || !r.isValid(v))
        throw new Error("y required");
      if (_ == null || !r.isValid(_))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(g) {
      const { x: v, y: _ } = g || {};
      if (!g || !r.isValid(v) || !r.isValid(_))
        throw new Error("invalid affine point");
      if (g instanceof h)
        throw new Error("projective point not allowed");
      const x = (k) => r.eql(k, r.ZERO);
      return x(v) && x(_) ? h.ZERO : new h(v, _, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(g) {
      const v = r.invertBatch(g.map((_) => _.pz));
      return g.map((_, x) => _.toAffine(v[x])).map(h.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(g) {
      const v = h.fromAffine(o(Ur("pointHex", g)));
      return v.assertValidity(), v;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(g) {
      return h.BASE.multiply(c(g));
    }
    // Multiscalar Multiplication
    static msm(g, v) {
      return K4(h, n, g, v);
    }
    // "Private method", don't use it directly
    _setWindowSize(g) {
      y.setWindowSize(this, g);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      l(this);
    }
    hasEvenY() {
      const { y: g } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(g);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(g) {
      u(g);
      const { px: v, py: _, pz: x } = this, { px: k, py: P, pz: I } = g, R = r.eql(r.mul(v, I), r.mul(k, x)), j = r.eql(r.mul(_, I), r.mul(P, x));
      return R && j;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new h(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: g, b: v } = t, _ = r.mul(v, U0), { px: x, py: k, pz: P } = this;
      let I = r.ZERO, R = r.ZERO, j = r.ZERO, W = r.mul(x, x), re = r.mul(k, k), X = r.mul(P, P), N = r.mul(x, k);
      return N = r.add(N, N), j = r.mul(x, P), j = r.add(j, j), I = r.mul(g, j), R = r.mul(_, X), R = r.add(I, R), I = r.sub(re, R), R = r.add(re, R), R = r.mul(I, R), I = r.mul(N, I), j = r.mul(_, j), X = r.mul(g, X), N = r.sub(W, X), N = r.mul(g, N), N = r.add(N, j), j = r.add(W, W), W = r.add(j, W), W = r.add(W, X), W = r.mul(W, N), R = r.add(R, W), X = r.mul(k, P), X = r.add(X, X), W = r.mul(X, N), I = r.sub(I, W), j = r.mul(X, re), j = r.add(j, j), j = r.add(j, j), new h(I, R, j);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(g) {
      u(g);
      const { px: v, py: _, pz: x } = this, { px: k, py: P, pz: I } = g;
      let R = r.ZERO, j = r.ZERO, W = r.ZERO;
      const re = t.a, X = r.mul(t.b, U0);
      let N = r.mul(v, k), G = r.mul(_, P), M = r.mul(x, I), $ = r.add(v, _), H = r.add(k, P);
      $ = r.mul($, H), H = r.add(N, G), $ = r.sub($, H), H = r.add(v, x);
      let q = r.add(k, I);
      return H = r.mul(H, q), q = r.add(N, M), H = r.sub(H, q), q = r.add(_, x), R = r.add(P, I), q = r.mul(q, R), R = r.add(G, M), q = r.sub(q, R), W = r.mul(re, H), R = r.mul(X, M), W = r.add(R, W), R = r.sub(G, W), W = r.add(G, W), j = r.mul(R, W), G = r.add(N, N), G = r.add(G, N), M = r.mul(re, M), H = r.mul(X, H), G = r.add(G, M), M = r.sub(N, M), M = r.mul(re, M), H = r.add(H, M), N = r.mul(G, H), j = r.add(j, N), N = r.mul(q, H), R = r.mul($, R), R = r.sub(R, N), N = r.mul($, G), W = r.mul(q, W), W = r.add(W, N), new h(R, j, W);
    }
    subtract(g) {
      return this.add(g.negate());
    }
    is0() {
      return this.equals(h.ZERO);
    }
    wNAF(g) {
      return y.wNAFCached(this, g, h.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(g) {
      Xi("scalar", g, Cn, t.n);
      const v = h.ZERO;
      if (g === Cn)
        return v;
      if (g === $t)
        return this;
      const { endo: _ } = t;
      if (!_)
        return y.unsafeLadder(this, g);
      let { k1neg: x, k1: k, k2neg: P, k2: I } = _.splitScalar(g), R = v, j = v, W = this;
      for (; k > Cn || I > Cn; )
        k & $t && (R = R.add(W)), I & $t && (j = j.add(W)), W = W.double(), k >>= $t, I >>= $t;
      return x && (R = R.negate()), P && (j = j.negate()), j = new h(r.mul(j.px, _.beta), j.py, j.pz), R.add(j);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(g) {
      const { endo: v, n: _ } = t;
      Xi("scalar", g, $t, _);
      let x, k;
      if (v) {
        const { k1neg: P, k1: I, k2neg: R, k2: j } = v.splitScalar(g);
        let { p: W, f: re } = this.wNAF(I), { p: X, f: N } = this.wNAF(j);
        W = y.constTimeNegate(P, W), X = y.constTimeNegate(R, X), X = new h(r.mul(X.px, v.beta), X.py, X.pz), x = W.add(X), k = re.add(N);
      } else {
        const { p: P, f: I } = this.wNAF(g);
        x = P, k = I;
      }
      return h.normalizeZ([x, k])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(g, v, _) {
      const x = h.BASE, k = (I, R) => R === Cn || R === $t || !I.equals(x) ? I.multiplyUnsafe(R) : I.multiply(R), P = k(this, v).add(k(g, _));
      return P.is0() ? void 0 : P;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(g) {
      return f(this, g);
    }
    isTorsionFree() {
      const { h: g, isTorsionFree: v } = t;
      if (g === $t)
        return !0;
      if (v)
        return v(h, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: g, clearCofactor: v } = t;
      return g === $t ? this : v ? v(h, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(g = !0) {
      return Ro("isCompressed", g), this.assertValidity(), i(h, this, g);
    }
    toHex(g = !0) {
      return Ro("isCompressed", g), Lo(this.toRawBytes(g));
    }
  }
  h.BASE = new h(t.Gx, t.Gy, r.ONE), h.ZERO = new h(r.ZERO, r.ONE, r.ZERO);
  const m = t.nBitLength, y = M4(h, t.endo ? Math.ceil(m / 2) : m);
  return {
    CURVE: t,
    ProjectivePoint: h,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: a
  };
}
function Z4(e) {
  const t = pg(e);
  return ca(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function X4(e) {
  const t = Z4(e), { Fp: r, n } = t, i = r.BYTES + 1, o = 2 * r.BYTES + 1;
  function s(M) {
    return Zt(M, n);
  }
  function a(M) {
    return mf(M, n);
  }
  const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: f, isWithinCurveOrder: l } = G4({
    ...t,
    toBytes(M, $, H) {
      const q = $.toAffine(), ne = r.toBytes(q.x), ie = Fs;
      return Ro("isCompressed", H), H ? ie(Uint8Array.from([$.hasEvenY() ? 2 : 3]), ne) : ie(Uint8Array.from([4]), ne, r.toBytes(q.y));
    },
    fromBytes(M) {
      const $ = M.length, H = M[0], q = M.subarray(1);
      if ($ === i && (H === 2 || H === 3)) {
        const ne = Zi(q);
        if (!cu(ne, $t, r.ORDER))
          throw new Error("Point is not on curve");
        const ie = f(ne);
        let pe;
        try {
          pe = r.sqrt(ie);
        } catch (V) {
          const He = V instanceof Error ? ": " + V.message : "";
          throw new Error("Point is not on curve" + He);
        }
        const se = (pe & $t) === $t;
        return (H & 1) === 1 !== se && (pe = r.neg(pe)), { x: ne, y: pe };
      } else if ($ === o && H === 4) {
        const ne = r.fromBytes(q.subarray(0, r.BYTES)), ie = r.fromBytes(q.subarray(r.BYTES, 2 * r.BYTES));
        return { x: ne, y: ie };
      } else
        throw new Error(`Point of length ${$} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`);
    }
  }), h = (M) => Lo(jo(M, t.nByteLength));
  function m(M) {
    const $ = n >> $t;
    return M > $;
  }
  function y(M) {
    return m(M) ? s(-M) : M;
  }
  const b = (M, $, H) => Zi(M.slice($, H));
  class g {
    constructor($, H, q) {
      this.r = $, this.s = H, this.recovery = q, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact($) {
      const H = t.nByteLength;
      return $ = Ur("compactSignature", $, H * 2), new g(b($, 0, H), b($, H, 2 * H));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER($) {
      const { r: H, s: q } = Tn.toSig(Ur("DER", $));
      return new g(H, q);
    }
    assertValidity() {
      Xi("r", this.r, $t, n), Xi("s", this.s, $t, n);
    }
    addRecoveryBit($) {
      return new g(this.r, this.s, $);
    }
    recoverPublicKey($) {
      const { r: H, s: q, recovery: ne } = this, ie = I(Ur("msgHash", $));
      if (ne == null || ![0, 1, 2, 3].includes(ne))
        throw new Error("recovery id invalid");
      const pe = ne === 2 || ne === 3 ? H + t.n : H;
      if (pe >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const se = ne & 1 ? "03" : "02", ke = c.fromHex(se + h(pe)), V = a(pe), He = s(-ie * V), Rt = s(q * V), et = c.BASE.multiplyAndAddUnsafe(ke, He, Rt);
      if (!et)
        throw new Error("point at infinify");
      return et.assertValidity(), et;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return m(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new g(this.r, s(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return zo(this.toDERHex());
    }
    toDERHex() {
      return Tn.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return zo(this.toCompactHex());
    }
    toCompactHex() {
      return h(this.r) + h(this.s);
    }
  }
  const v = {
    isValidPrivateKey(M) {
      try {
        return u(M), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: u,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const M = hg(t.n);
      return j4(t.randomBytes(M), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(M = 8, $ = c.BASE) {
      return $._setWindowSize(M), $.multiply(BigInt(3)), $;
    }
  };
  function _(M, $ = !0) {
    return c.fromPrivateKey(M).toRawBytes($);
  }
  function x(M) {
    const $ = eo(M), H = typeof M == "string", q = ($ || H) && M.length;
    return $ ? q === i || q === o : H ? q === 2 * i || q === 2 * o : M instanceof c;
  }
  function k(M, $, H = !0) {
    if (x(M))
      throw new Error("first arg must be private key");
    if (!x($))
      throw new Error("second arg must be public key");
    return c.fromHex($).multiply(u(M)).toRawBytes(H);
  }
  const P = t.bits2int || function(M) {
    const $ = Zi(M), H = M.length * 8 - t.nBitLength;
    return H > 0 ? $ >> BigInt(H) : $;
  }, I = t.bits2int_modN || function(M) {
    return s(P(M));
  }, R = Pd(t.nBitLength);
  function j(M) {
    return Xi(`num < 2^${t.nBitLength}`, M, Cn, R), jo(M, t.nByteLength);
  }
  function W(M, $, H = re) {
    if (["recovered", "canonical"].some((yt) => yt in H))
      throw new Error("sign() legacy options not supported");
    const { hash: q, randomBytes: ne } = t;
    let { lowS: ie, prehash: pe, extraEntropy: se } = H;
    ie == null && (ie = !0), M = Ur("msgHash", M), N0(H), pe && (M = Ur("prehashed msgHash", q(M)));
    const ke = I(M), V = u($), He = [j(V), j(ke)];
    if (se != null && se !== !1) {
      const yt = se === !0 ? ne(r.BYTES) : se;
      He.push(Ur("extraEntropy", yt));
    }
    const Rt = Fs(...He), et = ke;
    function Lt(yt) {
      const ht = P(yt);
      if (!l(ht))
        return;
      const St = a(ht), zt = c.BASE.multiply(ht).toAffine(), tt = s(zt.x);
      if (tt === Cn)
        return;
      const je = s(St * s(et + tt * V));
      if (je === Cn)
        return;
      let wt = (zt.x === tt ? 0 : 2) | Number(zt.y & $t), Yr = je;
      return ie && m(je) && (Yr = y(je), wt ^= 1), new g(tt, Yr, wt);
    }
    return { seed: Rt, k2sig: Lt };
  }
  const re = { lowS: t.lowS, prehash: !1 }, X = { lowS: t.lowS, prehash: !1 };
  function N(M, $, H = re) {
    const { seed: q, k2sig: ne } = W(M, $, H), ie = t;
    return lg(ie.hash.outputLen, ie.nByteLength, ie.hmac)(q, ne);
  }
  c.BASE._setWindowSize(8);
  function G(M, $, H, q = X) {
    var zt;
    const ne = M;
    if ($ = Ur("msgHash", $), H = Ur("publicKey", H), "strict" in q)
      throw new Error("options.strict was renamed to lowS");
    N0(q);
    const { lowS: ie, prehash: pe } = q;
    let se, ke;
    try {
      if (typeof ne == "string" || eo(ne))
        try {
          se = g.fromDER(ne);
        } catch (tt) {
          if (!(tt instanceof Tn.Err))
            throw tt;
          se = g.fromCompact(ne);
        }
      else if (typeof ne == "object" && typeof ne.r == "bigint" && typeof ne.s == "bigint") {
        const { r: tt, s: je } = ne;
        se = new g(tt, je);
      } else
        throw new Error("PARSE");
      ke = c.fromHex(H);
    } catch (tt) {
      if (tt.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ie && se.hasHighS())
      return !1;
    pe && ($ = t.hash($));
    const { r: V, s: He } = se, Rt = I($), et = a(He), Lt = s(Rt * et), yt = s(V * et), ht = (zt = c.BASE.multiplyAndAddUnsafe(ke, Lt, yt)) == null ? void 0 : zt.toAffine();
    return ht ? s(ht.x) === V : !1;
  }
  return {
    CURVE: t,
    getPublicKey: _,
    getSharedSecret: k,
    sign: N,
    verify: G,
    ProjectivePoint: c,
    Signature: g,
    utils: v
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Y4(e) {
  return {
    hash: e,
    hmac: (t, ...r) => Sd(e, t, tw(...r)),
    randomBytes: rw
  };
}
function J4(e, t) {
  const r = (n) => X4({ ...e, ...Y4(n) });
  return Object.freeze({ ...r(t), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const gg = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), F0 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Q4 = BigInt(1), bf = BigInt(2), H0 = (e, t) => (e + t / bf) / t;
function e6(e) {
  const t = gg, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, f = u * u * e % t, l = Sr(f, r, t) * f % t, h = Sr(l, r, t) * f % t, m = Sr(h, bf, t) * u % t, y = Sr(m, i, t) * m % t, b = Sr(y, o, t) * y % t, g = Sr(b, a, t) * b % t, v = Sr(g, c, t) * g % t, _ = Sr(v, a, t) * b % t, x = Sr(_, r, t) * f % t, k = Sr(x, s, t) * y % t, P = Sr(k, n, t) * u % t, I = Sr(P, bf, t);
  if (!yf.eql(yf.sqr(I), e))
    throw new Error("Cannot find square root");
  return I;
}
const yf = Id(gg, void 0, void 0, { sqrt: e6 }), to = J4({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: yf,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: F0,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = F0, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Q4 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, s = BigInt("0x100000000000000000000000000000000"), a = H0(o * e, t), c = H0(-n * e, t);
      let u = Zt(e - a * r - c * i, t), f = Zt(-a * n - c * o, t);
      const l = u > s, h = f > s;
      if (l && (u = t - u), h && (f = t - f), u > s || f > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: l, k1: u, k2neg: h, k2: f };
    }
  }
}, Ut);
BigInt(0);
to.ProjectivePoint;
function t6(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function R0(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function r6(e, t) {
  t6(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const n6 = (e) => e instanceof Uint8Array, Sl = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Qr = (e, t) => e << 32 - t | e >>> t, i6 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!i6)
  throw new Error("Non little-endian hardware is not supported");
function o6(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function mg(e) {
  if (typeof e == "string" && (e = o6(e)), !n6(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let s6 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function a6(e) {
  const t = (n) => e().update(mg(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function c6(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
let u6 = class extends s6 {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Sl(this.buffer);
  }
  update(t) {
    R0(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = mg(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const c = Sl(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    R0(this), r6(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let l = s; l < i; l++)
      r[l] = 0;
    c6(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const a = Sl(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++)
      a.setUint32(4 * l, f[l], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
  }
};
const l6 = (e, t, r) => e & t ^ ~e & r, f6 = (e, t, r) => e & t ^ e & r ^ t & r, d6 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Wn = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Gn = /* @__PURE__ */ new Uint32Array(64);
let h6 = class extends u6 {
  constructor() {
    super(64, 32, 8, !1), this.A = Wn[0] | 0, this.B = Wn[1] | 0, this.C = Wn[2] | 0, this.D = Wn[3] | 0, this.E = Wn[4] | 0, this.F = Wn[5] | 0, this.G = Wn[6] | 0, this.H = Wn[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: c } = this;
    return [t, r, n, i, o, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      Gn[l] = t.getUint32(r, !1);
    for (let l = 16; l < 64; l++) {
      const h = Gn[l - 15], m = Gn[l - 2], y = Qr(h, 7) ^ Qr(h, 18) ^ h >>> 3, b = Qr(m, 17) ^ Qr(m, 19) ^ m >>> 10;
      Gn[l] = b + Gn[l - 7] + y + Gn[l - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: a, F: c, G: u, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const h = Qr(a, 6) ^ Qr(a, 11) ^ Qr(a, 25), m = f + h + l6(a, c, u) + d6[l] + Gn[l] | 0, b = (Qr(n, 2) ^ Qr(n, 13) ^ Qr(n, 22)) + f6(n, i, o) | 0;
      f = u, u = c, c = a, a = s + m | 0, s = o, o = i, i = n, n = m + b | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, s, a, c, u, f);
  }
  roundClean() {
    Gn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const wf = /* @__PURE__ */ a6(() => new h6());
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// @__NO_SIDE_EFFECTS__
function ua(...e) {
  const t = (i, o) => (s) => i(o(s)), r = Array.from(e).reverse().reduce((i, o) => i ? t(i, o.encode) : o.encode, void 0), n = e.reduce((i, o) => i ? t(i, o.decode) : o.decode, void 0);
  return { encode: r, decode: n };
}
// @__NO_SIDE_EFFECTS__
function uu(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function lu(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function bg(e, t = "=") {
  if (typeof t != "string")
    throw new Error("padding chr should be string");
  return {
    encode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let n of r)
        if (typeof n != "string")
          throw new Error(`padding.encode: non-string input=${n}`);
      for (; r.length * e % 8; )
        r.push(t);
      return r;
    },
    decode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i of r)
        if (typeof i != "string")
          throw new Error(`padding.decode: non-string input=${i}`);
      let n = r.length;
      if (n * e % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n > 0 && r[n - 1] === t; n--)
        if (!((n - 1) * e % 8))
          throw new Error("Invalid padding: string has too much padding");
      return r.slice(0, n);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function L0(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const i = [], o = Array.from(e);
  for (o.forEach((s) => {
    if (s < 0 || s >= t)
      throw new Error(`Wrong integer: ${s}`);
  }); ; ) {
    let s = 0, a = !0;
    for (let c = n; c < o.length; c++) {
      const u = o[c], f = t * s + u;
      if (!Number.isSafeInteger(f) || t * s / t !== s || f - u !== t * s)
        throw new Error("convertRadix: carry overflow");
      s = f % r;
      const l = Math.floor(f / r);
      if (o[c] = l, !Number.isSafeInteger(l) || l * r + s !== f)
        throw new Error("convertRadix: carry overflow");
      if (a)
        l ? a = !1 : n = c;
      else continue;
    }
    if (i.push(s), a)
      break;
  }
  for (let s = 0; s < e.length - 1 && e[s] === 0; s++)
    i.push(0);
  return i.reverse();
}
const yg = /* @__NO_SIDE_EFFECTS__ */ (e, t) => t ? /* @__PURE__ */ yg(t, e % t) : e, wc = /* @__NO_SIDE_EFFECTS__ */ (e, t) => e + (t - /* @__PURE__ */ yg(e, t));
// @__NO_SIDE_EFFECTS__
function vf(e, t, r, n) {
  if (!Array.isArray(e))
    throw new Error("convertRadix2: data should be array");
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong to=${r}`);
  if (/* @__PURE__ */ wc(t, r) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${/* @__PURE__ */ wc(t, r)}`);
  let i = 0, o = 0;
  const s = 2 ** r - 1, a = [];
  for (const c of e) {
    if (c >= 2 ** t)
      throw new Error(`convertRadix2: invalid data word=${c} from=${t}`);
    if (i = i << t | c, o + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`);
    for (o += t; o >= r; o -= r)
      a.push((i >> o - r & s) >>> 0);
    i &= 2 ** o - 1;
  }
  if (i = i << r - o & s, !n && o >= t)
    throw new Error("Excess padding");
  if (!n && i)
    throw new Error(`Non-zero padding: ${i}`);
  return n && o > 0 && a.push(i >>> 0), a;
}
// @__NO_SIDE_EFFECTS__
function p6(e) {
  return {
    encode: (t) => {
      if (!(t instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ L0(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ L0(t, e, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function Bd(e, t = !1) {
  if (e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ wc(8, e) > 32 || /* @__PURE__ */ wc(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (r) => {
      if (!(r instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return /* @__PURE__ */ vf(Array.from(r), 8, e, !t);
    },
    decode: (r) => {
      if (!Array.isArray(r) || r.length && typeof r[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(/* @__PURE__ */ vf(r, e, 8, t));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function z0(e) {
  if (typeof e != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
// @__NO_SIDE_EFFECTS__
function g6(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), i = new Uint8Array(r.length + e);
      return i.set(r), i.set(n, r.length), i;
    },
    decode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), i = t(n).slice(0, e), o = r.slice(-e);
      for (let s = 0; s < e; s++)
        if (i[s] !== o[s])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
const j0 = /* @__PURE__ */ ua(/* @__PURE__ */ Bd(6), /* @__PURE__ */ uu("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ bg(6), /* @__PURE__ */ lu("")), D0 = /* @__PURE__ */ ua(/* @__PURE__ */ Bd(6), /* @__PURE__ */ uu("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ bg(6), /* @__PURE__ */ lu("")), m6 = (e) => /* @__PURE__ */ ua(/* @__PURE__ */ p6(58), /* @__PURE__ */ uu(e), /* @__PURE__ */ lu("")), b6 = /* @__PURE__ */ m6("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), M0 = (e) => /* @__PURE__ */ ua(/* @__PURE__ */ g6(4, (t) => e(e(t))), b6), xf = /* @__PURE__ */ ua(/* @__PURE__ */ uu("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ lu("")), K0 = [996825010, 642813549, 513874426, 1027748829, 705979059];
// @__NO_SIDE_EFFECTS__
function ms(e) {
  const t = e >> 25;
  let r = (e & 33554431) << 5;
  for (let n = 0; n < K0.length; n++)
    (t >> n & 1) === 1 && (r ^= K0[n]);
  return r;
}
// @__NO_SIDE_EFFECTS__
function q0(e, t, r = 1) {
  const n = e.length;
  let i = 1;
  for (let o = 0; o < n; o++) {
    const s = e.charCodeAt(o);
    if (s < 33 || s > 126)
      throw new Error(`Invalid prefix (${e})`);
    i = /* @__PURE__ */ ms(i) ^ s >> 5;
  }
  i = /* @__PURE__ */ ms(i);
  for (let o = 0; o < n; o++)
    i = /* @__PURE__ */ ms(i) ^ e.charCodeAt(o) & 31;
  for (let o of t)
    i = /* @__PURE__ */ ms(i) ^ o;
  for (let o = 0; o < 6; o++)
    i = /* @__PURE__ */ ms(i);
  return i ^= r, xf.encode(/* @__PURE__ */ vf([i % 2 ** 30], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function wg(e) {
  const t = e === "bech32" ? 1 : 734539939, r = /* @__PURE__ */ Bd(5), n = r.decode, i = r.encode, o = /* @__PURE__ */ z0(n);
  function s(f, l, h = 90) {
    if (typeof f != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof f}`);
    if (!Array.isArray(l) || l.length && typeof l[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof l}`);
    const m = f.length + 7 + l.length;
    if (h !== !1 && m > h)
      throw new TypeError(`Length ${m} exceeds limit ${h}`);
    const y = f.toLowerCase(), b = /* @__PURE__ */ q0(y, l, t);
    return `${y}1${xf.encode(l)}${b}`;
  }
  function a(f, l = 90) {
    if (typeof f != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof f}`);
    if (f.length < 8 || l !== !1 && f.length > l)
      throw new TypeError(`Wrong string length: ${f.length} (${f}). Expected (8..${l})`);
    const h = f.toLowerCase();
    if (f !== h && f !== f.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    f = h;
    const m = f.lastIndexOf("1");
    if (m === 0 || m === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const y = f.slice(0, m), b = f.slice(m + 1);
    if (b.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const g = xf.decode(b).slice(0, -6), v = /* @__PURE__ */ q0(y, g, t);
    if (!b.endsWith(v))
      throw new Error(`Invalid checksum in ${f}: expected "${v}"`);
    return { prefix: y, words: g };
  }
  const c = /* @__PURE__ */ z0(a);
  function u(f) {
    const { prefix: l, words: h } = a(f, !1);
    return { prefix: l, words: h, bytes: n(h) };
  }
  return { encode: s, decode: a, decodeToBytes: u, decodeUnsafe: c, fromWords: n, fromWordsUnsafe: o, toWords: i };
}
const Fa = /* @__PURE__ */ wg("bech32"), Ha = /* @__PURE__ */ wg("bech32m"), an = {
  b58chk: {
    encode: (e) => M0(wf).encode(e),
    decode: (e) => M0(wf).decode(e)
  },
  base64: {
    encode: (e) => j0.encode(e),
    decode: (e) => j0.decode(e)
  },
  b64url: {
    encode: (e) => D0.encode(e),
    decode: (e) => D0.decode(e)
  },
  bech32: {
    to_words: Fa.toWords,
    to_bytes: Fa.fromWords,
    encode: (e, t, r = !1) => Fa.encode(e, t, r),
    decode: (e, t = !1) => {
      const { prefix: r, words: n } = Fa.decode(e, t);
      return { prefix: r, words: n };
    }
  },
  bech32m: {
    to_words: Ha.toWords,
    to_bytes: Ha.fromWords,
    encode: (e, t, r = !1) => Ha.encode(e, t, r),
    decode: (e, t = !1) => {
      const { prefix: r, words: n } = Ha.decode(e, t);
      return { prefix: r, words: n };
    }
  }
};
function y6(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function w6(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function v6(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
function vg(e, t) {
  if (e !== t)
    throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
const x6 = BigInt(0), E6 = BigInt(255), xg = BigInt(256);
function A6(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function S6(e, t, r = "be") {
  t === void 0 && (t = A6(e));
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (; e > x6; ) {
    const a = e & E6, c = Number(a);
    n ? o.setUint8(s++, c) : o.setUint8(s--, c), e = (e - a) / xg;
  }
  return new Uint8Array(i);
}
function _6(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * xg + BigInt(e[r]);
  return BigInt(t);
}
function k6(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, i = 0; n < t.length; n += 8, i++) {
    let o = 0;
    for (let s = 0; s < 8; s++)
      o |= t[n + s] << 7 - s;
    r[i] = o;
  }
  return r;
}
function T6(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let i = 7; i >= 0; i--, r++)
      t[r] = n >> i & 1;
  }
  return t.join("");
}
function C6(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function P6(e, t, r = "be") {
  t === void 0 && (t = C6(e));
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(i);
}
function I6(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], v6(t);
  return t;
}
const B6 = new TextEncoder(), O6 = new TextDecoder();
function Od(e) {
  return B6.encode(e);
}
function _l(e) {
  return O6.decode(e);
}
function $6(e, t) {
  w6(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function N6(e, t, r = "le") {
  t = $6(e, t);
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? o.setUint8(s++, u) : o.setUint8(s--, u);
  }
  return new Uint8Array(i);
}
function U6(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
const { getRandomValues: F6 } = crypto ?? globalThis.crypto ?? window.crypto;
function H6(e = 32) {
  if (typeof F6 == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function Eg(e) {
  return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function R6(e) {
  return typeof e == "string" && Eg(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? !0 : !!(Array.isArray(e) && e.every((t) => typeof t == "number"));
}
function L6(e, t, r = "be") {
  t === void 0 && (t = e.length), y6(e, t);
  const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
  return n.set(e, i), n;
}
function Ag(e) {
  let t, r = 0;
  const n = e.reduce((o, s) => o + s.length, 0), i = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const o = e[t];
    i.set(o, r), r += o.length;
  }
  return i;
}
function z6(e, t) {
  return typeof t == "bigint" ? `${t}n` : t;
}
function j6(e, t) {
  return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function D6(e, t, r) {
  const n = e.length, i = r / t;
  if (r % t !== 0)
    throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
  if (n !== r)
    throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
  if (n % t !== 0)
    throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
  const o = new Array(i);
  for (let s = 0; s < i; s++) {
    const a = s * t;
    o[s] = e.subarray(a, a + t);
  }
  return o;
}
function $d(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return L6(e, t, r);
  if (Array.isArray(e)) {
    const n = e.map((i) => $d(i, t, r));
    return Ag(n);
  } else {
    if (typeof e == "string")
      return N6(e, t, r);
    if (typeof e == "bigint")
      return S6(e, t, r);
    if (typeof e == "number")
      return P6(e, t, r);
    if (typeof e == "boolean")
      return Uint8Array.of(e ? 1 : 0);
  }
  throw new TypeError("Unsupported format:" + typeof e);
}
var he;
let We = (he = class extends Uint8Array {
  static random(t = 32) {
    const r = H6(t);
    return new he(r, t);
  }
  static now(t = 4) {
    const r = Math.floor(Date.now() / 1e3);
    return new he(r, t);
  }
  constructor(t, r, n) {
    if (t instanceof he && r === void 0)
      return t;
    const i = $d(t, r, n);
    super(i);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.to_num();
  }
  get big() {
    return this.to_big();
  }
  get str() {
    return this.to_str();
  }
  get hex() {
    return this.to_hex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.to_bin();
  }
  get b58chk() {
    return this.to_b58chk();
  }
  get base64() {
    return this.to_base64();
  }
  get b64url() {
    return this.to_b64url();
  }
  get digest() {
    return this.to_hash();
  }
  get id() {
    return this.to_hash().hex;
  }
  get stream() {
    return new rv(this);
  }
  to_num(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return I6(r);
  }
  to_big(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return _6(r);
  }
  to_bin() {
    return T6(this);
  }
  to_hash() {
    const t = wf(this);
    return new he(t);
  }
  to_json(t) {
    t === void 0 && (t = j6);
    const r = _l(this);
    return JSON.parse(r, t);
  }
  to_bech32(t, r) {
    const { encode: n, to_words: i } = an.bech32, o = i(this);
    return n(t, o, r);
  }
  to_bech32m(t, r) {
    const { encode: n, to_words: i } = an.bech32m, o = i(this);
    return n(t, o, r);
  }
  to_str() {
    return _l(this);
  }
  to_hex() {
    return U6(this);
  }
  to_bytes() {
    return new Uint8Array(this);
  }
  to_b58chk() {
    return an.b58chk.encode(this);
  }
  to_base64() {
    return an.base64.encode(this);
  }
  to_b64url() {
    return an.b64url.encode(this);
  }
  append(t) {
    return he.join([this, he.bytes(t)]);
  }
  prepend(t) {
    return he.join([he.bytes(t), this]);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new he(t);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new he(n);
  }
  set(t, r) {
    this.set(t, r);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new he(n);
  }
  write(t, r) {
    const n = he.bytes(t);
    this.set(n, r);
  }
  add_varint(t) {
    const r = he.calc_varint(this.length, t);
    return he.join([r, this]);
  }
  static from(t) {
    return new he(Uint8Array.from(t));
  }
  static of(...t) {
    return new he(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((i) => he.bytes(i)), n = Ag(r);
    return new he(n);
  }
  static sort(t, r) {
    const n = t.map((i) => V0(i, r).hex);
    return n.sort(), n.map((i) => he.hex(i, r));
  }
  static calc_varint(t, r) {
    if (t < 253)
      return he.num(t, 1);
    if (t < 65536)
      return he.of(253, ...he.num(t, 2, r));
    if (t < 4294967296)
      return he.of(254, ...he.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return he.of(255, ...he.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
}, he.num = M6, he.big = q6, he.bin = K6, he.raw = V6, he.str = W6, he.hex = G6, he.bytes = V0, he.json = Z6, he.base64 = X6, he.b64url = Y6, he.bech32 = J6, he.bech32m = Q6, he.b58chk = ev, he.encode = Od, he.decode = _l, he.parse = tv, he.is_bytes = R6, he.is_hex = Eg, he);
function M6(e, t, r) {
  return new We(e, t, r);
}
function K6(e, t, r) {
  return new We(k6(e), t, r);
}
function q6(e, t, r) {
  return new We(e, t, r);
}
function V6(e, t, r) {
  return new We(e, t, r);
}
function W6(e, t, r) {
  return new We(Od(e), t, r);
}
function G6(e, t, r) {
  return new We(e, t, r);
}
function Z6(e, t) {
  t === void 0 && (t = z6);
  const r = JSON.stringify(e, t);
  return new We(Od(r));
}
function X6(e) {
  return new We(an.base64.decode(e));
}
function Y6(e) {
  return new We(an.b64url.decode(e));
}
function J6(e, t, r) {
  const { decode: n, to_bytes: i } = an.bech32, { prefix: o, words: s } = n(e, t), a = i(s);
  return typeof r == "string" && vg(o, r), new We(a);
}
function Q6(e, t, r) {
  const { decode: n, to_bytes: i } = an.bech32m, { prefix: o, words: s } = n(e, t), a = i(s);
  return typeof r == "string" && vg(o, r), new We(a);
}
function ev(e) {
  return new We(an.b58chk.decode(e));
}
function tv(e, t, r) {
  const n = $d(e);
  return D6(n, t, r).map((o) => We.bytes(o));
}
let rv = class {
  constructor(t) {
    this.data = We.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new We(this.data.slice(0, t));
  }
  read(t) {
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  read_varint(t) {
    const r = this.read(1).num;
    switch (!0) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).to_num(t);
      case r === 254:
        return this.read(4).to_num(t);
      case r === 255:
        return this.read(8).to_num(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
function V0(e, t, r) {
  return new We(e, t, r);
}
const vc = to.CURVE, fu = vc.n, nv = vc.p, W0 = { x: vc.Gx, y: vc.Gy }, iv = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
const ov = (e) => Zt(e, fu);
function Sg(e, t = !1) {
  if (!t)
    return !1;
  throw new Error(e);
}
function sv(e, t, r) {
  const n = We.bytes(e);
  return n.length !== t ? Sg(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function av(e, t) {
  return typeof e == "bigint" && iv < e && e < fu || Sg("x value is not in the field!", t), !0;
}
const cv = Id(fu, 32, !0), G0 = to.ProjectivePoint, bs = cv;
var Ye;
let Do = (Ye = class extends Uint8Array {
  static add(t) {
    return t.map((r) => Ye.mod(r)).reduce((r, n) => r.add(n));
  }
  static mod(t) {
    return new Ye(t);
  }
  static mul(t) {
    return t.map((r) => Ye.mod(r)).reduce((r, n) => r.mul(n));
  }
  static is_valid(t, r) {
    const n = We.bytes(t, 32).big;
    return av(n, r);
  }
  constructor(t) {
    const r = ov(uv(t));
    Ye.is_valid(r, !0), super(We.big(r, 32), 32);
  }
  get buff() {
    return new We(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(t) {
    return new Ye(t).big > this.big;
  }
  lt(t) {
    return new Ye(t).big < this.big;
  }
  eq(t) {
    return new Ye(t).big === this.big;
  }
  ne(t) {
    return new Ye(t).big !== this.big;
  }
  add(t) {
    const r = Ye.mod(t), n = bs.add(this.big, r.big);
    return new Ye(n);
  }
  sub(t) {
    const r = Ye.mod(t), n = bs.sub(this.big, r.big);
    return new Ye(n);
  }
  mul(t) {
    const r = Ye.mod(t), n = bs.mul(this.big, r.big);
    return new Ye(n);
  }
  pow(t) {
    const r = Ye.mod(t), n = bs.pow(this.big, r.big);
    return new Ye(n);
  }
  div(t) {
    const r = Ye.mod(t), n = bs.div(this.big, r.big);
    return new Ye(n);
  }
  negate() {
    return new Ye(Ye.N - this.big);
  }
  generate() {
    const r = to.ProjectivePoint.BASE.multiply(this.big);
    return Nd.import(r);
  }
}, Ye.N = fu, Ye);
var Me;
let Nd = (Me = class {
  static from_x(t, r = !1) {
    let n = lv(t);
    n.length === 32 ? n = n.prepend(2) : r && (n[0] = 2), sv(n, 33);
    const i = G0.fromHex(n.hex);
    return i.assertValidity(), new Me(i.x, i.y);
  }
  static generate(t) {
    const r = Do.mod(t), n = Me.base.multiply(r.big);
    return Me.import(n);
  }
  static import(t) {
    const r = t instanceof Me ? { x: t.x.big, y: t.y.big } : { x: t.x, y: t.y };
    return new Me(r.x, r.y);
  }
  constructor(t, r) {
    this._p = new G0(t, r, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return We.big(this.p.x, 32);
  }
  get y() {
    return We.big(this.p.y, 32);
  }
  get buff() {
    return We.raw(this.p.toRawBytes(!0));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  eq(t) {
    const r = t instanceof Me ? t : Me.from_x(t);
    return this.x.big === r.x.big && this.y.big === r.y.big;
  }
  add(t) {
    return t instanceof Me ? Me.import(this.p.add(t.p)) : Me.import(this.p.add(Me.generate(t).p));
  }
  sub(t) {
    return t instanceof Me ? Me.import(this.p.subtract(t.p)) : Me.import(this.p.subtract(Me.generate(t).p));
  }
  mul(t) {
    return t instanceof Me ? Me.import(this.p.multiply(t.x.big)) : Me.import(this.p.multiply(Do.mod(t).big));
  }
  negate() {
    return Me.import(this.p.negate());
  }
}, Me.P = nv, Me.G = new Me(W0.x, W0.y), Me.curve = to.CURVE, Me.base = to.ProjectivePoint.BASE, Me.mul = Me.generate, Me);
function uv(e) {
  if (e instanceof Do)
    return e.big;
  if (e instanceof Nd)
    return e.x.big;
  if (e instanceof Uint8Array)
    return We.raw(e).big;
  if (typeof e == "string")
    return We.hex(e).big;
  if (typeof e == "number")
    return We.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function lv(e) {
  if (e instanceof Do)
    return e.point.buff;
  if (e instanceof Nd)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return We.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return We.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
const Ra = /* @__PURE__ */ BigInt(2 ** 32 - 1), Ef = /* @__PURE__ */ BigInt(32);
function _g(e, t = !1) {
  return t ? { h: Number(e & Ra), l: Number(e >> Ef & Ra) } : { h: Number(e >> Ef & Ra) | 0, l: Number(e & Ra) | 0 };
}
function fv(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: s } = _g(e[i], t);
    [r[i], n[i]] = [o, s];
  }
  return [r, n];
}
const dv = (e, t) => BigInt(e >>> 0) << Ef | BigInt(t >>> 0), hv = (e, t, r) => e >>> r, pv = (e, t, r) => e << 32 - r | t >>> r, gv = (e, t, r) => e >>> r | t << 32 - r, mv = (e, t, r) => e << 32 - r | t >>> r, bv = (e, t, r) => e << 64 - r | t >>> r - 32, yv = (e, t, r) => e >>> r - 32 | t << 64 - r, wv = (e, t) => t, vv = (e, t) => e, xv = (e, t, r) => e << r | t >>> 32 - r, Ev = (e, t, r) => t << r | e >>> 32 - r, Av = (e, t, r) => t << r - 32 | e >>> 64 - r, Sv = (e, t, r) => e << r - 32 | t >>> 64 - r;
function _v(e, t, r, n) {
  const i = (t >>> 0) + (n >>> 0);
  return { h: e + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const kv = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), Tv = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, Cv = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), Pv = (e, t, r, n, i) => t + r + n + i + (e / 2 ** 32 | 0) | 0, Iv = (e, t, r, n, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Bv = (e, t, r, n, i, o) => t + r + n + i + o + (e / 2 ** 32 | 0) | 0, Te = {
  fromBig: _g,
  split: fv,
  toBig: dv,
  shrSH: hv,
  shrSL: pv,
  rotrSH: gv,
  rotrSL: mv,
  rotrBH: bv,
  rotrBL: yv,
  rotr32H: wv,
  rotr32L: vv,
  rotlSH: xv,
  rotlSL: Ev,
  rotlBH: Av,
  rotlBL: Sv,
  add: _v,
  add3L: kv,
  add3H: Tv,
  add4L: Cv,
  add4H: Pv,
  add5H: Bv,
  add5L: Iv
}, [Ov, $v] = Te.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), Zn = /* @__PURE__ */ new Uint32Array(80), Xn = /* @__PURE__ */ new Uint32Array(80);
let Nv = class extends dd {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: c, Eh: u, El: f, Fh: l, Fl: h, Gh: m, Gl: y, Hh: b, Hl: g } = this;
    return [t, r, n, i, o, s, a, c, u, f, l, h, m, y, b, g];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c, u, f, l, h, m, y, b, g) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = f | 0, this.Fh = l | 0, this.Fl = h | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = g | 0;
  }
  process(t, r) {
    for (let x = 0; x < 16; x++, r += 4)
      Zn[x] = t.getUint32(r), Xn[x] = t.getUint32(r += 4);
    for (let x = 16; x < 80; x++) {
      const k = Zn[x - 15] | 0, P = Xn[x - 15] | 0, I = Te.rotrSH(k, P, 1) ^ Te.rotrSH(k, P, 8) ^ Te.shrSH(k, P, 7), R = Te.rotrSL(k, P, 1) ^ Te.rotrSL(k, P, 8) ^ Te.shrSL(k, P, 7), j = Zn[x - 2] | 0, W = Xn[x - 2] | 0, re = Te.rotrSH(j, W, 19) ^ Te.rotrBH(j, W, 61) ^ Te.shrSH(j, W, 6), X = Te.rotrSL(j, W, 19) ^ Te.rotrBL(j, W, 61) ^ Te.shrSL(j, W, 6), N = Te.add4L(R, X, Xn[x - 7], Xn[x - 16]), G = Te.add4H(N, I, re, Zn[x - 7], Zn[x - 16]);
      Zn[x] = G | 0, Xn[x] = N | 0;
    }
    let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: c, Dh: u, Dl: f, Eh: l, El: h, Fh: m, Fl: y, Gh: b, Gl: g, Hh: v, Hl: _ } = this;
    for (let x = 0; x < 80; x++) {
      const k = Te.rotrSH(l, h, 14) ^ Te.rotrSH(l, h, 18) ^ Te.rotrBH(l, h, 41), P = Te.rotrSL(l, h, 14) ^ Te.rotrSL(l, h, 18) ^ Te.rotrBL(l, h, 41), I = l & m ^ ~l & b, R = h & y ^ ~h & g, j = Te.add5L(_, P, R, $v[x], Xn[x]), W = Te.add5H(j, v, k, I, Ov[x], Zn[x]), re = j | 0, X = Te.rotrSH(n, i, 28) ^ Te.rotrBH(n, i, 34) ^ Te.rotrBH(n, i, 39), N = Te.rotrSL(n, i, 28) ^ Te.rotrBL(n, i, 34) ^ Te.rotrBL(n, i, 39), G = n & o ^ n & a ^ o & a, M = i & s ^ i & c ^ s & c;
      v = b | 0, _ = g | 0, b = m | 0, g = y | 0, m = l | 0, y = h | 0, { h: l, l: h } = Te.add(u | 0, f | 0, W | 0, re | 0), u = a | 0, f = c | 0, a = o | 0, c = s | 0, o = n | 0, s = i | 0;
      const $ = Te.add3L(re, N, M);
      n = Te.add3H($, W, X, G), i = $ | 0;
    }
    ({ h: n, l: i } = Te.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: o, l: s } = Te.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0), { h: a, l: c } = Te.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l: f } = Te.add(this.Dh | 0, this.Dl | 0, u | 0, f | 0), { h: l, l: h } = Te.add(this.Eh | 0, this.El | 0, l | 0, h | 0), { h: m, l: y } = Te.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: b, l: g } = Te.add(this.Gh | 0, this.Gl | 0, b | 0, g | 0), { h: v, l: _ } = Te.add(this.Hh | 0, this.Hl | 0, v | 0, _ | 0), this.set(n, i, o, s, a, c, u, f, l, h, m, y, b, g, v, _);
  }
  roundClean() {
    Zn.fill(0), Xn.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const Uv = /* @__PURE__ */ fd(() => new Nv());
function Fv(e, t = !1) {
  const r = Do.mod(e);
  return t ? r.negated.buff : r.buff;
}
function kg(e, t = !1) {
  const r = Do.mod(e).point;
  return t ? r.x : r.buff;
}
to.ProjectivePoint;
function Af(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Hv(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function Tg(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Rv(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Af(e.outputLen), Af(e.blockLen);
}
function Lv(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function zv(e, t) {
  Tg(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const jv = {
  number: Af,
  bool: Hv,
  bytes: Tg,
  hash: Rv,
  exists: Lv,
  output: zv
};
var kl = jv;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Tl = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), en = (e, t) => e << 32 - t | e >>> t, Dv = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Dv)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Mv(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Cg(e) {
  if (typeof e == "string" && (e = Mv(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let Kv = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function Pg(e) {
  const t = (n) => e().update(Cg(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function qv(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
let Vv = class extends Kv {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Tl(this.buffer);
  }
  update(t) {
    kl.exists(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = Cg(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const c = Tl(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    kl.exists(this), kl.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let l = s; l < i; l++)
      r[l] = 0;
    qv(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const a = Tl(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++)
      a.setUint32(4 * l, f[l], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
  }
};
const Wv = (e, t, r) => e & t ^ ~e & r, Gv = (e, t, r) => e & t ^ e & r ^ t & r, Zv = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Yn = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Jn = new Uint32Array(64);
let Ig = class extends Vv {
  constructor() {
    super(64, 32, 8, !1), this.A = Yn[0] | 0, this.B = Yn[1] | 0, this.C = Yn[2] | 0, this.D = Yn[3] | 0, this.E = Yn[4] | 0, this.F = Yn[5] | 0, this.G = Yn[6] | 0, this.H = Yn[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: c } = this;
    return [t, r, n, i, o, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      Jn[l] = t.getUint32(r, !1);
    for (let l = 16; l < 64; l++) {
      const h = Jn[l - 15], m = Jn[l - 2], y = en(h, 7) ^ en(h, 18) ^ h >>> 3, b = en(m, 17) ^ en(m, 19) ^ m >>> 10;
      Jn[l] = b + Jn[l - 7] + y + Jn[l - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: a, F: c, G: u, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const h = en(a, 6) ^ en(a, 11) ^ en(a, 25), m = f + h + Wv(a, c, u) + Zv[l] + Jn[l] | 0, b = (en(n, 2) ^ en(n, 13) ^ en(n, 22)) + Gv(n, i, o) | 0;
      f = u, u = c, c = a, a = s + m | 0, s = o, o = i, i = n, n = m + b | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, s, a, c, u, f);
  }
  roundClean() {
    Jn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, Xv = class extends Ig {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Sf = Pg(() => new Ig());
Pg(() => new Xv());
function Yv(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Jv(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Qv(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: e7 } = crypto ?? globalThis.crypto ?? window.crypto;
function t7(e = 32) {
  if (typeof e7 == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function r7(e, t, r = "be") {
  t === void 0 && (t = e.length), Yv(e, t);
  const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
  return n.set(e, i), n;
}
function Bg(e) {
  let t, r = 0;
  const n = e.reduce((o, s) => o + s.length, 0), i = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const o = e[t];
    i.set(o, r), r += o.length;
  }
  return i;
}
const n7 = new TextEncoder(), i7 = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function Og(e) {
  for (const t of i7)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function o7(e, t, r = !1) {
  typeof e == "string" && (e = n7.encode(e));
  const n = Og(t), i = n.length, o = [];
  let s = "", a, c = 0, u, f;
  for (a = 0; a < e.length; a++)
    for (c = 0, u = e[a], s += u > 0 || (s.length ^ a) > 0 ? "" : "1"; c in o || u > 0; )
      f = o[c], f = f > 0 ? f * 256 + u : u, u = f / i | 0, o[c] = f % i, c++;
  for (; c-- > 0; )
    s += n[o[c]];
  return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function s7(e, t) {
  const r = Og(t), n = r.length, i = [], o = [];
  e = e.replace("=", "");
  let s, a = 0, c, u;
  for (s = 0; s < e.length; s++) {
    if (a = 0, c = r.indexOf(e[s]), c < 0)
      throw new Error(`Character range out of bounds: ${c}`);
    for (c > 0 || (o.length ^ s) > 0 || o.push(0); a in i || c > 0; )
      u = i[a], u = u > 0 ? u * n + c : c, c = u >> 8, i[a] = u % 256, a++;
  }
  for (; a-- > 0; )
    o.push(i[a]);
  return new Uint8Array(o);
}
function $g(e) {
  return Sf(Sf(e));
}
function a7(e) {
  const t = $g(e);
  return Bg([e, t.slice(0, 4)]);
}
function c7(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if ($g(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
const Z0 = {
  encode: o7,
  decode: s7
}, Ng = {
  encode: (e) => {
    const t = a7(e);
    return Z0.encode(t, "base58");
  },
  decode: (e) => {
    const t = Z0.decode(e, "base58");
    return c7(t);
  }
}, Ug = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", u7 = [996825010, 642813549, 513874426, 1027748829, 705979059], xc = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function Fg(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let i = 0; i < 5; ++i)
      n >> i & 1 && (t ^= u7[i]);
  }
  return t;
}
function Hg(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function l7(e, t, r) {
  const n = Hg(e).concat(t);
  return Fg(n) === r.const;
}
function f7(e, t, r) {
  const n = Hg(e).concat(t).concat([0, 0, 0, 0, 0, 0]), i = Fg(n) ^ r.const, o = [];
  for (let s = 0; s < 6; ++s)
    o.push(i >> 5 * (5 - s) & 31);
  return o;
}
function Rg(e, t, r, n = !0) {
  const i = [];
  let o = 0, s = 0;
  const a = (1 << r) - 1, c = (1 << t + r - 1) - 1;
  for (const u of e) {
    if (u < 0 || u >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(u));
    for (o = (o << t | u) & c, s += t; s >= r; )
      s -= r, i.push(o >> s & a);
  }
  if (n)
    s > 0 && i.push(o << r - s & a);
  else if (s >= t || (o << r - s & a) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return i;
}
function d7(e, t, r) {
  const n = t.concat(f7(e, t, r));
  let i = e + "1";
  for (let o = 0; o < n.length; ++o)
    i += Ug.charAt(n[o]);
  return i;
}
function Lg(e) {
  if (!h7(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !p7(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let o = r + 1; o < e.length; ++o) {
    const s = Ug.indexOf(e.charAt(o));
    if (s === -1)
      throw new Error("Character idx out of bounds: " + String(o));
    t.push(s);
  }
  const i = xc.find((o) => o.version === t[0]) ?? xc[0];
  if (!l7(n, t, i))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function h7(e) {
  let t, r, n = !1, i = !1;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return !1;
    r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i = !0);
  }
  return !(n && i);
}
function p7(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function g7(e, t = "bc", r = 0) {
  const n = [r, ...Rg([...e], 8, 5)], i = xc.find((s) => s.version === r) ?? xc[0], o = d7(t, n, i);
  return zg(o), o;
}
function zg(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = Lg(e), i = Rg(n.slice(1), 5, 8, !1), o = i.length;
  switch (!0) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (i === null || o < 2 || o > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(i);
  }
}
function m7(e) {
  e = e.toLowerCase();
  const [t, r] = Lg(e);
  return r[0];
}
const jg = {
  encode: g7,
  decode: zg,
  version: m7
}, Dg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Mg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", b7 = new TextEncoder();
function Kg(e, t = !1, r = !0) {
  typeof e == "string" && (e = b7.encode(e));
  const n = t ? Mg : Dg;
  let i = "", o = 0, s = 0;
  for (let a = 0; a < e.length; a++)
    for (s = s << 8 | e[a], o += 8; o >= 6; )
      o -= 6, i += n[s >> o & 63];
  if (o > 0)
    for (s <<= 6 - o, i += n[s & 63]; o < 6; )
      i += r ? "=" : "", o += 2;
  return i;
}
function qg(e, t = !1) {
  const r = t || e.includes("-") || e.includes("_") ? Mg.split("") : Dg.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let i = 0, o = 0;
  const s = [];
  for (let a = 0; a < n.length; a++) {
    const c = n[a], u = r.indexOf(c);
    if (u === -1)
      throw new Error("Invalid character: " + c);
    i += 6, o <<= 6, o |= u, i >= 8 && (i -= 8, s.push(o >>> i & 255));
  }
  return new Uint8Array(s);
}
const Vg = {
  encode: Kg,
  decode: qg
}, Wg = {
  encode: (e) => Kg(e, !0, !1),
  decode: (e) => qg(e, !0)
}, y7 = BigInt(0), w7 = BigInt(255), Gg = BigInt(256);
function v7(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function x7(e, t, r = "be") {
  t === void 0 && (t = v7(e));
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (; e > y7; ) {
    const a = e & w7, c = Number(a);
    n ? o.setUint8(s++, c) : o.setUint8(s--, c), e = (e - a) / Gg;
  }
  return new Uint8Array(i);
}
function E7(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * Gg + BigInt(e[r]);
  return BigInt(t);
}
function A7(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, i = 0; n < t.length; n += 8, i++) {
    let o = 0;
    for (let s = 0; s < 8; s++)
      o |= t[n + s] << 7 - s;
    r[i] = o;
  }
  return r;
}
function S7(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let i = 7; i >= 0; i--, r++)
      t[r] = n >> i & 1;
  }
  return t.join("");
}
function _7(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function k7(e, t, r = "be") {
  t === void 0 && (t = _7(e));
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(i);
}
function T7(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], Qv(t);
  return t;
}
const C7 = new TextEncoder(), P7 = new TextDecoder();
function Ud(e) {
  return C7.encode(e);
}
function Cl(e) {
  return P7.decode(e);
}
function I7(e, t) {
  Jv(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function B7(e, t, r = "le") {
  t = I7(e, t);
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? o.setUint8(s++, u) : o.setUint8(s--, u);
  }
  return new Uint8Array(i);
}
function O7(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function $7(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return Ud(t);
}
function N7(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return r7(e, t, r);
  if (typeof e == "string")
    return B7(e, t, r);
  if (typeof e == "bigint")
    return x7(e, t, r);
  if (typeof e == "number")
    return k7(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
var Ee;
let U = (Ee = class extends Uint8Array {
  static random(t = 32) {
    const r = t7(t);
    return new Ee(r, t);
  }
  constructor(t, r, n) {
    const i = N7(t, r, n);
    super(i);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new ns(this);
  }
  toNum(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return T7(r);
  }
  toBin() {
    return S7(this);
  }
  toBig(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return E7(r);
  }
  toHash() {
    const t = Sf(this);
    return new Ee(t);
  }
  toJson() {
    const t = Cl(this);
    return JSON.parse(t);
  }
  toBech32(t, r = 0) {
    return jg.encode(this, t, r);
  }
  toStr() {
    return Cl(this);
  }
  toHex() {
    return O7(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return Ng.encode(this);
  }
  toBase64() {
    return Vg.encode(this);
  }
  toB64url() {
    return Wg.encode(this);
  }
  prepend(t) {
    return Ee.join([Ee.bytes(t), this]);
  }
  append(t) {
    return Ee.join([this, Ee.bytes(t)]);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new Ee(n);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new Ee(n);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new Ee(t);
  }
  write(t, r) {
    const n = Ee.bytes(t);
    this.set(n, r);
  }
  prefixSize(t) {
    const r = Ee.varInt(this.length, t);
    return Ee.join([r, this]);
  }
  static from(t) {
    return new Ee(Uint8Array.from(t));
  }
  static of(...t) {
    return new Ee(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((i) => Ee.bytes(i)), n = Bg(r);
    return new Ee(n);
  }
  static varInt(t, r) {
    if (t < 253)
      return Ee.num(t, 1);
    if (t < 65536)
      return Ee.of(253, ...Ee.num(t, 2, r));
    if (t < 4294967296)
      return Ee.of(254, ...Ee.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return Ee.of(255, ...Ee.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
}, Ee.num = U7, Ee.big = H7, Ee.bin = F7, Ee.raw = R7, Ee.str = L7, Ee.hex = z7, Ee.bytes = j7, Ee.json = D7, Ee.base64 = M7, Ee.b64url = K7, Ee.bech32 = q7, Ee.b58chk = V7, Ee.encode = Ud, Ee.decode = Cl, Ee);
function U7(e, t, r) {
  return new U(e, t, r);
}
function F7(e, t, r) {
  return new U(A7(e), t, r);
}
function H7(e, t, r) {
  return new U(e, t, r);
}
function R7(e, t, r) {
  return new U(e, t, r);
}
function L7(e, t, r) {
  return new U(Ud(e), t, r);
}
function z7(e, t, r) {
  return new U(e, t, r);
}
function j7(e, t, r) {
  return new U(e, t, r);
}
function D7(e) {
  return new U($7(e));
}
function M7(e) {
  return new U(Vg.decode(e));
}
function K7(e) {
  return new U(Wg.decode(e));
}
function q7(e) {
  return new U(jg.decode(e));
}
function V7(e) {
  return new U(Ng.decode(e));
}
let ns = class {
  constructor(t) {
    this.data = U.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new U(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (!0) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
function pn(e, t) {
  const r = U.bytes(e);
  if (r.length !== t)
    throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function Vt(e, t) {
  if (t)
    throw new Error(e);
  return !1;
}
function ec(e, ...t) {
  const r = U.str(e).digest.raw, n = t.map((i) => U.bytes(i));
  return U.join([r, r, U.join(n)]).digest;
}
const Zg = {
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_SUCCESS80: 80,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_SUCCESS98: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_SUCCESS126: 126,
  OP_SUCCESS127: 127,
  OP_SUCCESS128: 128,
  OP_SUCCESS129: 129,
  OP_SIZE: 130,
  OP_SUCCESS131: 131,
  OP_SUCCESS132: 132,
  OP_SUCCESS133: 133,
  OP_SUCCESS134: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_SUCCESS137: 137,
  OP_SUCCESS138: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_SUCCESS141: 141,
  OP_SUCCESS142: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_SUCCESS149: 149,
  OP_SUCCESS150: 150,
  OP_SUCCESS151: 151,
  OP_SUCCESS152: 152,
  OP_SUCCESS153: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186
};
function W7(e) {
  if (e > 186 && e < 255)
    return "OP_SUCCESS" + String(e);
  for (const [t, r] of Object.entries(Zg))
    if (r === e)
      return t;
  throw new Error("OPCODE not found:" + String(e));
}
function G7(e) {
  for (const [t, r] of Object.entries(Zg))
    if (t === e)
      return Number(r);
  throw new Error("OPCODE not found:" + e);
}
function Z7(e) {
  switch (!0) {
    case e === 0:
      return "opcode";
    case (e >= 1 && e <= 75):
      return "varint";
    case e === 76:
      return "pushdata1";
    case e === 77:
      return "pushdata2";
    case e === 78:
      return "pushdata4";
    case e <= 254:
      return "opcode";
    default:
      throw new Error(`Invalid word range: ${e}`);
  }
}
function X7(e) {
  const n = [];
  switch (!0) {
    case typeof e != "number":
      return !1;
    case e === 0:
      return !0;
    case n.includes(e):
      return !1;
    case (75 < e && e < 254):
      return !0;
    default:
      return !1;
  }
}
function Ln(e) {
  return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function Xg(e) {
  return Ln(e) || e instanceof Uint8Array;
}
const Ec = 520;
function fo(e = [], t = !0) {
  let r = U.num(0);
  return Array.isArray(e) && (r = U.raw(Yg(e))), Ln(e) && (r = U.hex(e)), e instanceof Uint8Array && (r = U.raw(e)), t && (r = r.prefixSize("le")), r;
}
function Yg(e) {
  const t = [];
  for (const r of e)
    t.push(Y7(r));
  return t.length > 0 ? U.join(t) : new Uint8Array();
}
function Y7(e) {
  let t = new Uint8Array();
  if (typeof e == "string") {
    if (e.startsWith("OP_"))
      return U.num(G7(e), 1);
    Ln(e) ? t = U.hex(e) : t = U.str(e);
  } else if (t = U.bytes(e), t.length === 1 && t[0] <= 16)
    return t[0] !== 0 && (t[0] += 80), t;
  if (t.length > Ec) {
    const r = Q7(t);
    return Yg(r);
  }
  return U.join([J7(t.length), t]);
}
function J7(e) {
  const t = U.num(76, 1), r = U.num(77, 1);
  switch (!0) {
    case e <= 75:
      return U.num(e);
    case (e > 75 && e < 256):
      return U.join([t, U.num(e, 1, "le")]);
    case (e >= 256 && e <= Ec):
      return U.join([r, U.num(e, 2, "le")]);
    default:
      throw new Error("Invalid word size:" + e.toString());
  }
}
function Q7(e) {
  const t = [], r = new ns(e);
  for (; r.size > Ec; )
    t.push(r.read(Ec));
  return t.push(r.read(r.size)), t;
}
function Fd(e, t = !1) {
  let r = U.bytes(e);
  if (t) {
    const i = r.stream.readSize("le");
    if (r = r.slice(1), r.length !== i)
      throw new Error(`Varint does not match stream size: ${i} !== ${r.length}`);
  }
  return ex(r);
}
function ex(e) {
  const t = new ns(e), r = [], n = t.size;
  let i, o, s, a = 0;
  for (; a < n; )
    switch (i = t.read(1).num, o = Z7(i), a++, o) {
      case "varint":
        r.push(t.read(i).hex), a += i;
        break;
      case "pushdata1":
        s = t.read(1).reverse().num, r.push(t.read(s).hex), a += s + 1;
        break;
      case "pushdata2":
        s = t.read(2).reverse().num, r.push(t.read(s).hex), a += s + 2;
        break;
      case "pushdata4":
        s = t.read(4).reverse().num, r.push(t.read(s).hex), a += s + 4;
        break;
      case "opcode":
        if (!X7(i))
          throw new Error(`Invalid OPCODE: ${i}`);
        r.push(W7(i));
        break;
      default:
        throw new Error(`Word type undefined: ${i}`);
    }
  return r;
}
function tx(e, t) {
  if (Array.isArray(e) && (e = fo(e, t)), e instanceof Uint8Array || Ln(e))
    return Fd(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function rx(e, t) {
  if ((e instanceof Uint8Array || Ln(e)) && (e = Fd(e, t)), Array.isArray(e))
    return fo(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function nx(e) {
  if (!Array.isArray(e))
    return U.bytes(e);
  throw new Error("Invalid format: " + typeof e);
}
const ix = {
  toAsm: tx,
  toBytes: rx,
  toParam: nx
}, Qt = {
  encode: fo,
  decode: Fd,
  fmt: ix
};
function _f(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function ox(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function Jg(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function sx(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  _f(e.outputLen), _f(e.blockLen);
}
function ax(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function cx(e, t) {
  Jg(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const ux = {
  number: _f,
  bool: ox,
  bytes: Jg,
  hash: sx,
  exists: ax,
  output: cx
};
var qi = ux;
const Pl = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Il = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), tn = (e, t) => e << 32 - t | e >>> t, lx = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!lx)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function fx(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Hd(e) {
  if (typeof e == "string" && (e = fx(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function dx(...e) {
  if (!e.every((n) => n instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((n, i) => n + i.length, 0), r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const o = e[n];
    r.set(o, i), i += o.length;
  }
  return r;
}
let Qg = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function em(e) {
  const t = (n) => e().update(Hd(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function tm(e = 32) {
  if (Pl && typeof Pl.getRandomValues == "function")
    return Pl.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
function hx(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
let px = class extends Qg {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Il(this.buffer);
  }
  update(t) {
    qi.exists(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = Hd(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const c = Il(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    qi.exists(this), qi.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let l = s; l < i; l++)
      r[l] = 0;
    hx(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const a = Il(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++)
      a.setUint32(4 * l, f[l], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
  }
};
const gx = (e, t, r) => e & t ^ ~e & r, mx = (e, t, r) => e & t ^ e & r ^ t & r, bx = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Qn = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ei = new Uint32Array(64);
let rm = class extends px {
  constructor() {
    super(64, 32, 8, !1), this.A = Qn[0] | 0, this.B = Qn[1] | 0, this.C = Qn[2] | 0, this.D = Qn[3] | 0, this.E = Qn[4] | 0, this.F = Qn[5] | 0, this.G = Qn[6] | 0, this.H = Qn[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: c } = this;
    return [t, r, n, i, o, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      ei[l] = t.getUint32(r, !1);
    for (let l = 16; l < 64; l++) {
      const h = ei[l - 15], m = ei[l - 2], y = tn(h, 7) ^ tn(h, 18) ^ h >>> 3, b = tn(m, 17) ^ tn(m, 19) ^ m >>> 10;
      ei[l] = b + ei[l - 7] + y + ei[l - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: a, F: c, G: u, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const h = tn(a, 6) ^ tn(a, 11) ^ tn(a, 25), m = f + h + gx(a, c, u) + bx[l] + ei[l] | 0, b = (tn(n, 2) ^ tn(n, 13) ^ tn(n, 22)) + mx(n, i, o) | 0;
      f = u, u = c, c = a, a = s + m | 0, s = o, o = i, i = n, n = m + b | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, s, a, c, u, f);
  }
  roundClean() {
    ei.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, yx = class extends rm {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Ac = em(() => new rm());
em(() => new yx());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const wx = BigInt(0), Rd = BigInt(1), vx = BigInt(2), du = (e) => e instanceof Uint8Array, xx = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Mo(e) {
  if (!du(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += xx[e[r]];
  return t;
}
function nm(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Ld(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function Ko(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const n = r * 2, i = e.slice(n, n + 2), o = Number.parseInt(i, 16);
    if (Number.isNaN(o) || o < 0)
      throw new Error("invalid byte sequence");
    t[r] = o;
  }
  return t;
}
function Yt(e) {
  return Ld(Mo(e));
}
function zd(e) {
  if (!du(e))
    throw new Error("Uint8Array expected");
  return Ld(Mo(Uint8Array.from(e).reverse()));
}
const Ei = (e, t) => Ko(e.toString(16).padStart(t * 2, "0")), im = (e, t) => Ei(e, t).reverse(), Ex = (e) => Ko(nm(e));
function Dt(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = Ko(t);
    } catch (o) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`);
    }
  else if (du(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const i = n.length;
  if (typeof r == "number" && i !== r)
    throw new Error(`${e} expected ${r} bytes, got ${i}`);
  return n;
}
function pr(...e) {
  const t = new Uint8Array(e.reduce((n, i) => n + i.length, 0));
  let r = 0;
  return e.forEach((n) => {
    if (!du(n))
      throw new Error("Uint8Array expected");
    t.set(n, r), r += n.length;
  }), t;
}
function Ax(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function hu(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Sx(e) {
  let t;
  for (t = 0; e > 0n; e >>= Rd, t += 1)
    ;
  return t;
}
const _x = (e, t) => e >> BigInt(t) & 1n, kx = (e, t, r) => e | (r ? Rd : wx) << BigInt(t), jd = (e) => (vx << BigInt(e - 1)) - Rd, Bl = (e) => new Uint8Array(e), X0 = (e) => Uint8Array.from(e);
function om(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = Bl(e), i = Bl(e), o = 0;
  const s = () => {
    n.fill(1), i.fill(0), o = 0;
  }, a = (...l) => r(i, n, ...l), c = (l = Bl()) => {
    i = a(X0([0]), l), n = a(), l.length !== 0 && (i = a(X0([1]), l), n = a());
  }, u = () => {
    if (o++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let l = 0;
    const h = [];
    for (; l < t; ) {
      n = a();
      const m = n.slice();
      h.push(m), l += n.length;
    }
    return pr(...h);
  };
  return (l, h) => {
    s(), c(l);
    let m;
    for (; !(m = h(u())); )
      c();
    return s(), m;
  };
}
const Tx = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function is(e, t, r = {}) {
  const n = (i, o, s) => {
    const a = Tx[o];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${o}", expected function`);
    const c = e[i];
    if (!(s && c === void 0) && !a(c, e))
      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`);
  };
  for (const [i, o] of Object.entries(t))
    n(i, o, !1);
  for (const [i, o] of Object.entries(r))
    n(i, o, !0);
  return e;
}
var Cx = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  bitGet: _x,
  bitLen: Sx,
  bitMask: jd,
  bitSet: kx,
  bytesToHex: Mo,
  bytesToNumberBE: Yt,
  bytesToNumberLE: zd,
  concatBytes: pr,
  createHmacDrbg: om,
  ensureBytes: Dt,
  equalBytes: Ax,
  hexToBytes: Ko,
  hexToNumber: Ld,
  numberToBytesBE: Ei,
  numberToBytesLE: im,
  numberToHexUnpadded: nm,
  numberToVarBytesBE: Ex,
  utf8ToBytes: hu,
  validateObject: is
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ht = BigInt(0), bt = BigInt(1), zi = BigInt(2), Px = BigInt(3), kf = BigInt(4), Y0 = BigInt(5), J0 = BigInt(8);
BigInt(9);
BigInt(16);
function It(e, t) {
  const r = e % t;
  return r >= Ht ? r : t + r;
}
function Ix(e, t, r) {
  if (r <= Ht || t < Ht)
    throw new Error("Expected power/modulo > 0");
  if (r === bt)
    return Ht;
  let n = bt;
  for (; t > Ht; )
    t & bt && (n = n * e % r), e = e * e % r, t >>= bt;
  return n;
}
function _r(e, t, r) {
  let n = e;
  for (; t-- > Ht; )
    n *= n, n %= r;
  return n;
}
function Tf(e, t) {
  if (e === Ht || t <= Ht)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = It(e, t), n = t, i = Ht, o = bt;
  for (; r !== Ht; ) {
    const a = n / r, c = n % r, u = i - o * a;
    n = r, r = c, i = o, o = u;
  }
  if (n !== bt)
    throw new Error("invert: does not exist");
  return It(i, t);
}
function Bx(e) {
  const t = (e - bt) / zi;
  let r, n, i;
  for (r = e - bt, n = 0; r % zi === Ht; r /= zi, n++)
    ;
  for (i = zi; i < e && Ix(i, t, e) !== e - bt; i++)
    ;
  if (n === 1) {
    const s = (e + bt) / kf;
    return function(c, u) {
      const f = c.pow(u, s);
      if (!c.eql(c.sqr(f), u))
        throw new Error("Cannot find square root");
      return f;
    };
  }
  const o = (r + bt) / zi;
  return function(a, c) {
    if (a.pow(c, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, f = a.pow(a.mul(a.ONE, i), r), l = a.pow(c, o), h = a.pow(c, r);
    for (; !a.eql(h, a.ONE); ) {
      if (a.eql(h, a.ZERO))
        return a.ZERO;
      let m = 1;
      for (let b = a.sqr(h); m < u && !a.eql(b, a.ONE); m++)
        b = a.sqr(b);
      const y = a.pow(f, bt << BigInt(u - m - 1));
      f = a.sqr(y), l = a.mul(l, y), h = a.mul(h, f), u = m;
    }
    return l;
  };
}
function Ox(e) {
  if (e % kf === Px) {
    const t = (e + bt) / kf;
    return function(n, i) {
      const o = n.pow(i, t);
      if (!n.eql(n.sqr(o), i))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % J0 === Y0) {
    const t = (e - Y0) / J0;
    return function(n, i) {
      const o = n.mul(i, zi), s = n.pow(o, t), a = n.mul(i, s), c = n.mul(n.mul(a, zi), s), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), i))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return Bx(e);
}
const $x = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function sm(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = $x.reduce((n, i) => (n[i] = "function", n), t);
  return is(e, r);
}
function Nx(e, t, r) {
  if (r < Ht)
    throw new Error("Expected power > 0");
  if (r === Ht)
    return e.ONE;
  if (r === bt)
    return t;
  let n = e.ONE, i = t;
  for (; r > Ht; )
    r & bt && (n = e.mul(n, i)), i = e.sqr(i), r >>= bt;
  return n;
}
function Ux(e, t) {
  const r = new Array(t.length), n = t.reduce((o, s, a) => e.is0(s) ? o : (r[a] = o, e.mul(o, s)), e.ONE), i = e.inv(n);
  return t.reduceRight((o, s, a) => e.is0(s) ? o : (r[a] = e.mul(o, r[a]), e.mul(o, s)), i), r;
}
function Dd(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function am(e, t, r = !1, n = {}) {
  if (e <= Ht)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: o } = Dd(e, t);
  if (o > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = Ox(e), a = Object.freeze({
    ORDER: e,
    BITS: i,
    BYTES: o,
    MASK: jd(i),
    ZERO: Ht,
    ONE: bt,
    create: (c) => It(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return Ht <= c && c < e;
    },
    is0: (c) => c === Ht,
    isOdd: (c) => (c & bt) === bt,
    neg: (c) => It(-c, e),
    eql: (c, u) => c === u,
    sqr: (c) => It(c * c, e),
    add: (c, u) => It(c + u, e),
    sub: (c, u) => It(c - u, e),
    mul: (c, u) => It(c * u, e),
    pow: (c, u) => Nx(a, c, u),
    div: (c, u) => It(c * Tf(u, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => Tf(c, e),
    sqrt: n.sqrt || ((c) => s(a, c)),
    invertBatch: (c) => Ux(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, f) => f ? u : c,
    toBytes: (c) => r ? im(c, o) : Ei(c, o),
    fromBytes: (c) => {
      if (c.length !== o)
        throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);
      return r ? zd(c) : Yt(c);
    }
  });
  return Object.freeze(a);
}
function Fx(e, t, r = !1) {
  e = Dt("privateHash", e);
  const n = e.length, i = Dd(t).nByteLength + 8;
  if (i < 24 || n < i || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);
  const o = r ? zd(e) : Yt(e);
  return It(o, t - bt) + bt;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Hx = BigInt(0), Ol = BigInt(1);
function Rx(e, t) {
  const r = (i, o) => {
    const s = o.negate();
    return i ? s : o;
  }, n = (i) => {
    const o = Math.ceil(t / i) + 1, s = 2 ** (i - 1);
    return { windows: o, windowSize: s };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(i, o) {
      let s = e.ZERO, a = i;
      for (; o > Hx; )
        o & Ol && (s = s.add(a)), a = a.double(), o >>= Ol;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, o) {
      const { windows: s, windowSize: a } = n(o), c = [];
      let u = i, f = u;
      for (let l = 0; l < s; l++) {
        f = u, c.push(f);
        for (let h = 1; h < a; h++)
          f = f.add(u), c.push(f);
        u = f.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, o, s) {
      const { windows: a, windowSize: c } = n(i);
      let u = e.ZERO, f = e.BASE;
      const l = BigInt(2 ** i - 1), h = 2 ** i, m = BigInt(i);
      for (let y = 0; y < a; y++) {
        const b = y * c;
        let g = Number(s & l);
        s >>= m, g > c && (g -= h, s += Ol);
        const v = b, _ = b + Math.abs(g) - 1, x = y % 2 !== 0, k = g < 0;
        g === 0 ? f = f.add(r(x, o[v])) : u = u.add(r(k, o[_]));
      }
      return { p: u, f };
    },
    wNAFCached(i, o, s, a) {
      const c = i._WINDOW_SIZE || 1;
      let u = o.get(i);
      return u || (u = this.precomputeWindow(i, c), c !== 1 && o.set(i, a(u))), this.wNAF(c, u, s);
    }
  };
}
function cm(e) {
  return sm(e.Fp), is(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...Dd(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Lx(e) {
  const t = cm(e);
  is(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: i } = t;
  if (r) {
    if (!n.eql(i, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: zx, hexToBytes: jx } = Cx, Vi = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(e) {
    const { Err: t } = Vi;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const r = e[1], n = e.subarray(2, r + 2);
    if (!r || n.length !== r)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] === 0 && n[1] <= 127)
      throw new t("Invalid signature integer: trailing length");
    return { d: zx(n), l: e.subarray(r + 2) };
  },
  toSig(e) {
    const { Err: t } = Vi, r = typeof e == "string" ? jx(e) : e;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = r.length;
    if (n < 2 || r[0] != 48)
      throw new t("Invalid signature tag");
    if (r[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: i, l: o } = Vi._parseInt(r.subarray(2)), { d: s, l: a } = Vi._parseInt(o);
    if (a.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: i, s };
  },
  hexFromSig(e) {
    const t = (u) => Number.parseInt(u[0], 16) >= 8 ? "00" + u : u, r = (u) => {
      const f = u.toString(16);
      return f.length & 1 ? `0${f}` : f;
    }, n = t(r(e.s)), i = t(r(e.r)), o = n.length / 2, s = i.length / 2, a = r(o), c = r(s);
    return `30${r(s + o + 4)}02${c}${i}02${a}${n}`;
  }
}, Hr = BigInt(0), Ct = BigInt(1), xn = BigInt(2), Sc = BigInt(3), Q0 = BigInt(4);
function Dx(e) {
  const t = Lx(e), { Fp: r } = t, n = t.toBytes || ((y, b, g) => {
    const v = b.toAffine();
    return pr(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));
  }), i = t.fromBytes || ((y) => {
    const b = y.subarray(1), g = r.fromBytes(b.subarray(0, r.BYTES)), v = r.fromBytes(b.subarray(r.BYTES, 2 * r.BYTES));
    return { x: g, y: v };
  });
  function o(y) {
    const { a: b, b: g } = t, v = r.sqr(y), _ = r.mul(v, y);
    return r.add(r.add(_, r.mul(y, b)), g);
  }
  function s(y) {
    return typeof y == "bigint" && Hr < y && y < t.n;
  }
  function a(y) {
    if (!s(y))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(y) {
    const { allowedPrivateKeyLengths: b, nByteLength: g, wrapPrivateKey: v, n: _ } = t;
    if (b && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = Mo(y)), typeof y != "string" || !b.includes(y.length))
        throw new Error("Invalid key");
      y = y.padStart(g * 2, "0");
    }
    let x;
    try {
      x = typeof y == "bigint" ? y : Yt(Dt("private key", y, g));
    } catch {
      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof y}`);
    }
    return v && (x = It(x, _)), a(x), x;
  }
  const u = /* @__PURE__ */ new Map();
  function f(y) {
    if (!(y instanceof l))
      throw new Error("ProjectivePoint expected");
  }
  class l {
    constructor(b, g, v) {
      if (this.px = b, this.py = g, this.pz = v, b == null || !r.isValid(b))
        throw new Error("x required");
      if (g == null || !r.isValid(g))
        throw new Error("y required");
      if (v == null || !r.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(b) {
      const { x: g, y: v } = b || {};
      if (!b || !r.isValid(g) || !r.isValid(v))
        throw new Error("invalid affine point");
      if (b instanceof l)
        throw new Error("projective point not allowed");
      const _ = (x) => r.eql(x, r.ZERO);
      return _(g) && _(v) ? l.ZERO : new l(g, v, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(b) {
      const g = r.invertBatch(b.map((v) => v.pz));
      return b.map((v, _) => v.toAffine(g[_])).map(l.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(b) {
      const g = l.fromAffine(i(Dt("pointHex", b)));
      return g.assertValidity(), g;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(b) {
      return l.BASE.multiply(c(b));
    }
    // "Private method", don't use it directly
    _setWindowSize(b) {
      this._WINDOW_SIZE = b, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: b, y: g } = this.toAffine();
      if (!r.isValid(b) || !r.isValid(g))
        throw new Error("bad point: x or y not FE");
      const v = r.sqr(g), _ = o(b);
      if (!r.eql(v, _))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(b) {
      f(b);
      const { px: g, py: v, pz: _ } = this, { px: x, py: k, pz: P } = b, I = r.eql(r.mul(g, P), r.mul(x, _)), R = r.eql(r.mul(v, P), r.mul(k, _));
      return I && R;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new l(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: g } = t, v = r.mul(g, Sc), { px: _, py: x, pz: k } = this;
      let P = r.ZERO, I = r.ZERO, R = r.ZERO, j = r.mul(_, _), W = r.mul(x, x), re = r.mul(k, k), X = r.mul(_, x);
      return X = r.add(X, X), R = r.mul(_, k), R = r.add(R, R), P = r.mul(b, R), I = r.mul(v, re), I = r.add(P, I), P = r.sub(W, I), I = r.add(W, I), I = r.mul(P, I), P = r.mul(X, P), R = r.mul(v, R), re = r.mul(b, re), X = r.sub(j, re), X = r.mul(b, X), X = r.add(X, R), R = r.add(j, j), j = r.add(R, j), j = r.add(j, re), j = r.mul(j, X), I = r.add(I, j), re = r.mul(x, k), re = r.add(re, re), j = r.mul(re, X), P = r.sub(P, j), R = r.mul(re, W), R = r.add(R, R), R = r.add(R, R), new l(P, I, R);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      f(b);
      const { px: g, py: v, pz: _ } = this, { px: x, py: k, pz: P } = b;
      let I = r.ZERO, R = r.ZERO, j = r.ZERO;
      const W = t.a, re = r.mul(t.b, Sc);
      let X = r.mul(g, x), N = r.mul(v, k), G = r.mul(_, P), M = r.add(g, v), $ = r.add(x, k);
      M = r.mul(M, $), $ = r.add(X, N), M = r.sub(M, $), $ = r.add(g, _);
      let H = r.add(x, P);
      return $ = r.mul($, H), H = r.add(X, G), $ = r.sub($, H), H = r.add(v, _), I = r.add(k, P), H = r.mul(H, I), I = r.add(N, G), H = r.sub(H, I), j = r.mul(W, $), I = r.mul(re, G), j = r.add(I, j), I = r.sub(N, j), j = r.add(N, j), R = r.mul(I, j), N = r.add(X, X), N = r.add(N, X), G = r.mul(W, G), $ = r.mul(re, $), N = r.add(N, G), G = r.sub(X, G), G = r.mul(W, G), $ = r.add($, G), X = r.mul(N, $), R = r.add(R, X), X = r.mul(H, $), I = r.mul(M, I), I = r.sub(I, X), X = r.mul(M, N), j = r.mul(H, j), j = r.add(j, X), new l(I, R, j);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(l.ZERO);
    }
    wNAF(b) {
      return m.wNAFCached(this, u, b, (g) => {
        const v = r.invertBatch(g.map((_) => _.pz));
        return g.map((_, x) => _.toAffine(v[x])).map(l.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      const g = l.ZERO;
      if (b === Hr)
        return g;
      if (a(b), b === Ct)
        return this;
      const { endo: v } = t;
      if (!v)
        return m.unsafeLadder(this, b);
      let { k1neg: _, k1: x, k2neg: k, k2: P } = v.splitScalar(b), I = g, R = g, j = this;
      for (; x > Hr || P > Hr; )
        x & Ct && (I = I.add(j)), P & Ct && (R = R.add(j)), j = j.double(), x >>= Ct, P >>= Ct;
      return _ && (I = I.negate()), k && (R = R.negate()), R = new l(r.mul(R.px, v.beta), R.py, R.pz), I.add(R);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      a(b);
      let g = b, v, _;
      const { endo: x } = t;
      if (x) {
        const { k1neg: k, k1: P, k2neg: I, k2: R } = x.splitScalar(g);
        let { p: j, f: W } = this.wNAF(P), { p: re, f: X } = this.wNAF(R);
        j = m.constTimeNegate(k, j), re = m.constTimeNegate(I, re), re = new l(r.mul(re.px, x.beta), re.py, re.pz), v = j.add(re), _ = W.add(X);
      } else {
        const { p: k, f: P } = this.wNAF(g);
        v = k, _ = P;
      }
      return l.normalizeZ([v, _])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(b, g, v) {
      const _ = l.BASE, x = (P, I) => I === Hr || I === Ct || !P.equals(_) ? P.multiplyUnsafe(I) : P.multiply(I), k = x(this, g).add(x(b, v));
      return k.is0() ? void 0 : k;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(b) {
      const { px: g, py: v, pz: _ } = this, x = this.is0();
      b == null && (b = x ? r.ONE : r.inv(_));
      const k = r.mul(g, b), P = r.mul(v, b), I = r.mul(_, b);
      if (x)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(I, r.ONE))
        throw new Error("invZ was invalid");
      return { x: k, y: P };
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: g } = t;
      if (b === Ct)
        return !0;
      if (g)
        return g(l, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: b, clearCofactor: g } = t;
      return b === Ct ? this : g ? g(l, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(b = !0) {
      return this.assertValidity(), n(l, this, b);
    }
    toHex(b = !0) {
      return Mo(this.toRawBytes(b));
    }
  }
  l.BASE = new l(t.Gx, t.Gy, r.ONE), l.ZERO = new l(r.ZERO, r.ONE, r.ZERO);
  const h = t.nBitLength, m = Rx(l, t.endo ? Math.ceil(h / 2) : h);
  return {
    CURVE: t,
    ProjectivePoint: l,
    normPrivateKeyToScalar: c,
    weierstrassEquation: o,
    isWithinCurveOrder: s
  };
}
function Mx(e) {
  const t = cm(e);
  return is(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function Kx(e) {
  const t = Mx(e), { Fp: r, n } = t, i = r.BYTES + 1, o = 2 * r.BYTES + 1;
  function s($) {
    return Hr < $ && $ < r.ORDER;
  }
  function a($) {
    return It($, n);
  }
  function c($) {
    return Tf($, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: f, weierstrassEquation: l, isWithinCurveOrder: h } = Dx({
    ...t,
    toBytes($, H, q) {
      const ne = H.toAffine(), ie = r.toBytes(ne.x), pe = pr;
      return q ? pe(Uint8Array.from([H.hasEvenY() ? 2 : 3]), ie) : pe(Uint8Array.from([4]), ie, r.toBytes(ne.y));
    },
    fromBytes($) {
      const H = $.length, q = $[0], ne = $.subarray(1);
      if (H === i && (q === 2 || q === 3)) {
        const ie = Yt(ne);
        if (!s(ie))
          throw new Error("Point is not on curve");
        const pe = l(ie);
        let se = r.sqrt(pe);
        const ke = (se & Ct) === Ct;
        return (q & 1) === 1 !== ke && (se = r.neg(se)), { x: ie, y: se };
      } else if (H === o && q === 4) {
        const ie = r.fromBytes(ne.subarray(0, r.BYTES)), pe = r.fromBytes(ne.subarray(r.BYTES, 2 * r.BYTES));
        return { x: ie, y: pe };
      } else
        throw new Error(`Point of length ${H} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`);
    }
  }), m = ($) => Mo(Ei($, t.nByteLength));
  function y($) {
    const H = n >> Ct;
    return $ > H;
  }
  function b($) {
    return y($) ? a(-$) : $;
  }
  const g = ($, H, q) => Yt($.slice(H, q));
  class v {
    constructor(H, q, ne) {
      this.r = H, this.s = q, this.recovery = ne, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(H) {
      const q = t.nByteLength;
      return H = Dt("compactSignature", H, q * 2), new v(g(H, 0, q), g(H, q, 2 * q));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(H) {
      const { r: q, s: ne } = Vi.toSig(Dt("DER", H));
      return new v(q, ne);
    }
    assertValidity() {
      if (!h(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!h(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(H) {
      return new v(this.r, this.s, H);
    }
    recoverPublicKey(H) {
      const { r: q, s: ne, recovery: ie } = this, pe = R(Dt("msgHash", H));
      if (ie == null || ![0, 1, 2, 3].includes(ie))
        throw new Error("recovery id invalid");
      const se = ie === 2 || ie === 3 ? q + t.n : q;
      if (se >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const ke = ie & 1 ? "03" : "02", V = u.fromHex(ke + m(se)), He = c(se), Rt = a(-pe * He), et = a(ne * He), Lt = u.BASE.multiplyAndAddUnsafe(V, Rt, et);
      if (!Lt)
        throw new Error("point at infinify");
      return Lt.assertValidity(), Lt;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Ko(this.toDERHex());
    }
    toDERHex() {
      return Vi.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Ko(this.toCompactHex());
    }
    toCompactHex() {
      return m(this.r) + m(this.s);
    }
  }
  const _ = {
    isValidPrivateKey($) {
      try {
        return f($), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: f,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const $ = t.randomBytes(r.BYTES + 8), H = Fx($, n);
      return Ei(H, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute($ = 8, H = u.BASE) {
      return H._setWindowSize($), H.multiply(BigInt(3)), H;
    }
  };
  function x($, H = !0) {
    return u.fromPrivateKey($).toRawBytes(H);
  }
  function k($) {
    const H = $ instanceof Uint8Array, q = typeof $ == "string", ne = (H || q) && $.length;
    return H ? ne === i || ne === o : q ? ne === 2 * i || ne === 2 * o : $ instanceof u;
  }
  function P($, H, q = !0) {
    if (k($))
      throw new Error("first arg must be private key");
    if (!k(H))
      throw new Error("second arg must be public key");
    return u.fromHex(H).multiply(f($)).toRawBytes(q);
  }
  const I = t.bits2int || function($) {
    const H = Yt($), q = $.length * 8 - t.nBitLength;
    return q > 0 ? H >> BigInt(q) : H;
  }, R = t.bits2int_modN || function($) {
    return a(I($));
  }, j = jd(t.nBitLength);
  function W($) {
    if (typeof $ != "bigint")
      throw new Error("bigint expected");
    if (!(Hr <= $ && $ < j))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Ei($, t.nByteLength);
  }
  function re($, H, q = X) {
    if (["recovered", "canonical"].some((ht) => ht in q))
      throw new Error("sign() legacy options not supported");
    const { hash: ne, randomBytes: ie } = t;
    let { lowS: pe, prehash: se, extraEntropy: ke } = q;
    pe == null && (pe = !0), $ = Dt("msgHash", $), se && ($ = Dt("prehashed msgHash", ne($)));
    const V = R($), He = f(H), Rt = [W(He), W(V)];
    if (ke != null) {
      const ht = ke === !0 ? ie(r.BYTES) : ke;
      Rt.push(Dt("extraEntropy", ht, r.BYTES));
    }
    const et = pr(...Rt), Lt = V;
    function yt(ht) {
      const St = I(ht);
      if (!h(St))
        return;
      const zt = c(St), tt = u.BASE.multiply(St).toAffine(), je = a(tt.x);
      if (je === Hr)
        return;
      const wt = a(zt * a(Lt + je * He));
      if (wt === Hr)
        return;
      let Yr = (tt.x === je ? 0 : 2) | Number(tt.y & Ct), xr = wt;
      return pe && y(wt) && (xr = b(wt), Yr ^= 1), new v(je, xr, Yr);
    }
    return { seed: et, k2sig: yt };
  }
  const X = { lowS: t.lowS, prehash: !1 }, N = { lowS: t.lowS, prehash: !1 };
  function G($, H, q = X) {
    const { seed: ne, k2sig: ie } = re($, H, q);
    return om(t.hash.outputLen, t.nByteLength, t.hmac)(ne, ie);
  }
  u.BASE._setWindowSize(8);
  function M($, H, q, ne = N) {
    var tt;
    const ie = $;
    if (H = Dt("msgHash", H), q = Dt("publicKey", q), "strict" in ne)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: pe, prehash: se } = ne;
    let ke, V;
    try {
      if (typeof ie == "string" || ie instanceof Uint8Array)
        try {
          ke = v.fromDER(ie);
        } catch (je) {
          if (!(je instanceof Vi.Err))
            throw je;
          ke = v.fromCompact(ie);
        }
      else if (typeof ie == "object" && typeof ie.r == "bigint" && typeof ie.s == "bigint") {
        const { r: je, s: wt } = ie;
        ke = new v(je, wt);
      } else
        throw new Error("PARSE");
      V = u.fromHex(q);
    } catch (je) {
      if (je.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (pe && ke.hasHighS())
      return !1;
    se && (H = t.hash(H));
    const { r: He, s: Rt } = ke, et = R(H), Lt = c(Rt), yt = a(et * Lt), ht = a(He * Lt), St = (tt = u.BASE.multiplyAndAddUnsafe(V, yt, ht)) == null ? void 0 : tt.toAffine();
    return St ? a(St.x) === He : !1;
  }
  return {
    CURVE: t,
    getPublicKey: x,
    getSharedSecret: P,
    sign: G,
    verify: M,
    ProjectivePoint: u,
    Signature: v,
    utils: _
  };
}
function qx(e, t) {
  const r = e.ORDER;
  let n = Hr;
  for (let h = r - Ct; h % xn === Hr; h /= xn)
    n += Ct;
  const i = n, o = (r - Ct) / xn ** i, s = (o - Ct) / xn, a = xn ** i - Ct, c = xn ** (i - Ct), u = e.pow(t, o), f = e.pow(t, (o + Ct) / xn);
  let l = (h, m) => {
    let y = u, b = e.pow(m, a), g = e.sqr(b);
    g = e.mul(g, m);
    let v = e.mul(h, g);
    v = e.pow(v, s), v = e.mul(v, b), b = e.mul(v, m), g = e.mul(v, h);
    let _ = e.mul(g, b);
    v = e.pow(_, c);
    let x = e.eql(v, e.ONE);
    b = e.mul(g, f), v = e.mul(_, y), g = e.cmov(b, g, x), _ = e.cmov(v, _, x);
    for (let k = i; k > 1; k--) {
      let P = xn ** (k - xn), I = e.pow(_, P);
      const R = e.eql(I, e.ONE);
      b = e.mul(g, y), y = e.mul(y, y), I = e.mul(_, y), g = e.cmov(b, g, R), _ = e.cmov(I, _, R);
    }
    return { isValid: x, value: g };
  };
  if (e.ORDER % Q0 === Sc) {
    const h = (e.ORDER - Sc) / Q0, m = e.sqrt(e.neg(t));
    l = (y, b) => {
      let g = e.sqr(b);
      const v = e.mul(y, b);
      g = e.mul(g, v);
      let _ = e.pow(g, h);
      _ = e.mul(_, v);
      const x = e.mul(_, m), k = e.mul(e.sqr(_), b), P = e.eql(k, y);
      let I = e.cmov(x, _, P);
      return { isValid: P, value: I };
    };
  }
  return l;
}
function Vx(e, t) {
  if (sm(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const r = qx(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (n) => {
    let i, o, s, a, c, u, f, l;
    i = e.sqr(n), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), s = e.add(o, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), a = e.mul(a, t.A), o = e.sqr(s), u = e.sqr(a), c = e.mul(u, t.A), o = e.add(o, c), o = e.mul(o, s), u = e.mul(u, a), c = e.mul(u, t.B), o = e.add(o, c), f = e.mul(i, s);
    const { isValid: h, value: m } = r(o, u);
    l = e.mul(i, n), l = e.mul(l, m), f = e.cmov(f, s, h), l = e.cmov(l, m, h);
    const y = e.isOdd(n) === e.isOdd(l);
    return l = e.cmov(e.neg(l), l, y), f = e.div(f, a), { x: f, y: l };
  };
}
function Wx(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return hu(e);
  throw new Error("DST must be Uint8Array or string");
}
const Gx = Yt;
function pi(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let n = t - 1; n >= 0; n--)
    r[n] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function Zx(e, t) {
  const r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e[n] ^ t[n];
  return r;
}
function Hs(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function Md(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function Xx(e, t, r, n) {
  Hs(e), Hs(t), Md(r), t.length > 255 && (t = n(pr(hu("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: i, blockLen: o } = n, s = Math.ceil(r / i);
  if (s > 255)
    throw new Error("Invalid xmd length");
  const a = pr(t, pi(t.length, 1)), c = pi(0, o), u = pi(r, 2), f = new Array(s), l = n(pr(c, e, u, pi(0, 1), a));
  f[0] = n(pr(l, pi(1, 1), a));
  for (let m = 1; m <= s; m++) {
    const y = [Zx(l, f[m - 1]), pi(m + 1, 1), a];
    f[m] = n(pr(...y));
  }
  return pr(...f).slice(0, r);
}
function Yx(e, t, r, n, i) {
  if (Hs(e), Hs(t), Md(r), t.length > 255) {
    const o = Math.ceil(2 * n / 8);
    t = i.create({ dkLen: o }).update(hu("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return i.create({ dkLen: r }).update(e).update(pi(r, 2)).update(t).update(pi(t.length, 1)).digest();
}
function e1(e, t, r) {
  is(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: n, k: i, m: o, hash: s, expand: a, DST: c } = r;
  Hs(e), Md(t);
  const u = Wx(c), f = n.toString(2).length, l = Math.ceil((f + i) / 8), h = t * o * l;
  let m;
  if (a === "xmd")
    m = Xx(e, u, h, s);
  else if (a === "xof")
    m = Yx(e, u, h, i, s);
  else if (a === void 0)
    m = e;
  else
    throw new Error('expand must be "xmd", "xof" or undefined');
  const y = new Array(t);
  for (let b = 0; b < t; b++) {
    const g = new Array(o);
    for (let v = 0; v < o; v++) {
      const _ = l * (v + b * o), x = m.subarray(_, _ + l);
      g[v] = It(Gx(x), n);
    }
    y[b] = g;
  }
  return y;
}
function Jx(e, t) {
  const r = t.map((n) => Array.from(n).reverse());
  return (n, i) => {
    const [o, s, a, c] = r.map((u) => u.reduce((f, l) => e.add(e.mul(f, n), l)));
    return n = e.div(o, s), i = e.mul(i, e.div(a, c)), { x: n, y: i };
  };
}
function Qx(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(n, i) {
      const o = e1(n, 2, { ...r, DST: r.DST, ...i }), s = e.fromAffine(t(o[0])), a = e.fromAffine(t(o[1])), c = s.add(a).clearCofactor();
      return c.assertValidity(), c;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(n, i) {
      const o = e1(n, 1, { ...r, DST: r.encodeDST, ...i }), s = e.fromAffine(t(o[0])).clearCofactor();
      return s.assertValidity(), s;
    }
  };
}
let um = class extends Qg {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, qi.hash(t);
    const n = Hd(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, o = new Uint8Array(i);
    o.set(n.length > i ? t.create().update(n).digest() : n);
    for (let s = 0; s < o.length; s++)
      o[s] ^= 54;
    this.iHash.update(o), this.oHash = t.create();
    for (let s = 0; s < o.length; s++)
      o[s] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return qi.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    qi.exists(this), qi.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const lm = (e, t, r) => new um(e, t).update(r).digest();
lm.create = (e, t) => new um(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function e9(e) {
  return {
    hash: e,
    hmac: (t, ...r) => lm(e, t, dx(...r)),
    randomBytes: tm
  };
}
function t9(e, t) {
  const r = (n) => Kx({ ...e, ...e9(n) });
  return Object.freeze({ ...r(t), create: r });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const pu = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), _c = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), fm = BigInt(1), kc = BigInt(2), t1 = (e, t) => (e + t / kc) / t;
function dm(e) {
  const t = pu, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, f = u * u * e % t, l = _r(f, r, t) * f % t, h = _r(l, r, t) * f % t, m = _r(h, kc, t) * u % t, y = _r(m, i, t) * m % t, b = _r(y, o, t) * y % t, g = _r(b, a, t) * b % t, v = _r(g, c, t) * g % t, _ = _r(v, a, t) * b % t, x = _r(_, r, t) * f % t, k = _r(x, s, t) * y % t, P = _r(k, n, t) * u % t, I = _r(P, kc, t);
  if (!_i.eql(_i.sqr(I), e))
    throw new Error("Cannot find square root");
  return I;
}
const _i = am(pu, void 0, void 0, { sqrt: dm }), fn = t9({
  a: BigInt(0),
  b: BigInt(7),
  Fp: _i,
  n: _c,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: !0,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = _c, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -fm * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, s = BigInt("0x100000000000000000000000000000000"), a = t1(o * e, t), c = t1(-n * e, t);
      let u = It(e - a * r - c * i, t), f = It(-a * n - c * o, t);
      const l = u > s, h = f > s;
      if (l && (u = t - u), h && (f = t - f), u > s || f > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: l, k1: u, k2neg: h, k2: f };
    }
  }
}, Ac), gu = BigInt(0), hm = (e) => typeof e == "bigint" && gu < e && e < pu, r9 = (e) => typeof e == "bigint" && gu < e && e < _c, r1 = {};
function Tc(e, ...t) {
  let r = r1[e];
  if (r === void 0) {
    const n = Ac(Uint8Array.from(e, (i) => i.charCodeAt(0)));
    r = pr(n, n), r1[e] = r;
  }
  return Ac(pr(r, ...t));
}
const Kd = (e) => e.toRawBytes(!0).slice(1), Cf = (e) => Ei(e, 32), $l = (e) => It(e, pu), Rs = (e) => It(e, _c), qd = fn.ProjectivePoint, n9 = (e, t, r) => qd.BASE.multiplyAndAddUnsafe(e, t, r);
function Pf(e) {
  let t = fn.utils.normPrivateKeyToScalar(e), r = qd.fromPrivateKey(t);
  return { scalar: r.hasEvenY() ? t : Rs(-t), bytes: Kd(r) };
}
function pm(e) {
  if (!hm(e))
    throw new Error("bad x: need 0 < x < p");
  const t = $l(e * e), r = $l(t * e + BigInt(7));
  let n = dm(r);
  n % kc !== gu && (n = $l(-n));
  const i = new qd(e, n, fm);
  return i.assertValidity(), i;
}
function gm(...e) {
  return Rs(Yt(Tc("BIP0340/challenge", ...e)));
}
function i9(e) {
  return Pf(e).bytes;
}
function o9(e, t, r = tm(32)) {
  const n = Dt("message", e), { bytes: i, scalar: o } = Pf(t), s = Dt("auxRand", r, 32), a = Cf(o ^ Yt(Tc("BIP0340/aux", s))), c = Tc("BIP0340/nonce", a, i, n), u = Rs(Yt(c));
  if (u === gu)
    throw new Error("sign failed: k is zero");
  const { bytes: f, scalar: l } = Pf(u), h = gm(f, i, n), m = new Uint8Array(64);
  if (m.set(f, 0), m.set(Cf(Rs(l + h * o)), 32), !mm(m, n, i))
    throw new Error("sign: Invalid signature produced");
  return m;
}
function mm(e, t, r) {
  const n = Dt("signature", e, 64), i = Dt("message", t), o = Dt("publicKey", r, 32);
  try {
    const s = pm(Yt(o)), a = Yt(n.subarray(0, 32));
    if (!hm(a))
      return !1;
    const c = Yt(n.subarray(32, 64));
    if (!r9(c))
      return !1;
    const u = gm(Cf(a), Kd(s), i), f = n9(s, c, Rs(-u));
    return !(!f || !f.hasEvenY() || f.toAffine().x !== a);
  } catch {
    return !1;
  }
}
const s9 = {
  getPublicKey: i9,
  sign: o9,
  verify: mm,
  utils: {
    randomPrivateKey: fn.utils.randomPrivateKey,
    lift_x: pm,
    pointToBytes: Kd,
    numberToBytesBE: Ei,
    bytesToNumberBE: Yt,
    taggedHash: Tc,
    mod: It
  }
}, a9 = Jx(_i, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((e) => e.map((t) => BigInt(t)))), c9 = Vx(_i, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: _i.create(BigInt("-11"))
});
Qx(fn.ProjectivePoint, (e) => {
  const { x: t, y: r } = c9(_i.create(e[0]));
  return a9(t, r);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: _i.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: Ac
});
function If(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function u9(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function bm(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function l9(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  If(e.outputLen), If(e.blockLen);
}
function f9(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function d9(e, t) {
  bm(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const h9 = {
  number: If,
  bool: u9,
  bytes: bm,
  hash: l9,
  exists: f9,
  output: d9
};
var Nl = h9;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ul = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), rn = (e, t) => e << 32 - t | e >>> t, p9 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!p9)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function g9(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function ym(e) {
  if (typeof e == "string" && (e = g9(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
let m9 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wm(e) {
  const t = (n) => e().update(ym(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function b9(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
let y9 = class extends m9 {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Ul(this.buffer);
  }
  update(t) {
    Nl.exists(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = ym(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const c = Ul(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Nl.exists(this), Nl.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let l = s; l < i; l++)
      r[l] = 0;
    b9(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const a = Ul(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++)
      a.setUint32(4 * l, f[l], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
  }
};
const w9 = (e, t, r) => e & t ^ ~e & r, v9 = (e, t, r) => e & t ^ e & r ^ t & r, x9 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ti = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ri = new Uint32Array(64);
let vm = class extends y9 {
  constructor() {
    super(64, 32, 8, !1), this.A = ti[0] | 0, this.B = ti[1] | 0, this.C = ti[2] | 0, this.D = ti[3] | 0, this.E = ti[4] | 0, this.F = ti[5] | 0, this.G = ti[6] | 0, this.H = ti[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: c } = this;
    return [t, r, n, i, o, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      ri[l] = t.getUint32(r, !1);
    for (let l = 16; l < 64; l++) {
      const h = ri[l - 15], m = ri[l - 2], y = rn(h, 7) ^ rn(h, 18) ^ h >>> 3, b = rn(m, 17) ^ rn(m, 19) ^ m >>> 10;
      ri[l] = b + ri[l - 7] + y + ri[l - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: a, F: c, G: u, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const h = rn(a, 6) ^ rn(a, 11) ^ rn(a, 25), m = f + h + w9(a, c, u) + x9[l] + ri[l] | 0, b = (rn(n, 2) ^ rn(n, 13) ^ rn(n, 22)) + v9(n, i, o) | 0;
      f = u, u = c, c = a, a = s + m | 0, s = o, o = i, i = n, n = m + b | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, s, a, c, u, f);
  }
  roundClean() {
    ri.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, E9 = class extends vm {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Bf = wm(() => new vm());
wm(() => new E9());
function A9(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function S9(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function _9(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
const { getRandomValues: k9 } = crypto ?? globalThis.crypto ?? window.crypto;
function T9(e = 32) {
  if (typeof k9 == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function C9(e, t, r = "be") {
  t === void 0 && (t = e.length), A9(e, t);
  const n = new Uint8Array(t).fill(0), i = r === "be" ? 0 : t - e.length;
  return n.set(e, i), n;
}
function xm(e) {
  let t, r = 0;
  const n = e.reduce((o, s) => o + s.length, 0), i = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const o = e[t];
    i.set(o, r), r += o.length;
  }
  return i;
}
const P9 = new TextEncoder(), I9 = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function Em(e) {
  for (const t of I9)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function B9(e, t, r = !1) {
  typeof e == "string" && (e = P9.encode(e));
  const n = Em(t), i = n.length, o = [];
  let s = "", a, c = 0, u, f;
  for (a = 0; a < e.length; a++)
    for (c = 0, u = e[a], s += u > 0 || (s.length ^ a) > 0 ? "" : "1"; c in o || u > 0; )
      f = o[c], f = f > 0 ? f * 256 + u : u, u = f / i | 0, o[c] = f % i, c++;
  for (; c-- > 0; )
    s += n[o[c]];
  return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function O9(e, t) {
  const r = Em(t), n = r.length, i = [], o = [];
  e = e.replace("=", "");
  let s, a = 0, c, u;
  for (s = 0; s < e.length; s++) {
    if (a = 0, c = r.indexOf(e[s]), c < 0)
      throw new Error(`Character range out of bounds: ${c}`);
    for (c > 0 || (o.length ^ s) > 0 || o.push(0); a in i || c > 0; )
      u = i[a], u = u > 0 ? u * n + c : c, c = u >> 8, i[a] = u % 256, a++;
  }
  for (; a-- > 0; )
    o.push(i[a]);
  return new Uint8Array(o);
}
function Am(e) {
  return Bf(Bf(e));
}
function $9(e) {
  const t = Am(e);
  return xm([e, t.slice(0, 4)]);
}
function N9(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (Am(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
const n1 = {
  encode: B9,
  decode: O9
}, Sm = {
  encode: (e) => {
    const t = $9(e);
    return n1.encode(t, "base58");
  },
  decode: (e) => {
    const t = n1.decode(e, "base58");
    return N9(t);
  }
}, _m = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", U9 = [996825010, 642813549, 513874426, 1027748829, 705979059], Cc = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function km(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let i = 0; i < 5; ++i)
      n >> i & 1 && (t ^= U9[i]);
  }
  return t;
}
function Tm(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function F9(e, t, r) {
  const n = Tm(e).concat(t);
  return km(n) === r.const;
}
function H9(e, t, r) {
  const n = Tm(e).concat(t).concat([0, 0, 0, 0, 0, 0]), i = km(n) ^ r.const, o = [];
  for (let s = 0; s < 6; ++s)
    o.push(i >> 5 * (5 - s) & 31);
  return o;
}
function Cm(e, t, r, n = !0) {
  const i = [];
  let o = 0, s = 0;
  const a = (1 << r) - 1, c = (1 << t + r - 1) - 1;
  for (const u of e) {
    if (u < 0 || u >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(u));
    for (o = (o << t | u) & c, s += t; s >= r; )
      s -= r, i.push(o >> s & a);
  }
  if (n)
    s > 0 && i.push(o << r - s & a);
  else if (s >= t || (o << r - s & a) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return i;
}
function R9(e, t, r) {
  const n = t.concat(H9(e, t, r));
  let i = e + "1";
  for (let o = 0; o < n.length; ++o)
    i += _m.charAt(n[o]);
  return i;
}
function Pm(e) {
  if (!L9(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !z9(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let o = r + 1; o < e.length; ++o) {
    const s = _m.indexOf(e.charAt(o));
    if (s === -1)
      throw new Error("Character idx out of bounds: " + String(o));
    t.push(s);
  }
  const i = Cc.find((o) => o.version === t[0]) ?? Cc[0];
  if (!F9(n, t, i))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function L9(e) {
  let t, r, n = !1, i = !1;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return !1;
    r >= 97 && r <= 122 && (n = !0), r >= 65 && r <= 90 && (i = !0);
  }
  return !(n && i);
}
function z9(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function j9(e, t = "bc", r = 0) {
  const n = [r, ...Cm([...e], 8, 5)], i = Cc.find((s) => s.version === r) ?? Cc[0], o = R9(t, n, i);
  return Im(o), o;
}
function Im(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = Pm(e), i = Cm(n.slice(1), 5, 8, !1), o = i.length;
  switch (!0) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (i === null || o < 2 || o > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(i);
  }
}
function D9(e) {
  e = e.toLowerCase();
  const [t, r] = Pm(e);
  return r[0];
}
const Bm = {
  encode: j9,
  decode: Im,
  version: D9
}, Om = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", $m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", M9 = new TextEncoder();
function Nm(e, t = !1, r = !0) {
  typeof e == "string" && (e = M9.encode(e));
  const n = t ? $m : Om;
  let i = "", o = 0, s = 0;
  for (let a = 0; a < e.length; a++)
    for (s = s << 8 | e[a], o += 8; o >= 6; )
      o -= 6, i += n[s >> o & 63];
  if (o > 0)
    for (s <<= 6 - o, i += n[s & 63]; o < 6; )
      i += r ? "=" : "", o += 2;
  return i;
}
function Um(e, t = !1) {
  const r = t || e.includes("-") || e.includes("_") ? $m.split("") : Om.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let i = 0, o = 0;
  const s = [];
  for (let a = 0; a < n.length; a++) {
    const c = n[a], u = r.indexOf(c);
    if (u === -1)
      throw new Error("Invalid character: " + c);
    i += 6, o <<= 6, o |= u, i >= 8 && (i -= 8, s.push(o >>> i & 255));
  }
  return new Uint8Array(s);
}
const Fm = {
  encode: Nm,
  decode: Um
}, Hm = {
  encode: (e) => Nm(e, !0, !1),
  decode: (e) => Um(e, !0)
}, K9 = BigInt(0), q9 = BigInt(255), Rm = BigInt(256);
function V9(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function W9(e, t, r = "be") {
  t === void 0 && (t = V9(e));
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (; e > K9; ) {
    const a = e & q9, c = Number(a);
    n ? o.setUint8(s++, c) : o.setUint8(s--, c), e = (e - a) / Rm;
  }
  return new Uint8Array(i);
}
function G9(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * Rm + BigInt(e[r]);
  return BigInt(t);
}
function Z9(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, i = 0; n < t.length; n += 8, i++) {
    let o = 0;
    for (let s = 0; s < 8; s++)
      o |= t[n + s] << 7 - s;
    r[i] = o;
  }
  return r;
}
function X9(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let i = 7; i >= 0; i--, r++)
      t[r] = n >> i & 1;
  }
  return t.join("");
}
function Y9(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function J9(e, t, r = "be") {
  t === void 0 && (t = Y9(e));
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? o.setUint8(s++, e) : o.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(i);
}
function Q9(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], _9(t);
  return t;
}
const eE = new TextEncoder(), tE = new TextDecoder();
function Vd(e) {
  return eE.encode(e);
}
function Fl(e) {
  return tE.decode(e);
}
function rE(e, t) {
  S9(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function nE(e, t, r = "le") {
  t = rE(e, t);
  const n = r === "le", i = new ArrayBuffer(t), o = new DataView(i);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? o.setUint8(s++, u) : o.setUint8(s--, u);
  }
  return new Uint8Array(i);
}
function iE(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function oE(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return Vd(t);
}
function sE(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return C9(e, t, r);
  if (typeof e == "string")
    return nE(e, t, r);
  if (typeof e == "bigint")
    return W9(e, t, r);
  if (typeof e == "number")
    return J9(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
const Be = class Be extends Uint8Array {
  static random(t = 32) {
    const r = T9(t);
    return new Be(r, t);
  }
  constructor(t, r, n) {
    const i = sE(t, r, n);
    super(i);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new wE(this);
  }
  toNum(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return Q9(r);
  }
  toBin() {
    return X9(this);
  }
  toBig(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return G9(r);
  }
  toHash() {
    const t = Bf(this);
    return new Be(t);
  }
  toJson() {
    const t = Fl(this);
    return JSON.parse(t);
  }
  toBech32(t, r = 0) {
    return Bm.encode(this, t, r);
  }
  toStr() {
    return Fl(this);
  }
  toHex() {
    return iE(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return Sm.encode(this);
  }
  toBase64() {
    return Fm.encode(this);
  }
  toB64url() {
    return Hm.encode(this);
  }
  prepend(t) {
    return Be.join([Be.bytes(t), this]);
  }
  append(t) {
    return Be.join([this, Be.bytes(t)]);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new Be(n);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new Be(n);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new Be(t);
  }
  write(t, r) {
    const n = Be.bytes(t);
    this.set(n, r);
  }
  prefixSize(t) {
    const r = Be.varInt(this.length, t);
    return Be.join([r, this]);
  }
  static from(t) {
    return new Be(Uint8Array.from(t));
  }
  static of(...t) {
    return new Be(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((i) => Be.bytes(i)), n = xm(r);
    return new Be(n);
  }
  static varInt(t, r) {
    if (t < 253)
      return Be.num(t, 1);
    if (t < 65536)
      return Be.of(253, ...Be.num(t, 2, r));
    if (t < 4294967296)
      return Be.of(254, ...Be.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return Be.of(255, ...Be.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
};
Be.num = aE, Be.big = uE, Be.bin = cE, Be.raw = lE, Be.str = fE, Be.hex = dE, Be.bytes = hE, Be.json = pE, Be.base64 = gE, Be.b64url = mE, Be.bech32 = bE, Be.b58chk = yE, Be.encode = Vd, Be.decode = Fl;
let be = Be;
function aE(e, t, r) {
  return new be(e, t, r);
}
function cE(e, t, r) {
  return new be(Z9(e), t, r);
}
function uE(e, t, r) {
  return new be(e, t, r);
}
function lE(e, t, r) {
  return new be(e, t, r);
}
function fE(e, t, r) {
  return new be(Vd(e), t, r);
}
function dE(e, t, r) {
  return new be(e, t, r);
}
function hE(e, t, r) {
  return new be(e, t, r);
}
function pE(e) {
  return new be(oE(e));
}
function gE(e) {
  return new be(Fm.decode(e));
}
function mE(e) {
  return new be(Hm.decode(e));
}
function bE(e) {
  return new be(Bm.decode(e));
}
function yE(e) {
  return new be(Sm.decode(e));
}
class wE {
  constructor(t) {
    this.data = be.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new be(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (!0) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
}
const Pc = fn.CURVE, Wd = Pc.n, vE = Pc.p, xE = { x: Pc.Gx, y: Pc.Gy }, EE = BigInt(0), AE = BigInt(1), SE = BigInt(2), _E = BigInt(3), kE = BigInt(4), Of = { N: Wd, P: vE, G: xE, _0n: EE, _1n: AE, _2n: SE, _3n: _E, _4n: kE }, ys = am(Wd, 32, !0), Lm = (e) => It(e, Wd);
function Gd(e, t = !1) {
  if (t)
    throw new Error(e);
  return !1;
}
function zm(e) {
  return be.random(e);
}
function TE(e) {
  const t = be.bytes(e).big;
  return be.big(Lm(t), 32);
}
var CE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fail: Gd,
  mod_bytes: TE,
  random: zm
});
const { N: PE, P: Z$, _0n: IE } = Of;
function BE(e, t, r) {
  const n = be.bytes(e);
  return n.length !== t ? Gd(`Invalid byte size: ${n.hex} !== ${t}`, r) : !0;
}
function OE(e, t) {
  return typeof e == "bigint" && IE < e && e < PE || Gd("x value is not in the field!", t), !0;
}
const i1 = fn.ProjectivePoint, pt = class pt extends Uint8Array {
  static mod(t) {
    return new pt(t);
  }
  static is_valid(t, r) {
    const n = be.bytes(t, 32).big;
    return OE(n, r);
  }
  constructor(t) {
    let r = $E(t);
    r = Lm(r), pt.is_valid(r, !0), super(be.big(r, 32), 32);
  }
  get buff() {
    return new be(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(t) {
    return new pt(t).big > this.big;
  }
  lt(t) {
    return new pt(t).big < this.big;
  }
  eq(t) {
    return new pt(t).big === this.big;
  }
  ne(t) {
    return new pt(t).big !== this.big;
  }
  add(t) {
    const r = pt.mod(t), n = ys.add(this.big, r.big);
    return new pt(n);
  }
  sub(t) {
    const r = pt.mod(t), n = ys.sub(this.big, r.big);
    return new pt(n);
  }
  mul(t) {
    const r = pt.mod(t), n = ys.mul(this.big, r.big);
    return new pt(n);
  }
  pow(t) {
    const r = pt.mod(t), n = ys.pow(this.big, r.big);
    return new pt(n);
  }
  div(t) {
    const r = pt.mod(t), n = ys.div(this.big, r.big);
    return new pt(n);
  }
  negate() {
    return new pt(pt.N - this.big);
  }
  generate() {
    const r = fn.ProjectivePoint.BASE.multiply(this.big);
    return Un.import(r);
  }
};
pt.N = fn.CURVE.n;
let Mt = pt;
const nt = class nt {
  static from_x(t) {
    let r = NE(t);
    r.length === 32 && (r = r.prepend(2)), BE(r, 33);
    const n = i1.fromHex(r.hex);
    return n.assertValidity(), new nt(n.x, n.y);
  }
  static generate(t) {
    const r = Mt.mod(t), n = nt.base.multiply(r.big);
    return nt.import(n);
  }
  static import(t) {
    const r = t instanceof nt ? { x: t.x.big, y: t.y.big } : { x: t.x, y: t.y };
    return new nt(r.x, r.y);
  }
  constructor(t, r) {
    this._p = new i1(t, r, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return be.big(this.p.x, 32);
  }
  get y() {
    return be.big(this.p.y, 32);
  }
  get buff() {
    return be.raw(this.p.toRawBytes(!0));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  eq(t) {
    const r = t instanceof nt ? t : nt.from_x(t);
    return this.x.big === r.x.big && this.y.big === r.y.big;
  }
  add(t) {
    return t instanceof nt ? nt.import(this.p.add(t.p)) : nt.import(this.p.add(nt.generate(t).p));
  }
  sub(t) {
    return t instanceof nt ? nt.import(this.p.subtract(t.p)) : nt.import(this.p.subtract(nt.generate(t).p));
  }
  mul(t) {
    return t instanceof nt ? nt.import(this.p.multiply(t.x.big)) : nt.import(this.p.multiply(Mt.mod(t).big));
  }
  negate() {
    return nt.import(this.p.negate());
  }
};
nt.P = Of.P, nt.G = Of.G, nt.base = fn.ProjectivePoint.BASE;
let Un = nt;
function $E(e) {
  if (e instanceof Mt)
    return e.big;
  if (e instanceof Un)
    return e.x.big;
  if (e instanceof Uint8Array)
    return be.raw(e).big;
  if (typeof e == "string")
    return be.hex(e).big;
  if (typeof e == "number")
    return be.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function NE(e) {
  if (e instanceof Mt)
    return e.point.buff;
  if (e instanceof Un)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return be.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return be.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
function $f(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function UE(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function jm(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function FE(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  $f(e.outputLen), $f(e.blockLen);
}
function HE(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function RE(e, t) {
  jm(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const LE = {
  number: $f,
  bool: UE,
  bytes: jm,
  hash: FE,
  exists: HE,
  output: RE
};
var Wi = LE;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const zE = (e) => e instanceof Uint8Array, Hl = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), nn = (e, t) => e << 32 - t | e >>> t, jE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!jE)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function DE(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Zd(e) {
  if (typeof e == "string" && (e = DE(e)), !zE(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
class Dm {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function ho(e) {
  const t = (n) => e().update(Zd(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function ME(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
class Xd extends Dm {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Hl(this.buffer);
  }
  update(t) {
    Wi.exists(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = Zd(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const c = Hl(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Wi.exists(this), Wi.output(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let l = s; l < i; l++)
      r[l] = 0;
    ME(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const a = Hl(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++)
      a.setUint32(4 * l, f[l], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
  }
}
const KE = (e, t, r) => e & t ^ ~e & r, qE = (e, t, r) => e & t ^ e & r ^ t & r, VE = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ni = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ii = new Uint32Array(64);
let Mm = class extends Xd {
  constructor() {
    super(64, 32, 8, !1), this.A = ni[0] | 0, this.B = ni[1] | 0, this.C = ni[2] | 0, this.D = ni[3] | 0, this.E = ni[4] | 0, this.F = ni[5] | 0, this.G = ni[6] | 0, this.H = ni[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: c } = this;
    return [t, r, n, i, o, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      ii[l] = t.getUint32(r, !1);
    for (let l = 16; l < 64; l++) {
      const h = ii[l - 15], m = ii[l - 2], y = nn(h, 7) ^ nn(h, 18) ^ h >>> 3, b = nn(m, 17) ^ nn(m, 19) ^ m >>> 10;
      ii[l] = b + ii[l - 7] + y + ii[l - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: a, F: c, G: u, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const h = nn(a, 6) ^ nn(a, 11) ^ nn(a, 25), m = f + h + KE(a, c, u) + VE[l] + ii[l] | 0, b = (nn(n, 2) ^ nn(n, 13) ^ nn(n, 22)) + qE(n, i, o) | 0;
      f = u, u = c, c = a, a = s + m | 0, s = o, o = i, i = n, n = m + b | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, s, a, c, u, f);
  }
  roundClean() {
    ii.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, WE = class extends Mm {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
const Ic = ho(() => new Mm());
ho(() => new WE());
const La = BigInt(2 ** 32 - 1), Nf = BigInt(32);
function Km(e, t = !1) {
  return t ? { h: Number(e & La), l: Number(e >> Nf & La) } : { h: Number(e >> Nf & La) | 0, l: Number(e & La) | 0 };
}
function GE(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: s } = Km(e[i], t);
    [r[i], n[i]] = [o, s];
  }
  return [r, n];
}
const ZE = (e, t) => BigInt(e >>> 0) << Nf | BigInt(t >>> 0), XE = (e, t, r) => e >>> r, YE = (e, t, r) => e << 32 - r | t >>> r, JE = (e, t, r) => e >>> r | t << 32 - r, QE = (e, t, r) => e << 32 - r | t >>> r, eA = (e, t, r) => e << 64 - r | t >>> r - 32, tA = (e, t, r) => e >>> r - 32 | t << 64 - r, rA = (e, t) => t, nA = (e, t) => e, iA = (e, t, r) => e << r | t >>> 32 - r, oA = (e, t, r) => t << r | e >>> 32 - r, sA = (e, t, r) => t << r - 32 | e >>> 64 - r, aA = (e, t, r) => e << r - 32 | t >>> 64 - r;
function cA(e, t, r, n) {
  const i = (t >>> 0) + (n >>> 0);
  return { h: e + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const uA = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), lA = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, fA = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0), dA = (e, t, r, n, i) => t + r + n + i + (e / 2 ** 32 | 0) | 0, hA = (e, t, r, n, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), pA = (e, t, r, n, i, o) => t + r + n + i + o + (e / 2 ** 32 | 0) | 0, gA = {
  fromBig: Km,
  split: GE,
  toBig: ZE,
  shrSH: XE,
  shrSL: YE,
  rotrSH: JE,
  rotrSL: QE,
  rotrBH: eA,
  rotrBL: tA,
  rotr32H: rA,
  rotr32L: nA,
  rotlSH: iA,
  rotlSL: oA,
  rotlBH: sA,
  rotlBL: aA,
  add: cA,
  add3L: uA,
  add3H: lA,
  add4L: fA,
  add4H: dA,
  add5H: pA,
  add5L: hA
};
var Ce = gA;
const [mA, bA] = Ce.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), oi = new Uint32Array(80), si = new Uint32Array(80);
let mu = class extends Xd {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: c, Eh: u, El: f, Fh: l, Fl: h, Gh: m, Gl: y, Hh: b, Hl: g } = this;
    return [t, r, n, i, o, s, a, c, u, f, l, h, m, y, b, g];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c, u, f, l, h, m, y, b, g) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = f | 0, this.Fh = l | 0, this.Fl = h | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = g | 0;
  }
  process(t, r) {
    for (let x = 0; x < 16; x++, r += 4)
      oi[x] = t.getUint32(r), si[x] = t.getUint32(r += 4);
    for (let x = 16; x < 80; x++) {
      const k = oi[x - 15] | 0, P = si[x - 15] | 0, I = Ce.rotrSH(k, P, 1) ^ Ce.rotrSH(k, P, 8) ^ Ce.shrSH(k, P, 7), R = Ce.rotrSL(k, P, 1) ^ Ce.rotrSL(k, P, 8) ^ Ce.shrSL(k, P, 7), j = oi[x - 2] | 0, W = si[x - 2] | 0, re = Ce.rotrSH(j, W, 19) ^ Ce.rotrBH(j, W, 61) ^ Ce.shrSH(j, W, 6), X = Ce.rotrSL(j, W, 19) ^ Ce.rotrBL(j, W, 61) ^ Ce.shrSL(j, W, 6), N = Ce.add4L(R, X, si[x - 7], si[x - 16]), G = Ce.add4H(N, I, re, oi[x - 7], oi[x - 16]);
      oi[x] = G | 0, si[x] = N | 0;
    }
    let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: c, Dh: u, Dl: f, Eh: l, El: h, Fh: m, Fl: y, Gh: b, Gl: g, Hh: v, Hl: _ } = this;
    for (let x = 0; x < 80; x++) {
      const k = Ce.rotrSH(l, h, 14) ^ Ce.rotrSH(l, h, 18) ^ Ce.rotrBH(l, h, 41), P = Ce.rotrSL(l, h, 14) ^ Ce.rotrSL(l, h, 18) ^ Ce.rotrBL(l, h, 41), I = l & m ^ ~l & b, R = h & y ^ ~h & g, j = Ce.add5L(_, P, R, bA[x], si[x]), W = Ce.add5H(j, v, k, I, mA[x], oi[x]), re = j | 0, X = Ce.rotrSH(n, i, 28) ^ Ce.rotrBH(n, i, 34) ^ Ce.rotrBH(n, i, 39), N = Ce.rotrSL(n, i, 28) ^ Ce.rotrBL(n, i, 34) ^ Ce.rotrBL(n, i, 39), G = n & o ^ n & a ^ o & a, M = i & s ^ i & c ^ s & c;
      v = b | 0, _ = g | 0, b = m | 0, g = y | 0, m = l | 0, y = h | 0, { h: l, l: h } = Ce.add(u | 0, f | 0, W | 0, re | 0), u = a | 0, f = c | 0, a = o | 0, c = s | 0, o = n | 0, s = i | 0;
      const $ = Ce.add3L(re, N, M);
      n = Ce.add3H($, W, X, G), i = $ | 0;
    }
    ({ h: n, l: i } = Ce.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: o, l: s } = Ce.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0), { h: a, l: c } = Ce.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l: f } = Ce.add(this.Dh | 0, this.Dl | 0, u | 0, f | 0), { h: l, l: h } = Ce.add(this.Eh | 0, this.El | 0, l | 0, h | 0), { h: m, l: y } = Ce.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: b, l: g } = Ce.add(this.Gh | 0, this.Gl | 0, b | 0, g | 0), { h: v, l: _ } = Ce.add(this.Hh | 0, this.Hl | 0, v | 0, _ | 0), this.set(n, i, o, s, a, c, u, f, l, h, m, y, b, g, v, _);
  }
  roundClean() {
    oi.fill(0), si.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}, yA = class extends mu {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}, wA = class extends mu {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}, vA = class extends mu {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
const xA = ho(() => new mu());
ho(() => new yA());
ho(() => new wA());
ho(() => new vA());
const EA = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), qm = Uint8Array.from({ length: 16 }, (e, t) => t), AA = qm.map((e) => (9 * e + 5) % 16);
let Yd = [qm], Jd = [AA];
for (let e = 0; e < 4; e++)
  for (let t of [Yd, Jd])
    t.push(t[e].map((r) => EA[r]));
const Vm = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e)), SA = Yd.map((e, t) => e.map((r) => Vm[t][r])), _A = Jd.map((e, t) => e.map((r) => Vm[t][r])), kA = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), TA = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), za = (e, t) => e << t | e >>> 32 - t;
function o1(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const ja = new Uint32Array(16);
class CA extends Xd {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: i, h4: o } = this;
    return [t, r, n, i, o];
  }
  set(t, r, n, i, o) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = o | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4)
      ja[m] = t.getUint32(r, !0);
    let n = this.h0 | 0, i = n, o = this.h1 | 0, s = o, a = this.h2 | 0, c = a, u = this.h3 | 0, f = u, l = this.h4 | 0, h = l;
    for (let m = 0; m < 5; m++) {
      const y = 4 - m, b = kA[m], g = TA[m], v = Yd[m], _ = Jd[m], x = SA[m], k = _A[m];
      for (let P = 0; P < 16; P++) {
        const I = za(n + o1(m, o, a, u) + ja[v[P]] + b, x[P]) + l | 0;
        n = l, l = u, u = za(a, 10) | 0, a = o, o = I;
      }
      for (let P = 0; P < 16; P++) {
        const I = za(i + o1(y, s, c, f) + ja[_[P]] + g, k[P]) + h | 0;
        i = h, h = f, f = za(c, 10) | 0, c = s, s = I;
      }
    }
    this.set(this.h1 + a + f | 0, this.h2 + u + h | 0, this.h3 + l + i | 0, this.h4 + n + s | 0, this.h0 + o + c | 0);
  }
  roundClean() {
    ja.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
const PA = ho(() => new CA());
class Wm extends Dm {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, Wi.hash(t);
    const n = Zd(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, o = new Uint8Array(i);
    o.set(n.length > i ? t.create().update(n).digest() : n);
    for (let s = 0; s < o.length; s++)
      o[s] ^= 54;
    this.iHash.update(o), this.oHash = t.create();
    for (let s = 0; s < o.length; s++)
      o[s] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(t) {
    return Wi.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Wi.exists(this), Wi.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const Gm = (e, t, r) => new Wm(e, t).update(r).digest();
Gm.create = (e, t) => new Wm(e, t);
function IA(e) {
  const t = be.bytes(e);
  return be.raw(Ic(t));
}
function qo(e) {
  const t = be.bytes(e);
  return be.raw(Ic(Ic(t)));
}
function Qd(e) {
  const t = be.bytes(e);
  return be.raw(PA(Ic(t)));
}
function BA(e, t) {
  const r = be.bytes(e), n = be.bytes(t);
  return be.raw(Gm(xA, r, n));
}
function OA(e) {
  const t = be.str(e).digest;
  return be.join([t, t]);
}
function $A(e = 32) {
  return eh(zm(e));
}
function eh(e) {
  return Mt.mod(e).buff;
}
function Zm(e, t = !1) {
  const r = Mt.mod(e).point;
  return t ? r.x : r.buff;
}
function Xm(e, t) {
  const r = Un.from_x(t), n = Mt.mod(e);
  return r.mul(n).buff;
}
function NA(e, t, r = "ecdh/code") {
  const n = OA(r), i = eh(e), o = Zm(i), s = be.bytes(t), a = Xm(i, s), c = [o.hex, s.hex];
  return c.sort(), BA(a, be.join([n, ...c]));
}
function UA(e) {
  const t = be.bytes(e);
  switch (!0) {
    case t.length === 32:
      return !0;
    case (t.length === 33 && t[0] === 2):
      return !0;
    case (t.length === 33 && t[0] === 3):
      return !1;
    default:
      throw new TypeError(`Invalid public key: ${t.hex}`);
  }
}
function FA(e) {
  const t = be.bytes(e);
  switch (t.length) {
    case 32:
      return t;
    case 33:
      return t.slice(1, 33);
    default:
      throw new Error(`Invalid key length: ${t.length}`);
  }
}
var HA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  genSecretKey: $A,
  getPublicKey: Zm,
  getSecretKey: eh,
  getSharedCode: NA,
  getSharedKey: Xm,
  is_even_pub: UA,
  xonly_pub: FA
});
be.random(32);
const Ym = { secp: fn, schnorr: s9 }, Uf = { ...HA, ...CE };
function bu(e) {
  const t = U.bytes(e);
  return pn(t, 33), Qd(t);
}
function Jm(e) {
  const t = Qt.fmt.toBytes(e, !1);
  return Qd(t);
}
function Qm(e) {
  const t = Qt.fmt.toBytes(e, !1);
  return IA(t);
}
function e2(e, t = "main") {
  const r = t === "main" ? ["1"] : ["m", "n"];
  for (const n of r)
    if (e.startsWith(n))
      return !0;
  return !1;
}
function t2(e, t = "main") {
  const r = U.bytes(e), n = t === "main" ? U.num(0) : U.num(111);
  return pn(e, 20), r.prepend(n).tob58chk();
}
function RA(e, t = "main") {
  if (!e2(e, t))
    throw new TypeError("Invalid p2pkh address!");
  return U.b58chk(e).slice(1);
}
function LA(e) {
  const t = U.bytes(e);
  return pn(t, 20), ["OP_DUP", "OP_HASH160", t.hex, "OP_EQUALVERIFY", "OP_CHECKSIG"];
}
function zA(e, t) {
  const r = bu(e);
  return t2(r, t);
}
const r2 = { check: e2, encode: t2, decode: RA, hash: bu, scriptPubKey: LA, fromPubKey: zA };
function n2(e, t = "main") {
  const r = t === "main" ? ["3"] : ["2"];
  for (const n of r)
    if (e.startsWith(n))
      return !0;
  return !1;
}
function i2(e, t = "main") {
  const r = t === "main" ? U.num(5) : U.num(196), n = U.bytes(e);
  return pn(n, 20), n.prepend(r).tob58chk();
}
function jA(e, t = "main") {
  if (!n2(e, t))
    throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
  return U.b58chk(e).slice(1);
}
function DA(e) {
  return ["OP_HASH160", U.bytes(e).hex, "OP_EQUAL"];
}
function MA(e, t) {
  const r = Jm(e);
  return i2(r, t);
}
const o2 = { check: n2, encode: i2, decode: jA, hash: Jm, scriptPubKey: DA, fromScript: MA }, th = {
  main: "bc",
  testnet: "tb",
  signet: "tb",
  regtest: "bcrt"
}, KA = ["bc1q", "tb1q", "bcrt1q"];
function s2(e) {
  for (const t of KA)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function a2(e, t = "main") {
  const r = th[t], n = U.bytes(e);
  return pn(n, 20), n.toBech32(r, 0);
}
function qA(e) {
  if (!s2(e))
    throw new TypeError("Invalid segwit address!");
  return U.bech32(e);
}
function VA(e) {
  const t = U.bytes(e);
  return pn(t, 20), ["OP_0", t.hex];
}
function WA(e, t) {
  const r = bu(e);
  return a2(r, t);
}
const c2 = { check: s2, encode: a2, decode: qA, hash: bu, scriptPubKey: VA, fromPubKey: WA }, GA = ["bc1q", "tb1q", "bcrt1q"];
function u2(e) {
  for (const t of GA)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function l2(e, t = "main") {
  const r = th[t], n = U.bytes(e);
  return pn(n, 32), n.toBech32(r, 0);
}
function ZA(e) {
  if (!u2(e))
    throw new TypeError("Invalid segwit address!");
  return U.bech32(e);
}
function XA(e) {
  const t = U.bytes(e);
  return pn(t, 32), ["OP_0", t.hex];
}
function YA(e, t) {
  const r = Qm(e);
  return l2(r, t);
}
const f2 = { check: u2, encode: l2, decode: ZA, hash: Qm, scriptPubKey: XA, fromScript: YA };
function ro(e) {
  const t = U.bytes(e);
  return t.length > 32 ? t.slice(1, 33) : t;
}
const JA = ["bc1p", "tb1p", "bcrt1p"];
function d2(e) {
  for (const t of JA)
    if (e.startsWith(t))
      return !0;
  return !1;
}
function h2(e, t = "main") {
  const r = th[t], n = U.bytes(e);
  return pn(n, 32), n.toBech32(r, 1);
}
function QA(e) {
  if (!d2(e))
    throw new TypeError("Invalid taproot address!");
  return U.bech32(e);
}
function eS(e) {
  const t = U.bytes(e);
  return pn(t, 32), ["OP_1", t.hex];
}
function tS(e, t) {
  const r = ro(e);
  return h2(r, t);
}
const p2 = { check: d2, encode: h2, decode: QA, scriptPubKey: eS, fromPubKey: tS }, rS = {
  version: 2,
  vin: [],
  vout: [],
  locktime: 0
}, nS = {
  scriptSig: [],
  sequence: 4294967293,
  witness: []
}, iS = {
  value: 0n,
  scriptPubKey: []
};
function rh(e) {
  const t = { ...rS, ...e };
  return t.vin = t.vin.map((r) => ({ ...nS, ...r })), t.vout = t.vout.map((r) => ({ ...iS, ...r })), t;
}
function Vo(e, t) {
  const { version: r, vin: n, vout: i, locktime: o } = rh(e), s = t !== !0 && oS(n), a = [nh(r)];
  s && a.push(U.hex("0001")), a.push(sS(n)), a.push(aS(i));
  for (const c of n)
    s && a.push(uS(c.witness));
  return a.push(ih(o)), U.join(a);
}
function oS(e) {
  for (const t of e) {
    const { witness: r } = t;
    if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0)
      return !0;
  }
  return !1;
}
function nh(e) {
  return U.num(e, 4).reverse();
}
function la(e) {
  return U.hex(e, 32).reverse();
}
function fa(e) {
  return U.num(e, 4).reverse();
}
function da(e) {
  if (typeof e == "string")
    return U.hex(e, 4).reverse();
  if (typeof e == "number")
    return U.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function sS(e) {
  const t = [U.varInt(e.length, "le")];
  for (const r of e) {
    const { txid: n, vout: i, scriptSig: o, sequence: s } = r;
    t.push(la(n)), t.push(fa(i)), t.push(fo(o, !0)), t.push(da(s));
  }
  return U.join(t);
}
function ki(e) {
  if (typeof e == "number") {
    if (e % 1 !== 0)
      throw new Error("Value must be an integer:" + String(e));
    return U.num(e, 8).reverse();
  }
  return U.big(e, 8).reverse();
}
function aS(e) {
  const t = [U.varInt(e.length, "le")];
  for (const r of e)
    t.push(cS(r));
  return U.join(t);
}
function cS(e) {
  const { value: t, scriptPubKey: r } = e, n = [];
  return n.push(ki(t)), n.push(fo(r, !0)), U.join(n);
}
function uS(e = []) {
  const t = [];
  if (Array.isArray(e)) {
    const r = U.varInt(e.length);
    t.push(r);
    for (const n of e)
      t.push(lS(n));
    return U.join(t);
  } else
    return U.bytes(e);
}
function lS(e) {
  return fS(e) ? new U(0) : fo(e, !0);
}
function fS(e) {
  if (Array.isArray(e))
    return e.length === 0;
  if (typeof e == "string" && e === "")
    return !0;
  const t = U.bytes(e);
  return t.length === 1 && t[0] === 0;
}
function ih(e) {
  if (typeof e == "string")
    return U.hex(e, 4);
  if (typeof e == "number")
    return U.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function oh(e) {
  typeof e == "string" && (e = U.hex(e).raw);
  const t = new ns(e), r = dS(t), n = hS(t), i = pS(t), o = mS(t);
  if (n)
    for (const a of i)
      a.witness = yS(t);
  const s = wS(t);
  return { version: r, vin: i, vout: o, locktime: s };
}
function dS(e) {
  return e.read(4).reverse().toNum();
}
function hS(e) {
  const [t, r] = [...e.peek(2)];
  if (t === 0) {
    if (e.read(2), r === 1)
      return !0;
    throw new Error(`Invalid witness flag: ${r}`);
  }
  return !1;
}
function pS(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(gS(e));
  return t;
}
function gS(e) {
  return {
    txid: e.read(32).reverse().toHex(),
    vout: e.read(4).reverse().toNum(),
    scriptSig: m2(e),
    sequence: e.read(4).reverse().toHex(),
    witness: []
  };
}
function mS(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(bS(e));
  return t;
}
function bS(e) {
  return {
    value: e.read(8).reverse().big,
    scriptPubKey: m2(e)
  };
}
function yS(e) {
  const t = [], r = e.readSize();
  for (let n = 0; n < r; n++) {
    const i = g2(e);
    t.push(i ?? "");
  }
  return t;
}
function g2(e, t) {
  const r = e.readSize("le");
  return r > 0 ? e.read(r).hex : null;
}
function m2(e, t) {
  const r = g2(e);
  return r !== null ? r : [];
}
function wS(e) {
  return e.read(4).reverse().toNum();
}
function vS(e) {
  if (Xg(e))
    return oh(e);
  if (typeof e == "object" && !(e instanceof Uint8Array))
    return Vo(e), rh(e);
  throw new Error("Invalid format: " + typeof e);
}
function xS(e) {
  if (Xg(e))
    return oh(e), U.bytes(e);
  if (typeof e == "object")
    return Vo(e);
  throw new Error("Invalid format: " + typeof e);
}
const sh = {
  toBytes: xS,
  toJson: vS
}, ES = [
  ["p2pkh", /^76a914(?<hash>\w{40})88ac$/],
  ["p2sh", /^a914(?<hash>\w{40})87$/],
  ["p2w-pkh", /^0014(?<hash>\w{40})$/],
  ["p2w-sh", /^0020(?<hash>\w{64})$/],
  ["p2tr", /^5120(?<hash>\w{64})$/]
], AS = [
  192,
  194,
  196,
  198,
  200,
  202,
  204,
  206,
  208,
  210,
  212,
  214,
  216,
  218,
  220,
  222,
  224,
  226,
  228,
  230,
  232,
  234,
  236,
  238,
  240,
  242,
  244,
  246,
  248,
  250,
  252,
  254,
  102,
  126,
  128,
  132,
  150,
  152,
  186,
  188,
  190
];
function SS(e) {
  let t = e.at(-1);
  return Ln(t) && (t = U.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), U.raw(t)) : null;
}
function _S(e) {
  let t = e.at(-1);
  return Ln(t) && (t = U.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && AS.includes(t[0] & 254) ? (e.pop(), U.raw(t)) : null;
}
function kS(e) {
  if (e.length > 1) {
    const t = e.at(-1);
    try {
      const r = Qt.fmt.toBytes(t);
      return e.pop(), r;
    } catch {
      return null;
    }
  }
  return null;
}
function TS(e) {
  const t = [];
  for (const r of e)
    if (Ln(r) || r instanceof Uint8Array || typeof r == "number")
      t.push(U.bytes(r));
    else
      throw new Error("unrecognized value: " + String(r));
  return t;
}
function CS(e = []) {
  const t = [...e], r = SS(t), n = _S(t), i = kS(t), o = TS(t);
  return { annex: r, cblock: n, script: i, params: o };
}
function PS(e) {
  const t = Qt.fmt.toBytes(e, !1).hex;
  for (const [r, n] of ES) {
    const i = r, { groups: o } = n.exec(t) ?? {}, { hash: s } = o ?? {};
    if (Ln(s))
      return { type: i, data: U.hex(s) };
  }
  return { type: "raw", data: U.hex(t) };
}
function IS(e) {
  const t = sh.toJson(e), r = Vo(t, !0);
  return qo(r).reverse().hex;
}
function BS(e) {
  const t = sh.toJson(e), r = Vo(t, !0).length, n = Vo(t, !1).length, i = r * 3 + n, o = i % 4 > 0 ? 1 : 0, s = Math.floor(i / 4) + o;
  return { size: n, bsize: r, vsize: s, weight: i };
}
const zr = {
  create: rh,
  encode: Vo,
  decode: oh,
  fmt: sh,
  util: {
    getTxSize: BS,
    getTxid: IS,
    readScriptPubKey: PS,
    readWitness: CS
  }
}, OS = [
  ["1", "p2pkh", "main", 20, "base58"],
  ["3", "p2sh", "main", 20, "base58"],
  ["m", "p2pkh", "testnet", 20, "base58"],
  ["n", "p2pkh", "testnet", 20, "base58"],
  ["2", "p2sh", "testnet", 20, "base58"],
  ["bc1q", "p2w-pkh", "main", 20, "bech32"],
  ["tb1q", "p2w-pkh", "testnet", 20, "bech32"],
  ["bcrt1q", "p2w-pkh", "regtest", 20, "bech32"],
  ["bc1q", "p2w-sh", "main", 32, "bech32"],
  ["tb1q", "p2w-sh", "testnet", 32, "bech32"],
  ["bcrt1q", "p2w-sh", "regtest", 32, "bech32"],
  ["bc1p", "p2tr", "main", 32, "bech32m"],
  ["tb1p", "p2tr", "testnet", 32, "bech32m"],
  ["bcrt1p", "p2tr", "regtest", 32, "bech32m"]
];
function $S(e, t) {
  switch (t) {
    case "base58":
      return U.b58chk(e).slice(1);
    case "bech32":
      return U.bech32(e);
    case "bech32m":
      return U.bech32(e);
    default:
      throw new Error("Invalid address format: " + t);
  }
}
function NS(e) {
  for (const t of OS) {
    const [r, n, i, o, s] = t;
    if (e.startsWith(r) && $S(e, s).length === o)
      return t;
  }
  throw new Error("Invalid address: " + e);
}
function b2(e) {
  switch (e) {
    case "p2pkh":
      return r2;
    case "p2sh":
      return o2;
    case "p2w-pkh":
      return c2;
    case "p2w-sh":
      return f2;
    case "p2tr":
      return p2;
    default:
      throw new Error("Invalid address type: " + e);
  }
}
function y2(e) {
  const [t, r, n] = NS(e), i = b2(r), o = i.decode(e, n), s = i.scriptPubKey(o);
  return { prefix: t, type: r, network: n, data: o, script: s };
}
function US(e, t) {
  const { type: r, data: n } = zr.util.readScriptPubKey(e);
  return b2(r).encode(n, t);
}
function FS(e) {
  const { script: t } = y2(e);
  return Qt.fmt.toAsm(t, !1);
}
const w2 = {
  p2pkh: r2,
  p2sh: o2,
  p2wpkh: c2,
  p2wsh: f2,
  p2tr: p2,
  decode: y2,
  fromScriptPubKey: US,
  toScriptPubKey: FS
}, HS = [1, 2, 3];
function ah(e, t, r = {}) {
  const { sigflag: n = 1 } = r, i = (n & 128) === 128, o = n % 128;
  if (!HS.includes(o))
    throw new Error("Invalid hash type: " + String(n));
  const s = zr.fmt.toJson(e), { version: a, vin: c, vout: u, locktime: f } = s, { txid: l, vout: h, prevout: m, sequence: y } = c[t], { value: b } = m ?? {};
  if (b === void 0)
    throw new Error("Prevout value is empty!");
  let g = r.script;
  if (g === void 0 && r.pubkey !== void 0 && (g = `76a914${Qd(r.pubkey).hex}88ac`), g === void 0)
    throw new Error("No pubkey / script has been set!");
  if (Qt.fmt.toAsm(g).includes("OP_CODESEPARATOR"))
    throw new Error("This library does not currently support the use of OP_CODESEPARATOR in segwit scripts.");
  const v = [
    nh(a),
    RS(c, i),
    LS(c, o, i),
    la(l),
    fa(h),
    Qt.encode(g, !0),
    ki(b),
    da(y),
    zS(u, t, o),
    ih(f),
    U.num(n, 4).reverse()
  ];
  return qo(U.join(v));
}
function RS(e, t) {
  if (t === !0)
    return U.num(0, 32);
  const r = [];
  for (const { txid: n, vout: i } of e)
    r.push(la(n)), r.push(fa(i));
  return qo(U.join(r));
}
function LS(e, t, r) {
  if (r || t !== 1)
    return U.num(0, 32);
  const n = [];
  for (const { sequence: i } of e)
    n.push(da(i));
  return qo(U.join(n));
}
function zS(e, t, r) {
  const n = [];
  if (r === 1) {
    for (const { value: i, scriptPubKey: o } of e)
      n.push(ki(i)), n.push(Qt.encode(o, !0));
    return qo(U.join(n));
  }
  if (r === 3 && t < e.length) {
    const { value: i, scriptPubKey: o } = e[t];
    return n.push(ki(i)), n.push(Qt.encode(o, !0)), qo(U.join(n));
  }
  return U.num(0, 32);
}
function jS(e, t, r, n = {}) {
  const { sigflag: i = 1 } = n, o = ah(t, r, n), s = Ym.secp.sign(o, e).toDERRawBytes(!0);
  return U.join([s, i]);
}
function DS(e, t, r = {}) {
  const n = zr.fmt.toJson(e), { throws: i = !1 } = r, { witness: o = [] } = n.vin[t], s = zr.util.readWitness(o), { script: a, params: c } = s;
  let u = null;
  if (c.length < 1)
    return Vt("Invalid witness data: " + String(o), i);
  if (r.script === void 0 && a !== null && (r.script = a), r.pubkey !== void 0)
    u = U.bytes(r.pubkey);
  else if (c.length > 1 && c[1].length === 33)
    u = U.bytes(c[1]);
  else
    return Vt("No pubkey provided!", i);
  const f = Qt.fmt.toParam(c[0]), l = f.slice(0, -1), h = f.slice(-1)[0], m = ah(n, t, { ...r, sigflag: h });
  return Ym.secp.verify(l, m, u) ? !0 : Vt("Invalid signature!", i);
}
const MS = {
  hash: ah,
  sign: jS,
  verify: DS
}, KS = [0, 1, 2, 3, 129, 130, 131];
function ch(e, t, r = {}) {
  const { extension: n, sigflag: i = 0, extflag: o = 0, key_version: s = 0, separator_pos: a = 4294967295 } = r, c = zr.fmt.toJson(e), { version: u, vin: f, vout: l, locktime: h } = c;
  if (t >= f.length)
    throw new Error("Index out of bounds: " + String(t));
  if (!KS.includes(i))
    throw new Error("Invalid hash type: " + String(i));
  if (o < 0 || o > 127)
    throw new Error("Extention flag out of range: " + String(o));
  const { txid: m, vout: y, sequence: b, witness: g = [] } = f[t], v = (i & 128) === 128, _ = YS(g), x = _ !== void 0 ? 1 : 0, P = (o + (n !== void 0 ? 1 : 0)) * 2 + x, I = U.str("TapSighash").digest, R = [
    I,
    I,
    U.num(0, 1),
    U.num(i, 1),
    nh(u),
    ih(h)
  ];
  if (!v) {
    const j = f.map((W) => s1(W));
    R.push(qS(f), WS(j), GS(j), VS(f));
  }
  if (((i & 3) < 2 || (i & 3) > 3) && R.push(ZS(l)), R.push(U.num(P, 1)), v) {
    const { value: j, scriptPubKey: W } = s1(f[t]);
    R.push(la(m), fa(y), ki(j), Qt.encode(W, !0), da(b));
  } else
    R.push(U.num(t, 4).reverse());
  return _ !== void 0 && R.push(_), (i & 3) === 3 && R.push(XS(l[t])), n !== void 0 && R.push(U.bytes(n), U.num(s), U.num(a, 4)), U.join(R).digest;
}
function qS(e) {
  const t = [];
  for (const { txid: r, vout: n } of e)
    t.push(la(r)), t.push(fa(n));
  return U.join(t).digest;
}
function VS(e) {
  const t = [];
  for (const { sequence: r } of e)
    t.push(da(r));
  return U.join(t).digest;
}
function WS(e) {
  const t = [];
  for (const { value: r } of e)
    t.push(ki(r));
  return U.join(t).digest;
}
function GS(e) {
  const t = [];
  for (const { scriptPubKey: r } of e)
    t.push(fo(r, !0));
  return U.join(t).digest;
}
function ZS(e) {
  const t = [];
  for (const { value: r, scriptPubKey: n } of e)
    t.push(ki(r)), t.push(Qt.encode(n, !0));
  return U.join(t).digest;
}
function XS(e) {
  return U.join([
    ki(e.value),
    Qt.encode(e.scriptPubKey, !0)
  ]).digest;
}
function YS(e) {
  if (e === void 0 || e.length < 2)
    return;
  let t = e.at(-1);
  if (typeof t == "string" && (t = U.hex(t)), t instanceof Uint8Array && t[0] === 80)
    return U.raw(t).prefixSize("be").digest;
}
function s1(e) {
  if (e.prevout === void 0)
    throw new Error("Prevout data missing for input: " + String(e.txid));
  return e.prevout;
}
const JS = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, QS = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function e_(e, t, r, n = {}) {
  const { sigflag: i = 0 } = n, o = ch(t, r, n), s = t_(e, o);
  return i === 0 ? U.raw(s) : U.join([s, i]);
}
function t_(e, t, r = U.random(32)) {
  const n = U.bytes(t), i = new Mt(e), o = i.point, s = o.hasEvenY ? i.big : i.negated.big, a = ec("BIP0340/aux", U.bytes(r)), c = s ^ a.big, u = ec("BIP0340/nonce", c, o.x.raw, n), f = new Mt(u), l = f.point, h = l.hasEvenY ? f.big : f.negated.big, m = new Mt(ec("BIP0340/challenge", l.x.raw, o.x.raw, n)), y = new Mt(h + m.big * s);
  return U.join([l.x.raw, y.raw]);
}
function r_(e, t, r, n = !1) {
  const i = Un.from_x(ro(r)), o = U.bytes(t), s = U.bytes(e).stream;
  s.size < 64 && Vt("Signature length is too small: " + String(s.size), n);
  const a = s.read(32);
  a.big > JS && Vt("Signature r value greater than field size!", n);
  const c = s.read(32);
  c.big > QS && Vt("Signature s value greater than curve order!", n);
  const u = new Mt(ec("BIP0340/challenge", a.raw, i.x.raw, o)), f = new Mt(c).point, l = i.mul(u.big), h = f.sub(l);
  return h.hasOddY && Vt("Signature R value has odd Y coordinate!", n), h.x.big === 0n && Vt("Signature R value is infinite!", n), h.x.big === a.big;
}
const n_ = 192;
function yu(e) {
  const t = U.str(e).digest;
  return U.join([t, t]);
}
function uh(e, t = n_) {
  return U.join([
    yu("TapLeaf"),
    s_(t),
    U.bytes(e)
  ]).digest.hex;
}
function i_(e, t) {
  return uh(Qt.fmt.toBytes(e), t);
}
function lh(e, t) {
  return t < e && ([e, t] = [t, e]), U.join([
    yu("TapBranch"),
    U.hex(e).raw,
    U.hex(t).raw
  ]).digest.hex;
}
function o_(e) {
  return U.hex(Bc(e)[0]);
}
function Bc(e, t, r = []) {
  const n = [], i = [];
  if (e.length < 1)
    throw new Error("Tree is empty!");
  for (let o = 0; o < e.length; o++) {
    const s = e[o];
    if (Array.isArray(s)) {
      const [a, c, u] = Bc(s, t);
      t = c, n.push(a);
      for (const f of u)
        r.push(f);
    } else
      n.push(s);
  }
  if (n.length === 1)
    return [n[0], t, r];
  n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
  for (let o = 0; o < n.length - 1; o += 2) {
    const s = lh(n[o], n[o + 1]);
    i.push(s), typeof t == "string" && (t === n[o] ? (r.push(n[o + 1]), t = s) : t === n[o + 1] && (r.push(n[o]), t = s));
  }
  return Bc(i, t, r);
}
function s_(e = 192) {
  return e & 254;
}
function v2(e, t = new Uint8Array(), r = !1) {
  const n = r ? new Mt(e).point.x.raw : ro(e);
  return U.join([yu("TapTweak"), n, U.bytes(t)]).digest;
}
function No(e, t, r = !1) {
  t === void 0 && (t = new Uint8Array());
  const n = U.bytes(e), i = v2(e, t, r);
  return r ? x2(n, i) : E2(n, i);
}
function a_(e, t) {
  return No(e, t);
}
function c_(e, t) {
  return No(e, t, !0);
}
function x2(e, t) {
  let r = new Mt(e);
  return r.point.hasOddY && (r = r.negate()), U.raw(r.add(t).raw);
}
function E2(e, t) {
  e = ro(e);
  const n = Un.from_x(e).add(t);
  return U.raw(n.raw);
}
function u_() {
  const e = U.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
  return Un.from_x(e.digest).x;
}
const l_ = u_(), f_ = 192;
function d_(e, t = {}) {
  return A2(e, { ...t, isPrivate: !0 });
}
function h_(e, t = {}) {
  return A2(e, { ...t, isPrivate: !1 });
}
function A2(e, t = {}) {
  const { isPrivate: r = !1, tree: n = [], version: i = f_ } = t, o = r ? Uf.getPublicKey(e, !0) : ro(e);
  let { target: s } = t;
  s !== void 0 && (s = U.bytes(s).hex);
  let a, c = [];
  if (n.length > 0) {
    const [m, y, b] = Bc(n, s);
    c = b, a = No(e, m, r);
  } else
    s !== void 0 ? a = No(e, s, r) : a = No(e, void 0, r);
  const u = r ? Uf.getPublicKey(a)[0] : a[0], l = [U.num(i + _2(u)), o];
  c.length > 0 && c.forEach((m) => l.push(U.hex(m)));
  const h = U.join(l);
  if (s !== void 0 && !fh(a, s, h, t))
    throw new Error("Path checking failed! Unable to generate path.");
  return [ro(a).hex, h.hex];
}
function fh(e, t, r, n = {}) {
  const { isPrivate: i = !1, throws: o = !1 } = n, { parity: s, paths: a, intkey: c } = S2(r), u = i ? Uf.getPublicKey(e, !0) : ro(e), f = U.join([s, u]);
  if (f.length !== 33)
    return Vt("Invalid tapkey: " + f.hex, o);
  let l = U.bytes(t).hex;
  for (const m of a)
    l = lh(l, m);
  const h = No(c, l);
  return U.raw(h).hex === U.raw(f).hex;
}
function S2(e) {
  const t = new ns(U.bytes(e)), r = t.read(1).num, n = t.read(32), [i, o] = r % 2 === 0 ? [r, 2] : [r - 1, 3], s = [];
  for (; t.size >= 32; )
    s.push(t.read(32).hex);
  if (t.size !== 0)
    throw new Error("Non-empty buffer on control block: " + String(t));
  return { intkey: n, paths: s, parity: o, version: i };
}
function _2(e = 2) {
  if (e === 0 || e === 1)
    return e;
  if (e === 2 || e === "02")
    return 0;
  if (e === 3 || e === "03")
    return 1;
  throw new Error("Invalid parity bit: " + String(e));
}
function p_(e, t, r = {}) {
  const n = zr.fmt.toJson(e), { throws: i = !1 } = r, { prevout: o, witness: s = [] } = n.vin[t], a = zr.util.readWitness(s), { cblock: c, script: u, params: f } = a;
  let l;
  if (f.length < 1)
    return Vt("Invalid witness data: " + String(s), i);
  const { scriptPubKey: h } = o ?? {};
  if (h === void 0)
    return Vt("Prevout scriptPubKey is empty!", i);
  const { type: m, data: y } = zr.util.readScriptPubKey(h);
  if (m !== "p2tr")
    return Vt("Prevout script is not a valid taproot output:" + y.hex, i);
  if (y.length !== 32)
    return Vt("Invalid tapkey length: " + String(y.length), i);
  if (c !== null && u !== null) {
    const x = c[0] & 254, k = uh(u, x);
    if (r.extension = k, !fh(y, k, c, { throws: i }))
      return Vt("cblock verification failed!", i);
  }
  r.pubkey !== void 0 ? l = U.bytes(r.pubkey) : f.length > 1 && f[1].length === 32 ? l = U.bytes(f[1]) : l = U.bytes(y);
  const b = Qt.fmt.toParam(f[0]), g = new ns(b), v = g.read(64).raw;
  if (g.size === 1 && (r.sigflag = g.read(1).num, r.sigflag === 0))
    return Vt("0x00 is not a valid appended sigflag!", i);
  const _ = ch(n, t, r);
  return r_(v, _, l, i) ? !0 : Vt("Invalid signature!", i);
}
const g_ = {
  hash: ch,
  sign: e_,
  verify: p_
}, m_ = {
  segwit: MS,
  taproot: g_
}, b_ = {
  getTag: yu,
  getLeaf: uh,
  getBranch: lh,
  getRoot: o_
}, y_ = {
  readCtrlBlock: S2,
  readParityBit: _2
}, w_ = {
  getPubKey: a_,
  getSecKey: c_,
  getTweak: v2,
  tweakSecKey: x2,
  tweakPubKey: E2
}, Oc = {
  getPubKey: h_,
  getSecKey: d_,
  encodeScript: i_,
  checkPath: fh,
  tree: b_,
  tweak: w_,
  util: y_,
  SCRIPT_PUBKEY: l_
};
var De;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function r(i) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (i) => {
    const o = {};
    for (const s of i)
      o[s] = s;
    return o;
  }, e.getValidEnumValues = (i) => {
    const o = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), s = {};
    for (const a of o)
      s[a] = i[a];
    return e.objectValues(s);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(o) {
    return i[o];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
    return o;
  }, e.find = (i, o) => {
    for (const s of i)
      if (o(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, o = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(o);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
})(De || (De = {}));
var Ff;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(Ff || (Ff = {}));
const ee = De.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), xi = (e) => {
  switch (typeof e) {
    case "undefined":
      return ee.undefined;
    case "string":
      return ee.string;
    case "number":
      return isNaN(e) ? ee.nan : ee.number;
    case "boolean":
      return ee.boolean;
    case "function":
      return ee.function;
    case "bigint":
      return ee.bigint;
    case "symbol":
      return ee.symbol;
    case "object":
      return Array.isArray(e) ? ee.array : e === null ? ee.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? ee.promise : typeof Map < "u" && e instanceof Map ? ee.map : typeof Set < "u" && e instanceof Set ? ee.set : typeof Date < "u" && e instanceof Date ? ee.date : ee.object;
    default:
      return ee.unknown;
  }
}, Z = De.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), v_ = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class jr extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(o) {
      return o.message;
    }, n = { _errors: [] }, i = (o) => {
      for (const s of o.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          n._errors.push(r(s));
        else {
          let a = n, c = 0;
          for (; c < s.path.length; ) {
            const u = s.path[c];
            c === s.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(r(s))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, De.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (r[i.path[0]] = r[i.path[0]] || [], r[i.path[0]].push(t(i))) : n.push(t(i));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
jr.create = (e) => new jr(e);
const Ls = (e, t) => {
  let r;
  switch (e.code) {
    case Z.invalid_type:
      e.received === ee.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Z.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, De.jsonStringifyReplacer)}`;
      break;
    case Z.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${De.joinValues(e.keys, ", ")}`;
      break;
    case Z.invalid_union:
      r = "Invalid input";
      break;
    case Z.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${De.joinValues(e.options)}`;
      break;
    case Z.invalid_enum_value:
      r = `Invalid enum value. Expected ${De.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Z.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Z.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Z.invalid_date:
      r = "Invalid date";
      break;
    case Z.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : De.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case Z.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case Z.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case Z.custom:
      r = "Invalid input";
      break;
    case Z.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Z.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Z.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, De.assertNever(e);
  }
  return { message: r };
};
let k2 = Ls;
function x_(e) {
  k2 = e;
}
function $c() {
  return k2;
}
const Nc = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: i } = e, o = [...r, ...i.path || []], s = {
    ...i,
    path: o
  };
  let a = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(s, { data: t, defaultError: a }).message;
  return {
    ...i,
    path: o,
    message: i.message || a
  };
}, E_ = [];
function te(e, t) {
  const r = Nc({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      $c(),
      Ls
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(r);
}
class Gt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const i of r) {
      if (i.status === "aborted")
        return ve;
      i.status === "dirty" && t.dirty(), n.push(i.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const i of r)
      n.push({
        key: await i.key,
        value: await i.value
      });
    return Gt.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const i of r) {
      const { key: o, value: s } = i;
      if (o.status === "aborted" || s.status === "aborted")
        return ve;
      o.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), (typeof s.value < "u" || i.alwaysSet) && (n[o.value] = s.value);
    }
    return { status: t.value, value: n };
  }
}
const ve = Object.freeze({
  status: "aborted"
}), T2 = (e) => ({ status: "dirty", value: e }), er = (e) => ({ status: "valid", value: e }), Hf = (e) => e.status === "aborted", Rf = (e) => e.status === "dirty", Uc = (e) => e.status === "valid", Fc = (e) => typeof Promise < "u" && e instanceof Promise;
var ue;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(ue || (ue = {}));
class dn {
  constructor(t, r, n, i) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const a1 = (e, t) => {
  if (Uc(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new jr(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function _e(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: i } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (s, a) => s.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: n ?? a.defaultError } : { message: r ?? a.defaultError }, description: i };
}
class Oe {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return xi(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: xi(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Gt(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: xi(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (Fc(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: xi(t)
    }, o = this._parseSync({ data: t, path: i.path, parent: i });
    return a1(i, o);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: !0
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: xi(t)
    }, i = this._parse({ data: t, path: n.path, parent: n }), o = await (Fc(i) ? i : Promise.resolve(i));
    return a1(n, o);
  }
  refine(t, r) {
    const n = (i) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(i) : r;
    return this._refinement((i, o) => {
      const s = t(i), a = () => o.addIssue({
        code: Z.custom,
        ...n(i)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((c) => c ? !0 : (a(), !1)) : s ? !0 : (a(), !1);
    });
  }
  refinement(t, r) {
    return this._refinement((n, i) => t(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1));
  }
  _refinement(t) {
    return new qr({
      schema: this,
      typeName: ge.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Bn.create(this, this._def);
  }
  nullable() {
    return oo.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Dr.create(this, this._def);
  }
  promise() {
    return Go.create(this, this._def);
  }
  or(t) {
    return Ms.create([this, t], this._def);
  }
  and(t) {
    return Ks.create(this, t, this._def);
  }
  transform(t) {
    return new qr({
      ..._e(this._def),
      schema: this,
      typeName: ge.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Zs({
      ..._e(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ge.ZodDefault
    });
  }
  brand() {
    return new P2({
      typeName: ge.ZodBranded,
      type: this,
      ..._e(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new zc({
      ..._e(this._def),
      innerType: this,
      catchValue: r,
      typeName: ge.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return ha.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const A_ = /^c[^\s-]{8,}$/i, S_ = /^[a-z][a-z0-9]*$/, __ = /[0-9A-HJKMNP-TV-Z]{26}/, k_ = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, T_ = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, C_ = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"), P_ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, I_ = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, B_ = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function O_(e, t) {
  return !!((t === "v4" || !t) && P_.test(e) || (t === "v6" || !t) && I_.test(e));
}
class Rr extends Oe {
  constructor() {
    super(...arguments), this._regex = (t, r, n) => this.refinement((i) => t.test(i), {
      validation: r,
      code: Z.invalid_string,
      ...ue.errToObj(n)
    }), this.nonempty = (t) => this.min(1, ue.errToObj(t)), this.trim = () => new Rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new Rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new Rr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ee.string) {
      const o = this._getOrReturnCtx(t);
      return te(
        o,
        {
          code: Z.invalid_type,
          expected: ee.string,
          received: o.parsedType
        }
        //
      ), ve;
    }
    const n = new Gt();
    let i;
    for (const o of this._def.checks)
      if (o.kind === "min")
        t.data.length < o.value && (i = this._getOrReturnCtx(t, i), te(i, {
          code: Z.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), n.dirty());
      else if (o.kind === "max")
        t.data.length > o.value && (i = this._getOrReturnCtx(t, i), te(i, {
          code: Z.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: o.message
        }), n.dirty());
      else if (o.kind === "length") {
        const s = t.data.length > o.value, a = t.data.length < o.value;
        (s || a) && (i = this._getOrReturnCtx(t, i), s ? te(i, {
          code: Z.too_big,
          maximum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }) : a && te(i, {
          code: Z.too_small,
          minimum: o.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: o.message
        }), n.dirty());
      } else if (o.kind === "email")
        T_.test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
          validation: "email",
          code: Z.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "emoji")
        C_.test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
          validation: "emoji",
          code: Z.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "uuid")
        k_.test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
          validation: "uuid",
          code: Z.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "cuid")
        A_.test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
          validation: "cuid",
          code: Z.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "cuid2")
        S_.test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
          validation: "cuid2",
          code: Z.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "ulid")
        __.test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
          validation: "ulid",
          code: Z.invalid_string,
          message: o.message
        }), n.dirty());
      else if (o.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), te(i, {
            validation: "url",
            code: Z.invalid_string,
            message: o.message
          }), n.dirty();
        }
      else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
        validation: "regex",
        code: Z.invalid_string,
        message: o.message
      }), n.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (i = this._getOrReturnCtx(t, i), te(i, {
        code: Z.invalid_string,
        validation: { includes: o.value, position: o.position },
        message: o.message
      }), n.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (i = this._getOrReturnCtx(t, i), te(i, {
        code: Z.invalid_string,
        validation: { startsWith: o.value },
        message: o.message
      }), n.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (i = this._getOrReturnCtx(t, i), te(i, {
        code: Z.invalid_string,
        validation: { endsWith: o.value },
        message: o.message
      }), n.dirty()) : o.kind === "datetime" ? B_(o).test(t.data) || (i = this._getOrReturnCtx(t, i), te(i, {
        code: Z.invalid_string,
        validation: "datetime",
        message: o.message
      }), n.dirty()) : o.kind === "ip" ? O_(t.data, o.version) || (i = this._getOrReturnCtx(t, i), te(i, {
        validation: "ip",
        code: Z.invalid_string,
        message: o.message
      }), n.dirty()) : De.assertNever(o);
    return { status: n.value, value: t.data };
  }
  _addCheck(t) {
    return new Rr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...ue.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...ue.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...ue.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...ue.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...ue.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...ue.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...ue.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...ue.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
      ...ue.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...ue.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...ue.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...ue.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...ue.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...ue.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...ue.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...ue.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Rr.create = (e) => {
  var t;
  return new Rr({
    checks: [],
    typeName: ge.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ..._e(e)
  });
};
function $_(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, i = r > n ? r : n, o = parseInt(e.toFixed(i).replace(".", "")), s = parseInt(t.toFixed(i).replace(".", ""));
  return o % s / Math.pow(10, i);
}
class Ti extends Oe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ee.number) {
      const o = this._getOrReturnCtx(t);
      return te(o, {
        code: Z.invalid_type,
        expected: ee.number,
        received: o.parsedType
      }), ve;
    }
    let n;
    const i = new Gt();
    for (const o of this._def.checks)
      o.kind === "int" ? De.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), i.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: !1,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? $_(t.data, o.value) !== 0 && (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.not_finite,
        message: o.message
      }), i.dirty()) : De.assertNever(o);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, ue.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, ue.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, ue.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, ue.toString(r));
  }
  setLimit(t, r, n, i) {
    return new Ti({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: ue.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ti({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: ue.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ue.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ue.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ue.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ue.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: ue.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: ue.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ue.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ue.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && De.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
}
Ti.create = (e) => new Ti({
  checks: [],
  typeName: ge.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ..._e(e)
});
class Ci extends Oe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== ee.bigint) {
      const o = this._getOrReturnCtx(t);
      return te(o, {
        code: Z.invalid_type,
        expected: ee.bigint,
        received: o.parsedType
      }), ve;
    }
    let n;
    const i = new Gt();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), i.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), te(n, {
        code: Z.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), i.dirty()) : De.assertNever(o);
    return { status: i.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, !0, ue.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, !1, ue.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, !0, ue.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, !1, ue.toString(r));
  }
  setLimit(t, r, n, i) {
    return new Ci({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: ue.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ci({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ue.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ue.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ue.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ue.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: ue.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
}
Ci.create = (e) => {
  var t;
  return new Ci({
    checks: [],
    typeName: ge.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ..._e(e)
  });
};
class zs extends Oe {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ee.boolean) {
      const n = this._getOrReturnCtx(t);
      return te(n, {
        code: Z.invalid_type,
        expected: ee.boolean,
        received: n.parsedType
      }), ve;
    }
    return er(t.data);
  }
}
zs.create = (e) => new zs({
  typeName: ge.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ..._e(e)
});
class no extends Oe {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ee.date) {
      const o = this._getOrReturnCtx(t);
      return te(o, {
        code: Z.invalid_type,
        expected: ee.date,
        received: o.parsedType
      }), ve;
    }
    if (isNaN(t.data.getTime())) {
      const o = this._getOrReturnCtx(t);
      return te(o, {
        code: Z.invalid_date
      }), ve;
    }
    const n = new Gt();
    let i;
    for (const o of this._def.checks)
      o.kind === "min" ? t.data.getTime() < o.value && (i = this._getOrReturnCtx(t, i), te(i, {
        code: Z.too_small,
        message: o.message,
        inclusive: !0,
        exact: !1,
        minimum: o.value,
        type: "date"
      }), n.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (i = this._getOrReturnCtx(t, i), te(i, {
        code: Z.too_big,
        message: o.message,
        inclusive: !0,
        exact: !1,
        maximum: o.value,
        type: "date"
      }), n.dirty()) : De.assertNever(o);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new no({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: ue.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: ue.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
}
no.create = (e) => new no({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: ge.ZodDate,
  ..._e(e)
});
class Hc extends Oe {
  _parse(t) {
    if (this._getType(t) !== ee.symbol) {
      const n = this._getOrReturnCtx(t);
      return te(n, {
        code: Z.invalid_type,
        expected: ee.symbol,
        received: n.parsedType
      }), ve;
    }
    return er(t.data);
  }
}
Hc.create = (e) => new Hc({
  typeName: ge.ZodSymbol,
  ..._e(e)
});
class js extends Oe {
  _parse(t) {
    if (this._getType(t) !== ee.undefined) {
      const n = this._getOrReturnCtx(t);
      return te(n, {
        code: Z.invalid_type,
        expected: ee.undefined,
        received: n.parsedType
      }), ve;
    }
    return er(t.data);
  }
}
js.create = (e) => new js({
  typeName: ge.ZodUndefined,
  ..._e(e)
});
class Ds extends Oe {
  _parse(t) {
    if (this._getType(t) !== ee.null) {
      const n = this._getOrReturnCtx(t);
      return te(n, {
        code: Z.invalid_type,
        expected: ee.null,
        received: n.parsedType
      }), ve;
    }
    return er(t.data);
  }
}
Ds.create = (e) => new Ds({
  typeName: ge.ZodNull,
  ..._e(e)
});
class Wo extends Oe {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return er(t.data);
  }
}
Wo.create = (e) => new Wo({
  typeName: ge.ZodAny,
  ..._e(e)
});
class Yi extends Oe {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return er(t.data);
  }
}
Yi.create = (e) => new Yi({
  typeName: ge.ZodUnknown,
  ..._e(e)
});
class Fn extends Oe {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return te(r, {
      code: Z.invalid_type,
      expected: ee.never,
      received: r.parsedType
    }), ve;
  }
}
Fn.create = (e) => new Fn({
  typeName: ge.ZodNever,
  ..._e(e)
});
class Rc extends Oe {
  _parse(t) {
    if (this._getType(t) !== ee.undefined) {
      const n = this._getOrReturnCtx(t);
      return te(n, {
        code: Z.invalid_type,
        expected: ee.void,
        received: n.parsedType
      }), ve;
    }
    return er(t.data);
  }
}
Rc.create = (e) => new Rc({
  typeName: ge.ZodVoid,
  ..._e(e)
});
class Dr extends Oe {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), i = this._def;
    if (r.parsedType !== ee.array)
      return te(r, {
        code: Z.invalid_type,
        expected: ee.array,
        received: r.parsedType
      }), ve;
    if (i.exactLength !== null) {
      const s = r.data.length > i.exactLength.value, a = r.data.length < i.exactLength.value;
      (s || a) && (te(r, {
        code: s ? Z.too_big : Z.too_small,
        minimum: a ? i.exactLength.value : void 0,
        maximum: s ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && r.data.length < i.minLength.value && (te(r, {
      code: Z.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && r.data.length > i.maxLength.value && (te(r, {
      code: Z.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((s, a) => i.type._parseAsync(new dn(r, s, r.path, a)))).then((s) => Gt.mergeArray(n, s));
    const o = [...r.data].map((s, a) => i.type._parseSync(new dn(r, s, r.path, a)));
    return Gt.mergeArray(n, o);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new Dr({
      ...this._def,
      minLength: { value: t, message: ue.toString(r) }
    });
  }
  max(t, r) {
    return new Dr({
      ...this._def,
      maxLength: { value: t, message: ue.toString(r) }
    });
  }
  length(t, r) {
    return new Dr({
      ...this._def,
      exactLength: { value: t, message: ue.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Dr.create = (e, t) => new Dr({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ge.ZodArray,
  ..._e(t)
});
function Co(e) {
  if (e instanceof it) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = Bn.create(Co(n));
    }
    return new it({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Dr ? new Dr({
    ...e._def,
    type: Co(e.element)
  }) : e instanceof Bn ? Bn.create(Co(e.unwrap())) : e instanceof oo ? oo.create(Co(e.unwrap())) : e instanceof hn ? hn.create(e.items.map((t) => Co(t))) : e;
}
class it extends Oe {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = De.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== ee.object) {
      const u = this._getOrReturnCtx(t);
      return te(u, {
        code: Z.invalid_type,
        expected: ee.object,
        received: u.parsedType
      }), ve;
    }
    const { status: n, ctx: i } = this._processInputParams(t), { shape: o, keys: s } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof Fn && this._def.unknownKeys === "strip"))
      for (const u in i.data)
        s.includes(u) || a.push(u);
    const c = [];
    for (const u of s) {
      const f = o[u], l = i.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: f._parse(new dn(i, l, i.path, u)),
        alwaysSet: u in i.data
      });
    }
    if (this._def.catchall instanceof Fn) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const f of a)
          c.push({
            key: { status: "valid", value: f },
            value: { status: "valid", value: i.data[f] }
          });
      else if (u === "strict")
        a.length > 0 && (te(i, {
          code: Z.unrecognized_keys,
          keys: a
        }), n.dirty());
      else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const f of a) {
        const l = i.data[f];
        c.push({
          key: { status: "valid", value: f },
          value: u._parse(
            new dn(i, l, i.path, f)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: f in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const f of c) {
        const l = await f.key;
        u.push({
          key: l,
          value: await f.value,
          alwaysSet: f.alwaysSet
        });
      }
      return u;
    }).then((u) => Gt.mergeObjectSync(n, u)) : Gt.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return new it({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var i, o, s, a;
          const c = (s = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, r, n).message) !== null && s !== void 0 ? s : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (a = ue.errToObj(t).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new it({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new it({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new it({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new it({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: ge.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new it({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return De.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new it({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return De.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new it({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Co(this);
  }
  partial(t) {
    const r = {};
    return De.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      t && !t[n] ? r[n] = i : r[n] = i.optional();
    }), new it({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return De.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let o = this.shape[n];
        for (; o instanceof Bn; )
          o = o._def.innerType;
        r[n] = o;
      }
    }), new it({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return C2(De.objectKeys(this.shape));
  }
}
it.create = (e, t) => new it({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Fn.create(),
  typeName: ge.ZodObject,
  ..._e(t)
});
it.strictCreate = (e, t) => new it({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Fn.create(),
  typeName: ge.ZodObject,
  ..._e(t)
});
it.lazycreate = (e, t) => new it({
  shape: e,
  unknownKeys: "strip",
  catchall: Fn.create(),
  typeName: ge.ZodObject,
  ..._e(t)
});
class Ms extends Oe {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function i(o) {
      for (const a of o)
        if (a.result.status === "valid")
          return a.result;
      for (const a of o)
        if (a.result.status === "dirty")
          return r.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((a) => new jr(a.ctx.common.issues));
      return te(r, {
        code: Z.invalid_union,
        unionErrors: s
      }), ve;
    }
    if (r.common.async)
      return Promise.all(n.map(async (o) => {
        const s = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await o._parseAsync({
            data: r.data,
            path: r.path,
            parent: s
          }),
          ctx: s
        };
      })).then(i);
    {
      let o;
      const s = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, f = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (f.status === "valid")
          return f;
        f.status === "dirty" && !o && (o = { result: f, ctx: u }), u.common.issues.length && s.push(u.common.issues);
      }
      if (o)
        return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((c) => new jr(c));
      return te(r, {
        code: Z.invalid_union,
        unionErrors: a
      }), ve;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ms.create = (e, t) => new Ms({
  options: e,
  typeName: ge.ZodUnion,
  ..._e(t)
});
const tc = (e) => e instanceof Vs ? tc(e.schema) : e instanceof qr ? tc(e.innerType()) : e instanceof Ws ? [e.value] : e instanceof Pi ? e.options : e instanceof Gs ? Object.keys(e.enum) : e instanceof Zs ? tc(e._def.innerType) : e instanceof js ? [void 0] : e instanceof Ds ? [null] : null;
class wu extends Oe {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ee.object)
      return te(r, {
        code: Z.invalid_type,
        expected: ee.object,
        received: r.parsedType
      }), ve;
    const n = this.discriminator, i = r.data[n], o = this.optionsMap.get(i);
    return o ? r.common.async ? o._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : o._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (te(r, {
      code: Z.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), ve);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const i = /* @__PURE__ */ new Map();
    for (const o of r) {
      const s = tc(o.shape[t]);
      if (!s)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const a of s) {
        if (i.has(a))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
        i.set(a, o);
      }
    }
    return new wu({
      typeName: ge.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: i,
      ..._e(n)
    });
  }
}
function Lf(e, t) {
  const r = xi(e), n = xi(t);
  if (e === t)
    return { valid: !0, data: e };
  if (r === ee.object && n === ee.object) {
    const i = De.objectKeys(t), o = De.objectKeys(e).filter((a) => i.indexOf(a) !== -1), s = { ...e, ...t };
    for (const a of o) {
      const c = Lf(e[a], t[a]);
      if (!c.valid)
        return { valid: !1 };
      s[a] = c.data;
    }
    return { valid: !0, data: s };
  } else if (r === ee.array && n === ee.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let o = 0; o < e.length; o++) {
      const s = e[o], a = t[o], c = Lf(s, a);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else return r === ee.date && n === ee.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Ks extends Oe {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = (o, s) => {
      if (Hf(o) || Hf(s))
        return ve;
      const a = Lf(o.value, s.value);
      return a.valid ? ((Rf(o) || Rf(s)) && r.dirty(), { status: r.value, value: a.data }) : (te(n, {
        code: Z.invalid_intersection_types
      }), ve);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([o, s]) => i(o, s)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Ks.create = (e, t, r) => new Ks({
  left: e,
  right: t,
  typeName: ge.ZodIntersection,
  ..._e(r)
});
class hn extends Oe {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ee.array)
      return te(n, {
        code: Z.invalid_type,
        expected: ee.array,
        received: n.parsedType
      }), ve;
    if (n.data.length < this._def.items.length)
      return te(n, {
        code: Z.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), ve;
    !this._def.rest && n.data.length > this._def.items.length && (te(n, {
      code: Z.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const o = [...n.data].map((s, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new dn(n, s, n.path, a)) : null;
    }).filter((s) => !!s);
    return n.common.async ? Promise.all(o).then((s) => Gt.mergeArray(r, s)) : Gt.mergeArray(r, o);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new hn({
      ...this._def,
      rest: t
    });
  }
}
hn.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new hn({
    items: e,
    typeName: ge.ZodTuple,
    rest: null,
    ..._e(t)
  });
};
class qs extends Oe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ee.object)
      return te(n, {
        code: Z.invalid_type,
        expected: ee.object,
        received: n.parsedType
      }), ve;
    const i = [], o = this._def.keyType, s = this._def.valueType;
    for (const a in n.data)
      i.push({
        key: o._parse(new dn(n, a, n.path, a)),
        value: s._parse(new dn(n, n.data[a], n.path, a))
      });
    return n.common.async ? Gt.mergeObjectAsync(r, i) : Gt.mergeObjectSync(r, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof Oe ? new qs({
      keyType: t,
      valueType: r,
      typeName: ge.ZodRecord,
      ..._e(n)
    }) : new qs({
      keyType: Rr.create(),
      valueType: t,
      typeName: ge.ZodRecord,
      ..._e(r)
    });
  }
}
class Lc extends Oe {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ee.map)
      return te(n, {
        code: Z.invalid_type,
        expected: ee.map,
        received: n.parsedType
      }), ve;
    const i = this._def.keyType, o = this._def.valueType, s = [...n.data.entries()].map(([a, c], u) => ({
      key: i._parse(new dn(n, a, n.path, [u, "key"])),
      value: o._parse(new dn(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of s) {
          const u = await c.key, f = await c.value;
          if (u.status === "aborted" || f.status === "aborted")
            return ve;
          (u.status === "dirty" || f.status === "dirty") && r.dirty(), a.set(u.value, f.value);
        }
        return { status: r.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of s) {
        const u = c.key, f = c.value;
        if (u.status === "aborted" || f.status === "aborted")
          return ve;
        (u.status === "dirty" || f.status === "dirty") && r.dirty(), a.set(u.value, f.value);
      }
      return { status: r.value, value: a };
    }
  }
}
Lc.create = (e, t, r) => new Lc({
  valueType: t,
  keyType: e,
  typeName: ge.ZodMap,
  ..._e(r)
});
class io extends Oe {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ee.set)
      return te(n, {
        code: Z.invalid_type,
        expected: ee.set,
        received: n.parsedType
      }), ve;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (te(n, {
      code: Z.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), r.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (te(n, {
      code: Z.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), r.dirty());
    const o = this._def.valueType;
    function s(c) {
      const u = /* @__PURE__ */ new Set();
      for (const f of c) {
        if (f.status === "aborted")
          return ve;
        f.status === "dirty" && r.dirty(), u.add(f.value);
      }
      return { status: r.value, value: u };
    }
    const a = [...n.data.values()].map((c, u) => o._parse(new dn(n, c, n.path, u)));
    return n.common.async ? Promise.all(a).then((c) => s(c)) : s(a);
  }
  min(t, r) {
    return new io({
      ...this._def,
      minSize: { value: t, message: ue.toString(r) }
    });
  }
  max(t, r) {
    return new io({
      ...this._def,
      maxSize: { value: t, message: ue.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
io.create = (e, t) => new io({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: ge.ZodSet,
  ..._e(t)
});
class Uo extends Oe {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ee.function)
      return te(r, {
        code: Z.invalid_type,
        expected: ee.function,
        received: r.parsedType
      }), ve;
    function n(a, c) {
      return Nc({
        data: a,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          $c(),
          Ls
        ].filter((u) => !!u),
        issueData: {
          code: Z.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(a, c) {
      return Nc({
        data: a,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          $c(),
          Ls
        ].filter((u) => !!u),
        issueData: {
          code: Z.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const o = { errorMap: r.common.contextualErrorMap }, s = r.data;
    return this._def.returns instanceof Go ? er(async (...a) => {
      const c = new jr([]), u = await this._def.args.parseAsync(a, o).catch((h) => {
        throw c.addIssue(n(a, h)), c;
      }), f = await s(...u);
      return await this._def.returns._def.type.parseAsync(f, o).catch((h) => {
        throw c.addIssue(i(f, h)), c;
      });
    }) : er((...a) => {
      const c = this._def.args.safeParse(a, o);
      if (!c.success)
        throw new jr([n(a, c.error)]);
      const u = s(...c.data), f = this._def.returns.safeParse(u, o);
      if (!f.success)
        throw new jr([i(u, f.error)]);
      return f.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Uo({
      ...this._def,
      args: hn.create(t).rest(Yi.create())
    });
  }
  returns(t) {
    return new Uo({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new Uo({
      args: t || hn.create([]).rest(Yi.create()),
      returns: r || Yi.create(),
      typeName: ge.ZodFunction,
      ..._e(n)
    });
  }
}
class Vs extends Oe {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
Vs.create = (e, t) => new Vs({
  getter: e,
  typeName: ge.ZodLazy,
  ..._e(t)
});
class Ws extends Oe {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return te(r, {
        received: r.data,
        code: Z.invalid_literal,
        expected: this._def.value
      }), ve;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Ws.create = (e, t) => new Ws({
  value: e,
  typeName: ge.ZodLiteral,
  ..._e(t)
});
function C2(e, t) {
  return new Pi({
    values: e,
    typeName: ge.ZodEnum,
    ..._e(t)
  });
}
class Pi extends Oe {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return te(r, {
        expected: De.joinValues(n),
        received: r.parsedType,
        code: Z.invalid_type
      }), ve;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return te(r, {
        received: r.data,
        code: Z.invalid_enum_value,
        options: n
      }), ve;
    }
    return er(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return Pi.create(t);
  }
  exclude(t) {
    return Pi.create(this.options.filter((r) => !t.includes(r)));
  }
}
Pi.create = C2;
class Gs extends Oe {
  _parse(t) {
    const r = De.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== ee.string && n.parsedType !== ee.number) {
      const i = De.objectValues(r);
      return te(n, {
        expected: De.joinValues(i),
        received: n.parsedType,
        code: Z.invalid_type
      }), ve;
    }
    if (r.indexOf(t.data) === -1) {
      const i = De.objectValues(r);
      return te(n, {
        received: n.data,
        code: Z.invalid_enum_value,
        options: i
      }), ve;
    }
    return er(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Gs.create = (e, t) => new Gs({
  values: e,
  typeName: ge.ZodNativeEnum,
  ..._e(t)
});
class Go extends Oe {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ee.promise && r.common.async === !1)
      return te(r, {
        code: Z.invalid_type,
        expected: ee.promise,
        received: r.parsedType
      }), ve;
    const n = r.parsedType === ee.promise ? r.data : Promise.resolve(r.data);
    return er(n.then((i) => this._def.type.parseAsync(i, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
Go.create = (e, t) => new Go({
  type: e,
  typeName: ge.ZodPromise,
  ..._e(t)
});
class qr extends Oe {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ge.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), i = this._def.effect || null;
    if (i.type === "preprocess") {
      const s = i.transform(n.data);
      return n.common.async ? Promise.resolve(s).then((a) => this._def.schema._parseAsync({
        data: a,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: s,
        path: n.path,
        parent: n
      });
    }
    const o = {
      addIssue: (s) => {
        te(n, s), s.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (o.addIssue = o.addIssue.bind(o), i.type === "refinement") {
      const s = (a) => {
        const c = i.refinement(a, o);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? ve : (a.status === "dirty" && r.dirty(), s(a.value), { status: r.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => a.status === "aborted" ? ve : (a.status === "dirty" && r.dirty(), s(a.value).then(() => ({ status: r.value, value: a.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Uc(s))
          return s;
        const a = i.transform(s.value, o);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => Uc(s) ? Promise.resolve(i.transform(s.value, o)).then((a) => ({ status: r.value, value: a })) : s);
    De.assertNever(i);
  }
}
qr.create = (e, t, r) => new qr({
  schema: e,
  typeName: ge.ZodEffects,
  effect: t,
  ..._e(r)
});
qr.createWithPreprocess = (e, t, r) => new qr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: ge.ZodEffects,
  ..._e(r)
});
class Bn extends Oe {
  _parse(t) {
    return this._getType(t) === ee.undefined ? er(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Bn.create = (e, t) => new Bn({
  innerType: e,
  typeName: ge.ZodOptional,
  ..._e(t)
});
class oo extends Oe {
  _parse(t) {
    return this._getType(t) === ee.null ? er(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
oo.create = (e, t) => new oo({
  innerType: e,
  typeName: ge.ZodNullable,
  ..._e(t)
});
class Zs extends Oe {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === ee.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Zs.create = (e, t) => new Zs({
  innerType: e,
  typeName: ge.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ..._e(t)
});
class zc extends Oe {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Fc(i) ? i.then((o) => ({
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new jr(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new jr(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
zc.create = (e, t) => new zc({
  innerType: e,
  typeName: ge.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ..._e(t)
});
class jc extends Oe {
  _parse(t) {
    if (this._getType(t) !== ee.nan) {
      const n = this._getOrReturnCtx(t);
      return te(n, {
        code: Z.invalid_type,
        expected: ee.nan,
        received: n.parsedType
      }), ve;
    }
    return { status: "valid", value: t.data };
  }
}
jc.create = (e) => new jc({
  typeName: ge.ZodNaN,
  ..._e(e)
});
const N_ = Symbol("zod_brand");
class P2 extends Oe {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ha extends Oe {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const o = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? ve : o.status === "dirty" ? (r.dirty(), T2(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? ve : i.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new ha({
      in: t,
      out: r,
      typeName: ge.ZodPipeline
    });
  }
}
const I2 = (e, t = {}, r) => e ? Wo.create().superRefine((n, i) => {
  var o, s;
  if (!e(n)) {
    const a = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, c = (s = (o = a.fatal) !== null && o !== void 0 ? o : r) !== null && s !== void 0 ? s : !0, u = typeof a == "string" ? { message: a } : a;
    i.addIssue({ code: "custom", ...u, fatal: c });
  }
}) : Wo.create(), U_ = {
  object: it.lazycreate
};
var ge;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(ge || (ge = {}));
const F_ = (e, t = {
  message: `Input not instance of ${e.name}`
}) => I2((r) => r instanceof e, t), B2 = Rr.create, O2 = Ti.create, H_ = jc.create, R_ = Ci.create, $2 = zs.create, L_ = no.create, z_ = Hc.create, j_ = js.create, D_ = Ds.create, M_ = Wo.create, K_ = Yi.create, q_ = Fn.create, V_ = Rc.create, W_ = Dr.create, G_ = it.create, Z_ = it.strictCreate, X_ = Ms.create, Y_ = wu.create, J_ = Ks.create, Q_ = hn.create, ek = qs.create, tk = Lc.create, rk = io.create, nk = Uo.create, ik = Vs.create, ok = Ws.create, sk = Pi.create, ak = Gs.create, ck = Go.create, c1 = qr.create, uk = Bn.create, lk = oo.create, fk = qr.createWithPreprocess, dk = ha.create, hk = () => B2().optional(), pk = () => O2().optional(), gk = () => $2().optional(), mk = {
  string: (e) => Rr.create({ ...e, coerce: !0 }),
  number: (e) => Ti.create({ ...e, coerce: !0 }),
  boolean: (e) => zs.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Ci.create({ ...e, coerce: !0 }),
  date: (e) => no.create({ ...e, coerce: !0 })
}, bk = ve;
var Jt = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Ls,
  setErrorMap: x_,
  getErrorMap: $c,
  makeIssue: Nc,
  EMPTY_PATH: E_,
  addIssueToContext: te,
  ParseStatus: Gt,
  INVALID: ve,
  DIRTY: T2,
  OK: er,
  isAborted: Hf,
  isDirty: Rf,
  isValid: Uc,
  isAsync: Fc,
  get util() {
    return De;
  },
  get objectUtil() {
    return Ff;
  },
  ZodParsedType: ee,
  getParsedType: xi,
  ZodType: Oe,
  ZodString: Rr,
  ZodNumber: Ti,
  ZodBigInt: Ci,
  ZodBoolean: zs,
  ZodDate: no,
  ZodSymbol: Hc,
  ZodUndefined: js,
  ZodNull: Ds,
  ZodAny: Wo,
  ZodUnknown: Yi,
  ZodNever: Fn,
  ZodVoid: Rc,
  ZodArray: Dr,
  ZodObject: it,
  ZodUnion: Ms,
  ZodDiscriminatedUnion: wu,
  ZodIntersection: Ks,
  ZodTuple: hn,
  ZodRecord: qs,
  ZodMap: Lc,
  ZodSet: io,
  ZodFunction: Uo,
  ZodLazy: Vs,
  ZodLiteral: Ws,
  ZodEnum: Pi,
  ZodNativeEnum: Gs,
  ZodPromise: Go,
  ZodEffects: qr,
  ZodTransformer: qr,
  ZodOptional: Bn,
  ZodNullable: oo,
  ZodDefault: Zs,
  ZodCatch: zc,
  ZodNaN: jc,
  BRAND: N_,
  ZodBranded: P2,
  ZodPipeline: ha,
  custom: I2,
  Schema: Oe,
  ZodSchema: Oe,
  late: U_,
  get ZodFirstPartyTypeKind() {
    return ge;
  },
  coerce: mk,
  any: M_,
  array: W_,
  bigint: R_,
  boolean: $2,
  date: L_,
  discriminatedUnion: Y_,
  effect: c1,
  enum: sk,
  function: nk,
  instanceof: F_,
  intersection: J_,
  lazy: ik,
  literal: ok,
  map: tk,
  nan: H_,
  nativeEnum: ak,
  never: q_,
  null: D_,
  nullable: lk,
  number: O2,
  object: G_,
  oboolean: gk,
  onumber: pk,
  optional: uk,
  ostring: hk,
  pipeline: dk,
  preprocess: fk,
  promise: ck,
  record: ek,
  set: rk,
  strictObject: Z_,
  string: B2,
  symbol: z_,
  transformer: c1,
  tuple: Q_,
  undefined: j_,
  union: X_,
  unknown: K_,
  void: V_,
  NEVER: bk,
  ZodIssueCode: Z,
  quotelessJson: v_,
  ZodError: jr
});
const N2 = Jt.string().regex(/^[a-fA-F0-9]$/), yk = Jt.string().regex(/^[a-fA-F0-9]{64}$/), Zo = Jt.number().min(0).max(4294967295), wk = Jt.bigint(), U2 = Jt.instanceof(Uint8Array), vk = Jt.union([N2, Zo, Jt.string(), U2]).array(), dh = Jt.union([vk, N2, U2]), xk = Jt.array(dh), F2 = Jt.object({
  value: Jt.union([Zo, wk]),
  scriptPubKey: dh
}), Ek = Jt.object({
  txid: yk,
  vout: Zo,
  scriptSig: dh,
  sequence: Zo,
  prevout: F2.optional(),
  witness: xk
});
Jt.object({
  version: Zo,
  vin: Jt.array(Ek),
  vout: Jt.array(F2),
  locktime: Zo
});
var lt = {}, hh = {};
const Ak = {}, Sk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ak
}, Symbol.toStringTag, { value: "Module" })), H2 = /* @__PURE__ */ xw(Sk);
(function(e) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.Signature = e.Point = e.CURVE = void 0;
  const t = H2, r = BigInt(0), n = BigInt(1), i = BigInt(2), o = BigInt(3), s = BigInt(8), a = Object.freeze({
    a: r,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  e.CURVE = a;
  const c = (C, E) => (C + E / i) / E, u = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(C) {
      const { n: E } = a, T = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), O = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), z = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), K = T, Y = BigInt("0x100000000000000000000000000000000"), J = c(K * C, E), de = c(-O * C, E);
      let ce = V(C - J * T - de * z, E), xe = V(-J * O - de * K, E);
      const Fe = ce > Y, Re = xe > Y;
      if (Fe && (ce = E - ce), Re && (xe = E - xe), ce > Y || xe > Y)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + C);
      return { k1neg: Fe, k1: ce, k2neg: Re, k2: xe };
    }
  }, f = 32, l = 32, h = 32, m = f + 1, y = 2 * f + 1;
  function b(C) {
    const { a: E, b: T } = a, O = V(C * C), z = V(O * C);
    return V(z + E * C + T);
  }
  const g = a.a === r;
  class v extends Error {
    constructor(E) {
      super(E);
    }
  }
  function _(C) {
    if (!(C instanceof x))
      throw new TypeError("JacobianPoint expected");
  }
  class x {
    constructor(E, T, O) {
      this.x = E, this.y = T, this.z = O;
    }
    static fromAffine(E) {
      if (!(E instanceof I))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return E.equals(I.ZERO) ? x.ZERO : new x(E.x, E.y, n);
    }
    static toAffineBatch(E) {
      const T = Lt(E.map((O) => O.z));
      return E.map((O, z) => O.toAffine(T[z]));
    }
    static normalizeZ(E) {
      return x.toAffineBatch(E).map(x.fromAffine);
    }
    equals(E) {
      _(E);
      const { x: T, y: O, z } = this, { x: K, y: Y, z: J } = E, de = V(z * z), ce = V(J * J), xe = V(T * ce), Fe = V(K * de), Re = V(V(O * J) * ce), _t = V(V(Y * z) * de);
      return xe === Fe && Re === _t;
    }
    negate() {
      return new x(this.x, V(-this.y), this.z);
    }
    double() {
      const { x: E, y: T, z: O } = this, z = V(E * E), K = V(T * T), Y = V(K * K), J = E + K, de = V(i * (V(J * J) - z - Y)), ce = V(o * z), xe = V(ce * ce), Fe = V(xe - i * de), Re = V(ce * (de - Fe) - s * Y), _t = V(i * T * O);
      return new x(Fe, Re, _t);
    }
    add(E) {
      _(E);
      const { x: T, y: O, z } = this, { x: K, y: Y, z: J } = E;
      if (K === r || Y === r)
        return this;
      if (T === r || O === r)
        return E;
      const de = V(z * z), ce = V(J * J), xe = V(T * ce), Fe = V(K * de), Re = V(V(O * J) * ce), _t = V(V(Y * z) * de), vt = V(Fe - xe), $r = V(_t - Re);
      if (vt === r)
        return $r === r ? this.double() : x.ZERO;
      const wo = V(vt * vt), vo = V(vt * wo), xo = V(xe * wo), ka = V($r * $r - vo - i * xo), nl = V($r * (xo - ka) - Re * vo), ds = V(z * J * vt);
      return new x(ka, nl, ds);
    }
    subtract(E) {
      return this.add(E.negate());
    }
    multiplyUnsafe(E) {
      const T = x.ZERO;
      if (typeof E == "bigint" && E === r)
        return T;
      let O = ke(E);
      if (O === n)
        return this;
      if (!g) {
        let Fe = T, Re = this;
        for (; O > r; )
          O & n && (Fe = Fe.add(Re)), Re = Re.double(), O >>= n;
        return Fe;
      }
      let { k1neg: z, k1: K, k2neg: Y, k2: J } = u.splitScalar(O), de = T, ce = T, xe = this;
      for (; K > r || J > r; )
        K & n && (de = de.add(xe)), J & n && (ce = ce.add(xe)), xe = xe.double(), K >>= n, J >>= n;
      return z && (de = de.negate()), Y && (ce = ce.negate()), ce = new x(V(ce.x * u.beta), ce.y, ce.z), de.add(ce);
    }
    precomputeWindow(E) {
      const T = g ? 128 / E + 1 : 256 / E + 1, O = [];
      let z = this, K = z;
      for (let Y = 0; Y < T; Y++) {
        K = z, O.push(K);
        for (let J = 1; J < 2 ** (E - 1); J++)
          K = K.add(z), O.push(K);
        z = K.double();
      }
      return O;
    }
    wNAF(E, T) {
      !T && this.equals(x.BASE) && (T = I.BASE);
      const O = T && T._WINDOW_SIZE || 1;
      if (256 % O)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let z = T && P.get(T);
      z || (z = this.precomputeWindow(O), T && O !== 1 && (z = x.normalizeZ(z), P.set(T, z)));
      let K = x.ZERO, Y = x.BASE;
      const J = 1 + (g ? 128 / O : 256 / O), de = 2 ** (O - 1), ce = BigInt(2 ** O - 1), xe = 2 ** O, Fe = BigInt(O);
      for (let Re = 0; Re < J; Re++) {
        const _t = Re * de;
        let vt = Number(E & ce);
        E >>= Fe, vt > de && (vt -= xe, E += n);
        const $r = _t, wo = _t + Math.abs(vt) - 1, vo = Re % 2 !== 0, xo = vt < 0;
        vt === 0 ? Y = Y.add(k(vo, z[$r])) : K = K.add(k(xo, z[wo]));
      }
      return { p: K, f: Y };
    }
    multiply(E, T) {
      let O = ke(E), z, K;
      if (g) {
        const { k1neg: Y, k1: J, k2neg: de, k2: ce } = u.splitScalar(O);
        let { p: xe, f: Fe } = this.wNAF(J, T), { p: Re, f: _t } = this.wNAF(ce, T);
        xe = k(Y, xe), Re = k(de, Re), Re = new x(V(Re.x * u.beta), Re.y, Re.z), z = xe.add(Re), K = Fe.add(_t);
      } else {
        const { p: Y, f: J } = this.wNAF(O, T);
        z = Y, K = J;
      }
      return x.normalizeZ([z, K])[0];
    }
    toAffine(E) {
      const { x: T, y: O, z } = this, K = this.equals(x.ZERO);
      E == null && (E = K ? s : et(z));
      const Y = E, J = V(Y * Y), de = V(J * Y), ce = V(T * J), xe = V(O * de), Fe = V(z * Y);
      if (K)
        return I.ZERO;
      if (Fe !== n)
        throw new Error("invZ was invalid");
      return new I(ce, xe);
    }
  }
  x.BASE = new x(a.Gx, a.Gy, n), x.ZERO = new x(r, n, r);
  function k(C, E) {
    const T = E.negate();
    return C ? T : E;
  }
  const P = /* @__PURE__ */ new WeakMap();
  class I {
    constructor(E, T) {
      this.x = E, this.y = T;
    }
    _setWindowSize(E) {
      this._WINDOW_SIZE = E, P.delete(this);
    }
    hasEvenY() {
      return this.y % i === r;
    }
    static fromCompressedHex(E) {
      const T = E.length === 32, O = pe(T ? E : E.subarray(1));
      if (!wt(O))
        throw new Error("Point is not on curve");
      const z = b(O);
      let K = Rt(z);
      const Y = (K & n) === n;
      T ? Y && (K = V(-K)) : (E[0] & 1) === 1 !== Y && (K = V(-K));
      const J = new I(O, K);
      return J.assertValidity(), J;
    }
    static fromUncompressedHex(E) {
      const T = pe(E.subarray(1, f + 1)), O = pe(E.subarray(f + 1, f * 2 + 1)), z = new I(T, O);
      return z.assertValidity(), z;
    }
    static fromHex(E) {
      const T = se(E), O = T.length, z = T[0];
      if (O === f)
        return this.fromCompressedHex(T);
      if (O === m && (z === 2 || z === 3))
        return this.fromCompressedHex(T);
      if (O === y && z === 4)
        return this.fromUncompressedHex(T);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${m} compressed bytes or ${y} uncompressed bytes, not ${O}`);
    }
    static fromPrivateKey(E) {
      return I.BASE.multiply(xr(E));
    }
    static fromSignature(E, T, O) {
      const { r: z, s: K } = Ea(T);
      if (![0, 1, 2, 3].includes(O))
        throw new Error("Cannot recover: invalid recovery bit");
      const Y = ht(se(E)), { n: J } = a, de = O === 2 || O === 3 ? z + J : z, ce = et(de, J), xe = V(-Y * ce, J), Fe = V(K * ce, J), Re = O & 1 ? "03" : "02", _t = I.fromHex(Re + $(de)), vt = I.BASE.multiplyAndAddUnsafe(_t, xe, Fe);
      if (!vt)
        throw new Error("Cannot recover signature: point at infinify");
      return vt.assertValidity(), vt;
    }
    toRawBytes(E = !1) {
      return ie(this.toHex(E));
    }
    toHex(E = !1) {
      const T = $(this.x);
      return E ? `${this.hasEvenY() ? "02" : "03"}${T}` : `04${T}${$(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const E = "Point is not on elliptic curve", { x: T, y: O } = this;
      if (!wt(T) || !wt(O))
        throw new Error(E);
      const z = V(O * O), K = b(T);
      if (V(z - K) !== r)
        throw new Error(E);
    }
    equals(E) {
      return this.x === E.x && this.y === E.y;
    }
    negate() {
      return new I(this.x, V(-this.y));
    }
    double() {
      return x.fromAffine(this).double().toAffine();
    }
    add(E) {
      return x.fromAffine(this).add(x.fromAffine(E)).toAffine();
    }
    subtract(E) {
      return this.add(E.negate());
    }
    multiply(E) {
      return x.fromAffine(this).multiply(E, this).toAffine();
    }
    multiplyAndAddUnsafe(E, T, O) {
      const z = x.fromAffine(this), K = T === r || T === n || this !== I.BASE ? z.multiplyUnsafe(T) : z.multiply(T), Y = x.fromAffine(E).multiplyUnsafe(O), J = K.add(Y);
      return J.equals(x.ZERO) ? void 0 : J.toAffine();
    }
  }
  e.Point = I, I.BASE = new I(a.Gx, a.Gy), I.ZERO = new I(r, r);
  function R(C) {
    return Number.parseInt(C[0], 16) >= 8 ? "00" + C : C;
  }
  function j(C) {
    if (C.length < 2 || C[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${G(C)}`);
    const E = C[1], T = C.subarray(2, E + 2);
    if (!E || T.length !== E)
      throw new Error("Invalid signature integer: wrong length");
    if (T[0] === 0 && T[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: pe(T), left: C.subarray(E + 2) };
  }
  function W(C) {
    if (C.length < 2 || C[0] != 48)
      throw new Error(`Invalid signature tag: ${G(C)}`);
    if (C[1] !== C.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: E, left: T } = j(C.subarray(2)), { data: O, left: z } = j(T);
    if (z.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${G(z)}`);
    return { r: E, s: O };
  }
  class re {
    constructor(E, T) {
      this.r = E, this.s = T, this.assertValidity();
    }
    static fromCompact(E) {
      const T = E instanceof Uint8Array, O = "Signature.fromCompact";
      if (typeof E != "string" && !T)
        throw new TypeError(`${O}: Expected string or Uint8Array`);
      const z = T ? G(E) : E;
      if (z.length !== 128)
        throw new Error(`${O}: Expected 64-byte hex`);
      return new re(ne(z.slice(0, 64)), ne(z.slice(64, 128)));
    }
    static fromDER(E) {
      const T = E instanceof Uint8Array;
      if (typeof E != "string" && !T)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: O, s: z } = W(T ? E : ie(E));
      return new re(O, z);
    }
    static fromHex(E) {
      return this.fromDER(E);
    }
    assertValidity() {
      const { r: E, s: T } = this;
      if (!je(E))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!je(T))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const E = a.n >> n;
      return this.s > E;
    }
    normalizeS() {
      return this.hasHighS() ? new re(this.r, V(-this.s, a.n)) : this;
    }
    toDERRawBytes() {
      return ie(this.toDERHex());
    }
    toDERHex() {
      const E = R(q(this.s)), T = R(q(this.r)), O = E.length / 2, z = T.length / 2, K = q(O), Y = q(z);
      return `30${q(z + O + 4)}02${Y}${T}02${K}${E}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return ie(this.toCompactHex());
    }
    toCompactHex() {
      return $(this.r) + $(this.s);
    }
  }
  e.Signature = re;
  function X(...C) {
    if (!C.every((O) => O instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (C.length === 1)
      return C[0];
    const E = C.reduce((O, z) => O + z.length, 0), T = new Uint8Array(E);
    for (let O = 0, z = 0; O < C.length; O++) {
      const K = C[O];
      T.set(K, z), z += K.length;
    }
    return T;
  }
  const N = Array.from({ length: 256 }, (C, E) => E.toString(16).padStart(2, "0"));
  function G(C) {
    if (!(C instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let E = "";
    for (let T = 0; T < C.length; T++)
      E += N[C[T]];
    return E;
  }
  const M = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function $(C) {
    if (typeof C != "bigint")
      throw new Error("Expected bigint");
    if (!(r <= C && C < M))
      throw new Error("Expected number 0 <= n < 2^256");
    return C.toString(16).padStart(64, "0");
  }
  function H(C) {
    const E = ie($(C));
    if (E.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return E;
  }
  function q(C) {
    const E = C.toString(16);
    return E.length & 1 ? `0${E}` : E;
  }
  function ne(C) {
    if (typeof C != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof C);
    return BigInt(`0x${C}`);
  }
  function ie(C) {
    if (typeof C != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof C);
    if (C.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + C.length);
    const E = new Uint8Array(C.length / 2);
    for (let T = 0; T < E.length; T++) {
      const O = T * 2, z = C.slice(O, O + 2), K = Number.parseInt(z, 16);
      if (Number.isNaN(K) || K < 0)
        throw new Error("Invalid byte sequence");
      E[T] = K;
    }
    return E;
  }
  function pe(C) {
    return ne(G(C));
  }
  function se(C) {
    return C instanceof Uint8Array ? Uint8Array.from(C) : ie(C);
  }
  function ke(C) {
    if (typeof C == "number" && Number.isSafeInteger(C) && C > 0)
      return BigInt(C);
    if (typeof C == "bigint" && je(C))
      return C;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function V(C, E = a.P) {
    const T = C % E;
    return T >= r ? T : E + T;
  }
  function He(C, E) {
    const { P: T } = a;
    let O = C;
    for (; E-- > r; )
      O *= O, O %= T;
    return O;
  }
  function Rt(C) {
    const { P: E } = a, T = BigInt(6), O = BigInt(11), z = BigInt(22), K = BigInt(23), Y = BigInt(44), J = BigInt(88), de = C * C * C % E, ce = de * de * C % E, xe = He(ce, o) * ce % E, Fe = He(xe, o) * ce % E, Re = He(Fe, i) * de % E, _t = He(Re, O) * Re % E, vt = He(_t, z) * _t % E, $r = He(vt, Y) * vt % E, wo = He($r, J) * $r % E, vo = He(wo, Y) * vt % E, xo = He(vo, o) * ce % E, ka = He(xo, K) * _t % E, nl = He(ka, T) * de % E, ds = He(nl, i);
    if (ds * ds % E !== C)
      throw new Error("Cannot find square root");
    return ds;
  }
  function et(C, E = a.P) {
    if (C === r || E <= r)
      throw new Error(`invert: expected positive integers, got n=${C} mod=${E}`);
    let T = V(C, E), O = E, z = r, K = n;
    for (; T !== r; ) {
      const J = O / T, de = O % T, ce = z - K * J;
      O = T, T = de, z = K, K = ce;
    }
    if (O !== n)
      throw new Error("invert: does not exist");
    return V(z, E);
  }
  function Lt(C, E = a.P) {
    const T = new Array(C.length), O = C.reduce((K, Y, J) => Y === r ? K : (T[J] = K, V(K * Y, E)), n), z = et(O, E);
    return C.reduceRight((K, Y, J) => Y === r ? K : (T[J] = V(K * T[J], E), V(K * Y, E)), z), T;
  }
  function yt(C) {
    const E = C.length * 8 - l * 8, T = pe(C);
    return E > 0 ? T >> BigInt(E) : T;
  }
  function ht(C, E = !1) {
    const T = yt(C);
    if (E)
      return T;
    const { n: O } = a;
    return T >= O ? T - O : T;
  }
  let St, zt;
  class tt {
    constructor(E, T) {
      if (this.hashLen = E, this.qByteLen = T, typeof E != "number" || E < 2)
        throw new Error("hashLen must be a number");
      if (typeof T != "number" || T < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(E).fill(1), this.k = new Uint8Array(E).fill(0), this.counter = 0;
    }
    hmac(...E) {
      return e.utils.hmacSha256(this.k, ...E);
    }
    hmacSync(...E) {
      return zt(this.k, ...E);
    }
    checkSync() {
      if (typeof zt != "function")
        throw new v("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(E = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), E), this.v = await this.hmac(this.v), E.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), E), this.v = await this.hmac(this.v));
    }
    reseedSync(E = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), E), this.v = this.hmacSync(this.v), E.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), E), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let E = 0;
      const T = [];
      for (; E < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const O = this.v.slice();
        T.push(O), E += this.v.length;
      }
      return X(...T);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let E = 0;
      const T = [];
      for (; E < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const O = this.v.slice();
        T.push(O), E += this.v.length;
      }
      return X(...T);
    }
  }
  function je(C) {
    return r < C && C < a.n;
  }
  function wt(C) {
    return r < C && C < a.P;
  }
  function Yr(C, E, T, O = !0) {
    const { n: z } = a, K = ht(C, !0);
    if (!je(K))
      return;
    const Y = et(K, z), J = I.BASE.multiply(K), de = V(J.x, z);
    if (de === r)
      return;
    const ce = V(Y * V(E + T * de, z), z);
    if (ce === r)
      return;
    let xe = new re(de, ce), Fe = (J.x === xe.r ? 0 : 2) | Number(J.y & n);
    return O && xe.hasHighS() && (xe = xe.normalizeS(), Fe ^= 1), { sig: xe, recovery: Fe };
  }
  function xr(C) {
    let E;
    if (typeof C == "bigint")
      E = C;
    else if (typeof C == "number" && Number.isSafeInteger(C) && C > 0)
      E = BigInt(C);
    else if (typeof C == "string") {
      if (C.length !== 2 * l)
        throw new Error("Expected 32 bytes of private key");
      E = ne(C);
    } else if (C instanceof Uint8Array) {
      if (C.length !== l)
        throw new Error("Expected 32 bytes of private key");
      E = pe(C);
    } else
      throw new TypeError("Expected valid private key");
    if (!je(E))
      throw new Error("Expected private key: 0 < key < n");
    return E;
  }
  function Ni(C) {
    return C instanceof I ? (C.assertValidity(), C) : I.fromHex(C);
  }
  function Ea(C) {
    if (C instanceof re)
      return C.assertValidity(), C;
    try {
      return re.fromDER(C);
    } catch {
      return re.fromCompact(C);
    }
  }
  function tl(C, E = !1) {
    return I.fromPrivateKey(C).toRawBytes(E);
  }
  e.getPublicKey = tl;
  function Aa(C, E, T, O = !1) {
    return I.fromSignature(C, E, T).toRawBytes(O);
  }
  e.recoverPublicKey = Aa;
  function Ui(C) {
    const E = C instanceof Uint8Array, T = typeof C == "string", O = (E || T) && C.length;
    return E ? O === m || O === y : T ? O === m * 2 || O === y * 2 : C instanceof I;
  }
  function Er(C, E, T = !1) {
    if (Ui(C))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Ui(E))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const O = Ni(E);
    return O.assertValidity(), O.multiply(xr(C)).toRawBytes(T);
  }
  e.getSharedSecret = Er;
  function yo(C) {
    const E = C.length > f ? C.slice(0, f) : C;
    return pe(E);
  }
  function rl(C) {
    const E = yo(C), T = V(E, a.n);
    return Or(T < r ? E : T);
  }
  function Or(C) {
    return H(C);
  }
  function Sa(C, E, T) {
    if (C == null)
      throw new Error(`sign: expected valid message hash, not "${C}"`);
    const O = se(C), z = xr(E), K = [Or(z), rl(O)];
    if (T != null) {
      T === !0 && (T = e.utils.randomBytes(f));
      const de = se(T);
      if (de.length !== f)
        throw new Error(`sign: Expected ${f} bytes of extra data`);
      K.push(de);
    }
    const Y = X(...K), J = yo(O);
    return { seed: Y, m: J, d: z };
  }
  function w(C, E) {
    const { sig: T, recovery: O } = C, { der: z, recovered: K } = Object.assign({ canonical: !0, der: !0 }, E), Y = z ? T.toDERRawBytes() : T.toCompactRawBytes();
    return K ? [Y, O] : Y;
  }
  async function d(C, E, T = {}) {
    const { seed: O, m: z, d: K } = Sa(C, E, T.extraEntropy), Y = new tt(h, l);
    await Y.reseed(O);
    let J;
    for (; !(J = Yr(await Y.generate(), z, K, T.canonical)); )
      await Y.reseed();
    return w(J, T);
  }
  e.sign = d;
  function p(C, E, T = {}) {
    const { seed: O, m: z, d: K } = Sa(C, E, T.extraEntropy), Y = new tt(h, l);
    Y.reseedSync(O);
    let J;
    for (; !(J = Yr(Y.generateSync(), z, K, T.canonical)); )
      Y.reseedSync();
    return w(J, T);
  }
  e.signSync = p;
  const A = { strict: !0 };
  function B(C, E, T, O = A) {
    let z;
    try {
      z = Ea(C), E = se(E);
    } catch {
      return !1;
    }
    const { r: K, s: Y } = z;
    if (O.strict && z.hasHighS())
      return !1;
    const J = ht(E);
    let de;
    try {
      de = Ni(T);
    } catch {
      return !1;
    }
    const { n: ce } = a, xe = et(Y, ce), Fe = V(J * xe, ce), Re = V(K * xe, ce), _t = I.BASE.multiplyAndAddUnsafe(de, Fe, Re);
    return _t ? V(_t.x, ce) === K : !1;
  }
  e.verify = B;
  function F(C) {
    return V(pe(C), a.n);
  }
  class D {
    constructor(E, T) {
      this.r = E, this.s = T, this.assertValidity();
    }
    static fromHex(E) {
      const T = se(E);
      if (T.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${T.length}`);
      const O = pe(T.subarray(0, 32)), z = pe(T.subarray(32, 64));
      return new D(O, z);
    }
    assertValidity() {
      const { r: E, s: T } = this;
      if (!wt(E) || !je(T))
        throw new Error("Invalid signature");
    }
    toHex() {
      return $(this.r) + $(this.s);
    }
    toRawBytes() {
      return ie(this.toHex());
    }
  }
  function Ie(C) {
    return I.fromPrivateKey(C).toRawX();
  }
  class Je {
    constructor(E, T, O = e.utils.randomBytes()) {
      if (E == null)
        throw new TypeError(`sign: Expected valid message, not "${E}"`);
      this.m = se(E);
      const { x: z, scalar: K } = this.getScalar(xr(T));
      if (this.px = z, this.d = K, this.rand = se(O), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(E) {
      const T = I.fromPrivateKey(E), O = T.hasEvenY() ? E : a.n - E;
      return { point: T, scalar: O, x: T.toRawX() };
    }
    initNonce(E, T) {
      return H(E ^ pe(T));
    }
    finalizeNonce(E) {
      const T = V(pe(E), a.n);
      if (T === r)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: O, x: z, scalar: K } = this.getScalar(T);
      return { R: O, rx: z, k: K };
    }
    finalizeSig(E, T, O, z) {
      return new D(E.x, V(T + O * z, a.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: E, d: T, px: O, rand: z } = this, K = e.utils.taggedHash, Y = this.initNonce(T, await K(Dn.aux, z)), { R: J, rx: de, k: ce } = this.finalizeNonce(await K(Dn.nonce, Y, O, E)), xe = F(await K(Dn.challenge, de, O, E)), Fe = this.finalizeSig(J, ce, xe, T);
      return await Kh(Fe, E, O) || this.error(), Fe;
    }
    calcSync() {
      const { m: E, d: T, px: O, rand: z } = this, K = e.utils.taggedHashSync, Y = this.initNonce(T, K(Dn.aux, z)), { R: J, rx: de, k: ce } = this.finalizeNonce(K(Dn.nonce, Y, O, E)), xe = F(K(Dn.challenge, de, O, E)), Fe = this.finalizeSig(J, ce, xe, T);
      return qh(Fe, E, O) || this.error(), Fe;
    }
  }
  async function Ze(C, E, T) {
    return new Je(C, E, T).calc();
  }
  function rt(C, E, T) {
    return new Je(C, E, T).calcSync();
  }
  function Ke(C, E, T) {
    const O = C instanceof D, z = O ? C : D.fromHex(C);
    return O && z.assertValidity(), {
      ...z,
      m: se(E),
      P: Ni(T)
    };
  }
  function Mh(C, E, T, O) {
    const z = I.BASE.multiplyAndAddUnsafe(E, xr(T), V(-O, a.n));
    return !(!z || !z.hasEvenY() || z.x !== C);
  }
  async function Kh(C, E, T) {
    try {
      const { r: O, s: z, m: K, P: Y } = Ke(C, E, T), J = F(await e.utils.taggedHash(Dn.challenge, H(O), Y.toRawX(), K));
      return Mh(O, Y, z, J);
    } catch {
      return !1;
    }
  }
  function qh(C, E, T) {
    try {
      const { r: O, s: z, m: K, P: Y } = Ke(C, E, T), J = F(e.utils.taggedHashSync(Dn.challenge, H(O), Y.toRawX(), K));
      return Mh(O, Y, z, J);
    } catch (O) {
      if (O instanceof v)
        throw O;
      return !1;
    }
  }
  e.schnorr = {
    Signature: D,
    getPublicKey: Ie,
    sign: Ze,
    verify: Kh,
    signSync: rt,
    verifySync: qh
  }, I.BASE._setWindowSize(8);
  const hr = {
    node: t,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Dn = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, _a = {};
  e.utils = {
    bytesToHex: G,
    hexToBytes: ie,
    concatBytes: X,
    mod: V,
    invert: et,
    isValidPrivateKey(C) {
      try {
        return xr(C), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: H,
    _normalizePrivateKey: xr,
    hashToPrivateKey: (C) => {
      C = se(C);
      const E = l + 8;
      if (C.length < E || C.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const T = V(pe(C), a.n - n) + n;
      return H(T);
    },
    randomBytes: (C = 32) => {
      if (hr.web)
        return hr.web.getRandomValues(new Uint8Array(C));
      if (hr.node) {
        const { randomBytes: E } = hr.node;
        return Uint8Array.from(E(C));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => e.utils.hashToPrivateKey(e.utils.randomBytes(l + 8)),
    precompute(C = 8, E = I.BASE) {
      const T = E === I.BASE ? E : new I(E.x, E.y);
      return T._setWindowSize(C), T.multiply(o), T;
    },
    sha256: async (...C) => {
      if (hr.web) {
        const E = await hr.web.subtle.digest("SHA-256", X(...C));
        return new Uint8Array(E);
      } else if (hr.node) {
        const { createHash: E } = hr.node, T = E("sha256");
        return C.forEach((O) => T.update(O)), Uint8Array.from(T.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (C, ...E) => {
      if (hr.web) {
        const T = await hr.web.subtle.importKey("raw", C, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), O = X(...E), z = await hr.web.subtle.sign("HMAC", T, O);
        return new Uint8Array(z);
      } else if (hr.node) {
        const { createHmac: T } = hr.node, O = T("sha256", C);
        return E.forEach((z) => O.update(z)), Uint8Array.from(O.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (C, ...E) => {
      let T = _a[C];
      if (T === void 0) {
        const O = await e.utils.sha256(Uint8Array.from(C, (z) => z.charCodeAt(0)));
        T = X(O, O), _a[C] = T;
      }
      return e.utils.sha256(T, ...E);
    },
    taggedHashSync: (C, ...E) => {
      if (typeof St != "function")
        throw new v("sha256Sync is undefined, you need to set it");
      let T = _a[C];
      if (T === void 0) {
        const O = St(Uint8Array.from(C, (z) => z.charCodeAt(0)));
        T = X(O, O), _a[C] = T;
      }
      return St(T, ...E);
    },
    _JacobianPoint: x
  }, Object.defineProperties(e.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return St;
      },
      set(C) {
        St || (St = C);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return zt;
      },
      set(C) {
        zt || (zt = C);
      }
    }
  });
})(hh);
var vu = {}, wr = {};
Object.defineProperty(wr, "__esModule", { value: !0 });
wr.isBytes = L2;
wr.number = Dc;
wr.bool = R2;
wr.bytes = ph;
wr.hash = z2;
wr.exists = j2;
wr.output = D2;
function Dc(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function R2(e) {
  if (typeof e != "boolean")
    throw new Error(`boolean expected, not ${e}`);
}
function L2(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function ph(e, ...t) {
  if (!L2(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function z2(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Dc(e.outputLen), Dc(e.blockLen);
}
function j2(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function D2(e, t) {
  ph(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const _k = { number: Dc, bool: R2, bytes: ph, hash: z2, exists: j2, output: D2 };
wr.default = _k;
var Bi = {}, xu = {};
Object.defineProperty(xu, "__esModule", { value: !0 });
xu.crypto = void 0;
xu.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Hash = e.nextTick = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = void 0, e.isBytes = n, e.byteSwap32 = f, e.bytesToHex = h, e.hexToBytes = b, e.asyncLoop = v, e.utf8ToBytes = _, e.toBytes = x, e.concatBytes = k, e.checkOpts = R, e.wrapConstructor = j, e.wrapConstructorWithOpts = W, e.wrapXOFConstructorWithOpts = re, e.randomBytes = X;
  const t = xu, r = wr;
  function n(N) {
    return N instanceof Uint8Array || N != null && typeof N == "object" && N.constructor.name === "Uint8Array";
  }
  const i = (N) => new Uint8Array(N.buffer, N.byteOffset, N.byteLength);
  e.u8 = i;
  const o = (N) => new Uint32Array(N.buffer, N.byteOffset, Math.floor(N.byteLength / 4));
  e.u32 = o;
  const s = (N) => new DataView(N.buffer, N.byteOffset, N.byteLength);
  e.createView = s;
  const a = (N, G) => N << 32 - G | N >>> G;
  e.rotr = a;
  const c = (N, G) => N << G | N >>> 32 - G >>> 0;
  e.rotl = c, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const u = (N) => N << 24 & 4278190080 | N << 8 & 16711680 | N >>> 8 & 65280 | N >>> 24 & 255;
  e.byteSwap = u, e.byteSwapIfBE = e.isLE ? (N) => N : (N) => (0, e.byteSwap)(N);
  function f(N) {
    for (let G = 0; G < N.length; G++)
      N[G] = (0, e.byteSwap)(N[G]);
  }
  const l = /* @__PURE__ */ Array.from({ length: 256 }, (N, G) => G.toString(16).padStart(2, "0"));
  function h(N) {
    (0, r.bytes)(N);
    let G = "";
    for (let M = 0; M < N.length; M++)
      G += l[N[M]];
    return G;
  }
  const m = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function y(N) {
    if (N >= m._0 && N <= m._9)
      return N - m._0;
    if (N >= m._A && N <= m._F)
      return N - (m._A - 10);
    if (N >= m._a && N <= m._f)
      return N - (m._a - 10);
  }
  function b(N) {
    if (typeof N != "string")
      throw new Error("hex string expected, got " + typeof N);
    const G = N.length, M = G / 2;
    if (G % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + G);
    const $ = new Uint8Array(M);
    for (let H = 0, q = 0; H < M; H++, q += 2) {
      const ne = y(N.charCodeAt(q)), ie = y(N.charCodeAt(q + 1));
      if (ne === void 0 || ie === void 0) {
        const pe = N[q] + N[q + 1];
        throw new Error('hex string expected, got non-hex character "' + pe + '" at index ' + q);
      }
      $[H] = ne * 16 + ie;
    }
    return $;
  }
  const g = async () => {
  };
  e.nextTick = g;
  async function v(N, G, M) {
    let $ = Date.now();
    for (let H = 0; H < N; H++) {
      M(H);
      const q = Date.now() - $;
      q >= 0 && q < G || (await (0, e.nextTick)(), $ += q);
    }
  }
  function _(N) {
    if (typeof N != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof N}`);
    return new Uint8Array(new TextEncoder().encode(N));
  }
  function x(N) {
    return typeof N == "string" && (N = _(N)), (0, r.bytes)(N), N;
  }
  function k(...N) {
    let G = 0;
    for (let $ = 0; $ < N.length; $++) {
      const H = N[$];
      (0, r.bytes)(H), G += H.length;
    }
    const M = new Uint8Array(G);
    for (let $ = 0, H = 0; $ < N.length; $++) {
      const q = N[$];
      M.set(q, H), H += q.length;
    }
    return M;
  }
  class P {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = P;
  const I = {}.toString;
  function R(N, G) {
    if (G !== void 0 && I.call(G) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(N, G);
  }
  function j(N) {
    const G = ($) => N().update(x($)).digest(), M = N();
    return G.outputLen = M.outputLen, G.blockLen = M.blockLen, G.create = () => N(), G;
  }
  function W(N) {
    const G = ($, H) => N(H).update(x($)).digest(), M = N({});
    return G.outputLen = M.outputLen, G.blockLen = M.blockLen, G.create = ($) => N($), G;
  }
  function re(N) {
    const G = ($, H) => N(H).update(x($)).digest(), M = N({});
    return G.outputLen = M.outputLen, G.blockLen = M.blockLen, G.create = ($) => N($), G;
  }
  function X(N = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(N));
    if (t.crypto && typeof t.crypto.randomBytes == "function")
      return t.crypto.randomBytes(N);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(Bi);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const t = wr, r = Bi;
  class n extends r.Hash {
    constructor(s, a) {
      super(), this.finished = !1, this.destroyed = !1, (0, t.hash)(s);
      const c = (0, r.toBytes)(a);
      if (this.iHash = s.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const u = this.blockLen, f = new Uint8Array(u);
      f.set(c.length > u ? s.create().update(c).digest() : c);
      for (let l = 0; l < f.length; l++)
        f[l] ^= 54;
      this.iHash.update(f), this.oHash = s.create();
      for (let l = 0; l < f.length; l++)
        f[l] ^= 106;
      this.oHash.update(f), f.fill(0);
    }
    update(s) {
      return (0, t.exists)(this), this.iHash.update(s), this;
    }
    digestInto(s) {
      (0, t.exists)(this), (0, t.bytes)(s, this.outputLen), this.finished = !0, this.iHash.digestInto(s), this.oHash.update(s), this.oHash.digestInto(s), this.destroy();
    }
    digest() {
      const s = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(s), s;
    }
    _cloneInto(s) {
      s || (s = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: a, iHash: c, finished: u, destroyed: f, blockLen: l, outputLen: h } = this;
      return s = s, s.finished = u, s.destroyed = f, s.blockLen = l, s.outputLen = h, s.oHash = a._cloneInto(s.oHash), s.iHash = c._cloneInto(s.iHash), s;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = n;
  const i = (o, s, a) => new n(o, s).update(a).digest();
  e.hmac = i, e.hmac.create = (o, s) => new n(o, s);
})(vu);
var Mr = {}, On = {};
Object.defineProperty(On, "__esModule", { value: !0 });
On.HashMD = On.Maj = On.Chi = void 0;
const Rl = wr, ws = Bi;
function kk(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(r >> i & o), a = Number(r & o), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
const Tk = (e, t, r) => e & t ^ ~e & r;
On.Chi = Tk;
const Ck = (e, t, r) => e & t ^ e & r ^ t & r;
On.Maj = Ck;
class Pk extends ws.Hash {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, ws.createView)(this.buffer);
  }
  update(t) {
    (0, Rl.exists)(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = (0, ws.toBytes)(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const a = Math.min(i - this.pos, o - s);
      if (a === i) {
        const c = (0, ws.createView)(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    (0, Rl.exists)(this), (0, Rl.output)(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let l = s; l < i; l++)
      r[l] = 0;
    kk(n, i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const a = (0, ws.createView)(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, f = this.get();
    if (u > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < u; l++)
      a.setUint32(4 * l, f[l], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: a } = this;
    return t.length = i, t.pos = a, t.finished = o, t.destroyed = s, i % r && t.buffer.set(n), t;
  }
}
On.HashMD = Pk;
Object.defineProperty(Mr, "__esModule", { value: !0 });
Mr.sha224 = Mr.sha256 = Mr.SHA256 = void 0;
const Ll = On, Tr = Bi, Ik = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ai = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ci = /* @__PURE__ */ new Uint32Array(64);
class gh extends Ll.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = ai[0] | 0, this.B = ai[1] | 0, this.C = ai[2] | 0, this.D = ai[3] | 0, this.E = ai[4] | 0, this.F = ai[5] | 0, this.G = ai[6] | 0, this.H = ai[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: a, H: c } = this;
    return [t, r, n, i, o, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let l = 0; l < 16; l++, r += 4)
      ci[l] = t.getUint32(r, !1);
    for (let l = 16; l < 64; l++) {
      const h = ci[l - 15], m = ci[l - 2], y = (0, Tr.rotr)(h, 7) ^ (0, Tr.rotr)(h, 18) ^ h >>> 3, b = (0, Tr.rotr)(m, 17) ^ (0, Tr.rotr)(m, 19) ^ m >>> 10;
      ci[l] = b + ci[l - 7] + y + ci[l - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: a, F: c, G: u, H: f } = this;
    for (let l = 0; l < 64; l++) {
      const h = (0, Tr.rotr)(a, 6) ^ (0, Tr.rotr)(a, 11) ^ (0, Tr.rotr)(a, 25), m = f + h + (0, Ll.Chi)(a, c, u) + Ik[l] + ci[l] | 0, b = ((0, Tr.rotr)(n, 2) ^ (0, Tr.rotr)(n, 13) ^ (0, Tr.rotr)(n, 22)) + (0, Ll.Maj)(n, i, o) | 0;
      f = u, u = c, c = a, a = s + m | 0, s = o, o = i, i = n, n = m + b | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, f = f + this.H | 0, this.set(n, i, o, s, a, c, u, f);
  }
  roundClean() {
    ci.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
Mr.SHA256 = gh;
class Bk extends gh {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
Mr.sha256 = (0, Tr.wrapConstructor)(() => new gh());
Mr.sha224 = (0, Tr.wrapConstructor)(() => new Bk());
var Ok = hh, $k = vu, M2 = Mr;
function Nk(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(r) {
    if (r !== "default") {
      var n = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(t, r, n.get ? n : {
        enumerable: !0,
        get: function() {
          return e[r];
        }
      });
    }
  }), t.default = e, Object.freeze(t);
}
var ze = /* @__PURE__ */ Nk(Ok);
const Oi = "Expected Private", $i = "Expected Point", pa = "Expected Tweak", Uk = "Expected Hash", Mc = "Expected Signature", mh = "Expected Extra Data (32 bytes)", ga = "Expected Scalar", Fk = "Bad Recovery Id";
ze.utils.hmacSha256Sync = (e, ...t) => $k.hmac(M2.sha256, e, ze.utils.concatBytes(...t));
ze.utils.sha256Sync = (...e) => M2.sha256(ze.utils.concatBytes(...e));
const bh = ze.utils._normalizePrivateKey, Hk = 32, Rk = 32, zf = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]), Lk = 32, zk = new Uint8Array(32), jk = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function Dk(e) {
  return e instanceof Uint8Array;
}
function Xs(e, t) {
  for (let r = 0; r < 32; ++r)
    if (e[r] !== t[r])
      return e[r] < t[r] ? -1 : 1;
  return 0;
}
function u1(e) {
  return Xs(e, zk) === 0;
}
function ma(e) {
  return !(!(e instanceof Uint8Array) || e.length !== Rk || Xs(e, zf) >= 0);
}
function yh(e) {
  return e instanceof Uint8Array && e.length === 64 && Xs(e.subarray(0, 32), zf) < 0 && Xs(e.subarray(32, 64), zf) < 0;
}
function Mk(e) {
  return Dk(e) && e.length === 64 && Xs(e.subarray(0, 32), jk) < 0;
}
function Kk(e) {
  return !(u1(e.subarray(0, 32)) || u1(e.subarray(32, 64)));
}
function os(e) {
  return e instanceof Uint8Array && e.length === Hk;
}
function wh(e) {
  return e === void 0 || e instanceof Uint8Array && e.length === Lk;
}
function K2(e) {
  if (typeof e != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof e);
  return BigInt(`0x${e}`);
}
function qk(e) {
  return K2(ze.utils.bytesToHex(e));
}
function vh(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0)
    t = BigInt(e);
  else if (typeof e == "string") {
    if (e.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    t = K2(e);
  } else if (e instanceof Uint8Array) {
    if (e.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    t = qk(e);
  } else
    throw new TypeError("Expected valid private scalar");
  if (t < 0) throw new Error("Expected private scalar >= 0");
  return t;
}
const Vk = (e, t) => {
  const r = bh(e), n = vh(t), i = ze.utils._bigintTo32Bytes(ze.utils.mod(r + n, ze.CURVE.n));
  return ze.utils.isValidPrivateKey(i) ? i : null;
}, Wk = (e, t) => {
  const r = bh(e), n = vh(t), i = ze.utils._bigintTo32Bytes(ze.utils.mod(r - n, ze.CURVE.n));
  return ze.utils.isValidPrivateKey(i) ? i : null;
}, Gk = (e) => {
  const t = bh(e), r = ze.utils._bigintTo32Bytes(ze.CURVE.n - t);
  return ze.utils.isValidPrivateKey(r) ? r : null;
}, q2 = (e, t, r) => {
  const n = ze.Point.fromHex(e), i = vh(t), o = ze.Point.BASE.multiplyAndAddUnsafe(n, i, BigInt(1));
  if (!o) throw new Error("Tweaked point at infinity");
  return o.toRawBytes(r);
}, Zk = (e, t, r) => {
  const n = ze.Point.fromHex(e), i = typeof t == "string" ? t : ze.utils.bytesToHex(t), o = BigInt(`0x${i}`);
  return n.multiply(o).toRawBytes(r);
};
function ss(e, t) {
  return e === void 0 ? t !== void 0 ? V2(t) : !0 : !!e;
}
function po(e) {
  try {
    return e();
  } catch {
    return null;
  }
}
function xh(e, t) {
  if (e.length === 32 !== t) return !1;
  try {
    return !!ze.Point.fromHex(e);
  } catch {
    return !1;
  }
}
function Ii(e) {
  return xh(e, !1);
}
function V2(e) {
  return xh(e, !1) && e.length === 33;
}
function zn(e) {
  return ze.utils.isValidPrivateKey(e);
}
function Eu(e) {
  return xh(e, !0);
}
function Xk(e, t) {
  if (!Eu(e))
    throw new Error($i);
  if (!ma(t))
    throw new Error(pa);
  return po(() => {
    const r = q2(e, t, !0);
    return { parity: r[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: r.slice(1) };
  });
}
function W2(e) {
  if (!Ii(e))
    throw new Error($i);
  return e.slice(1, 33);
}
function G2(e, t) {
  if (!zn(e))
    throw new Error(Oi);
  return po(
    () => ze.getPublicKey(e, ss(t))
  );
}
function Yk(e) {
  if (!zn(e))
    throw new Error(Oi);
  return W2(G2(e));
}
function Jk(e, t) {
  if (!Ii(e))
    throw new Error($i);
  return ze.Point.fromHex(e).toRawBytes(ss(t, e));
}
function Qk(e, t, r) {
  if (!Ii(e))
    throw new Error($i);
  if (!ma(t))
    throw new Error(pa);
  return po(
    () => Zk(e, t, ss(r, e))
  );
}
function eT(e, t, r) {
  if (!Ii(e) || !Ii(t))
    throw new Error($i);
  return po(() => {
    const n = ze.Point.fromHex(e), i = ze.Point.fromHex(t);
    return n.equals(i.negate()) ? null : n.add(i).toRawBytes(ss(r, e));
  });
}
function tT(e, t, r) {
  if (!Ii(e))
    throw new Error($i);
  if (!ma(t))
    throw new Error(pa);
  return po(
    () => q2(e, t, ss(r, e))
  );
}
function rT(e, t) {
  if (zn(e) === !1)
    throw new Error(Oi);
  if (ma(t) === !1)
    throw new Error(pa);
  return po(() => Vk(e, t));
}
function nT(e, t) {
  if (zn(e) === !1)
    throw new Error(Oi);
  if (ma(t) === !1)
    throw new Error(pa);
  return po(() => Wk(e, t));
}
function iT(e) {
  if (zn(e) === !1)
    throw new Error(Oi);
  return Gk(e);
}
function oT(e, t, r) {
  if (!zn(t))
    throw new Error(Oi);
  if (!os(e))
    throw new Error(ga);
  if (!wh(r))
    throw new Error(mh);
  return ze.signSync(e, t, { der: !1, extraEntropy: r });
}
function sT(e, t, r) {
  if (!zn(t))
    throw new Error(Oi);
  if (!os(e))
    throw new Error(ga);
  if (!wh(r))
    throw new Error(mh);
  const [n, i] = ze.signSync(e, t, { der: !1, extraEntropy: r, recovered: !0 });
  return { signature: n, recoveryId: i };
}
function aT(e, t, r = Buffer.alloc(32, 0)) {
  if (!zn(t))
    throw new Error(Oi);
  if (!os(e))
    throw new Error(ga);
  if (!wh(r))
    throw new Error(mh);
  return ze.schnorr.signSync(e, t, r);
}
function cT(e, t, r, n) {
  if (!os(e))
    throw new Error(Uk);
  if (!yh(t) || !Kk(t))
    throw new Error(Mc);
  if (r & 2 && !Mk(t))
    throw new Error(Fk);
  if (!Eu(t.subarray(0, 32)))
    throw new Error(Mc);
  return ze.recoverPublicKey(e, t, r, ss(n));
}
function uT(e, t, r, n) {
  if (!Ii(t))
    throw new Error($i);
  if (!yh(r))
    throw new Error(Mc);
  if (!os(e))
    throw new Error(ga);
  return ze.verify(r, e, t, { strict: n });
}
function lT(e, t, r) {
  if (!Eu(t))
    throw new Error($i);
  if (!yh(r))
    throw new Error(Mc);
  if (!os(e))
    throw new Error(ga);
  return ze.schnorr.verifySync(r, e, t);
}
var fT = lt.isPoint = Ii, dT = lt.isPointCompressed = V2, hT = lt.isPrivate = zn, pT = lt.isXOnlyPoint = Eu, gT = lt.pointAdd = eT, mT = lt.pointAddScalar = tT, bT = lt.pointCompress = Jk, yT = lt.pointFromScalar = G2, wT = lt.pointMultiply = Qk, vT = lt.privateAdd = rT, xT = lt.privateNegate = iT, ET = lt.privateSub = nT, AT = lt.recover = cT, ST = lt.sign = oT, _T = lt.signRecoverable = sT, kT = lt.signSchnorr = aT, TT = lt.verify = uT, CT = lt.verifySchnorr = lT, PT = lt.xOnlyPointAddTweak = Xk, IT = lt.xOnlyPointFromPoint = W2, BT = lt.xOnlyPointFromScalar = Yk;
const Eh = /* @__PURE__ */ a5({
  __proto__: null,
  default: lt,
  isPoint: fT,
  isPointCompressed: dT,
  isPrivate: hT,
  isXOnlyPoint: pT,
  pointAdd: gT,
  pointAddScalar: mT,
  pointCompress: bT,
  pointFromScalar: yT,
  pointMultiply: wT,
  privateAdd: vT,
  privateNegate: xT,
  privateSub: ET,
  recover: AT,
  sign: ST,
  signRecoverable: _T,
  signSchnorr: kT,
  verify: TT,
  verifySchnorr: CT,
  xOnlyPointAddTweak: PT,
  xOnlyPointFromPoint: IT,
  xOnlyPointFromScalar: BT
}, [lt]);
var Z2 = {}, as = {};
as.byteLength = NT;
as.toByteArray = FT;
as.fromByteArray = LT;
var cn = [], Cr = [], OT = typeof Uint8Array < "u" ? Uint8Array : Array, zl = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var _o = 0, $T = zl.length; _o < $T; ++_o)
  cn[_o] = zl[_o], Cr[zl.charCodeAt(_o)] = _o;
Cr[45] = 62;
Cr[95] = 63;
function X2(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function NT(e) {
  var t = X2(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function UT(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function FT(e) {
  var t, r = X2(e), n = r[0], i = r[1], o = new OT(UT(e, n, i)), s = 0, a = i > 0 ? n - 4 : n, c;
  for (c = 0; c < a; c += 4)
    t = Cr[e.charCodeAt(c)] << 18 | Cr[e.charCodeAt(c + 1)] << 12 | Cr[e.charCodeAt(c + 2)] << 6 | Cr[e.charCodeAt(c + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
  return i === 2 && (t = Cr[e.charCodeAt(c)] << 2 | Cr[e.charCodeAt(c + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = Cr[e.charCodeAt(c)] << 10 | Cr[e.charCodeAt(c + 1)] << 4 | Cr[e.charCodeAt(c + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function HT(e) {
  return cn[e >> 18 & 63] + cn[e >> 12 & 63] + cn[e >> 6 & 63] + cn[e & 63];
}
function RT(e, t, r) {
  for (var n, i = [], o = t; o < r; o += 3)
    n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(HT(n));
  return i.join("");
}
function LT(e) {
  for (var t, r = e.length, n = r % 3, i = [], o = 16383, s = 0, a = r - n; s < a; s += o)
    i.push(RT(e, s, s + o > a ? a : s + o));
  return n === 1 ? (t = e[r - 1], i.push(
    cn[t >> 2] + cn[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    cn[t >> 10] + cn[t >> 4 & 63] + cn[t << 2 & 63] + "="
  )), i.join("");
}
var Ah = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Ah.read = function(e, t, r, n, i) {
  var o, s, a = i * 8 - n - 1, c = (1 << a) - 1, u = c >> 1, f = -7, l = r ? i - 1 : 0, h = r ? -1 : 1, m = e[t + l];
  for (l += h, o = m & (1 << -f) - 1, m >>= -f, f += a; f > 0; o = o * 256 + e[t + l], l += h, f -= 8)
    ;
  for (s = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; s = s * 256 + e[t + l], l += h, f -= 8)
    ;
  if (o === 0)
    o = 1 - u;
  else {
    if (o === c)
      return s ? NaN : (m ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, n), o = o - u;
  }
  return (m ? -1 : 1) * s * Math.pow(2, o - n);
};
Ah.write = function(e, t, r, n, i, o) {
  var s, a, c, u = o * 8 - i - 1, f = (1 << u) - 1, l = f >> 1, h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = n ? 0 : o - 1, y = n ? 1 : -1, b = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = f) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), s + l >= 1 ? t += h / c : t += h * Math.pow(2, 1 - l), t * c >= 2 && (s++, c /= 2), s + l >= f ? (a = 0, s = f) : s + l >= 1 ? (a = (t * c - 1) * Math.pow(2, i), s = s + l) : (a = t * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + m] = a & 255, m += y, a /= 256, i -= 8)
    ;
  for (s = s << i | a, u += i; u > 0; e[r + m] = s & 255, m += y, s /= 256, u -= 8)
    ;
  e[r + m - y] |= b * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = as, r = Ah, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = a, e.SlowBuffer = _, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = o(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o() {
    try {
      const w = new Uint8Array(1), d = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(d, Uint8Array.prototype), Object.setPrototypeOf(w, d), w.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s(w) {
    if (w > i)
      throw new RangeError('The value "' + w + '" is invalid for option "size"');
    const d = new Uint8Array(w);
    return Object.setPrototypeOf(d, a.prototype), d;
  }
  function a(w, d, p) {
    if (typeof w == "number") {
      if (typeof d == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return l(w);
    }
    return c(w, d, p);
  }
  a.poolSize = 8192;
  function c(w, d, p) {
    if (typeof w == "string")
      return h(w, d);
    if (ArrayBuffer.isView(w))
      return y(w);
    if (w == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof w
      );
    if (Er(w, ArrayBuffer) || w && Er(w.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Er(w, SharedArrayBuffer) || w && Er(w.buffer, SharedArrayBuffer)))
      return b(w, d, p);
    if (typeof w == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const A = w.valueOf && w.valueOf();
    if (A != null && A !== w)
      return a.from(A, d, p);
    const B = g(w);
    if (B) return B;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof w[Symbol.toPrimitive] == "function")
      return a.from(w[Symbol.toPrimitive]("string"), d, p);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof w
    );
  }
  a.from = function(w, d, p) {
    return c(w, d, p);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function u(w) {
    if (typeof w != "number")
      throw new TypeError('"size" argument must be of type number');
    if (w < 0)
      throw new RangeError('The value "' + w + '" is invalid for option "size"');
  }
  function f(w, d, p) {
    return u(w), w <= 0 ? s(w) : d !== void 0 ? typeof p == "string" ? s(w).fill(d, p) : s(w).fill(d) : s(w);
  }
  a.alloc = function(w, d, p) {
    return f(w, d, p);
  };
  function l(w) {
    return u(w), s(w < 0 ? 0 : v(w) | 0);
  }
  a.allocUnsafe = function(w) {
    return l(w);
  }, a.allocUnsafeSlow = function(w) {
    return l(w);
  };
  function h(w, d) {
    if ((typeof d != "string" || d === "") && (d = "utf8"), !a.isEncoding(d))
      throw new TypeError("Unknown encoding: " + d);
    const p = x(w, d) | 0;
    let A = s(p);
    const B = A.write(w, d);
    return B !== p && (A = A.slice(0, B)), A;
  }
  function m(w) {
    const d = w.length < 0 ? 0 : v(w.length) | 0, p = s(d);
    for (let A = 0; A < d; A += 1)
      p[A] = w[A] & 255;
    return p;
  }
  function y(w) {
    if (Er(w, Uint8Array)) {
      const d = new Uint8Array(w);
      return b(d.buffer, d.byteOffset, d.byteLength);
    }
    return m(w);
  }
  function b(w, d, p) {
    if (d < 0 || w.byteLength < d)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (w.byteLength < d + (p || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return d === void 0 && p === void 0 ? A = new Uint8Array(w) : p === void 0 ? A = new Uint8Array(w, d) : A = new Uint8Array(w, d, p), Object.setPrototypeOf(A, a.prototype), A;
  }
  function g(w) {
    if (a.isBuffer(w)) {
      const d = v(w.length) | 0, p = s(d);
      return p.length === 0 || w.copy(p, 0, 0, d), p;
    }
    if (w.length !== void 0)
      return typeof w.length != "number" || yo(w.length) ? s(0) : m(w);
    if (w.type === "Buffer" && Array.isArray(w.data))
      return m(w.data);
  }
  function v(w) {
    if (w >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return w | 0;
  }
  function _(w) {
    return +w != w && (w = 0), a.alloc(+w);
  }
  a.isBuffer = function(d) {
    return d != null && d._isBuffer === !0 && d !== a.prototype;
  }, a.compare = function(d, p) {
    if (Er(d, Uint8Array) && (d = a.from(d, d.offset, d.byteLength)), Er(p, Uint8Array) && (p = a.from(p, p.offset, p.byteLength)), !a.isBuffer(d) || !a.isBuffer(p))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (d === p) return 0;
    let A = d.length, B = p.length;
    for (let F = 0, D = Math.min(A, B); F < D; ++F)
      if (d[F] !== p[F]) {
        A = d[F], B = p[F];
        break;
      }
    return A < B ? -1 : B < A ? 1 : 0;
  }, a.isEncoding = function(d) {
    switch (String(d).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, a.concat = function(d, p) {
    if (!Array.isArray(d))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (d.length === 0)
      return a.alloc(0);
    let A;
    if (p === void 0)
      for (p = 0, A = 0; A < d.length; ++A)
        p += d[A].length;
    const B = a.allocUnsafe(p);
    let F = 0;
    for (A = 0; A < d.length; ++A) {
      let D = d[A];
      if (Er(D, Uint8Array))
        F + D.length > B.length ? (a.isBuffer(D) || (D = a.from(D)), D.copy(B, F)) : Uint8Array.prototype.set.call(
          B,
          D,
          F
        );
      else if (a.isBuffer(D))
        D.copy(B, F);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      F += D.length;
    }
    return B;
  };
  function x(w, d) {
    if (a.isBuffer(w))
      return w.length;
    if (ArrayBuffer.isView(w) || Er(w, ArrayBuffer))
      return w.byteLength;
    if (typeof w != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof w
      );
    const p = w.length, A = arguments.length > 2 && arguments[2] === !0;
    if (!A && p === 0) return 0;
    let B = !1;
    for (; ; )
      switch (d) {
        case "ascii":
        case "latin1":
        case "binary":
          return p;
        case "utf8":
        case "utf-8":
          return Ni(w).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return p * 2;
        case "hex":
          return p >>> 1;
        case "base64":
          return Aa(w).length;
        default:
          if (B)
            return A ? -1 : Ni(w).length;
          d = ("" + d).toLowerCase(), B = !0;
      }
  }
  a.byteLength = x;
  function k(w, d, p) {
    let A = !1;
    if ((d === void 0 || d < 0) && (d = 0), d > this.length || ((p === void 0 || p > this.length) && (p = this.length), p <= 0) || (p >>>= 0, d >>>= 0, p <= d))
      return "";
    for (w || (w = "utf8"); ; )
      switch (w) {
        case "hex":
          return ie(this, d, p);
        case "utf8":
        case "utf-8":
          return M(this, d, p);
        case "ascii":
          return q(this, d, p);
        case "latin1":
        case "binary":
          return ne(this, d, p);
        case "base64":
          return G(this, d, p);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return pe(this, d, p);
        default:
          if (A) throw new TypeError("Unknown encoding: " + w);
          w = (w + "").toLowerCase(), A = !0;
      }
  }
  a.prototype._isBuffer = !0;
  function P(w, d, p) {
    const A = w[d];
    w[d] = w[p], w[p] = A;
  }
  a.prototype.swap16 = function() {
    const d = this.length;
    if (d % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let p = 0; p < d; p += 2)
      P(this, p, p + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const d = this.length;
    if (d % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let p = 0; p < d; p += 4)
      P(this, p, p + 3), P(this, p + 1, p + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const d = this.length;
    if (d % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let p = 0; p < d; p += 8)
      P(this, p, p + 7), P(this, p + 1, p + 6), P(this, p + 2, p + 5), P(this, p + 3, p + 4);
    return this;
  }, a.prototype.toString = function() {
    const d = this.length;
    return d === 0 ? "" : arguments.length === 0 ? M(this, 0, d) : k.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(d) {
    if (!a.isBuffer(d)) throw new TypeError("Argument must be a Buffer");
    return this === d ? !0 : a.compare(this, d) === 0;
  }, a.prototype.inspect = function() {
    let d = "";
    const p = e.INSPECT_MAX_BYTES;
    return d = this.toString("hex", 0, p).replace(/(.{2})/g, "$1 ").trim(), this.length > p && (d += " ... "), "<Buffer " + d + ">";
  }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(d, p, A, B, F) {
    if (Er(d, Uint8Array) && (d = a.from(d, d.offset, d.byteLength)), !a.isBuffer(d))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof d
      );
    if (p === void 0 && (p = 0), A === void 0 && (A = d ? d.length : 0), B === void 0 && (B = 0), F === void 0 && (F = this.length), p < 0 || A > d.length || B < 0 || F > this.length)
      throw new RangeError("out of range index");
    if (B >= F && p >= A)
      return 0;
    if (B >= F)
      return -1;
    if (p >= A)
      return 1;
    if (p >>>= 0, A >>>= 0, B >>>= 0, F >>>= 0, this === d) return 0;
    let D = F - B, Ie = A - p;
    const Je = Math.min(D, Ie), Ze = this.slice(B, F), rt = d.slice(p, A);
    for (let Ke = 0; Ke < Je; ++Ke)
      if (Ze[Ke] !== rt[Ke]) {
        D = Ze[Ke], Ie = rt[Ke];
        break;
      }
    return D < Ie ? -1 : Ie < D ? 1 : 0;
  };
  function I(w, d, p, A, B) {
    if (w.length === 0) return -1;
    if (typeof p == "string" ? (A = p, p = 0) : p > 2147483647 ? p = 2147483647 : p < -2147483648 && (p = -2147483648), p = +p, yo(p) && (p = B ? 0 : w.length - 1), p < 0 && (p = w.length + p), p >= w.length) {
      if (B) return -1;
      p = w.length - 1;
    } else if (p < 0)
      if (B) p = 0;
      else return -1;
    if (typeof d == "string" && (d = a.from(d, A)), a.isBuffer(d))
      return d.length === 0 ? -1 : R(w, d, p, A, B);
    if (typeof d == "number")
      return d = d & 255, typeof Uint8Array.prototype.indexOf == "function" ? B ? Uint8Array.prototype.indexOf.call(w, d, p) : Uint8Array.prototype.lastIndexOf.call(w, d, p) : R(w, [d], p, A, B);
    throw new TypeError("val must be string, number or Buffer");
  }
  function R(w, d, p, A, B) {
    let F = 1, D = w.length, Ie = d.length;
    if (A !== void 0 && (A = String(A).toLowerCase(), A === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (w.length < 2 || d.length < 2)
        return -1;
      F = 2, D /= 2, Ie /= 2, p /= 2;
    }
    function Je(rt, Ke) {
      return F === 1 ? rt[Ke] : rt.readUInt16BE(Ke * F);
    }
    let Ze;
    if (B) {
      let rt = -1;
      for (Ze = p; Ze < D; Ze++)
        if (Je(w, Ze) === Je(d, rt === -1 ? 0 : Ze - rt)) {
          if (rt === -1 && (rt = Ze), Ze - rt + 1 === Ie) return rt * F;
        } else
          rt !== -1 && (Ze -= Ze - rt), rt = -1;
    } else
      for (p + Ie > D && (p = D - Ie), Ze = p; Ze >= 0; Ze--) {
        let rt = !0;
        for (let Ke = 0; Ke < Ie; Ke++)
          if (Je(w, Ze + Ke) !== Je(d, Ke)) {
            rt = !1;
            break;
          }
        if (rt) return Ze;
      }
    return -1;
  }
  a.prototype.includes = function(d, p, A) {
    return this.indexOf(d, p, A) !== -1;
  }, a.prototype.indexOf = function(d, p, A) {
    return I(this, d, p, A, !0);
  }, a.prototype.lastIndexOf = function(d, p, A) {
    return I(this, d, p, A, !1);
  };
  function j(w, d, p, A) {
    p = Number(p) || 0;
    const B = w.length - p;
    A ? (A = Number(A), A > B && (A = B)) : A = B;
    const F = d.length;
    A > F / 2 && (A = F / 2);
    let D;
    for (D = 0; D < A; ++D) {
      const Ie = parseInt(d.substr(D * 2, 2), 16);
      if (yo(Ie)) return D;
      w[p + D] = Ie;
    }
    return D;
  }
  function W(w, d, p, A) {
    return Ui(Ni(d, w.length - p), w, p, A);
  }
  function re(w, d, p, A) {
    return Ui(Ea(d), w, p, A);
  }
  function X(w, d, p, A) {
    return Ui(Aa(d), w, p, A);
  }
  function N(w, d, p, A) {
    return Ui(tl(d, w.length - p), w, p, A);
  }
  a.prototype.write = function(d, p, A, B) {
    if (p === void 0)
      B = "utf8", A = this.length, p = 0;
    else if (A === void 0 && typeof p == "string")
      B = p, A = this.length, p = 0;
    else if (isFinite(p))
      p = p >>> 0, isFinite(A) ? (A = A >>> 0, B === void 0 && (B = "utf8")) : (B = A, A = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const F = this.length - p;
    if ((A === void 0 || A > F) && (A = F), d.length > 0 && (A < 0 || p < 0) || p > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    B || (B = "utf8");
    let D = !1;
    for (; ; )
      switch (B) {
        case "hex":
          return j(this, d, p, A);
        case "utf8":
        case "utf-8":
          return W(this, d, p, A);
        case "ascii":
        case "latin1":
        case "binary":
          return re(this, d, p, A);
        case "base64":
          return X(this, d, p, A);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N(this, d, p, A);
        default:
          if (D) throw new TypeError("Unknown encoding: " + B);
          B = ("" + B).toLowerCase(), D = !0;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function G(w, d, p) {
    return d === 0 && p === w.length ? t.fromByteArray(w) : t.fromByteArray(w.slice(d, p));
  }
  function M(w, d, p) {
    p = Math.min(w.length, p);
    const A = [];
    let B = d;
    for (; B < p; ) {
      const F = w[B];
      let D = null, Ie = F > 239 ? 4 : F > 223 ? 3 : F > 191 ? 2 : 1;
      if (B + Ie <= p) {
        let Je, Ze, rt, Ke;
        switch (Ie) {
          case 1:
            F < 128 && (D = F);
            break;
          case 2:
            Je = w[B + 1], (Je & 192) === 128 && (Ke = (F & 31) << 6 | Je & 63, Ke > 127 && (D = Ke));
            break;
          case 3:
            Je = w[B + 1], Ze = w[B + 2], (Je & 192) === 128 && (Ze & 192) === 128 && (Ke = (F & 15) << 12 | (Je & 63) << 6 | Ze & 63, Ke > 2047 && (Ke < 55296 || Ke > 57343) && (D = Ke));
            break;
          case 4:
            Je = w[B + 1], Ze = w[B + 2], rt = w[B + 3], (Je & 192) === 128 && (Ze & 192) === 128 && (rt & 192) === 128 && (Ke = (F & 15) << 18 | (Je & 63) << 12 | (Ze & 63) << 6 | rt & 63, Ke > 65535 && Ke < 1114112 && (D = Ke));
        }
      }
      D === null ? (D = 65533, Ie = 1) : D > 65535 && (D -= 65536, A.push(D >>> 10 & 1023 | 55296), D = 56320 | D & 1023), A.push(D), B += Ie;
    }
    return H(A);
  }
  const $ = 4096;
  function H(w) {
    const d = w.length;
    if (d <= $)
      return String.fromCharCode.apply(String, w);
    let p = "", A = 0;
    for (; A < d; )
      p += String.fromCharCode.apply(
        String,
        w.slice(A, A += $)
      );
    return p;
  }
  function q(w, d, p) {
    let A = "";
    p = Math.min(w.length, p);
    for (let B = d; B < p; ++B)
      A += String.fromCharCode(w[B] & 127);
    return A;
  }
  function ne(w, d, p) {
    let A = "";
    p = Math.min(w.length, p);
    for (let B = d; B < p; ++B)
      A += String.fromCharCode(w[B]);
    return A;
  }
  function ie(w, d, p) {
    const A = w.length;
    (!d || d < 0) && (d = 0), (!p || p < 0 || p > A) && (p = A);
    let B = "";
    for (let F = d; F < p; ++F)
      B += rl[w[F]];
    return B;
  }
  function pe(w, d, p) {
    const A = w.slice(d, p);
    let B = "";
    for (let F = 0; F < A.length - 1; F += 2)
      B += String.fromCharCode(A[F] + A[F + 1] * 256);
    return B;
  }
  a.prototype.slice = function(d, p) {
    const A = this.length;
    d = ~~d, p = p === void 0 ? A : ~~p, d < 0 ? (d += A, d < 0 && (d = 0)) : d > A && (d = A), p < 0 ? (p += A, p < 0 && (p = 0)) : p > A && (p = A), p < d && (p = d);
    const B = this.subarray(d, p);
    return Object.setPrototypeOf(B, a.prototype), B;
  };
  function se(w, d, p) {
    if (w % 1 !== 0 || w < 0) throw new RangeError("offset is not uint");
    if (w + d > p) throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(d, p, A) {
    d = d >>> 0, p = p >>> 0, A || se(d, p, this.length);
    let B = this[d], F = 1, D = 0;
    for (; ++D < p && (F *= 256); )
      B += this[d + D] * F;
    return B;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(d, p, A) {
    d = d >>> 0, p = p >>> 0, A || se(d, p, this.length);
    let B = this[d + --p], F = 1;
    for (; p > 0 && (F *= 256); )
      B += this[d + --p] * F;
    return B;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(d, p) {
    return d = d >>> 0, p || se(d, 1, this.length), this[d];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(d, p) {
    return d = d >>> 0, p || se(d, 2, this.length), this[d] | this[d + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(d, p) {
    return d = d >>> 0, p || se(d, 2, this.length), this[d] << 8 | this[d + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(d, p) {
    return d = d >>> 0, p || se(d, 4, this.length), (this[d] | this[d + 1] << 8 | this[d + 2] << 16) + this[d + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(d, p) {
    return d = d >>> 0, p || se(d, 4, this.length), this[d] * 16777216 + (this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3]);
  }, a.prototype.readBigUInt64LE = Or(function(d) {
    d = d >>> 0, je(d, "offset");
    const p = this[d], A = this[d + 7];
    (p === void 0 || A === void 0) && wt(d, this.length - 8);
    const B = p + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + this[++d] * 2 ** 24, F = this[++d] + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + A * 2 ** 24;
    return BigInt(B) + (BigInt(F) << BigInt(32));
  }), a.prototype.readBigUInt64BE = Or(function(d) {
    d = d >>> 0, je(d, "offset");
    const p = this[d], A = this[d + 7];
    (p === void 0 || A === void 0) && wt(d, this.length - 8);
    const B = p * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + this[++d], F = this[++d] * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + A;
    return (BigInt(B) << BigInt(32)) + BigInt(F);
  }), a.prototype.readIntLE = function(d, p, A) {
    d = d >>> 0, p = p >>> 0, A || se(d, p, this.length);
    let B = this[d], F = 1, D = 0;
    for (; ++D < p && (F *= 256); )
      B += this[d + D] * F;
    return F *= 128, B >= F && (B -= Math.pow(2, 8 * p)), B;
  }, a.prototype.readIntBE = function(d, p, A) {
    d = d >>> 0, p = p >>> 0, A || se(d, p, this.length);
    let B = p, F = 1, D = this[d + --B];
    for (; B > 0 && (F *= 256); )
      D += this[d + --B] * F;
    return F *= 128, D >= F && (D -= Math.pow(2, 8 * p)), D;
  }, a.prototype.readInt8 = function(d, p) {
    return d = d >>> 0, p || se(d, 1, this.length), this[d] & 128 ? (255 - this[d] + 1) * -1 : this[d];
  }, a.prototype.readInt16LE = function(d, p) {
    d = d >>> 0, p || se(d, 2, this.length);
    const A = this[d] | this[d + 1] << 8;
    return A & 32768 ? A | 4294901760 : A;
  }, a.prototype.readInt16BE = function(d, p) {
    d = d >>> 0, p || se(d, 2, this.length);
    const A = this[d + 1] | this[d] << 8;
    return A & 32768 ? A | 4294901760 : A;
  }, a.prototype.readInt32LE = function(d, p) {
    return d = d >>> 0, p || se(d, 4, this.length), this[d] | this[d + 1] << 8 | this[d + 2] << 16 | this[d + 3] << 24;
  }, a.prototype.readInt32BE = function(d, p) {
    return d = d >>> 0, p || se(d, 4, this.length), this[d] << 24 | this[d + 1] << 16 | this[d + 2] << 8 | this[d + 3];
  }, a.prototype.readBigInt64LE = Or(function(d) {
    d = d >>> 0, je(d, "offset");
    const p = this[d], A = this[d + 7];
    (p === void 0 || A === void 0) && wt(d, this.length - 8);
    const B = this[d + 4] + this[d + 5] * 2 ** 8 + this[d + 6] * 2 ** 16 + (A << 24);
    return (BigInt(B) << BigInt(32)) + BigInt(p + this[++d] * 2 ** 8 + this[++d] * 2 ** 16 + this[++d] * 2 ** 24);
  }), a.prototype.readBigInt64BE = Or(function(d) {
    d = d >>> 0, je(d, "offset");
    const p = this[d], A = this[d + 7];
    (p === void 0 || A === void 0) && wt(d, this.length - 8);
    const B = (p << 24) + // Overflow
    this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + this[++d];
    return (BigInt(B) << BigInt(32)) + BigInt(this[++d] * 2 ** 24 + this[++d] * 2 ** 16 + this[++d] * 2 ** 8 + A);
  }), a.prototype.readFloatLE = function(d, p) {
    return d = d >>> 0, p || se(d, 4, this.length), r.read(this, d, !0, 23, 4);
  }, a.prototype.readFloatBE = function(d, p) {
    return d = d >>> 0, p || se(d, 4, this.length), r.read(this, d, !1, 23, 4);
  }, a.prototype.readDoubleLE = function(d, p) {
    return d = d >>> 0, p || se(d, 8, this.length), r.read(this, d, !0, 52, 8);
  }, a.prototype.readDoubleBE = function(d, p) {
    return d = d >>> 0, p || se(d, 8, this.length), r.read(this, d, !1, 52, 8);
  };
  function ke(w, d, p, A, B, F) {
    if (!a.isBuffer(w)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (d > B || d < F) throw new RangeError('"value" argument is out of bounds');
    if (p + A > w.length) throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(d, p, A, B) {
    if (d = +d, p = p >>> 0, A = A >>> 0, !B) {
      const Ie = Math.pow(2, 8 * A) - 1;
      ke(this, d, p, A, Ie, 0);
    }
    let F = 1, D = 0;
    for (this[p] = d & 255; ++D < A && (F *= 256); )
      this[p + D] = d / F & 255;
    return p + A;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(d, p, A, B) {
    if (d = +d, p = p >>> 0, A = A >>> 0, !B) {
      const Ie = Math.pow(2, 8 * A) - 1;
      ke(this, d, p, A, Ie, 0);
    }
    let F = A - 1, D = 1;
    for (this[p + F] = d & 255; --F >= 0 && (D *= 256); )
      this[p + F] = d / D & 255;
    return p + A;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 1, 255, 0), this[p] = d & 255, p + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 2, 65535, 0), this[p] = d & 255, this[p + 1] = d >>> 8, p + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 2, 65535, 0), this[p] = d >>> 8, this[p + 1] = d & 255, p + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 4, 4294967295, 0), this[p + 3] = d >>> 24, this[p + 2] = d >>> 16, this[p + 1] = d >>> 8, this[p] = d & 255, p + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 4, 4294967295, 0), this[p] = d >>> 24, this[p + 1] = d >>> 16, this[p + 2] = d >>> 8, this[p + 3] = d & 255, p + 4;
  };
  function V(w, d, p, A, B) {
    tt(d, A, B, w, p, 7);
    let F = Number(d & BigInt(4294967295));
    w[p++] = F, F = F >> 8, w[p++] = F, F = F >> 8, w[p++] = F, F = F >> 8, w[p++] = F;
    let D = Number(d >> BigInt(32) & BigInt(4294967295));
    return w[p++] = D, D = D >> 8, w[p++] = D, D = D >> 8, w[p++] = D, D = D >> 8, w[p++] = D, p;
  }
  function He(w, d, p, A, B) {
    tt(d, A, B, w, p, 7);
    let F = Number(d & BigInt(4294967295));
    w[p + 7] = F, F = F >> 8, w[p + 6] = F, F = F >> 8, w[p + 5] = F, F = F >> 8, w[p + 4] = F;
    let D = Number(d >> BigInt(32) & BigInt(4294967295));
    return w[p + 3] = D, D = D >> 8, w[p + 2] = D, D = D >> 8, w[p + 1] = D, D = D >> 8, w[p] = D, p + 8;
  }
  a.prototype.writeBigUInt64LE = Or(function(d, p = 0) {
    return V(this, d, p, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = Or(function(d, p = 0) {
    return He(this, d, p, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(d, p, A, B) {
    if (d = +d, p = p >>> 0, !B) {
      const Je = Math.pow(2, 8 * A - 1);
      ke(this, d, p, A, Je - 1, -Je);
    }
    let F = 0, D = 1, Ie = 0;
    for (this[p] = d & 255; ++F < A && (D *= 256); )
      d < 0 && Ie === 0 && this[p + F - 1] !== 0 && (Ie = 1), this[p + F] = (d / D >> 0) - Ie & 255;
    return p + A;
  }, a.prototype.writeIntBE = function(d, p, A, B) {
    if (d = +d, p = p >>> 0, !B) {
      const Je = Math.pow(2, 8 * A - 1);
      ke(this, d, p, A, Je - 1, -Je);
    }
    let F = A - 1, D = 1, Ie = 0;
    for (this[p + F] = d & 255; --F >= 0 && (D *= 256); )
      d < 0 && Ie === 0 && this[p + F + 1] !== 0 && (Ie = 1), this[p + F] = (d / D >> 0) - Ie & 255;
    return p + A;
  }, a.prototype.writeInt8 = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 1, 127, -128), d < 0 && (d = 255 + d + 1), this[p] = d & 255, p + 1;
  }, a.prototype.writeInt16LE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 2, 32767, -32768), this[p] = d & 255, this[p + 1] = d >>> 8, p + 2;
  }, a.prototype.writeInt16BE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 2, 32767, -32768), this[p] = d >>> 8, this[p + 1] = d & 255, p + 2;
  }, a.prototype.writeInt32LE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 4, 2147483647, -2147483648), this[p] = d & 255, this[p + 1] = d >>> 8, this[p + 2] = d >>> 16, this[p + 3] = d >>> 24, p + 4;
  }, a.prototype.writeInt32BE = function(d, p, A) {
    return d = +d, p = p >>> 0, A || ke(this, d, p, 4, 2147483647, -2147483648), d < 0 && (d = 4294967295 + d + 1), this[p] = d >>> 24, this[p + 1] = d >>> 16, this[p + 2] = d >>> 8, this[p + 3] = d & 255, p + 4;
  }, a.prototype.writeBigInt64LE = Or(function(d, p = 0) {
    return V(this, d, p, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = Or(function(d, p = 0) {
    return He(this, d, p, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Rt(w, d, p, A, B, F) {
    if (p + A > w.length) throw new RangeError("Index out of range");
    if (p < 0) throw new RangeError("Index out of range");
  }
  function et(w, d, p, A, B) {
    return d = +d, p = p >>> 0, B || Rt(w, d, p, 4), r.write(w, d, p, A, 23, 4), p + 4;
  }
  a.prototype.writeFloatLE = function(d, p, A) {
    return et(this, d, p, !0, A);
  }, a.prototype.writeFloatBE = function(d, p, A) {
    return et(this, d, p, !1, A);
  };
  function Lt(w, d, p, A, B) {
    return d = +d, p = p >>> 0, B || Rt(w, d, p, 8), r.write(w, d, p, A, 52, 8), p + 8;
  }
  a.prototype.writeDoubleLE = function(d, p, A) {
    return Lt(this, d, p, !0, A);
  }, a.prototype.writeDoubleBE = function(d, p, A) {
    return Lt(this, d, p, !1, A);
  }, a.prototype.copy = function(d, p, A, B) {
    if (!a.isBuffer(d)) throw new TypeError("argument should be a Buffer");
    if (A || (A = 0), !B && B !== 0 && (B = this.length), p >= d.length && (p = d.length), p || (p = 0), B > 0 && B < A && (B = A), B === A || d.length === 0 || this.length === 0) return 0;
    if (p < 0)
      throw new RangeError("targetStart out of bounds");
    if (A < 0 || A >= this.length) throw new RangeError("Index out of range");
    if (B < 0) throw new RangeError("sourceEnd out of bounds");
    B > this.length && (B = this.length), d.length - p < B - A && (B = d.length - p + A);
    const F = B - A;
    return this === d && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(p, A, B) : Uint8Array.prototype.set.call(
      d,
      this.subarray(A, B),
      p
    ), F;
  }, a.prototype.fill = function(d, p, A, B) {
    if (typeof d == "string") {
      if (typeof p == "string" ? (B = p, p = 0, A = this.length) : typeof A == "string" && (B = A, A = this.length), B !== void 0 && typeof B != "string")
        throw new TypeError("encoding must be a string");
      if (typeof B == "string" && !a.isEncoding(B))
        throw new TypeError("Unknown encoding: " + B);
      if (d.length === 1) {
        const D = d.charCodeAt(0);
        (B === "utf8" && D < 128 || B === "latin1") && (d = D);
      }
    } else typeof d == "number" ? d = d & 255 : typeof d == "boolean" && (d = Number(d));
    if (p < 0 || this.length < p || this.length < A)
      throw new RangeError("Out of range index");
    if (A <= p)
      return this;
    p = p >>> 0, A = A === void 0 ? this.length : A >>> 0, d || (d = 0);
    let F;
    if (typeof d == "number")
      for (F = p; F < A; ++F)
        this[F] = d;
    else {
      const D = a.isBuffer(d) ? d : a.from(d, B), Ie = D.length;
      if (Ie === 0)
        throw new TypeError('The value "' + d + '" is invalid for argument "value"');
      for (F = 0; F < A - p; ++F)
        this[F + p] = D[F % Ie];
    }
    return this;
  };
  const yt = {};
  function ht(w, d, p) {
    yt[w] = class extends p {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: d.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${w}]`, this.stack, delete this.name;
      }
      get code() {
        return w;
      }
      set code(B) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: B,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${w}]: ${this.message}`;
      }
    };
  }
  ht(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(w) {
      return w ? `${w} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ht(
    "ERR_INVALID_ARG_TYPE",
    function(w, d) {
      return `The "${w}" argument must be of type number. Received type ${typeof d}`;
    },
    TypeError
  ), ht(
    "ERR_OUT_OF_RANGE",
    function(w, d, p) {
      let A = `The value of "${w}" is out of range.`, B = p;
      return Number.isInteger(p) && Math.abs(p) > 2 ** 32 ? B = St(String(p)) : typeof p == "bigint" && (B = String(p), (p > BigInt(2) ** BigInt(32) || p < -(BigInt(2) ** BigInt(32))) && (B = St(B)), B += "n"), A += ` It must be ${d}. Received ${B}`, A;
    },
    RangeError
  );
  function St(w) {
    let d = "", p = w.length;
    const A = w[0] === "-" ? 1 : 0;
    for (; p >= A + 4; p -= 3)
      d = `_${w.slice(p - 3, p)}${d}`;
    return `${w.slice(0, p)}${d}`;
  }
  function zt(w, d, p) {
    je(d, "offset"), (w[d] === void 0 || w[d + p] === void 0) && wt(d, w.length - (p + 1));
  }
  function tt(w, d, p, A, B, F) {
    if (w > p || w < d) {
      const D = typeof d == "bigint" ? "n" : "";
      let Ie;
      throw d === 0 || d === BigInt(0) ? Ie = `>= 0${D} and < 2${D} ** ${(F + 1) * 8}${D}` : Ie = `>= -(2${D} ** ${(F + 1) * 8 - 1}${D}) and < 2 ** ${(F + 1) * 8 - 1}${D}`, new yt.ERR_OUT_OF_RANGE("value", Ie, w);
    }
    zt(A, B, F);
  }
  function je(w, d) {
    if (typeof w != "number")
      throw new yt.ERR_INVALID_ARG_TYPE(d, "number", w);
  }
  function wt(w, d, p) {
    throw Math.floor(w) !== w ? (je(w, p), new yt.ERR_OUT_OF_RANGE("offset", "an integer", w)) : d < 0 ? new yt.ERR_BUFFER_OUT_OF_BOUNDS() : new yt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${d}`,
      w
    );
  }
  const Yr = /[^+/0-9A-Za-z-_]/g;
  function xr(w) {
    if (w = w.split("=")[0], w = w.trim().replace(Yr, ""), w.length < 2) return "";
    for (; w.length % 4 !== 0; )
      w = w + "=";
    return w;
  }
  function Ni(w, d) {
    d = d || 1 / 0;
    let p;
    const A = w.length;
    let B = null;
    const F = [];
    for (let D = 0; D < A; ++D) {
      if (p = w.charCodeAt(D), p > 55295 && p < 57344) {
        if (!B) {
          if (p > 56319) {
            (d -= 3) > -1 && F.push(239, 191, 189);
            continue;
          } else if (D + 1 === A) {
            (d -= 3) > -1 && F.push(239, 191, 189);
            continue;
          }
          B = p;
          continue;
        }
        if (p < 56320) {
          (d -= 3) > -1 && F.push(239, 191, 189), B = p;
          continue;
        }
        p = (B - 55296 << 10 | p - 56320) + 65536;
      } else B && (d -= 3) > -1 && F.push(239, 191, 189);
      if (B = null, p < 128) {
        if ((d -= 1) < 0) break;
        F.push(p);
      } else if (p < 2048) {
        if ((d -= 2) < 0) break;
        F.push(
          p >> 6 | 192,
          p & 63 | 128
        );
      } else if (p < 65536) {
        if ((d -= 3) < 0) break;
        F.push(
          p >> 12 | 224,
          p >> 6 & 63 | 128,
          p & 63 | 128
        );
      } else if (p < 1114112) {
        if ((d -= 4) < 0) break;
        F.push(
          p >> 18 | 240,
          p >> 12 & 63 | 128,
          p >> 6 & 63 | 128,
          p & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return F;
  }
  function Ea(w) {
    const d = [];
    for (let p = 0; p < w.length; ++p)
      d.push(w.charCodeAt(p) & 255);
    return d;
  }
  function tl(w, d) {
    let p, A, B;
    const F = [];
    for (let D = 0; D < w.length && !((d -= 2) < 0); ++D)
      p = w.charCodeAt(D), A = p >> 8, B = p % 256, F.push(B), F.push(A);
    return F;
  }
  function Aa(w) {
    return t.toByteArray(xr(w));
  }
  function Ui(w, d, p, A) {
    let B;
    for (B = 0; B < A && !(B + p >= d.length || B >= w.length); ++B)
      d[B + p] = w[B];
    return B;
  }
  function Er(w, d) {
    return w instanceof d || w != null && w.constructor != null && w.constructor.name != null && w.constructor.name === d.name;
  }
  function yo(w) {
    return w !== w;
  }
  const rl = function() {
    const w = "0123456789abcdef", d = new Array(256);
    for (let p = 0; p < 16; ++p) {
      const A = p * 16;
      for (let B = 0; B < 16; ++B)
        d[A + B] = w[p] + w[B];
    }
    return d;
  }();
  function Or(w) {
    return typeof BigInt > "u" ? Sa : w;
  }
  function Sa() {
    throw new Error("BigInt not supported");
  }
})(Z2);
const nN = "Mainnet", Xo = "BITCOIN_MAINNET", Au = "BITCOIN_TESTNET", Su = "BITCOIN_TESTNET4", _u = "BITCOIN_SIGNET", ku = "FRACTAL_BITCOIN_MAINNET", Tu = "FRACTAL_BITCOIN_TESTNET", Y2 = "GLITTR_DEVNET", iN = "livenet", oN = "testnet", Es = "Mainnet", jf = "Testnet", zT = "Signet", jT = "livenet", DT = "testnet", Cs = "livenet", Df = "testnet", J2 = "testnet4", Q2 = "signet", Da = "Mainnet", jl = "Testnet", Mf = "mainnet", eb = "testnet", Ma = "main", l1 = "testnet", MT = "signet", Ue = "mainnet", Bt = "signet", Ge = "testnet", Et = "testnet4", fr = "fractal mainnet", At = "fractal testnet", tb = "glittr devnet", sN = "regtest", rc = (e) => e === Ue ? Es : e === Ge || e === Et ? jf : e === Bt ? zT : Es, aN = (e) => e === Ue ? Mf : e === Ge ? eb : Mf, rb = (e) => e === Ue ? Xo : e === Ge ? Au : e === Et ? Su : e === Bt ? _u : e === fr ? ku : e === At ? Tu : Xo, KT = (e) => e === Ue ? Xo : e === Ge ? Au : e === Et ? Su : e === Bt ? _u : e === fr ? ku : e === At ? Tu : e === tb ? Y2 : Xo, cN = (e) => e === Ue ? Cs : e === Ge ? Df : e === Et ? J2 : e === Bt ? Q2 : e === At ? Df : Cs, Dl = (e) => e === Ue ? Da : e === Ge || e === Et || e === Bt ? jl : Da, qT = (e) => e === Ue ? Ma : e === Et || e === Ge ? l1 : e === Bt ? MT : Ma, Kc = (e) => e === Xo ? Ue : e === Au ? Ge : e === Su ? Et : e === _u ? Bt : e === ku ? fr : e === Tu ? At : Ue, f1 = (e) => e === Xo ? Ue : e === Au ? Ge : e === Su ? Et : e === _u ? Bt : e === ku ? fr : e === Tu ? At : e === Y2 ? tb : Ue, uN = (e) => e === Es ? Ue : e === jf ? Ge : Ue, lN = (e) => e === Mf ? Ue : e === eb ? Ge : Ue, VT = (e) => e === jT ? Ue : e === DT ? Ge : Ue, d1 = (e) => e === Cs ? Ue : e === Df ? Ge : e === J2 ? Et : e === Q2 ? Bt : e === At ? Ge : Ue;
function nb(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: WT } = Object.prototype, { getPrototypeOf: Sh } = Object, Cu = /* @__PURE__ */ ((e) => (t) => {
  const r = WT.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Zr = (e) => (e = e.toLowerCase(), (t) => Cu(t) === e), Pu = (e) => (t) => typeof t === e, { isArray: cs } = Array, Ys = Pu("undefined");
function GT(e) {
  return e !== null && !Ys(e) && e.constructor !== null && !Ys(e.constructor) && br(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const ib = Zr("ArrayBuffer");
function ZT(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && ib(e.buffer), t;
}
const XT = Pu("string"), br = Pu("function"), ob = Pu("number"), Iu = (e) => e !== null && typeof e == "object", YT = (e) => e === !0 || e === !1, nc = (e) => {
  if (Cu(e) !== "object")
    return !1;
  const t = Sh(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, JT = Zr("Date"), QT = Zr("File"), eC = Zr("Blob"), tC = Zr("FileList"), rC = (e) => Iu(e) && br(e.pipe), nC = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || br(e.append) && ((t = Cu(e)) === "formdata" || // detect form-data instance
  t === "object" && br(e.toString) && e.toString() === "[object FormData]"));
}, iC = Zr("URLSearchParams"), [oC, sC, aC, cC] = ["ReadableStream", "Request", "Response", "Headers"].map(Zr), uC = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ba(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, i;
  if (typeof e != "object" && (e = [e]), cs(e))
    for (n = 0, i = e.length; n < i; n++)
      t.call(null, e[n], n, e);
  else {
    const o = r ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length;
    let a;
    for (n = 0; n < s; n++)
      a = o[n], t.call(null, e[a], a, e);
  }
}
function sb(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], t === i.toLowerCase())
      return i;
  return null;
}
const Gi = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, ab = (e) => !Ys(e) && e !== Gi;
function Kf() {
  const { caseless: e } = ab(this) && this || {}, t = {}, r = (n, i) => {
    const o = e && sb(t, i) || i;
    nc(t[o]) && nc(n) ? t[o] = Kf(t[o], n) : nc(n) ? t[o] = Kf({}, n) : cs(n) ? t[o] = n.slice() : t[o] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && ba(arguments[n], r);
  return t;
}
const lC = (e, t, r, { allOwnKeys: n } = {}) => (ba(t, (i, o) => {
  r && br(i) ? e[o] = nb(i, r) : e[o] = i;
}, { allOwnKeys: n }), e), fC = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), dC = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, hC = (e, t, r, n) => {
  let i, o, s;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0; )
      s = i[o], (!n || n(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = !0);
    e = r !== !1 && Sh(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, pC = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, gC = (e) => {
  if (!e) return null;
  if (cs(e)) return e;
  let t = e.length;
  if (!ob(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, mC = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Sh(Uint8Array)), bC = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const o = i.value;
    t.call(e, o[0], o[1]);
  }
}, yC = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, wC = Zr("HTMLFormElement"), vC = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), h1 = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), xC = Zr("RegExp"), cb = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  ba(r, (i, o) => {
    let s;
    (s = t(i, o, e)) !== !1 && (n[o] = s || i);
  }), Object.defineProperties(e, n);
}, EC = (e) => {
  cb(e, (t, r) => {
    if (br(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (br(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, AC = (e, t) => {
  const r = {}, n = (i) => {
    i.forEach((o) => {
      r[o] = !0;
    });
  };
  return cs(e) ? n(e) : n(String(e).split(t)), r;
}, SC = () => {
}, _C = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, Ml = "abcdefghijklmnopqrstuvwxyz", p1 = "0123456789", ub = {
  DIGIT: p1,
  ALPHA: Ml,
  ALPHA_DIGIT: Ml + Ml.toUpperCase() + p1
}, kC = (e = 16, t = ub.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function TC(e) {
  return !!(e && br(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const CC = (e) => {
  const t = new Array(10), r = (n, i) => {
    if (Iu(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[i] = n;
        const o = cs(n) ? [] : {};
        return ba(n, (s, a) => {
          const c = r(s, i + 1);
          !Ys(c) && (o[a] = c);
        }), t[i] = void 0, o;
      }
    }
    return n;
  };
  return r(e, 0);
}, PC = Zr("AsyncFunction"), IC = (e) => e && (Iu(e) || br(e)) && br(e.then) && br(e.catch), lb = ((e, t) => e ? setImmediate : t ? ((r, n) => (Gi.addEventListener("message", ({ source: i, data: o }) => {
  i === Gi && o === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), Gi.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  br(Gi.postMessage)
), BC = typeof queueMicrotask < "u" ? queueMicrotask.bind(Gi) : typeof process < "u" && process.nextTick || lb, L = {
  isArray: cs,
  isArrayBuffer: ib,
  isBuffer: GT,
  isFormData: nC,
  isArrayBufferView: ZT,
  isString: XT,
  isNumber: ob,
  isBoolean: YT,
  isObject: Iu,
  isPlainObject: nc,
  isReadableStream: oC,
  isRequest: sC,
  isResponse: aC,
  isHeaders: cC,
  isUndefined: Ys,
  isDate: JT,
  isFile: QT,
  isBlob: eC,
  isRegExp: xC,
  isFunction: br,
  isStream: rC,
  isURLSearchParams: iC,
  isTypedArray: mC,
  isFileList: tC,
  forEach: ba,
  merge: Kf,
  extend: lC,
  trim: uC,
  stripBOM: fC,
  inherits: dC,
  toFlatObject: hC,
  kindOf: Cu,
  kindOfTest: Zr,
  endsWith: pC,
  toArray: gC,
  forEachEntry: bC,
  matchAll: yC,
  isHTMLForm: wC,
  hasOwnProperty: h1,
  hasOwnProp: h1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: cb,
  freezeMethods: EC,
  toObjectSet: AC,
  toCamelCase: vC,
  noop: SC,
  toFiniteNumber: _C,
  findKey: sb,
  global: Gi,
  isContextDefined: ab,
  ALPHABET: ub,
  generateString: kC,
  isSpecCompliantForm: TC,
  toJSONObject: CC,
  isAsyncFn: PC,
  isThenable: IC,
  setImmediate: lb,
  asap: BC
};
function Ae(e, t, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
L.inherits(Ae, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: L.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const fb = Ae.prototype, db = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  db[e] = { value: e };
});
Object.defineProperties(Ae, db);
Object.defineProperty(fb, "isAxiosError", { value: !0 });
Ae.from = (e, t, r, n, i, o) => {
  const s = Object.create(fb);
  return L.toFlatObject(e, s, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), Ae.call(s, e.message, t, r, n, i), s.cause = e, s.name = e.name, o && Object.assign(s, o), s;
};
const OC = null;
function qf(e) {
  return L.isPlainObject(e) || L.isArray(e);
}
function hb(e) {
  return L.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function g1(e, t, r) {
  return e ? e.concat(t).map(function(i, o) {
    return i = hb(i), !r && o ? "[" + i + "]" : i;
  }).join(r ? "." : "") : t;
}
function $C(e) {
  return L.isArray(e) && !e.some(qf);
}
const NC = L.toFlatObject(L, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Bu(e, t, r) {
  if (!L.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = L.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(b, g) {
    return !L.isUndefined(g[b]);
  });
  const n = r.metaTokens, i = r.visitor || f, o = r.dots, s = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && L.isSpecCompliantForm(t);
  if (!L.isFunction(i))
    throw new TypeError("visitor must be a function");
  function u(y) {
    if (y === null) return "";
    if (L.isDate(y))
      return y.toISOString();
    if (!c && L.isBlob(y))
      throw new Ae("Blob is not supported. Use a Buffer instead.");
    return L.isArrayBuffer(y) || L.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function f(y, b, g) {
    let v = y;
    if (y && !g && typeof y == "object") {
      if (L.endsWith(b, "{}"))
        b = n ? b : b.slice(0, -2), y = JSON.stringify(y);
      else if (L.isArray(y) && $C(y) || (L.isFileList(y) || L.endsWith(b, "[]")) && (v = L.toArray(y)))
        return b = hb(b), v.forEach(function(x, k) {
          !(L.isUndefined(x) || x === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? g1([b], k, o) : s === null ? b : b + "[]",
            u(x)
          );
        }), !1;
    }
    return qf(y) ? !0 : (t.append(g1(g, b, o), u(y)), !1);
  }
  const l = [], h = Object.assign(NC, {
    defaultVisitor: f,
    convertValue: u,
    isVisitable: qf
  });
  function m(y, b) {
    if (!L.isUndefined(y)) {
      if (l.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      l.push(y), L.forEach(y, function(v, _) {
        (!(L.isUndefined(v) || v === null) && i.call(
          t,
          v,
          L.isString(_) ? _.trim() : _,
          b,
          h
        )) === !0 && m(v, b ? b.concat(_) : [_]);
      }), l.pop();
    }
  }
  if (!L.isObject(e))
    throw new TypeError("data must be an object");
  return m(e), t;
}
function m1(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function _h(e, t) {
  this._pairs = [], e && Bu(e, this, t);
}
const pb = _h.prototype;
pb.append = function(t, r) {
  this._pairs.push([t, r]);
};
pb.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, m1);
  } : m1;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function UC(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function gb(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || UC, i = r && r.serialize;
  let o;
  if (i ? o = i(t, r) : o = L.isURLSearchParams(t) ? t.toString() : new _h(t, r).toString(n), o) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
class b1 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    L.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
const mb = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, FC = typeof URLSearchParams < "u" ? URLSearchParams : _h, HC = typeof FormData < "u" ? FormData : null, RC = typeof Blob < "u" ? Blob : null, LC = {
  isBrowser: !0,
  classes: {
    URLSearchParams: FC,
    FormData: HC,
    Blob: RC
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, kh = typeof window < "u" && typeof document < "u", Vf = typeof navigator == "object" && navigator || void 0, zC = kh && (!Vf || ["ReactNative", "NativeScript", "NS"].indexOf(Vf.product) < 0), jC = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", DC = kh && window.location.href || "http://localhost", MC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: kh,
  hasStandardBrowserEnv: zC,
  hasStandardBrowserWebWorkerEnv: jC,
  navigator: Vf,
  origin: DC
}, Symbol.toStringTag, { value: "Module" })), sr = {
  ...MC,
  ...LC
};
function KC(e, t) {
  return Bu(e, new sr.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, o) {
      return sr.isNode && L.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function qC(e) {
  return L.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function VC(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const i = r.length;
  let o;
  for (n = 0; n < i; n++)
    o = r[n], t[o] = e[o];
  return t;
}
function bb(e) {
  function t(r, n, i, o) {
    let s = r[o++];
    if (s === "__proto__") return !0;
    const a = Number.isFinite(+s), c = o >= r.length;
    return s = !s && L.isArray(i) ? i.length : s, c ? (L.hasOwnProp(i, s) ? i[s] = [i[s], n] : i[s] = n, !a) : ((!i[s] || !L.isObject(i[s])) && (i[s] = []), t(r, n, i[s], o) && L.isArray(i[s]) && (i[s] = VC(i[s])), !a);
  }
  if (L.isFormData(e) && L.isFunction(e.entries)) {
    const r = {};
    return L.forEachEntry(e, (n, i) => {
      t(qC(n), i, r, 0);
    }), r;
  }
  return null;
}
function WC(e, t, r) {
  if (L.isString(e))
    try {
      return (t || JSON.parse)(e), L.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (0, JSON.stringify)(e);
}
const ya = {
  transitional: mb,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, o = L.isObject(t);
    if (o && L.isHTMLForm(t) && (t = new FormData(t)), L.isFormData(t))
      return i ? JSON.stringify(bb(t)) : t;
    if (L.isArrayBuffer(t) || L.isBuffer(t) || L.isStream(t) || L.isFile(t) || L.isBlob(t) || L.isReadableStream(t))
      return t;
    if (L.isArrayBufferView(t))
      return t.buffer;
    if (L.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return KC(t, this.formSerializer).toString();
      if ((a = L.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Bu(
          a ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return o || i ? (r.setContentType("application/json", !1), WC(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || ya.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (L.isResponse(t) || L.isReadableStream(t))
      return t;
    if (t && L.isString(t) && (n && !this.responseType || i)) {
      const s = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (s)
          throw a.name === "SyntaxError" ? Ae.from(a, Ae.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: sr.classes.FormData,
    Blob: sr.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
L.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  ya.headers[e] = {};
});
const GC = L.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), ZC = (e) => {
  const t = {};
  let r, n, i;
  return e && e.split(`
`).forEach(function(s) {
    i = s.indexOf(":"), r = s.substring(0, i).trim().toLowerCase(), n = s.substring(i + 1).trim(), !(!r || t[r] && GC[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
}, y1 = Symbol("internals");
function vs(e) {
  return e && String(e).trim().toLowerCase();
}
function ic(e) {
  return e === !1 || e == null ? e : L.isArray(e) ? e.map(ic) : String(e);
}
function XC(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const YC = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Kl(e, t, r, n, i) {
  if (L.isFunction(n))
    return n.call(this, t, r);
  if (i && (t = r), !!L.isString(t)) {
    if (L.isString(n))
      return t.indexOf(n) !== -1;
    if (L.isRegExp(n))
      return n.test(t);
  }
}
function JC(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function QC(e, t) {
  const r = L.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(i, o, s) {
        return this[n].call(this, t, i, o, s);
      },
      configurable: !0
    });
  });
}
class ar {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const i = this;
    function o(a, c, u) {
      const f = vs(c);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const l = L.findKey(i, f);
      (!l || i[l] === void 0 || u === !0 || u === void 0 && i[l] !== !1) && (i[l || c] = ic(a));
    }
    const s = (a, c) => L.forEach(a, (u, f) => o(u, f, c));
    if (L.isPlainObject(t) || t instanceof this.constructor)
      s(t, r);
    else if (L.isString(t) && (t = t.trim()) && !YC(t))
      s(ZC(t), r);
    else if (L.isHeaders(t))
      for (const [a, c] of t.entries())
        o(c, a, n);
    else
      t != null && o(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = vs(t), t) {
      const n = L.findKey(this, t);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return XC(i);
        if (L.isFunction(r))
          return r.call(this, i, n);
        if (L.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = vs(t), t) {
      const n = L.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || Kl(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let i = !1;
    function o(s) {
      if (s = vs(s), s) {
        const a = L.findKey(n, s);
        a && (!r || Kl(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return L.isArray(t) ? t.forEach(o) : o(t), i;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const o = r[n];
      (!t || Kl(this, this[o], o, t, !0)) && (delete this[o], i = !0);
    }
    return i;
  }
  normalize(t) {
    const r = this, n = {};
    return L.forEach(this, (i, o) => {
      const s = L.findKey(n, o);
      if (s) {
        r[s] = ic(i), delete r[o];
        return;
      }
      const a = t ? JC(o) : String(o).trim();
      a !== o && delete r[o], r[a] = ic(i), n[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return L.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = t && L.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(t) {
    const n = (this[y1] = this[y1] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function o(s) {
      const a = vs(s);
      n[a] || (QC(i, s), n[a] = !0);
    }
    return L.isArray(t) ? t.forEach(o) : o(t), this;
  }
}
ar.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
L.reduceDescriptors(ar.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
L.freezeMethods(ar);
function ql(e, t) {
  const r = this || ya, n = t || r, i = ar.from(n.headers);
  let o = n.data;
  return L.forEach(e, function(a) {
    o = a.call(r, o, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), o;
}
function yb(e) {
  return !!(e && e.__CANCEL__);
}
function us(e, t, r) {
  Ae.call(this, e ?? "canceled", Ae.ERR_CANCELED, t, r), this.name = "CanceledError";
}
L.inherits(us, Ae, {
  __CANCEL__: !0
});
function wb(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new Ae(
    "Request failed with status code " + r.status,
    [Ae.ERR_BAD_REQUEST, Ae.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function eP(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function tP(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let i = 0, o = 0, s;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const u = Date.now(), f = n[o];
    s || (s = u), r[i] = c, n[i] = u;
    let l = o, h = 0;
    for (; l !== i; )
      h += r[l++], l = l % e;
    if (i = (i + 1) % e, i === o && (o = (o + 1) % e), u - s < t)
      return;
    const m = f && u - f;
    return m ? Math.round(h * 1e3 / m) : void 0;
  };
}
function rP(e, t) {
  let r = 0, n = 1e3 / t, i, o;
  const s = (u, f = Date.now()) => {
    r = f, i = null, o && (clearTimeout(o), o = null), e.apply(null, u);
  };
  return [(...u) => {
    const f = Date.now(), l = f - r;
    l >= n ? s(u, f) : (i = u, o || (o = setTimeout(() => {
      o = null, s(i);
    }, n - l)));
  }, () => i && s(i)];
}
const qc = (e, t, r = 3) => {
  let n = 0;
  const i = tP(50, 250);
  return rP((o) => {
    const s = o.loaded, a = o.lengthComputable ? o.total : void 0, c = s - n, u = i(c), f = s <= a;
    n = s;
    const l = {
      loaded: s,
      total: a,
      progress: a ? s / a : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && a && f ? (a - s) / u : void 0,
      event: o,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(l);
  }, r);
}, w1 = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
}, v1 = (e) => (...t) => L.asap(() => e(...t)), nP = sr.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = sr.navigator && /(msie|trident)/i.test(sr.navigator.userAgent), r = document.createElement("a");
    let n;
    function i(o) {
      let s = o;
      return t && (r.setAttribute("href", s), s = r.href), r.setAttribute("href", s), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return n = i(window.location.href), function(s) {
      const a = L.isString(s) ? i(s) : s;
      return a.protocol === n.protocol && a.host === n.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), iP = sr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, i, o) {
      const s = [e + "=" + encodeURIComponent(t)];
      L.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), L.isString(n) && s.push("path=" + n), L.isString(i) && s.push("domain=" + i), o === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function oP(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function sP(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function vb(e, t) {
  return e && !oP(t) ? sP(e, t) : t;
}
const x1 = (e) => e instanceof ar ? { ...e } : e;
function so(e, t) {
  t = t || {};
  const r = {};
  function n(u, f, l) {
    return L.isPlainObject(u) && L.isPlainObject(f) ? L.merge.call({ caseless: l }, u, f) : L.isPlainObject(f) ? L.merge({}, f) : L.isArray(f) ? f.slice() : f;
  }
  function i(u, f, l) {
    if (L.isUndefined(f)) {
      if (!L.isUndefined(u))
        return n(void 0, u, l);
    } else return n(u, f, l);
  }
  function o(u, f) {
    if (!L.isUndefined(f))
      return n(void 0, f);
  }
  function s(u, f) {
    if (L.isUndefined(f)) {
      if (!L.isUndefined(u))
        return n(void 0, u);
    } else return n(void 0, f);
  }
  function a(u, f, l) {
    if (l in t)
      return n(u, f);
    if (l in e)
      return n(void 0, u);
  }
  const c = {
    url: o,
    method: o,
    data: o,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: a,
    headers: (u, f) => i(x1(u), x1(f), !0)
  };
  return L.forEach(Object.keys(Object.assign({}, e, t)), function(f) {
    const l = c[f] || i, h = l(e[f], t[f], f);
    L.isUndefined(h) && l !== a || (r[f] = h);
  }), r;
}
const xb = (e) => {
  const t = so({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: o, headers: s, auth: a } = t;
  t.headers = s = ar.from(s), t.url = gb(vb(t.baseURL, t.url), e.params, e.paramsSerializer), a && s.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (L.isFormData(r)) {
    if (sr.hasStandardBrowserEnv || sr.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((c = s.getContentType()) !== !1) {
      const [u, ...f] = c ? c.split(";").map((l) => l.trim()).filter(Boolean) : [];
      s.setContentType([u || "multipart/form-data", ...f].join("; "));
    }
  }
  if (sr.hasStandardBrowserEnv && (n && L.isFunction(n) && (n = n(t)), n || n !== !1 && nP(t.url))) {
    const u = i && o && iP.read(o);
    u && s.set(i, u);
  }
  return t;
}, aP = typeof XMLHttpRequest < "u", cP = aP && function(e) {
  return new Promise(function(r, n) {
    const i = xb(e);
    let o = i.data;
    const s = ar.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: u } = i, f, l, h, m, y;
    function b() {
      m && m(), y && y(), i.cancelToken && i.cancelToken.unsubscribe(f), i.signal && i.signal.removeEventListener("abort", f);
    }
    let g = new XMLHttpRequest();
    g.open(i.method.toUpperCase(), i.url, !0), g.timeout = i.timeout;
    function v() {
      if (!g)
        return;
      const x = ar.from(
        "getAllResponseHeaders" in g && g.getAllResponseHeaders()
      ), P = {
        data: !a || a === "text" || a === "json" ? g.responseText : g.response,
        status: g.status,
        statusText: g.statusText,
        headers: x,
        config: e,
        request: g
      };
      wb(function(R) {
        r(R), b();
      }, function(R) {
        n(R), b();
      }, P), g = null;
    }
    "onloadend" in g ? g.onloadend = v : g.onreadystatechange = function() {
      !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(v);
    }, g.onabort = function() {
      g && (n(new Ae("Request aborted", Ae.ECONNABORTED, e, g)), g = null);
    }, g.onerror = function() {
      n(new Ae("Network Error", Ae.ERR_NETWORK, e, g)), g = null;
    }, g.ontimeout = function() {
      let k = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const P = i.transitional || mb;
      i.timeoutErrorMessage && (k = i.timeoutErrorMessage), n(new Ae(
        k,
        P.clarifyTimeoutError ? Ae.ETIMEDOUT : Ae.ECONNABORTED,
        e,
        g
      )), g = null;
    }, o === void 0 && s.setContentType(null), "setRequestHeader" in g && L.forEach(s.toJSON(), function(k, P) {
      g.setRequestHeader(P, k);
    }), L.isUndefined(i.withCredentials) || (g.withCredentials = !!i.withCredentials), a && a !== "json" && (g.responseType = i.responseType), u && ([h, y] = qc(u, !0), g.addEventListener("progress", h)), c && g.upload && ([l, m] = qc(c), g.upload.addEventListener("progress", l), g.upload.addEventListener("loadend", m)), (i.cancelToken || i.signal) && (f = (x) => {
      g && (n(!x || x.type ? new us(null, e, g) : x), g.abort(), g = null);
    }, i.cancelToken && i.cancelToken.subscribe(f), i.signal && (i.signal.aborted ? f() : i.signal.addEventListener("abort", f)));
    const _ = eP(i.url);
    if (_ && sr.protocols.indexOf(_) === -1) {
      n(new Ae("Unsupported protocol " + _ + ":", Ae.ERR_BAD_REQUEST, e));
      return;
    }
    g.send(o || null);
  });
}, uP = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), i;
    const o = function(u) {
      if (!i) {
        i = !0, a();
        const f = u instanceof Error ? u : this.reason;
        n.abort(f instanceof Ae ? f : new us(f instanceof Error ? f.message : f));
      }
    };
    let s = t && setTimeout(() => {
      s = null, o(new Ae(`timeout ${t} of ms exceeded`, Ae.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(o) : u.removeEventListener("abort", o);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", o));
    const { signal: c } = n;
    return c.unsubscribe = () => L.asap(a), c;
  }
}, lP = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let n = 0, i;
  for (; n < r; )
    i = n + t, yield e.slice(n, i), n = i;
}, fP = async function* (e, t) {
  for await (const r of dP(e))
    yield* lP(r, t);
}, dP = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
}, E1 = (e, t, r, n) => {
  const i = fP(e, t);
  let o = 0, s, a = (c) => {
    s || (s = !0, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: f } = await i.next();
        if (u) {
          a(), c.close();
          return;
        }
        let l = f.byteLength;
        if (r) {
          let h = o += l;
          r(h);
        }
        c.enqueue(new Uint8Array(f));
      } catch (u) {
        throw a(u), u;
      }
    },
    cancel(c) {
      return a(c), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, Ou = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Eb = Ou && typeof ReadableStream == "function", hP = Ou && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), Ab = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, pP = Eb && Ab(() => {
  let e = !1;
  const t = new Request(sr.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), A1 = 64 * 1024, Wf = Eb && Ab(() => L.isReadableStream(new Response("").body)), Vc = {
  stream: Wf && ((e) => e.body)
};
Ou && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Vc[t] && (Vc[t] = L.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new Ae(`Response type '${t}' is not supported`, Ae.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const gP = async (e) => {
  if (e == null)
    return 0;
  if (L.isBlob(e))
    return e.size;
  if (L.isSpecCompliantForm(e))
    return (await new Request(sr.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (L.isArrayBufferView(e) || L.isArrayBuffer(e))
    return e.byteLength;
  if (L.isURLSearchParams(e) && (e = e + ""), L.isString(e))
    return (await hP(e)).byteLength;
}, mP = async (e, t) => {
  const r = L.toFiniteNumber(e.getContentLength());
  return r ?? gP(t);
}, bP = Ou && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: i,
    cancelToken: o,
    timeout: s,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: u,
    headers: f,
    withCredentials: l = "same-origin",
    fetchOptions: h
  } = xb(e);
  u = u ? (u + "").toLowerCase() : "text";
  let m = uP([i, o && o.toAbortSignal()], s), y;
  const b = m && m.unsubscribe && (() => {
    m.unsubscribe();
  });
  let g;
  try {
    if (c && pP && r !== "get" && r !== "head" && (g = await mP(f, n)) !== 0) {
      let P = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), I;
      if (L.isFormData(n) && (I = P.headers.get("content-type")) && f.setContentType(I), P.body) {
        const [R, j] = w1(
          g,
          qc(v1(c))
        );
        n = E1(P.body, A1, R, j);
      }
    }
    L.isString(l) || (l = l ? "include" : "omit");
    const v = "credentials" in Request.prototype;
    y = new Request(t, {
      ...h,
      signal: m,
      method: r.toUpperCase(),
      headers: f.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: v ? l : void 0
    });
    let _ = await fetch(y);
    const x = Wf && (u === "stream" || u === "response");
    if (Wf && (a || x && b)) {
      const P = {};
      ["status", "statusText", "headers"].forEach((W) => {
        P[W] = _[W];
      });
      const I = L.toFiniteNumber(_.headers.get("content-length")), [R, j] = a && w1(
        I,
        qc(v1(a), !0)
      ) || [];
      _ = new Response(
        E1(_.body, A1, R, () => {
          j && j(), b && b();
        }),
        P
      );
    }
    u = u || "text";
    let k = await Vc[L.findKey(Vc, u) || "text"](_, e);
    return !x && b && b(), await new Promise((P, I) => {
      wb(P, I, {
        data: k,
        headers: ar.from(_.headers),
        status: _.status,
        statusText: _.statusText,
        config: e,
        request: y
      });
    });
  } catch (v) {
    throw b && b(), v && v.name === "TypeError" && /fetch/i.test(v.message) ? Object.assign(
      new Ae("Network Error", Ae.ERR_NETWORK, e, y),
      {
        cause: v.cause || v
      }
    ) : Ae.from(v, v && v.code, e, y);
  }
}), Gf = {
  http: OC,
  xhr: cP,
  fetch: bP
};
L.forEach(Gf, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const S1 = (e) => `- ${e}`, yP = (e) => L.isFunction(e) || e === null || e === !1, Sb = {
  getAdapter: (e) => {
    e = L.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const i = {};
    for (let o = 0; o < t; o++) {
      r = e[o];
      let s;
      if (n = r, !yP(r) && (n = Gf[(s = String(r)).toLowerCase()], n === void 0))
        throw new Ae(`Unknown adapter '${s}'`);
      if (n)
        break;
      i[s || "#" + o] = n;
    }
    if (!n) {
      const o = Object.entries(i).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? o.length > 1 ? `since :
` + o.map(S1).join(`
`) : " " + S1(o[0]) : "as no adapter specified";
      throw new Ae(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: Gf
};
function Vl(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new us(null, e);
}
function _1(e) {
  return Vl(e), e.headers = ar.from(e.headers), e.data = ql.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Sb.getAdapter(e.adapter || ya.adapter)(e).then(function(n) {
    return Vl(e), n.data = ql.call(
      e,
      e.transformResponse,
      n
    ), n.headers = ar.from(n.headers), n;
  }, function(n) {
    return yb(n) || (Vl(e), n && n.response && (n.response.data = ql.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = ar.from(n.response.headers))), Promise.reject(n);
  });
}
const _b = "1.7.7", Th = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Th[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const k1 = {};
Th.transitional = function(t, r, n) {
  function i(o, s) {
    return "[Axios v" + _b + "] Transitional option '" + o + "'" + s + (n ? ". " + n : "");
  }
  return (o, s, a) => {
    if (t === !1)
      throw new Ae(
        i(s, " has been removed" + (r ? " in " + r : "")),
        Ae.ERR_DEPRECATED
      );
    return r && !k1[s] && (k1[s] = !0, console.warn(
      i(
        s,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(o, s, a) : !0;
  };
};
function wP(e, t, r) {
  if (typeof e != "object")
    throw new Ae("options must be an object", Ae.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let i = n.length;
  for (; i-- > 0; ) {
    const o = n[i], s = t[o];
    if (s) {
      const a = e[o], c = a === void 0 || s(a, o, e);
      if (c !== !0)
        throw new Ae("option " + o + " must be " + c, Ae.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new Ae("Unknown option " + o, Ae.ERR_BAD_OPTION);
  }
}
const Zf = {
  assertOptions: wP,
  validators: Th
}, ui = Zf.validators;
class Ji {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new b1(),
      response: new b1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const o = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? o && !String(n.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + o) : n.stack = o;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = so(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: o } = r;
    n !== void 0 && Zf.assertOptions(n, {
      silentJSONParsing: ui.transitional(ui.boolean),
      forcedJSONParsing: ui.transitional(ui.boolean),
      clarifyTimeoutError: ui.transitional(ui.boolean)
    }, !1), i != null && (L.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : Zf.assertOptions(i, {
      encode: ui.function,
      serialize: ui.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let s = o && L.merge(
      o.common,
      o[r.method]
    );
    o && L.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete o[y];
      }
    ), r.headers = ar.concat(s, o);
    const a = [];
    let c = !0;
    this.interceptors.request.forEach(function(b) {
      typeof b.runWhen == "function" && b.runWhen(r) === !1 || (c = c && b.synchronous, a.unshift(b.fulfilled, b.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(b) {
      u.push(b.fulfilled, b.rejected);
    });
    let f, l = 0, h;
    if (!c) {
      const y = [_1.bind(this), void 0];
      for (y.unshift.apply(y, a), y.push.apply(y, u), h = y.length, f = Promise.resolve(r); l < h; )
        f = f.then(y[l++], y[l++]);
      return f;
    }
    h = a.length;
    let m = r;
    for (l = 0; l < h; ) {
      const y = a[l++], b = a[l++];
      try {
        m = y(m);
      } catch (g) {
        b.call(this, g);
        break;
      }
    }
    try {
      f = _1.call(this, m);
    } catch (y) {
      return Promise.reject(y);
    }
    for (l = 0, h = u.length; l < h; )
      f = f.then(u[l++], u[l++]);
    return f;
  }
  getUri(t) {
    t = so(this.defaults, t);
    const r = vb(t.baseURL, t.url);
    return gb(r, t.params, t.paramsSerializer);
  }
}
L.forEach(["delete", "get", "head", "options"], function(t) {
  Ji.prototype[t] = function(r, n) {
    return this.request(so(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
L.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(o, s, a) {
      return this.request(so(a || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: s
      }));
    };
  }
  Ji.prototype[t] = r(), Ji.prototype[t + "Form"] = r(!0);
});
class Ch {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let o = n._listeners.length;
      for (; o-- > 0; )
        n._listeners[o](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let o;
      const s = new Promise((a) => {
        n.subscribe(a), o = a;
      }).then(i);
      return s.cancel = function() {
        n.unsubscribe(o);
      }, s;
    }, t(function(o, s, a) {
      n.reason || (n.reason = new us(o, s, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Ch(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
function vP(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function xP(e) {
  return L.isObject(e) && e.isAxiosError === !0;
}
const Xf = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Xf).forEach(([e, t]) => {
  Xf[t] = e;
});
function kb(e) {
  const t = new Ji(e), r = nb(Ji.prototype.request, t);
  return L.extend(r, Ji.prototype, t, { allOwnKeys: !0 }), L.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(i) {
    return kb(so(e, i));
  }, r;
}
const ft = kb(ya);
ft.Axios = Ji;
ft.CanceledError = us;
ft.CancelToken = Ch;
ft.isCancel = yb;
ft.VERSION = _b;
ft.toFormData = Bu;
ft.AxiosError = Ae;
ft.Cancel = ft.CanceledError;
ft.all = function(t) {
  return Promise.all(t);
};
ft.spread = vP;
ft.isAxiosError = xP;
ft.mergeConfig = so;
ft.AxiosHeaders = ar;
ft.formToJSON = (e) => bb(L.isHTMLForm(e) ? new FormData(e) : e);
ft.getAdapter = Sb.getAdapter;
ft.HttpStatusCode = Xf;
ft.default = ft;
const EP = "https://mempool.space", AP = "https://mempool.space/testnet", SP = "https://mempool.space/testnet4", _P = "https://mempool.space/signet", kP = "https://mempool.fractalbitcoin.io", TP = "https://mempool-testnet.fractalbitcoin.io", $u = (e) => e === Ge ? AP : e === Et ? SP : e === Bt ? _P : e === fr ? kP : e === At ? TP : EP, fN = "text/html", dN = "text/css", CP = "text/plain", hN = "text/javascript", pN = "text/markdown", gN = "application/json", mN = "application/javascript", bN = "application/xml", yN = "application/pdf", wN = "application/zip", vN = "application/gzip", xN = "application/xhtml+xml", EN = "application/rss+xml", AN = "application/atom+xml", SN = "application/x-www-form-urlencoded", _N = "application/octet-stream", kN = "image/jpeg", TN = "image/png", CN = "image/gif", PN = "image/svg+xml", IN = "image/webp", BN = "image/x-icon", ON = "video/mp4", $N = "video/webm", NN = "video/ogg", UN = "audio/mpeg", FN = "audio/wav", HN = "audio/ogg", RN = "multipart/form-data";
Sp(Eh);
const Ot = (e) => e === Ge || e === Et || e === Bt ? b5 : Gr, Ph = (e) => e.find(({ purpose: t }) => t === "ordinals"), Ih = (e) => e.find(({ purpose: t }) => t === "payment"), ls = async (e, t) => {
  try {
    const r = await Bh(e, t);
    return r ? r.reduce((n, i) => n + BigInt(i.value), 0n) : 0n;
  } catch (r) {
    throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
  }
};
function PP(e, t, r) {
  const a = e * 57 + t * 41, c = r * 34;
  return 10 + a + c;
}
async function Bh(e, t) {
  if (e.startsWith("t")) {
    if (t === Ue)
      return [];
    if (t === fr)
      return [];
    if (t === At)
      return [];
  }
  return await ft.get(`${$u(t)}/api/address/${e}/utxo`).then((r) => r.data);
}
async function Oh(e, t, r, n, i, o, s = 7) {
  const a = e === t, c = await Bh(t, o);
  if (!c)
    throw new Error("No UTXOs found");
  const u = c.sort((b, g) => g.value - b.value), f = new Qe({ network: Ot(o) }), l = PP(1, 0, 2), h = Math.floor(l * s) + n;
  let m = 0, y = 0;
  for await (let b of u) {
    const { txid: g, vout: v, value: _ } = b, x = yd(t, Ot(o));
    if (f.addInput({
      hash: g,
      index: v,
      witnessUtxo: {
        script: x,
        value: BigInt(_)
      }
    }), !a) {
      const k = Tb(i, o);
      f.updateInput(y, { redeemScript: k });
    }
    if (m += _, m >= h)
      break;
  }
  if (m < h)
    throw new Error("Insufficient funds");
  return f.addOutput({
    address: r,
    value: BigInt(n)
  }), m > h && f.addOutput({
    address: t,
    value: BigInt(m - h)
  }), {
    psbtBase64: f.toBase64(),
    psbtHex: f.toHex()
  };
}
function Tb(e, t) {
  var i;
  const r = na({
    pubkey: Z2.Buffer.from(e, "hex"),
    network: Ot(t)
  }), n = ts({
    redeem: r,
    network: Ot(t)
  });
  return (i = n == null ? void 0 : n.redeem) == null ? void 0 : i.output;
}
function IP(e) {
  return e == null ? void 0 : e.reduce((t, r) => t + r.value, 0);
}
async function $h(e, t) {
  return (await ft.post(`${$u(t)}/api/tx`, e, {
    headers: {
      "Content-Type": "text/plain"
    }
  })).data;
}
const BP = (e, t) => {
  try {
    const r = Ot(t), n = Up(e);
    if (n.version === r.pubKeyHash)
      return p5;
    if (n.version === r.scriptHash) {
      const i = at(n.hash);
      return i && i.length === 2 && i[0] === Ve.OP_0 ? g5 : X1;
    }
  } catch {
    try {
      const n = bd(e);
      if (n.version === 0 && n.data.length === 20)
        return nf;
      if (n.version === 0 && n.data.length === 32)
        return m5;
      if (n.version === 1 && n.data.length === 32)
        return Ss;
    } catch {
      return "unknown";
    }
  }
  return "unknown";
}, Nh = (e) => e === Ge || e === Et || e === Bt, Uh = (e) => e === Ue || e === fr || e === At;
var gn = {}, Nt = {}, ye = {};
Object.defineProperty(ye, "__esModule", { value: !0 });
ye.add5L = ye.add5H = ye.add4H = ye.add4L = ye.add3H = ye.add3L = ye.rotlBL = ye.rotlBH = ye.rotlSL = ye.rotlSH = ye.rotr32L = ye.rotr32H = ye.rotrBL = ye.rotrBH = ye.rotrSL = ye.rotrSH = ye.shrSL = ye.shrSH = ye.toBig = void 0;
ye.fromBig = Fh;
ye.split = Cb;
ye.add = Db;
const Ka = /* @__PURE__ */ BigInt(2 ** 32 - 1), Yf = /* @__PURE__ */ BigInt(32);
function Fh(e, t = !1) {
  return t ? { h: Number(e & Ka), l: Number(e >> Yf & Ka) } : { h: Number(e >> Yf & Ka) | 0, l: Number(e & Ka) | 0 };
}
function Cb(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: o, l: s } = Fh(e[i], t);
    [r[i], n[i]] = [o, s];
  }
  return [r, n];
}
const Pb = (e, t) => BigInt(e >>> 0) << Yf | BigInt(t >>> 0);
ye.toBig = Pb;
const Ib = (e, t, r) => e >>> r;
ye.shrSH = Ib;
const Bb = (e, t, r) => e << 32 - r | t >>> r;
ye.shrSL = Bb;
const Ob = (e, t, r) => e >>> r | t << 32 - r;
ye.rotrSH = Ob;
const $b = (e, t, r) => e << 32 - r | t >>> r;
ye.rotrSL = $b;
const Nb = (e, t, r) => e << 64 - r | t >>> r - 32;
ye.rotrBH = Nb;
const Ub = (e, t, r) => e >>> r - 32 | t << 64 - r;
ye.rotrBL = Ub;
const Fb = (e, t) => t;
ye.rotr32H = Fb;
const Hb = (e, t) => e;
ye.rotr32L = Hb;
const Rb = (e, t, r) => e << r | t >>> 32 - r;
ye.rotlSH = Rb;
const Lb = (e, t, r) => t << r | e >>> 32 - r;
ye.rotlSL = Lb;
const zb = (e, t, r) => t << r - 32 | e >>> 64 - r;
ye.rotlBH = zb;
const jb = (e, t, r) => e << r - 32 | t >>> 64 - r;
ye.rotlBL = jb;
function Db(e, t, r, n) {
  const i = (t >>> 0) + (n >>> 0);
  return { h: e + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const Mb = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
ye.add3L = Mb;
const Kb = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
ye.add3H = Kb;
const qb = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
ye.add4L = qb;
const Vb = (e, t, r, n, i) => t + r + n + i + (e / 2 ** 32 | 0) | 0;
ye.add4H = Vb;
const Wb = (e, t, r, n, i) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0);
ye.add5L = Wb;
const Gb = (e, t, r, n, i, o) => t + r + n + i + o + (e / 2 ** 32 | 0) | 0;
ye.add5H = Gb;
const OP = {
  fromBig: Fh,
  split: Cb,
  toBig: Pb,
  shrSH: Ib,
  shrSL: Bb,
  rotrSH: Ob,
  rotrSL: $b,
  rotrBH: Nb,
  rotrBL: Ub,
  rotr32H: Fb,
  rotr32L: Hb,
  rotlSH: Rb,
  rotlSL: Lb,
  rotlBH: zb,
  rotlBL: jb,
  add: Db,
  add3L: Mb,
  add3H: Kb,
  add4L: qb,
  add4H: Vb,
  add5H: Gb,
  add5L: Wb
};
ye.default = OP;
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.sha384 = Nt.sha512_256 = Nt.sha512_224 = Nt.sha512 = Nt.SHA384 = Nt.SHA512_256 = Nt.SHA512_224 = Nt.SHA512 = void 0;
const $P = On, Pe = ye, Nu = Bi, [NP, UP] = Pe.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))), li = /* @__PURE__ */ new Uint32Array(80), fi = /* @__PURE__ */ new Uint32Array(80);
class wa extends $P.HashMD {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: i, Ch: o, Cl: s, Dh: a, Dl: c, Eh: u, El: f, Fh: l, Fl: h, Gh: m, Gl: y, Hh: b, Hl: g } = this;
    return [t, r, n, i, o, s, a, c, u, f, l, h, m, y, b, g];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, a, c, u, f, l, h, m, y, b, g) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = o | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = f | 0, this.Fh = l | 0, this.Fl = h | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = g | 0;
  }
  process(t, r) {
    for (let x = 0; x < 16; x++, r += 4)
      li[x] = t.getUint32(r), fi[x] = t.getUint32(r += 4);
    for (let x = 16; x < 80; x++) {
      const k = li[x - 15] | 0, P = fi[x - 15] | 0, I = Pe.default.rotrSH(k, P, 1) ^ Pe.default.rotrSH(k, P, 8) ^ Pe.default.shrSH(k, P, 7), R = Pe.default.rotrSL(k, P, 1) ^ Pe.default.rotrSL(k, P, 8) ^ Pe.default.shrSL(k, P, 7), j = li[x - 2] | 0, W = fi[x - 2] | 0, re = Pe.default.rotrSH(j, W, 19) ^ Pe.default.rotrBH(j, W, 61) ^ Pe.default.shrSH(j, W, 6), X = Pe.default.rotrSL(j, W, 19) ^ Pe.default.rotrBL(j, W, 61) ^ Pe.default.shrSL(j, W, 6), N = Pe.default.add4L(R, X, fi[x - 7], fi[x - 16]), G = Pe.default.add4H(N, I, re, li[x - 7], li[x - 16]);
      li[x] = G | 0, fi[x] = N | 0;
    }
    let { Ah: n, Al: i, Bh: o, Bl: s, Ch: a, Cl: c, Dh: u, Dl: f, Eh: l, El: h, Fh: m, Fl: y, Gh: b, Gl: g, Hh: v, Hl: _ } = this;
    for (let x = 0; x < 80; x++) {
      const k = Pe.default.rotrSH(l, h, 14) ^ Pe.default.rotrSH(l, h, 18) ^ Pe.default.rotrBH(l, h, 41), P = Pe.default.rotrSL(l, h, 14) ^ Pe.default.rotrSL(l, h, 18) ^ Pe.default.rotrBL(l, h, 41), I = l & m ^ ~l & b, R = h & y ^ ~h & g, j = Pe.default.add5L(_, P, R, UP[x], fi[x]), W = Pe.default.add5H(j, v, k, I, NP[x], li[x]), re = j | 0, X = Pe.default.rotrSH(n, i, 28) ^ Pe.default.rotrBH(n, i, 34) ^ Pe.default.rotrBH(n, i, 39), N = Pe.default.rotrSL(n, i, 28) ^ Pe.default.rotrBL(n, i, 34) ^ Pe.default.rotrBL(n, i, 39), G = n & o ^ n & a ^ o & a, M = i & s ^ i & c ^ s & c;
      v = b | 0, _ = g | 0, b = m | 0, g = y | 0, m = l | 0, y = h | 0, { h: l, l: h } = Pe.default.add(u | 0, f | 0, W | 0, re | 0), u = a | 0, f = c | 0, a = o | 0, c = s | 0, o = n | 0, s = i | 0;
      const $ = Pe.default.add3L(re, N, M);
      n = Pe.default.add3H($, W, X, G), i = $ | 0;
    }
    ({ h: n, l: i } = Pe.default.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: o, l: s } = Pe.default.add(this.Bh | 0, this.Bl | 0, o | 0, s | 0), { h: a, l: c } = Pe.default.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l: f } = Pe.default.add(this.Dh | 0, this.Dl | 0, u | 0, f | 0), { h: l, l: h } = Pe.default.add(this.Eh | 0, this.El | 0, l | 0, h | 0), { h: m, l: y } = Pe.default.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: b, l: g } = Pe.default.add(this.Gh | 0, this.Gl | 0, b | 0, g | 0), { h: v, l: _ } = Pe.default.add(this.Hh | 0, this.Hl | 0, v | 0, _ | 0), this.set(n, i, o, s, a, c, u, f, l, h, m, y, b, g, v, _);
  }
  roundClean() {
    li.fill(0), fi.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
Nt.SHA512 = wa;
class Zb extends wa {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
Nt.SHA512_224 = Zb;
class Xb extends wa {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
Nt.SHA512_256 = Xb;
class Yb extends wa {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
Nt.SHA384 = Yb;
Nt.sha512 = (0, Nu.wrapConstructor)(() => new wa());
Nt.sha512_224 = (0, Nu.wrapConstructor)(() => new Zb());
Nt.sha512_256 = (0, Nu.wrapConstructor)(() => new Xb());
Nt.sha384 = (0, Nu.wrapConstructor)(() => new Yb());
var Uu = {};
Object.defineProperty(Uu, "__esModule", { value: !0 });
Uu.pbkdf2 = HP;
Uu.pbkdf2Async = RP;
const qa = wr, FP = vu, Fo = Bi;
function Jb(e, t, r, n) {
  (0, qa.hash)(e);
  const i = (0, Fo.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: o, dkLen: s, asyncTick: a } = i;
  if ((0, qa.number)(o), (0, qa.number)(s), (0, qa.number)(a), o < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const c = (0, Fo.toBytes)(t), u = (0, Fo.toBytes)(r), f = new Uint8Array(s), l = FP.hmac.create(e, c), h = l._cloneInto().update(u);
  return { c: o, dkLen: s, asyncTick: a, DK: f, PRF: l, PRFSalt: h };
}
function Qb(e, t, r, n, i) {
  return e.destroy(), t.destroy(), n && n.destroy(), i.fill(0), r;
}
function HP(e, t, r, n) {
  const { c: i, dkLen: o, DK: s, PRF: a, PRFSalt: c } = Jb(e, t, r, n);
  let u;
  const f = new Uint8Array(4), l = (0, Fo.createView)(f), h = new Uint8Array(a.outputLen);
  for (let m = 1, y = 0; y < o; m++, y += a.outputLen) {
    const b = s.subarray(y, y + a.outputLen);
    l.setInt32(0, m, !1), (u = c._cloneInto(u)).update(f).digestInto(h), b.set(h.subarray(0, b.length));
    for (let g = 1; g < i; g++) {
      a._cloneInto(u).update(h).digestInto(h);
      for (let v = 0; v < b.length; v++)
        b[v] ^= h[v];
    }
  }
  return Qb(a, c, s, u, h);
}
async function RP(e, t, r, n) {
  const { c: i, dkLen: o, asyncTick: s, DK: a, PRF: c, PRFSalt: u } = Jb(e, t, r, n);
  let f;
  const l = new Uint8Array(4), h = (0, Fo.createView)(l), m = new Uint8Array(c.outputLen);
  for (let y = 1, b = 0; b < o; y++, b += c.outputLen) {
    const g = a.subarray(b, b + c.outputLen);
    h.setInt32(0, y, !1), (f = u._cloneInto(f)).update(l).digestInto(m), g.set(m.subarray(0, g.length)), await (0, Fo.asyncLoop)(i - 1, s, () => {
      c._cloneInto(f).update(m).digestInto(m);
      for (let v = 0; v < g.length; v++)
        g[v] ^= m[v];
    });
  }
  return Qb(c, u, a, f, m);
}
var tr = {};
const LP = [
  "abdikace",
  "abeceda",
  "adresa",
  "agrese",
  "akce",
  "aktovka",
  "alej",
  "alkohol",
  "amputace",
  "ananas",
  "andulka",
  "anekdota",
  "anketa",
  "antika",
  "anulovat",
  "archa",
  "arogance",
  "asfalt",
  "asistent",
  "aspirace",
  "astma",
  "astronom",
  "atlas",
  "atletika",
  "atol",
  "autobus",
  "azyl",
  "babka",
  "bachor",
  "bacil",
  "baculka",
  "badatel",
  "bageta",
  "bagr",
  "bahno",
  "bakterie",
  "balada",
  "baletka",
  "balkon",
  "balonek",
  "balvan",
  "balza",
  "bambus",
  "bankomat",
  "barbar",
  "baret",
  "barman",
  "baroko",
  "barva",
  "baterka",
  "batoh",
  "bavlna",
  "bazalka",
  "bazilika",
  "bazuka",
  "bedna",
  "beran",
  "beseda",
  "bestie",
  "beton",
  "bezinka",
  "bezmoc",
  "beztak",
  "bicykl",
  "bidlo",
  "biftek",
  "bikiny",
  "bilance",
  "biograf",
  "biolog",
  "bitva",
  "bizon",
  "blahobyt",
  "blatouch",
  "blecha",
  "bledule",
  "blesk",
  "blikat",
  "blizna",
  "blokovat",
  "bloudit",
  "blud",
  "bobek",
  "bobr",
  "bodlina",
  "bodnout",
  "bohatost",
  "bojkot",
  "bojovat",
  "bokorys",
  "bolest",
  "borec",
  "borovice",
  "bota",
  "boubel",
  "bouchat",
  "bouda",
  "boule",
  "bourat",
  "boxer",
  "bradavka",
  "brambora",
  "branka",
  "bratr",
  "brepta",
  "briketa",
  "brko",
  "brloh",
  "bronz",
  "broskev",
  "brunetka",
  "brusinka",
  "brzda",
  "brzy",
  "bublina",
  "bubnovat",
  "buchta",
  "buditel",
  "budka",
  "budova",
  "bufet",
  "bujarost",
  "bukvice",
  "buldok",
  "bulva",
  "bunda",
  "bunkr",
  "burza",
  "butik",
  "buvol",
  "buzola",
  "bydlet",
  "bylina",
  "bytovka",
  "bzukot",
  "capart",
  "carevna",
  "cedr",
  "cedule",
  "cejch",
  "cejn",
  "cela",
  "celer",
  "celkem",
  "celnice",
  "cenina",
  "cennost",
  "cenovka",
  "centrum",
  "cenzor",
  "cestopis",
  "cetka",
  "chalupa",
  "chapadlo",
  "charita",
  "chata",
  "chechtat",
  "chemie",
  "chichot",
  "chirurg",
  "chlad",
  "chleba",
  "chlubit",
  "chmel",
  "chmura",
  "chobot",
  "chochol",
  "chodba",
  "cholera",
  "chomout",
  "chopit",
  "choroba",
  "chov",
  "chrapot",
  "chrlit",
  "chrt",
  "chrup",
  "chtivost",
  "chudina",
  "chutnat",
  "chvat",
  "chvilka",
  "chvost",
  "chyba",
  "chystat",
  "chytit",
  "cibule",
  "cigareta",
  "cihelna",
  "cihla",
  "cinkot",
  "cirkus",
  "cisterna",
  "citace",
  "citrus",
  "cizinec",
  "cizost",
  "clona",
  "cokoliv",
  "couvat",
  "ctitel",
  "ctnost",
  "cudnost",
  "cuketa",
  "cukr",
  "cupot",
  "cvaknout",
  "cval",
  "cvik",
  "cvrkot",
  "cyklista",
  "daleko",
  "dareba",
  "datel",
  "datum",
  "dcera",
  "debata",
  "dechovka",
  "decibel",
  "deficit",
  "deflace",
  "dekl",
  "dekret",
  "demokrat",
  "deprese",
  "derby",
  "deska",
  "detektiv",
  "dikobraz",
  "diktovat",
  "dioda",
  "diplom",
  "disk",
  "displej",
  "divadlo",
  "divoch",
  "dlaha",
  "dlouho",
  "dluhopis",
  "dnes",
  "dobro",
  "dobytek",
  "docent",
  "dochutit",
  "dodnes",
  "dohled",
  "dohoda",
  "dohra",
  "dojem",
  "dojnice",
  "doklad",
  "dokola",
  "doktor",
  "dokument",
  "dolar",
  "doleva",
  "dolina",
  "doma",
  "dominant",
  "domluvit",
  "domov",
  "donutit",
  "dopad",
  "dopis",
  "doplnit",
  "doposud",
  "doprovod",
  "dopustit",
  "dorazit",
  "dorost",
  "dort",
  "dosah",
  "doslov",
  "dostatek",
  "dosud",
  "dosyta",
  "dotaz",
  "dotek",
  "dotknout",
  "doufat",
  "doutnat",
  "dovozce",
  "dozadu",
  "doznat",
  "dozorce",
  "drahota",
  "drak",
  "dramatik",
  "dravec",
  "draze",
  "drdol",
  "drobnost",
  "drogerie",
  "drozd",
  "drsnost",
  "drtit",
  "drzost",
  "duben",
  "duchovno",
  "dudek",
  "duha",
  "duhovka",
  "dusit",
  "dusno",
  "dutost",
  "dvojice",
  "dvorec",
  "dynamit",
  "ekolog",
  "ekonomie",
  "elektron",
  "elipsa",
  "email",
  "emise",
  "emoce",
  "empatie",
  "epizoda",
  "epocha",
  "epopej",
  "epos",
  "esej",
  "esence",
  "eskorta",
  "eskymo",
  "etiketa",
  "euforie",
  "evoluce",
  "exekuce",
  "exkurze",
  "expedice",
  "exploze",
  "export",
  "extrakt",
  "facka",
  "fajfka",
  "fakulta",
  "fanatik",
  "fantazie",
  "farmacie",
  "favorit",
  "fazole",
  "federace",
  "fejeton",
  "fenka",
  "fialka",
  "figurant",
  "filozof",
  "filtr",
  "finance",
  "finta",
  "fixace",
  "fjord",
  "flanel",
  "flirt",
  "flotila",
  "fond",
  "fosfor",
  "fotbal",
  "fotka",
  "foton",
  "frakce",
  "freska",
  "fronta",
  "fukar",
  "funkce",
  "fyzika",
  "galeje",
  "garant",
  "genetika",
  "geolog",
  "gilotina",
  "glazura",
  "glejt",
  "golem",
  "golfista",
  "gotika",
  "graf",
  "gramofon",
  "granule",
  "grep",
  "gril",
  "grog",
  "groteska",
  "guma",
  "hadice",
  "hadr",
  "hala",
  "halenka",
  "hanba",
  "hanopis",
  "harfa",
  "harpuna",
  "havran",
  "hebkost",
  "hejkal",
  "hejno",
  "hejtman",
  "hektar",
  "helma",
  "hematom",
  "herec",
  "herna",
  "heslo",
  "hezky",
  "historik",
  "hladovka",
  "hlasivky",
  "hlava",
  "hledat",
  "hlen",
  "hlodavec",
  "hloh",
  "hloupost",
  "hltat",
  "hlubina",
  "hluchota",
  "hmat",
  "hmota",
  "hmyz",
  "hnis",
  "hnojivo",
  "hnout",
  "hoblina",
  "hoboj",
  "hoch",
  "hodiny",
  "hodlat",
  "hodnota",
  "hodovat",
  "hojnost",
  "hokej",
  "holinka",
  "holka",
  "holub",
  "homole",
  "honitba",
  "honorace",
  "horal",
  "horda",
  "horizont",
  "horko",
  "horlivec",
  "hormon",
  "hornina",
  "horoskop",
  "horstvo",
  "hospoda",
  "hostina",
  "hotovost",
  "houba",
  "houf",
  "houpat",
  "houska",
  "hovor",
  "hradba",
  "hranice",
  "hravost",
  "hrazda",
  "hrbolek",
  "hrdina",
  "hrdlo",
  "hrdost",
  "hrnek",
  "hrobka",
  "hromada",
  "hrot",
  "hrouda",
  "hrozen",
  "hrstka",
  "hrubost",
  "hryzat",
  "hubenost",
  "hubnout",
  "hudba",
  "hukot",
  "humr",
  "husita",
  "hustota",
  "hvozd",
  "hybnost",
  "hydrant",
  "hygiena",
  "hymna",
  "hysterik",
  "idylka",
  "ihned",
  "ikona",
  "iluze",
  "imunita",
  "infekce",
  "inflace",
  "inkaso",
  "inovace",
  "inspekce",
  "internet",
  "invalida",
  "investor",
  "inzerce",
  "ironie",
  "jablko",
  "jachta",
  "jahoda",
  "jakmile",
  "jakost",
  "jalovec",
  "jantar",
  "jarmark",
  "jaro",
  "jasan",
  "jasno",
  "jatka",
  "javor",
  "jazyk",
  "jedinec",
  "jedle",
  "jednatel",
  "jehlan",
  "jekot",
  "jelen",
  "jelito",
  "jemnost",
  "jenom",
  "jepice",
  "jeseter",
  "jevit",
  "jezdec",
  "jezero",
  "jinak",
  "jindy",
  "jinoch",
  "jiskra",
  "jistota",
  "jitrnice",
  "jizva",
  "jmenovat",
  "jogurt",
  "jurta",
  "kabaret",
  "kabel",
  "kabinet",
  "kachna",
  "kadet",
  "kadidlo",
  "kahan",
  "kajak",
  "kajuta",
  "kakao",
  "kaktus",
  "kalamita",
  "kalhoty",
  "kalibr",
  "kalnost",
  "kamera",
  "kamkoliv",
  "kamna",
  "kanibal",
  "kanoe",
  "kantor",
  "kapalina",
  "kapela",
  "kapitola",
  "kapka",
  "kaple",
  "kapota",
  "kapr",
  "kapusta",
  "kapybara",
  "karamel",
  "karotka",
  "karton",
  "kasa",
  "katalog",
  "katedra",
  "kauce",
  "kauza",
  "kavalec",
  "kazajka",
  "kazeta",
  "kazivost",
  "kdekoliv",
  "kdesi",
  "kedluben",
  "kemp",
  "keramika",
  "kino",
  "klacek",
  "kladivo",
  "klam",
  "klapot",
  "klasika",
  "klaun",
  "klec",
  "klenba",
  "klepat",
  "klesnout",
  "klid",
  "klima",
  "klisna",
  "klobouk",
  "klokan",
  "klopa",
  "kloub",
  "klubovna",
  "klusat",
  "kluzkost",
  "kmen",
  "kmitat",
  "kmotr",
  "kniha",
  "knot",
  "koalice",
  "koberec",
  "kobka",
  "kobliha",
  "kobyla",
  "kocour",
  "kohout",
  "kojenec",
  "kokos",
  "koktejl",
  "kolaps",
  "koleda",
  "kolize",
  "kolo",
  "komando",
  "kometa",
  "komik",
  "komnata",
  "komora",
  "kompas",
  "komunita",
  "konat",
  "koncept",
  "kondice",
  "konec",
  "konfese",
  "kongres",
  "konina",
  "konkurs",
  "kontakt",
  "konzerva",
  "kopanec",
  "kopie",
  "kopnout",
  "koprovka",
  "korbel",
  "korektor",
  "kormidlo",
  "koroptev",
  "korpus",
  "koruna",
  "koryto",
  "korzet",
  "kosatec",
  "kostka",
  "kotel",
  "kotleta",
  "kotoul",
  "koukat",
  "koupelna",
  "kousek",
  "kouzlo",
  "kovboj",
  "koza",
  "kozoroh",
  "krabice",
  "krach",
  "krajina",
  "kralovat",
  "krasopis",
  "kravata",
  "kredit",
  "krejcar",
  "kresba",
  "kreveta",
  "kriket",
  "kritik",
  "krize",
  "krkavec",
  "krmelec",
  "krmivo",
  "krocan",
  "krok",
  "kronika",
  "kropit",
  "kroupa",
  "krovka",
  "krtek",
  "kruhadlo",
  "krupice",
  "krutost",
  "krvinka",
  "krychle",
  "krypta",
  "krystal",
  "kryt",
  "kudlanka",
  "kufr",
  "kujnost",
  "kukla",
  "kulajda",
  "kulich",
  "kulka",
  "kulomet",
  "kultura",
  "kuna",
  "kupodivu",
  "kurt",
  "kurzor",
  "kutil",
  "kvalita",
  "kvasinka",
  "kvestor",
  "kynolog",
  "kyselina",
  "kytara",
  "kytice",
  "kytka",
  "kytovec",
  "kyvadlo",
  "labrador",
  "lachtan",
  "ladnost",
  "laik",
  "lakomec",
  "lamela",
  "lampa",
  "lanovka",
  "lasice",
  "laso",
  "lastura",
  "latinka",
  "lavina",
  "lebka",
  "leckdy",
  "leden",
  "lednice",
  "ledovka",
  "ledvina",
  "legenda",
  "legie",
  "legrace",
  "lehce",
  "lehkost",
  "lehnout",
  "lektvar",
  "lenochod",
  "lentilka",
  "lepenka",
  "lepidlo",
  "letadlo",
  "letec",
  "letmo",
  "letokruh",
  "levhart",
  "levitace",
  "levobok",
  "libra",
  "lichotka",
  "lidojed",
  "lidskost",
  "lihovina",
  "lijavec",
  "lilek",
  "limetka",
  "linie",
  "linka",
  "linoleum",
  "listopad",
  "litina",
  "litovat",
  "lobista",
  "lodivod",
  "logika",
  "logoped",
  "lokalita",
  "loket",
  "lomcovat",
  "lopata",
  "lopuch",
  "lord",
  "losos",
  "lotr",
  "loudal",
  "louh",
  "louka",
  "louskat",
  "lovec",
  "lstivost",
  "lucerna",
  "lucifer",
  "lump",
  "lusk",
  "lustrace",
  "lvice",
  "lyra",
  "lyrika",
  "lysina",
  "madam",
  "madlo",
  "magistr",
  "mahagon",
  "majetek",
  "majitel",
  "majorita",
  "makak",
  "makovice",
  "makrela",
  "malba",
  "malina",
  "malovat",
  "malvice",
  "maminka",
  "mandle",
  "manko",
  "marnost",
  "masakr",
  "maskot",
  "masopust",
  "matice",
  "matrika",
  "maturita",
  "mazanec",
  "mazivo",
  "mazlit",
  "mazurka",
  "mdloba",
  "mechanik",
  "meditace",
  "medovina",
  "melasa",
  "meloun",
  "mentolka",
  "metla",
  "metoda",
  "metr",
  "mezera",
  "migrace",
  "mihnout",
  "mihule",
  "mikina",
  "mikrofon",
  "milenec",
  "milimetr",
  "milost",
  "mimika",
  "mincovna",
  "minibar",
  "minomet",
  "minulost",
  "miska",
  "mistr",
  "mixovat",
  "mladost",
  "mlha",
  "mlhovina",
  "mlok",
  "mlsat",
  "mluvit",
  "mnich",
  "mnohem",
  "mobil",
  "mocnost",
  "modelka",
  "modlitba",
  "mohyla",
  "mokro",
  "molekula",
  "momentka",
  "monarcha",
  "monokl",
  "monstrum",
  "montovat",
  "monzun",
  "mosaz",
  "moskyt",
  "most",
  "motivace",
  "motorka",
  "motyka",
  "moucha",
  "moudrost",
  "mozaika",
  "mozek",
  "mozol",
  "mramor",
  "mravenec",
  "mrkev",
  "mrtvola",
  "mrzet",
  "mrzutost",
  "mstitel",
  "mudrc",
  "muflon",
  "mulat",
  "mumie",
  "munice",
  "muset",
  "mutace",
  "muzeum",
  "muzikant",
  "myslivec",
  "mzda",
  "nabourat",
  "nachytat",
  "nadace",
  "nadbytek",
  "nadhoz",
  "nadobro",
  "nadpis",
  "nahlas",
  "nahnat",
  "nahodile",
  "nahradit",
  "naivita",
  "najednou",
  "najisto",
  "najmout",
  "naklonit",
  "nakonec",
  "nakrmit",
  "nalevo",
  "namazat",
  "namluvit",
  "nanometr",
  "naoko",
  "naopak",
  "naostro",
  "napadat",
  "napevno",
  "naplnit",
  "napnout",
  "naposled",
  "naprosto",
  "narodit",
  "naruby",
  "narychlo",
  "nasadit",
  "nasekat",
  "naslepo",
  "nastat",
  "natolik",
  "navenek",
  "navrch",
  "navzdory",
  "nazvat",
  "nebe",
  "nechat",
  "necky",
  "nedaleko",
  "nedbat",
  "neduh",
  "negace",
  "nehet",
  "nehoda",
  "nejen",
  "nejprve",
  "neklid",
  "nelibost",
  "nemilost",
  "nemoc",
  "neochota",
  "neonka",
  "nepokoj",
  "nerost",
  "nerv",
  "nesmysl",
  "nesoulad",
  "netvor",
  "neuron",
  "nevina",
  "nezvykle",
  "nicota",
  "nijak",
  "nikam",
  "nikdy",
  "nikl",
  "nikterak",
  "nitro",
  "nocleh",
  "nohavice",
  "nominace",
  "nora",
  "norek",
  "nositel",
  "nosnost",
  "nouze",
  "noviny",
  "novota",
  "nozdra",
  "nuda",
  "nudle",
  "nuget",
  "nutit",
  "nutnost",
  "nutrie",
  "nymfa",
  "obal",
  "obarvit",
  "obava",
  "obdiv",
  "obec",
  "obehnat",
  "obejmout",
  "obezita",
  "obhajoba",
  "obilnice",
  "objasnit",
  "objekt",
  "obklopit",
  "oblast",
  "oblek",
  "obliba",
  "obloha",
  "obluda",
  "obnos",
  "obohatit",
  "obojek",
  "obout",
  "obrazec",
  "obrna",
  "obruba",
  "obrys",
  "obsah",
  "obsluha",
  "obstarat",
  "obuv",
  "obvaz",
  "obvinit",
  "obvod",
  "obvykle",
  "obyvatel",
  "obzor",
  "ocas",
  "ocel",
  "ocenit",
  "ochladit",
  "ochota",
  "ochrana",
  "ocitnout",
  "odboj",
  "odbyt",
  "odchod",
  "odcizit",
  "odebrat",
  "odeslat",
  "odevzdat",
  "odezva",
  "odhadce",
  "odhodit",
  "odjet",
  "odjinud",
  "odkaz",
  "odkoupit",
  "odliv",
  "odluka",
  "odmlka",
  "odolnost",
  "odpad",
  "odpis",
  "odplout",
  "odpor",
  "odpustit",
  "odpykat",
  "odrazka",
  "odsoudit",
  "odstup",
  "odsun",
  "odtok",
  "odtud",
  "odvaha",
  "odveta",
  "odvolat",
  "odvracet",
  "odznak",
  "ofina",
  "ofsajd",
  "ohlas",
  "ohnisko",
  "ohrada",
  "ohrozit",
  "ohryzek",
  "okap",
  "okenice",
  "oklika",
  "okno",
  "okouzlit",
  "okovy",
  "okrasa",
  "okres",
  "okrsek",
  "okruh",
  "okupant",
  "okurka",
  "okusit",
  "olejnina",
  "olizovat",
  "omak",
  "omeleta",
  "omezit",
  "omladina",
  "omlouvat",
  "omluva",
  "omyl",
  "onehdy",
  "opakovat",
  "opasek",
  "operace",
  "opice",
  "opilost",
  "opisovat",
  "opora",
  "opozice",
  "opravdu",
  "oproti",
  "orbital",
  "orchestr",
  "orgie",
  "orlice",
  "orloj",
  "ortel",
  "osada",
  "oschnout",
  "osika",
  "osivo",
  "oslava",
  "oslepit",
  "oslnit",
  "oslovit",
  "osnova",
  "osoba",
  "osolit",
  "ospalec",
  "osten",
  "ostraha",
  "ostuda",
  "ostych",
  "osvojit",
  "oteplit",
  "otisk",
  "otop",
  "otrhat",
  "otrlost",
  "otrok",
  "otruby",
  "otvor",
  "ovanout",
  "ovar",
  "oves",
  "ovlivnit",
  "ovoce",
  "oxid",
  "ozdoba",
  "pachatel",
  "pacient",
  "padouch",
  "pahorek",
  "pakt",
  "palanda",
  "palec",
  "palivo",
  "paluba",
  "pamflet",
  "pamlsek",
  "panenka",
  "panika",
  "panna",
  "panovat",
  "panstvo",
  "pantofle",
  "paprika",
  "parketa",
  "parodie",
  "parta",
  "paruka",
  "paryba",
  "paseka",
  "pasivita",
  "pastelka",
  "patent",
  "patrona",
  "pavouk",
  "pazneht",
  "pazourek",
  "pecka",
  "pedagog",
  "pejsek",
  "peklo",
  "peloton",
  "penalta",
  "pendrek",
  "penze",
  "periskop",
  "pero",
  "pestrost",
  "petarda",
  "petice",
  "petrolej",
  "pevnina",
  "pexeso",
  "pianista",
  "piha",
  "pijavice",
  "pikle",
  "piknik",
  "pilina",
  "pilnost",
  "pilulka",
  "pinzeta",
  "pipeta",
  "pisatel",
  "pistole",
  "pitevna",
  "pivnice",
  "pivovar",
  "placenta",
  "plakat",
  "plamen",
  "planeta",
  "plastika",
  "platit",
  "plavidlo",
  "plaz",
  "plech",
  "plemeno",
  "plenta",
  "ples",
  "pletivo",
  "plevel",
  "plivat",
  "plnit",
  "plno",
  "plocha",
  "plodina",
  "plomba",
  "plout",
  "pluk",
  "plyn",
  "pobavit",
  "pobyt",
  "pochod",
  "pocit",
  "poctivec",
  "podat",
  "podcenit",
  "podepsat",
  "podhled",
  "podivit",
  "podklad",
  "podmanit",
  "podnik",
  "podoba",
  "podpora",
  "podraz",
  "podstata",
  "podvod",
  "podzim",
  "poezie",
  "pohanka",
  "pohnutka",
  "pohovor",
  "pohroma",
  "pohyb",
  "pointa",
  "pojistka",
  "pojmout",
  "pokazit",
  "pokles",
  "pokoj",
  "pokrok",
  "pokuta",
  "pokyn",
  "poledne",
  "polibek",
  "polknout",
  "poloha",
  "polynom",
  "pomalu",
  "pominout",
  "pomlka",
  "pomoc",
  "pomsta",
  "pomyslet",
  "ponechat",
  "ponorka",
  "ponurost",
  "popadat",
  "popel",
  "popisek",
  "poplach",
  "poprosit",
  "popsat",
  "popud",
  "poradce",
  "porce",
  "porod",
  "porucha",
  "poryv",
  "posadit",
  "posed",
  "posila",
  "poskok",
  "poslanec",
  "posoudit",
  "pospolu",
  "postava",
  "posudek",
  "posyp",
  "potah",
  "potkan",
  "potlesk",
  "potomek",
  "potrava",
  "potupa",
  "potvora",
  "poukaz",
  "pouto",
  "pouzdro",
  "povaha",
  "povidla",
  "povlak",
  "povoz",
  "povrch",
  "povstat",
  "povyk",
  "povzdech",
  "pozdrav",
  "pozemek",
  "poznatek",
  "pozor",
  "pozvat",
  "pracovat",
  "prahory",
  "praktika",
  "prales",
  "praotec",
  "praporek",
  "prase",
  "pravda",
  "princip",
  "prkno",
  "probudit",
  "procento",
  "prodej",
  "profese",
  "prohra",
  "projekt",
  "prolomit",
  "promile",
  "pronikat",
  "propad",
  "prorok",
  "prosba",
  "proton",
  "proutek",
  "provaz",
  "prskavka",
  "prsten",
  "prudkost",
  "prut",
  "prvek",
  "prvohory",
  "psanec",
  "psovod",
  "pstruh",
  "ptactvo",
  "puberta",
  "puch",
  "pudl",
  "pukavec",
  "puklina",
  "pukrle",
  "pult",
  "pumpa",
  "punc",
  "pupen",
  "pusa",
  "pusinka",
  "pustina",
  "putovat",
  "putyka",
  "pyramida",
  "pysk",
  "pytel",
  "racek",
  "rachot",
  "radiace",
  "radnice",
  "radon",
  "raft",
  "ragby",
  "raketa",
  "rakovina",
  "rameno",
  "rampouch",
  "rande",
  "rarach",
  "rarita",
  "rasovna",
  "rastr",
  "ratolest",
  "razance",
  "razidlo",
  "reagovat",
  "reakce",
  "recept",
  "redaktor",
  "referent",
  "reflex",
  "rejnok",
  "reklama",
  "rekord",
  "rekrut",
  "rektor",
  "reputace",
  "revize",
  "revma",
  "revolver",
  "rezerva",
  "riskovat",
  "riziko",
  "robotika",
  "rodokmen",
  "rohovka",
  "rokle",
  "rokoko",
  "romaneto",
  "ropovod",
  "ropucha",
  "rorejs",
  "rosol",
  "rostlina",
  "rotmistr",
  "rotoped",
  "rotunda",
  "roubenka",
  "roucho",
  "roup",
  "roura",
  "rovina",
  "rovnice",
  "rozbor",
  "rozchod",
  "rozdat",
  "rozeznat",
  "rozhodce",
  "rozinka",
  "rozjezd",
  "rozkaz",
  "rozloha",
  "rozmar",
  "rozpad",
  "rozruch",
  "rozsah",
  "roztok",
  "rozum",
  "rozvod",
  "rubrika",
  "ruchadlo",
  "rukavice",
  "rukopis",
  "ryba",
  "rybolov",
  "rychlost",
  "rydlo",
  "rypadlo",
  "rytina",
  "ryzost",
  "sadista",
  "sahat",
  "sako",
  "samec",
  "samizdat",
  "samota",
  "sanitka",
  "sardinka",
  "sasanka",
  "satelit",
  "sazba",
  "sazenice",
  "sbor",
  "schovat",
  "sebranka",
  "secese",
  "sedadlo",
  "sediment",
  "sedlo",
  "sehnat",
  "sejmout",
  "sekera",
  "sekta",
  "sekunda",
  "sekvoje",
  "semeno",
  "seno",
  "servis",
  "sesadit",
  "seshora",
  "seskok",
  "seslat",
  "sestra",
  "sesuv",
  "sesypat",
  "setba",
  "setina",
  "setkat",
  "setnout",
  "setrvat",
  "sever",
  "seznam",
  "shoda",
  "shrnout",
  "sifon",
  "silnice",
  "sirka",
  "sirotek",
  "sirup",
  "situace",
  "skafandr",
  "skalisko",
  "skanzen",
  "skaut",
  "skeptik",
  "skica",
  "skladba",
  "sklenice",
  "sklo",
  "skluz",
  "skoba",
  "skokan",
  "skoro",
  "skripta",
  "skrz",
  "skupina",
  "skvost",
  "skvrna",
  "slabika",
  "sladidlo",
  "slanina",
  "slast",
  "slavnost",
  "sledovat",
  "slepec",
  "sleva",
  "slezina",
  "slib",
  "slina",
  "sliznice",
  "slon",
  "sloupek",
  "slovo",
  "sluch",
  "sluha",
  "slunce",
  "slupka",
  "slza",
  "smaragd",
  "smetana",
  "smilstvo",
  "smlouva",
  "smog",
  "smrad",
  "smrk",
  "smrtka",
  "smutek",
  "smysl",
  "snad",
  "snaha",
  "snob",
  "sobota",
  "socha",
  "sodovka",
  "sokol",
  "sopka",
  "sotva",
  "souboj",
  "soucit",
  "soudce",
  "souhlas",
  "soulad",
  "soumrak",
  "souprava",
  "soused",
  "soutok",
  "souviset",
  "spalovna",
  "spasitel",
  "spis",
  "splav",
  "spodek",
  "spojenec",
  "spolu",
  "sponzor",
  "spornost",
  "spousta",
  "sprcha",
  "spustit",
  "sranda",
  "sraz",
  "srdce",
  "srna",
  "srnec",
  "srovnat",
  "srpen",
  "srst",
  "srub",
  "stanice",
  "starosta",
  "statika",
  "stavba",
  "stehno",
  "stezka",
  "stodola",
  "stolek",
  "stopa",
  "storno",
  "stoupat",
  "strach",
  "stres",
  "strhnout",
  "strom",
  "struna",
  "studna",
  "stupnice",
  "stvol",
  "styk",
  "subjekt",
  "subtropy",
  "suchar",
  "sudost",
  "sukno",
  "sundat",
  "sunout",
  "surikata",
  "surovina",
  "svah",
  "svalstvo",
  "svetr",
  "svatba",
  "svazek",
  "svisle",
  "svitek",
  "svoboda",
  "svodidlo",
  "svorka",
  "svrab",
  "sykavka",
  "sykot",
  "synek",
  "synovec",
  "sypat",
  "sypkost",
  "syrovost",
  "sysel",
  "sytost",
  "tabletka",
  "tabule",
  "tahoun",
  "tajemno",
  "tajfun",
  "tajga",
  "tajit",
  "tajnost",
  "taktika",
  "tamhle",
  "tampon",
  "tancovat",
  "tanec",
  "tanker",
  "tapeta",
  "tavenina",
  "tazatel",
  "technika",
  "tehdy",
  "tekutina",
  "telefon",
  "temnota",
  "tendence",
  "tenista",
  "tenor",
  "teplota",
  "tepna",
  "teprve",
  "terapie",
  "termoska",
  "textil",
  "ticho",
  "tiskopis",
  "titulek",
  "tkadlec",
  "tkanina",
  "tlapka",
  "tleskat",
  "tlukot",
  "tlupa",
  "tmel",
  "toaleta",
  "topinka",
  "topol",
  "torzo",
  "touha",
  "toulec",
  "tradice",
  "traktor",
  "tramp",
  "trasa",
  "traverza",
  "trefit",
  "trest",
  "trezor",
  "trhavina",
  "trhlina",
  "trochu",
  "trojice",
  "troska",
  "trouba",
  "trpce",
  "trpitel",
  "trpkost",
  "trubec",
  "truchlit",
  "truhlice",
  "trus",
  "trvat",
  "tudy",
  "tuhnout",
  "tuhost",
  "tundra",
  "turista",
  "turnaj",
  "tuzemsko",
  "tvaroh",
  "tvorba",
  "tvrdost",
  "tvrz",
  "tygr",
  "tykev",
  "ubohost",
  "uboze",
  "ubrat",
  "ubrousek",
  "ubrus",
  "ubytovna",
  "ucho",
  "uctivost",
  "udivit",
  "uhradit",
  "ujednat",
  "ujistit",
  "ujmout",
  "ukazatel",
  "uklidnit",
  "uklonit",
  "ukotvit",
  "ukrojit",
  "ulice",
  "ulita",
  "ulovit",
  "umyvadlo",
  "unavit",
  "uniforma",
  "uniknout",
  "upadnout",
  "uplatnit",
  "uplynout",
  "upoutat",
  "upravit",
  "uran",
  "urazit",
  "usednout",
  "usilovat",
  "usmrtit",
  "usnadnit",
  "usnout",
  "usoudit",
  "ustlat",
  "ustrnout",
  "utahovat",
  "utkat",
  "utlumit",
  "utonout",
  "utopenec",
  "utrousit",
  "uvalit",
  "uvolnit",
  "uvozovka",
  "uzdravit",
  "uzel",
  "uzenina",
  "uzlina",
  "uznat",
  "vagon",
  "valcha",
  "valoun",
  "vana",
  "vandal",
  "vanilka",
  "varan",
  "varhany",
  "varovat",
  "vcelku",
  "vchod",
  "vdova",
  "vedro",
  "vegetace",
  "vejce",
  "velbloud",
  "veletrh",
  "velitel",
  "velmoc",
  "velryba",
  "venkov",
  "veranda",
  "verze",
  "veselka",
  "veskrze",
  "vesnice",
  "vespodu",
  "vesta",
  "veterina",
  "veverka",
  "vibrace",
  "vichr",
  "videohra",
  "vidina",
  "vidle",
  "vila",
  "vinice",
  "viset",
  "vitalita",
  "vize",
  "vizitka",
  "vjezd",
  "vklad",
  "vkus",
  "vlajka",
  "vlak",
  "vlasec",
  "vlevo",
  "vlhkost",
  "vliv",
  "vlnovka",
  "vloupat",
  "vnucovat",
  "vnuk",
  "voda",
  "vodivost",
  "vodoznak",
  "vodstvo",
  "vojensky",
  "vojna",
  "vojsko",
  "volant",
  "volba",
  "volit",
  "volno",
  "voskovka",
  "vozidlo",
  "vozovna",
  "vpravo",
  "vrabec",
  "vracet",
  "vrah",
  "vrata",
  "vrba",
  "vrcholek",
  "vrhat",
  "vrstva",
  "vrtule",
  "vsadit",
  "vstoupit",
  "vstup",
  "vtip",
  "vybavit",
  "vybrat",
  "vychovat",
  "vydat",
  "vydra",
  "vyfotit",
  "vyhledat",
  "vyhnout",
  "vyhodit",
  "vyhradit",
  "vyhubit",
  "vyjasnit",
  "vyjet",
  "vyjmout",
  "vyklopit",
  "vykonat",
  "vylekat",
  "vymazat",
  "vymezit",
  "vymizet",
  "vymyslet",
  "vynechat",
  "vynikat",
  "vynutit",
  "vypadat",
  "vyplatit",
  "vypravit",
  "vypustit",
  "vyrazit",
  "vyrovnat",
  "vyrvat",
  "vyslovit",
  "vysoko",
  "vystavit",
  "vysunout",
  "vysypat",
  "vytasit",
  "vytesat",
  "vytratit",
  "vyvinout",
  "vyvolat",
  "vyvrhel",
  "vyzdobit",
  "vyznat",
  "vzadu",
  "vzbudit",
  "vzchopit",
  "vzdor",
  "vzduch",
  "vzdychat",
  "vzestup",
  "vzhledem",
  "vzkaz",
  "vzlykat",
  "vznik",
  "vzorek",
  "vzpoura",
  "vztah",
  "vztek",
  "xylofon",
  "zabrat",
  "zabydlet",
  "zachovat",
  "zadarmo",
  "zadusit",
  "zafoukat",
  "zahltit",
  "zahodit",
  "zahrada",
  "zahynout",
  "zajatec",
  "zajet",
  "zajistit",
  "zaklepat",
  "zakoupit",
  "zalepit",
  "zamezit",
  "zamotat",
  "zamyslet",
  "zanechat",
  "zanikat",
  "zaplatit",
  "zapojit",
  "zapsat",
  "zarazit",
  "zastavit",
  "zasunout",
  "zatajit",
  "zatemnit",
  "zatknout",
  "zaujmout",
  "zavalit",
  "zavelet",
  "zavinit",
  "zavolat",
  "zavrtat",
  "zazvonit",
  "zbavit",
  "zbrusu",
  "zbudovat",
  "zbytek",
  "zdaleka",
  "zdarma",
  "zdatnost",
  "zdivo",
  "zdobit",
  "zdroj",
  "zdvih",
  "zdymadlo",
  "zelenina",
  "zeman",
  "zemina",
  "zeptat",
  "zezadu",
  "zezdola",
  "zhatit",
  "zhltnout",
  "zhluboka",
  "zhotovit",
  "zhruba",
  "zima",
  "zimnice",
  "zjemnit",
  "zklamat",
  "zkoumat",
  "zkratka",
  "zkumavka",
  "zlato",
  "zlehka",
  "zloba",
  "zlom",
  "zlost",
  "zlozvyk",
  "zmapovat",
  "zmar",
  "zmatek",
  "zmije",
  "zmizet",
  "zmocnit",
  "zmodrat",
  "zmrzlina",
  "zmutovat",
  "znak",
  "znalost",
  "znamenat",
  "znovu",
  "zobrazit",
  "zotavit",
  "zoubek",
  "zoufale",
  "zplodit",
  "zpomalit",
  "zprava",
  "zprostit",
  "zprudka",
  "zprvu",
  "zrada",
  "zranit",
  "zrcadlo",
  "zrnitost",
  "zrno",
  "zrovna",
  "zrychlit",
  "zrzavost",
  "zticha",
  "ztratit",
  "zubovina",
  "zubr",
  "zvednout",
  "zvenku",
  "zvesela",
  "zvon",
  "zvrat",
  "zvukovod",
  "zvyk"
], zP = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], jP = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], DP = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], MP = [
  "abaisser",
  "abandon",
  "abdiquer",
  "abeille",
  "abolir",
  "aborder",
  "aboutir",
  "aboyer",
  "abrasif",
  "abreuver",
  "abriter",
  "abroger",
  "abrupt",
  "absence",
  "absolu",
  "absurde",
  "abusif",
  "abyssal",
  "academie",
  "acajou",
  "acarien",
  "accabler",
  "accepter",
  "acclamer",
  "accolade",
  "accroche",
  "accuser",
  "acerbe",
  "achat",
  "acheter",
  "aciduler",
  "acier",
  "acompte",
  "acquerir",
  "acronyme",
  "acteur",
  "actif",
  "actuel",
  "adepte",
  "adequat",
  "adhesif",
  "adjectif",
  "adjuger",
  "admettre",
  "admirer",
  "adopter",
  "adorer",
  "adoucir",
  "adresse",
  "adroit",
  "adulte",
  "adverbe",
  "aerer",
  "aeronef",
  "affaire",
  "affecter",
  "affiche",
  "affreux",
  "affubler",
  "agacer",
  "agencer",
  "agile",
  "agiter",
  "agrafer",
  "agreable",
  "agrume",
  "aider",
  "aiguille",
  "ailier",
  "aimable",
  "aisance",
  "ajouter",
  "ajuster",
  "alarmer",
  "alchimie",
  "alerte",
  "algebre",
  "algue",
  "aliener",
  "aliment",
  "alleger",
  "alliage",
  "allouer",
  "allumer",
  "alourdir",
  "alpaga",
  "altesse",
  "alveole",
  "amateur",
  "ambigu",
  "ambre",
  "amenager",
  "amertume",
  "amidon",
  "amiral",
  "amorcer",
  "amour",
  "amovible",
  "amphibie",
  "ampleur",
  "amusant",
  "analyse",
  "anaphore",
  "anarchie",
  "anatomie",
  "ancien",
  "aneantir",
  "angle",
  "angoisse",
  "anguleux",
  "animal",
  "annexer",
  "annonce",
  "annuel",
  "anodin",
  "anomalie",
  "anonyme",
  "anormal",
  "antenne",
  "antidote",
  "anxieux",
  "apaiser",
  "aperitif",
  "aplanir",
  "apologie",
  "appareil",
  "appeler",
  "apporter",
  "appuyer",
  "aquarium",
  "aqueduc",
  "arbitre",
  "arbuste",
  "ardeur",
  "ardoise",
  "argent",
  "arlequin",
  "armature",
  "armement",
  "armoire",
  "armure",
  "arpenter",
  "arracher",
  "arriver",
  "arroser",
  "arsenic",
  "arteriel",
  "article",
  "aspect",
  "asphalte",
  "aspirer",
  "assaut",
  "asservir",
  "assiette",
  "associer",
  "assurer",
  "asticot",
  "astre",
  "astuce",
  "atelier",
  "atome",
  "atrium",
  "atroce",
  "attaque",
  "attentif",
  "attirer",
  "attraper",
  "aubaine",
  "auberge",
  "audace",
  "audible",
  "augurer",
  "aurore",
  "automne",
  "autruche",
  "avaler",
  "avancer",
  "avarice",
  "avenir",
  "averse",
  "aveugle",
  "aviateur",
  "avide",
  "avion",
  "aviser",
  "avoine",
  "avouer",
  "avril",
  "axial",
  "axiome",
  "badge",
  "bafouer",
  "bagage",
  "baguette",
  "baignade",
  "balancer",
  "balcon",
  "baleine",
  "balisage",
  "bambin",
  "bancaire",
  "bandage",
  "banlieue",
  "banniere",
  "banquier",
  "barbier",
  "baril",
  "baron",
  "barque",
  "barrage",
  "bassin",
  "bastion",
  "bataille",
  "bateau",
  "batterie",
  "baudrier",
  "bavarder",
  "belette",
  "belier",
  "belote",
  "benefice",
  "berceau",
  "berger",
  "berline",
  "bermuda",
  "besace",
  "besogne",
  "betail",
  "beurre",
  "biberon",
  "bicycle",
  "bidule",
  "bijou",
  "bilan",
  "bilingue",
  "billard",
  "binaire",
  "biologie",
  "biopsie",
  "biotype",
  "biscuit",
  "bison",
  "bistouri",
  "bitume",
  "bizarre",
  "blafard",
  "blague",
  "blanchir",
  "blessant",
  "blinder",
  "blond",
  "bloquer",
  "blouson",
  "bobard",
  "bobine",
  "boire",
  "boiser",
  "bolide",
  "bonbon",
  "bondir",
  "bonheur",
  "bonifier",
  "bonus",
  "bordure",
  "borne",
  "botte",
  "boucle",
  "boueux",
  "bougie",
  "boulon",
  "bouquin",
  "bourse",
  "boussole",
  "boutique",
  "boxeur",
  "branche",
  "brasier",
  "brave",
  "brebis",
  "breche",
  "breuvage",
  "bricoler",
  "brigade",
  "brillant",
  "brioche",
  "brique",
  "brochure",
  "broder",
  "bronzer",
  "brousse",
  "broyeur",
  "brume",
  "brusque",
  "brutal",
  "bruyant",
  "buffle",
  "buisson",
  "bulletin",
  "bureau",
  "burin",
  "bustier",
  "butiner",
  "butoir",
  "buvable",
  "buvette",
  "cabanon",
  "cabine",
  "cachette",
  "cadeau",
  "cadre",
  "cafeine",
  "caillou",
  "caisson",
  "calculer",
  "calepin",
  "calibre",
  "calmer",
  "calomnie",
  "calvaire",
  "camarade",
  "camera",
  "camion",
  "campagne",
  "canal",
  "caneton",
  "canon",
  "cantine",
  "canular",
  "capable",
  "caporal",
  "caprice",
  "capsule",
  "capter",
  "capuche",
  "carabine",
  "carbone",
  "caresser",
  "caribou",
  "carnage",
  "carotte",
  "carreau",
  "carton",
  "cascade",
  "casier",
  "casque",
  "cassure",
  "causer",
  "caution",
  "cavalier",
  "caverne",
  "caviar",
  "cedille",
  "ceinture",
  "celeste",
  "cellule",
  "cendrier",
  "censurer",
  "central",
  "cercle",
  "cerebral",
  "cerise",
  "cerner",
  "cerveau",
  "cesser",
  "chagrin",
  "chaise",
  "chaleur",
  "chambre",
  "chance",
  "chapitre",
  "charbon",
  "chasseur",
  "chaton",
  "chausson",
  "chavirer",
  "chemise",
  "chenille",
  "chequier",
  "chercher",
  "cheval",
  "chien",
  "chiffre",
  "chignon",
  "chimere",
  "chiot",
  "chlorure",
  "chocolat",
  "choisir",
  "chose",
  "chouette",
  "chrome",
  "chute",
  "cigare",
  "cigogne",
  "cimenter",
  "cinema",
  "cintrer",
  "circuler",
  "cirer",
  "cirque",
  "citerne",
  "citoyen",
  "citron",
  "civil",
  "clairon",
  "clameur",
  "claquer",
  "classe",
  "clavier",
  "client",
  "cligner",
  "climat",
  "clivage",
  "cloche",
  "clonage",
  "cloporte",
  "cobalt",
  "cobra",
  "cocasse",
  "cocotier",
  "coder",
  "codifier",
  "coffre",
  "cogner",
  "cohesion",
  "coiffer",
  "coincer",
  "colere",
  "colibri",
  "colline",
  "colmater",
  "colonel",
  "combat",
  "comedie",
  "commande",
  "compact",
  "concert",
  "conduire",
  "confier",
  "congeler",
  "connoter",
  "consonne",
  "contact",
  "convexe",
  "copain",
  "copie",
  "corail",
  "corbeau",
  "cordage",
  "corniche",
  "corpus",
  "correct",
  "cortege",
  "cosmique",
  "costume",
  "coton",
  "coude",
  "coupure",
  "courage",
  "couteau",
  "couvrir",
  "coyote",
  "crabe",
  "crainte",
  "cravate",
  "crayon",
  "creature",
  "crediter",
  "cremeux",
  "creuser",
  "crevette",
  "cribler",
  "crier",
  "cristal",
  "critere",
  "croire",
  "croquer",
  "crotale",
  "crucial",
  "cruel",
  "crypter",
  "cubique",
  "cueillir",
  "cuillere",
  "cuisine",
  "cuivre",
  "culminer",
  "cultiver",
  "cumuler",
  "cupide",
  "curatif",
  "curseur",
  "cyanure",
  "cycle",
  "cylindre",
  "cynique",
  "daigner",
  "damier",
  "danger",
  "danseur",
  "dauphin",
  "debattre",
  "debiter",
  "deborder",
  "debrider",
  "debutant",
  "decaler",
  "decembre",
  "dechirer",
  "decider",
  "declarer",
  "decorer",
  "decrire",
  "decupler",
  "dedale",
  "deductif",
  "deesse",
  "defensif",
  "defiler",
  "defrayer",
  "degager",
  "degivrer",
  "deglutir",
  "degrafer",
  "dejeuner",
  "delice",
  "deloger",
  "demander",
  "demeurer",
  "demolir",
  "denicher",
  "denouer",
  "dentelle",
  "denuder",
  "depart",
  "depenser",
  "dephaser",
  "deplacer",
  "deposer",
  "deranger",
  "derober",
  "desastre",
  "descente",
  "desert",
  "designer",
  "desobeir",
  "dessiner",
  "destrier",
  "detacher",
  "detester",
  "detourer",
  "detresse",
  "devancer",
  "devenir",
  "deviner",
  "devoir",
  "diable",
  "dialogue",
  "diamant",
  "dicter",
  "differer",
  "digerer",
  "digital",
  "digne",
  "diluer",
  "dimanche",
  "diminuer",
  "dioxyde",
  "directif",
  "diriger",
  "discuter",
  "disposer",
  "dissiper",
  "distance",
  "divertir",
  "diviser",
  "docile",
  "docteur",
  "dogme",
  "doigt",
  "domaine",
  "domicile",
  "dompter",
  "donateur",
  "donjon",
  "donner",
  "dopamine",
  "dortoir",
  "dorure",
  "dosage",
  "doseur",
  "dossier",
  "dotation",
  "douanier",
  "double",
  "douceur",
  "douter",
  "doyen",
  "dragon",
  "draper",
  "dresser",
  "dribbler",
  "droiture",
  "duperie",
  "duplexe",
  "durable",
  "durcir",
  "dynastie",
  "eblouir",
  "ecarter",
  "echarpe",
  "echelle",
  "eclairer",
  "eclipse",
  "eclore",
  "ecluse",
  "ecole",
  "economie",
  "ecorce",
  "ecouter",
  "ecraser",
  "ecremer",
  "ecrivain",
  "ecrou",
  "ecume",
  "ecureuil",
  "edifier",
  "eduquer",
  "effacer",
  "effectif",
  "effigie",
  "effort",
  "effrayer",
  "effusion",
  "egaliser",
  "egarer",
  "ejecter",
  "elaborer",
  "elargir",
  "electron",
  "elegant",
  "elephant",
  "eleve",
  "eligible",
  "elitisme",
  "eloge",
  "elucider",
  "eluder",
  "emballer",
  "embellir",
  "embryon",
  "emeraude",
  "emission",
  "emmener",
  "emotion",
  "emouvoir",
  "empereur",
  "employer",
  "emporter",
  "emprise",
  "emulsion",
  "encadrer",
  "enchere",
  "enclave",
  "encoche",
  "endiguer",
  "endosser",
  "endroit",
  "enduire",
  "energie",
  "enfance",
  "enfermer",
  "enfouir",
  "engager",
  "engin",
  "englober",
  "enigme",
  "enjamber",
  "enjeu",
  "enlever",
  "ennemi",
  "ennuyeux",
  "enrichir",
  "enrobage",
  "enseigne",
  "entasser",
  "entendre",
  "entier",
  "entourer",
  "entraver",
  "enumerer",
  "envahir",
  "enviable",
  "envoyer",
  "enzyme",
  "eolien",
  "epaissir",
  "epargne",
  "epatant",
  "epaule",
  "epicerie",
  "epidemie",
  "epier",
  "epilogue",
  "epine",
  "episode",
  "epitaphe",
  "epoque",
  "epreuve",
  "eprouver",
  "epuisant",
  "equerre",
  "equipe",
  "eriger",
  "erosion",
  "erreur",
  "eruption",
  "escalier",
  "espadon",
  "espece",
  "espiegle",
  "espoir",
  "esprit",
  "esquiver",
  "essayer",
  "essence",
  "essieu",
  "essorer",
  "estime",
  "estomac",
  "estrade",
  "etagere",
  "etaler",
  "etanche",
  "etatique",
  "eteindre",
  "etendoir",
  "eternel",
  "ethanol",
  "ethique",
  "ethnie",
  "etirer",
  "etoffer",
  "etoile",
  "etonnant",
  "etourdir",
  "etrange",
  "etroit",
  "etude",
  "euphorie",
  "evaluer",
  "evasion",
  "eventail",
  "evidence",
  "eviter",
  "evolutif",
  "evoquer",
  "exact",
  "exagerer",
  "exaucer",
  "exceller",
  "excitant",
  "exclusif",
  "excuse",
  "executer",
  "exemple",
  "exercer",
  "exhaler",
  "exhorter",
  "exigence",
  "exiler",
  "exister",
  "exotique",
  "expedier",
  "explorer",
  "exposer",
  "exprimer",
  "exquis",
  "extensif",
  "extraire",
  "exulter",
  "fable",
  "fabuleux",
  "facette",
  "facile",
  "facture",
  "faiblir",
  "falaise",
  "fameux",
  "famille",
  "farceur",
  "farfelu",
  "farine",
  "farouche",
  "fasciner",
  "fatal",
  "fatigue",
  "faucon",
  "fautif",
  "faveur",
  "favori",
  "febrile",
  "feconder",
  "federer",
  "felin",
  "femme",
  "femur",
  "fendoir",
  "feodal",
  "fermer",
  "feroce",
  "ferveur",
  "festival",
  "feuille",
  "feutre",
  "fevrier",
  "fiasco",
  "ficeler",
  "fictif",
  "fidele",
  "figure",
  "filature",
  "filetage",
  "filiere",
  "filleul",
  "filmer",
  "filou",
  "filtrer",
  "financer",
  "finir",
  "fiole",
  "firme",
  "fissure",
  "fixer",
  "flairer",
  "flamme",
  "flasque",
  "flatteur",
  "fleau",
  "fleche",
  "fleur",
  "flexion",
  "flocon",
  "flore",
  "fluctuer",
  "fluide",
  "fluvial",
  "folie",
  "fonderie",
  "fongible",
  "fontaine",
  "forcer",
  "forgeron",
  "formuler",
  "fortune",
  "fossile",
  "foudre",
  "fougere",
  "fouiller",
  "foulure",
  "fourmi",
  "fragile",
  "fraise",
  "franchir",
  "frapper",
  "frayeur",
  "fregate",
  "freiner",
  "frelon",
  "fremir",
  "frenesie",
  "frere",
  "friable",
  "friction",
  "frisson",
  "frivole",
  "froid",
  "fromage",
  "frontal",
  "frotter",
  "fruit",
  "fugitif",
  "fuite",
  "fureur",
  "furieux",
  "furtif",
  "fusion",
  "futur",
  "gagner",
  "galaxie",
  "galerie",
  "gambader",
  "garantir",
  "gardien",
  "garnir",
  "garrigue",
  "gazelle",
  "gazon",
  "geant",
  "gelatine",
  "gelule",
  "gendarme",
  "general",
  "genie",
  "genou",
  "gentil",
  "geologie",
  "geometre",
  "geranium",
  "germe",
  "gestuel",
  "geyser",
  "gibier",
  "gicler",
  "girafe",
  "givre",
  "glace",
  "glaive",
  "glisser",
  "globe",
  "gloire",
  "glorieux",
  "golfeur",
  "gomme",
  "gonfler",
  "gorge",
  "gorille",
  "goudron",
  "gouffre",
  "goulot",
  "goupille",
  "gourmand",
  "goutte",
  "graduel",
  "graffiti",
  "graine",
  "grand",
  "grappin",
  "gratuit",
  "gravir",
  "grenat",
  "griffure",
  "griller",
  "grimper",
  "grogner",
  "gronder",
  "grotte",
  "groupe",
  "gruger",
  "grutier",
  "gruyere",
  "guepard",
  "guerrier",
  "guide",
  "guimauve",
  "guitare",
  "gustatif",
  "gymnaste",
  "gyrostat",
  "habitude",
  "hachoir",
  "halte",
  "hameau",
  "hangar",
  "hanneton",
  "haricot",
  "harmonie",
  "harpon",
  "hasard",
  "helium",
  "hematome",
  "herbe",
  "herisson",
  "hermine",
  "heron",
  "hesiter",
  "heureux",
  "hiberner",
  "hibou",
  "hilarant",
  "histoire",
  "hiver",
  "homard",
  "hommage",
  "homogene",
  "honneur",
  "honorer",
  "honteux",
  "horde",
  "horizon",
  "horloge",
  "hormone",
  "horrible",
  "houleux",
  "housse",
  "hublot",
  "huileux",
  "humain",
  "humble",
  "humide",
  "humour",
  "hurler",
  "hydromel",
  "hygiene",
  "hymne",
  "hypnose",
  "idylle",
  "ignorer",
  "iguane",
  "illicite",
  "illusion",
  "image",
  "imbiber",
  "imiter",
  "immense",
  "immobile",
  "immuable",
  "impact",
  "imperial",
  "implorer",
  "imposer",
  "imprimer",
  "imputer",
  "incarner",
  "incendie",
  "incident",
  "incliner",
  "incolore",
  "indexer",
  "indice",
  "inductif",
  "inedit",
  "ineptie",
  "inexact",
  "infini",
  "infliger",
  "informer",
  "infusion",
  "ingerer",
  "inhaler",
  "inhiber",
  "injecter",
  "injure",
  "innocent",
  "inoculer",
  "inonder",
  "inscrire",
  "insecte",
  "insigne",
  "insolite",
  "inspirer",
  "instinct",
  "insulter",
  "intact",
  "intense",
  "intime",
  "intrigue",
  "intuitif",
  "inutile",
  "invasion",
  "inventer",
  "inviter",
  "invoquer",
  "ironique",
  "irradier",
  "irreel",
  "irriter",
  "isoler",
  "ivoire",
  "ivresse",
  "jaguar",
  "jaillir",
  "jambe",
  "janvier",
  "jardin",
  "jauger",
  "jaune",
  "javelot",
  "jetable",
  "jeton",
  "jeudi",
  "jeunesse",
  "joindre",
  "joncher",
  "jongler",
  "joueur",
  "jouissif",
  "journal",
  "jovial",
  "joyau",
  "joyeux",
  "jubiler",
  "jugement",
  "junior",
  "jupon",
  "juriste",
  "justice",
  "juteux",
  "juvenile",
  "kayak",
  "kimono",
  "kiosque",
  "label",
  "labial",
  "labourer",
  "lacerer",
  "lactose",
  "lagune",
  "laine",
  "laisser",
  "laitier",
  "lambeau",
  "lamelle",
  "lampe",
  "lanceur",
  "langage",
  "lanterne",
  "lapin",
  "largeur",
  "larme",
  "laurier",
  "lavabo",
  "lavoir",
  "lecture",
  "legal",
  "leger",
  "legume",
  "lessive",
  "lettre",
  "levier",
  "lexique",
  "lezard",
  "liasse",
  "liberer",
  "libre",
  "licence",
  "licorne",
  "liege",
  "lievre",
  "ligature",
  "ligoter",
  "ligue",
  "limer",
  "limite",
  "limonade",
  "limpide",
  "lineaire",
  "lingot",
  "lionceau",
  "liquide",
  "lisiere",
  "lister",
  "lithium",
  "litige",
  "littoral",
  "livreur",
  "logique",
  "lointain",
  "loisir",
  "lombric",
  "loterie",
  "louer",
  "lourd",
  "loutre",
  "louve",
  "loyal",
  "lubie",
  "lucide",
  "lucratif",
  "lueur",
  "lugubre",
  "luisant",
  "lumiere",
  "lunaire",
  "lundi",
  "luron",
  "lutter",
  "luxueux",
  "machine",
  "magasin",
  "magenta",
  "magique",
  "maigre",
  "maillon",
  "maintien",
  "mairie",
  "maison",
  "majorer",
  "malaxer",
  "malefice",
  "malheur",
  "malice",
  "mallette",
  "mammouth",
  "mandater",
  "maniable",
  "manquant",
  "manteau",
  "manuel",
  "marathon",
  "marbre",
  "marchand",
  "mardi",
  "maritime",
  "marqueur",
  "marron",
  "marteler",
  "mascotte",
  "massif",
  "materiel",
  "matiere",
  "matraque",
  "maudire",
  "maussade",
  "mauve",
  "maximal",
  "mechant",
  "meconnu",
  "medaille",
  "medecin",
  "mediter",
  "meduse",
  "meilleur",
  "melange",
  "melodie",
  "membre",
  "memoire",
  "menacer",
  "mener",
  "menhir",
  "mensonge",
  "mentor",
  "mercredi",
  "merite",
  "merle",
  "messager",
  "mesure",
  "metal",
  "meteore",
  "methode",
  "metier",
  "meuble",
  "miauler",
  "microbe",
  "miette",
  "mignon",
  "migrer",
  "milieu",
  "million",
  "mimique",
  "mince",
  "mineral",
  "minimal",
  "minorer",
  "minute",
  "miracle",
  "miroiter",
  "missile",
  "mixte",
  "mobile",
  "moderne",
  "moelleux",
  "mondial",
  "moniteur",
  "monnaie",
  "monotone",
  "monstre",
  "montagne",
  "monument",
  "moqueur",
  "morceau",
  "morsure",
  "mortier",
  "moteur",
  "motif",
  "mouche",
  "moufle",
  "moulin",
  "mousson",
  "mouton",
  "mouvant",
  "multiple",
  "munition",
  "muraille",
  "murene",
  "murmure",
  "muscle",
  "museum",
  "musicien",
  "mutation",
  "muter",
  "mutuel",
  "myriade",
  "myrtille",
  "mystere",
  "mythique",
  "nageur",
  "nappe",
  "narquois",
  "narrer",
  "natation",
  "nation",
  "nature",
  "naufrage",
  "nautique",
  "navire",
  "nebuleux",
  "nectar",
  "nefaste",
  "negation",
  "negliger",
  "negocier",
  "neige",
  "nerveux",
  "nettoyer",
  "neurone",
  "neutron",
  "neveu",
  "niche",
  "nickel",
  "nitrate",
  "niveau",
  "noble",
  "nocif",
  "nocturne",
  "noirceur",
  "noisette",
  "nomade",
  "nombreux",
  "nommer",
  "normatif",
  "notable",
  "notifier",
  "notoire",
  "nourrir",
  "nouveau",
  "novateur",
  "novembre",
  "novice",
  "nuage",
  "nuancer",
  "nuire",
  "nuisible",
  "numero",
  "nuptial",
  "nuque",
  "nutritif",
  "obeir",
  "objectif",
  "obliger",
  "obscur",
  "observer",
  "obstacle",
  "obtenir",
  "obturer",
  "occasion",
  "occuper",
  "ocean",
  "octobre",
  "octroyer",
  "octupler",
  "oculaire",
  "odeur",
  "odorant",
  "offenser",
  "officier",
  "offrir",
  "ogive",
  "oiseau",
  "oisillon",
  "olfactif",
  "olivier",
  "ombrage",
  "omettre",
  "onctueux",
  "onduler",
  "onereux",
  "onirique",
  "opale",
  "opaque",
  "operer",
  "opinion",
  "opportun",
  "opprimer",
  "opter",
  "optique",
  "orageux",
  "orange",
  "orbite",
  "ordonner",
  "oreille",
  "organe",
  "orgueil",
  "orifice",
  "ornement",
  "orque",
  "ortie",
  "osciller",
  "osmose",
  "ossature",
  "otarie",
  "ouragan",
  "ourson",
  "outil",
  "outrager",
  "ouvrage",
  "ovation",
  "oxyde",
  "oxygene",
  "ozone",
  "paisible",
  "palace",
  "palmares",
  "palourde",
  "palper",
  "panache",
  "panda",
  "pangolin",
  "paniquer",
  "panneau",
  "panorama",
  "pantalon",
  "papaye",
  "papier",
  "papoter",
  "papyrus",
  "paradoxe",
  "parcelle",
  "paresse",
  "parfumer",
  "parler",
  "parole",
  "parrain",
  "parsemer",
  "partager",
  "parure",
  "parvenir",
  "passion",
  "pasteque",
  "paternel",
  "patience",
  "patron",
  "pavillon",
  "pavoiser",
  "payer",
  "paysage",
  "peigne",
  "peintre",
  "pelage",
  "pelican",
  "pelle",
  "pelouse",
  "peluche",
  "pendule",
  "penetrer",
  "penible",
  "pensif",
  "penurie",
  "pepite",
  "peplum",
  "perdrix",
  "perforer",
  "periode",
  "permuter",
  "perplexe",
  "persil",
  "perte",
  "peser",
  "petale",
  "petit",
  "petrir",
  "peuple",
  "pharaon",
  "phobie",
  "phoque",
  "photon",
  "phrase",
  "physique",
  "piano",
  "pictural",
  "piece",
  "pierre",
  "pieuvre",
  "pilote",
  "pinceau",
  "pipette",
  "piquer",
  "pirogue",
  "piscine",
  "piston",
  "pivoter",
  "pixel",
  "pizza",
  "placard",
  "plafond",
  "plaisir",
  "planer",
  "plaque",
  "plastron",
  "plateau",
  "pleurer",
  "plexus",
  "pliage",
  "plomb",
  "plonger",
  "pluie",
  "plumage",
  "pochette",
  "poesie",
  "poete",
  "pointe",
  "poirier",
  "poisson",
  "poivre",
  "polaire",
  "policier",
  "pollen",
  "polygone",
  "pommade",
  "pompier",
  "ponctuel",
  "ponderer",
  "poney",
  "portique",
  "position",
  "posseder",
  "posture",
  "potager",
  "poteau",
  "potion",
  "pouce",
  "poulain",
  "poumon",
  "pourpre",
  "poussin",
  "pouvoir",
  "prairie",
  "pratique",
  "precieux",
  "predire",
  "prefixe",
  "prelude",
  "prenom",
  "presence",
  "pretexte",
  "prevoir",
  "primitif",
  "prince",
  "prison",
  "priver",
  "probleme",
  "proceder",
  "prodige",
  "profond",
  "progres",
  "proie",
  "projeter",
  "prologue",
  "promener",
  "propre",
  "prospere",
  "proteger",
  "prouesse",
  "proverbe",
  "prudence",
  "pruneau",
  "psychose",
  "public",
  "puceron",
  "puiser",
  "pulpe",
  "pulsar",
  "punaise",
  "punitif",
  "pupitre",
  "purifier",
  "puzzle",
  "pyramide",
  "quasar",
  "querelle",
  "question",
  "quietude",
  "quitter",
  "quotient",
  "racine",
  "raconter",
  "radieux",
  "ragondin",
  "raideur",
  "raisin",
  "ralentir",
  "rallonge",
  "ramasser",
  "rapide",
  "rasage",
  "ratisser",
  "ravager",
  "ravin",
  "rayonner",
  "reactif",
  "reagir",
  "realiser",
  "reanimer",
  "recevoir",
  "reciter",
  "reclamer",
  "recolter",
  "recruter",
  "reculer",
  "recycler",
  "rediger",
  "redouter",
  "refaire",
  "reflexe",
  "reformer",
  "refrain",
  "refuge",
  "regalien",
  "region",
  "reglage",
  "regulier",
  "reiterer",
  "rejeter",
  "rejouer",
  "relatif",
  "relever",
  "relief",
  "remarque",
  "remede",
  "remise",
  "remonter",
  "remplir",
  "remuer",
  "renard",
  "renfort",
  "renifler",
  "renoncer",
  "rentrer",
  "renvoi",
  "replier",
  "reporter",
  "reprise",
  "reptile",
  "requin",
  "reserve",
  "resineux",
  "resoudre",
  "respect",
  "rester",
  "resultat",
  "retablir",
  "retenir",
  "reticule",
  "retomber",
  "retracer",
  "reunion",
  "reussir",
  "revanche",
  "revivre",
  "revolte",
  "revulsif",
  "richesse",
  "rideau",
  "rieur",
  "rigide",
  "rigoler",
  "rincer",
  "riposter",
  "risible",
  "risque",
  "rituel",
  "rival",
  "riviere",
  "rocheux",
  "romance",
  "rompre",
  "ronce",
  "rondin",
  "roseau",
  "rosier",
  "rotatif",
  "rotor",
  "rotule",
  "rouge",
  "rouille",
  "rouleau",
  "routine",
  "royaume",
  "ruban",
  "rubis",
  "ruche",
  "ruelle",
  "rugueux",
  "ruiner",
  "ruisseau",
  "ruser",
  "rustique",
  "rythme",
  "sabler",
  "saboter",
  "sabre",
  "sacoche",
  "safari",
  "sagesse",
  "saisir",
  "salade",
  "salive",
  "salon",
  "saluer",
  "samedi",
  "sanction",
  "sanglier",
  "sarcasme",
  "sardine",
  "saturer",
  "saugrenu",
  "saumon",
  "sauter",
  "sauvage",
  "savant",
  "savonner",
  "scalpel",
  "scandale",
  "scelerat",
  "scenario",
  "sceptre",
  "schema",
  "science",
  "scinder",
  "score",
  "scrutin",
  "sculpter",
  "seance",
  "secable",
  "secher",
  "secouer",
  "secreter",
  "sedatif",
  "seduire",
  "seigneur",
  "sejour",
  "selectif",
  "semaine",
  "sembler",
  "semence",
  "seminal",
  "senateur",
  "sensible",
  "sentence",
  "separer",
  "sequence",
  "serein",
  "sergent",
  "serieux",
  "serrure",
  "serum",
  "service",
  "sesame",
  "sevir",
  "sevrage",
  "sextuple",
  "sideral",
  "siecle",
  "sieger",
  "siffler",
  "sigle",
  "signal",
  "silence",
  "silicium",
  "simple",
  "sincere",
  "sinistre",
  "siphon",
  "sirop",
  "sismique",
  "situer",
  "skier",
  "social",
  "socle",
  "sodium",
  "soigneux",
  "soldat",
  "soleil",
  "solitude",
  "soluble",
  "sombre",
  "sommeil",
  "somnoler",
  "sonde",
  "songeur",
  "sonnette",
  "sonore",
  "sorcier",
  "sortir",
  "sosie",
  "sottise",
  "soucieux",
  "soudure",
  "souffle",
  "soulever",
  "soupape",
  "source",
  "soutirer",
  "souvenir",
  "spacieux",
  "spatial",
  "special",
  "sphere",
  "spiral",
  "stable",
  "station",
  "sternum",
  "stimulus",
  "stipuler",
  "strict",
  "studieux",
  "stupeur",
  "styliste",
  "sublime",
  "substrat",
  "subtil",
  "subvenir",
  "succes",
  "sucre",
  "suffixe",
  "suggerer",
  "suiveur",
  "sulfate",
  "superbe",
  "supplier",
  "surface",
  "suricate",
  "surmener",
  "surprise",
  "sursaut",
  "survie",
  "suspect",
  "syllabe",
  "symbole",
  "symetrie",
  "synapse",
  "syntaxe",
  "systeme",
  "tabac",
  "tablier",
  "tactile",
  "tailler",
  "talent",
  "talisman",
  "talonner",
  "tambour",
  "tamiser",
  "tangible",
  "tapis",
  "taquiner",
  "tarder",
  "tarif",
  "tartine",
  "tasse",
  "tatami",
  "tatouage",
  "taupe",
  "taureau",
  "taxer",
  "temoin",
  "temporel",
  "tenaille",
  "tendre",
  "teneur",
  "tenir",
  "tension",
  "terminer",
  "terne",
  "terrible",
  "tetine",
  "texte",
  "theme",
  "theorie",
  "therapie",
  "thorax",
  "tibia",
  "tiede",
  "timide",
  "tirelire",
  "tiroir",
  "tissu",
  "titane",
  "titre",
  "tituber",
  "toboggan",
  "tolerant",
  "tomate",
  "tonique",
  "tonneau",
  "toponyme",
  "torche",
  "tordre",
  "tornade",
  "torpille",
  "torrent",
  "torse",
  "tortue",
  "totem",
  "toucher",
  "tournage",
  "tousser",
  "toxine",
  "traction",
  "trafic",
  "tragique",
  "trahir",
  "train",
  "trancher",
  "travail",
  "trefle",
  "tremper",
  "tresor",
  "treuil",
  "triage",
  "tribunal",
  "tricoter",
  "trilogie",
  "triomphe",
  "tripler",
  "triturer",
  "trivial",
  "trombone",
  "tronc",
  "tropical",
  "troupeau",
  "tuile",
  "tulipe",
  "tumulte",
  "tunnel",
  "turbine",
  "tuteur",
  "tutoyer",
  "tuyau",
  "tympan",
  "typhon",
  "typique",
  "tyran",
  "ubuesque",
  "ultime",
  "ultrason",
  "unanime",
  "unifier",
  "union",
  "unique",
  "unitaire",
  "univers",
  "uranium",
  "urbain",
  "urticant",
  "usage",
  "usine",
  "usuel",
  "usure",
  "utile",
  "utopie",
  "vacarme",
  "vaccin",
  "vagabond",
  "vague",
  "vaillant",
  "vaincre",
  "vaisseau",
  "valable",
  "valise",
  "vallon",
  "valve",
  "vampire",
  "vanille",
  "vapeur",
  "varier",
  "vaseux",
  "vassal",
  "vaste",
  "vecteur",
  "vedette",
  "vegetal",
  "vehicule",
  "veinard",
  "veloce",
  "vendredi",
  "venerer",
  "venger",
  "venimeux",
  "ventouse",
  "verdure",
  "verin",
  "vernir",
  "verrou",
  "verser",
  "vertu",
  "veston",
  "veteran",
  "vetuste",
  "vexant",
  "vexer",
  "viaduc",
  "viande",
  "victoire",
  "vidange",
  "video",
  "vignette",
  "vigueur",
  "vilain",
  "village",
  "vinaigre",
  "violon",
  "vipere",
  "virement",
  "virtuose",
  "virus",
  "visage",
  "viseur",
  "vision",
  "visqueux",
  "visuel",
  "vital",
  "vitesse",
  "viticole",
  "vitrine",
  "vivace",
  "vivipare",
  "vocation",
  "voguer",
  "voile",
  "voisin",
  "voiture",
  "volaille",
  "volcan",
  "voltiger",
  "volume",
  "vorace",
  "vortex",
  "voter",
  "vouloir",
  "voyage",
  "voyelle",
  "wagon",
  "xenon",
  "yacht",
  "zebre",
  "zenith",
  "zeste",
  "zoologie"
], KP = [
  "abaco",
  "abbaglio",
  "abbinato",
  "abete",
  "abisso",
  "abolire",
  "abrasivo",
  "abrogato",
  "accadere",
  "accenno",
  "accusato",
  "acetone",
  "achille",
  "acido",
  "acqua",
  "acre",
  "acrilico",
  "acrobata",
  "acuto",
  "adagio",
  "addebito",
  "addome",
  "adeguato",
  "aderire",
  "adipe",
  "adottare",
  "adulare",
  "affabile",
  "affetto",
  "affisso",
  "affranto",
  "aforisma",
  "afoso",
  "africano",
  "agave",
  "agente",
  "agevole",
  "aggancio",
  "agire",
  "agitare",
  "agonismo",
  "agricolo",
  "agrumeto",
  "aguzzo",
  "alabarda",
  "alato",
  "albatro",
  "alberato",
  "albo",
  "albume",
  "alce",
  "alcolico",
  "alettone",
  "alfa",
  "algebra",
  "aliante",
  "alibi",
  "alimento",
  "allagato",
  "allegro",
  "allievo",
  "allodola",
  "allusivo",
  "almeno",
  "alogeno",
  "alpaca",
  "alpestre",
  "altalena",
  "alterno",
  "alticcio",
  "altrove",
  "alunno",
  "alveolo",
  "alzare",
  "amalgama",
  "amanita",
  "amarena",
  "ambito",
  "ambrato",
  "ameba",
  "america",
  "ametista",
  "amico",
  "ammasso",
  "ammenda",
  "ammirare",
  "ammonito",
  "amore",
  "ampio",
  "ampliare",
  "amuleto",
  "anacardo",
  "anagrafe",
  "analista",
  "anarchia",
  "anatra",
  "anca",
  "ancella",
  "ancora",
  "andare",
  "andrea",
  "anello",
  "angelo",
  "angolare",
  "angusto",
  "anima",
  "annegare",
  "annidato",
  "anno",
  "annuncio",
  "anonimo",
  "anticipo",
  "anzi",
  "apatico",
  "apertura",
  "apode",
  "apparire",
  "appetito",
  "appoggio",
  "approdo",
  "appunto",
  "aprile",
  "arabica",
  "arachide",
  "aragosta",
  "araldica",
  "arancio",
  "aratura",
  "arazzo",
  "arbitro",
  "archivio",
  "ardito",
  "arenile",
  "argento",
  "argine",
  "arguto",
  "aria",
  "armonia",
  "arnese",
  "arredato",
  "arringa",
  "arrosto",
  "arsenico",
  "arso",
  "artefice",
  "arzillo",
  "asciutto",
  "ascolto",
  "asepsi",
  "asettico",
  "asfalto",
  "asino",
  "asola",
  "aspirato",
  "aspro",
  "assaggio",
  "asse",
  "assoluto",
  "assurdo",
  "asta",
  "astenuto",
  "astice",
  "astratto",
  "atavico",
  "ateismo",
  "atomico",
  "atono",
  "attesa",
  "attivare",
  "attorno",
  "attrito",
  "attuale",
  "ausilio",
  "austria",
  "autista",
  "autonomo",
  "autunno",
  "avanzato",
  "avere",
  "avvenire",
  "avviso",
  "avvolgere",
  "azione",
  "azoto",
  "azzimo",
  "azzurro",
  "babele",
  "baccano",
  "bacino",
  "baco",
  "badessa",
  "badilata",
  "bagnato",
  "baita",
  "balcone",
  "baldo",
  "balena",
  "ballata",
  "balzano",
  "bambino",
  "bandire",
  "baraonda",
  "barbaro",
  "barca",
  "baritono",
  "barlume",
  "barocco",
  "basilico",
  "basso",
  "batosta",
  "battuto",
  "baule",
  "bava",
  "bavosa",
  "becco",
  "beffa",
  "belgio",
  "belva",
  "benda",
  "benevole",
  "benigno",
  "benzina",
  "bere",
  "berlina",
  "beta",
  "bibita",
  "bici",
  "bidone",
  "bifido",
  "biga",
  "bilancia",
  "bimbo",
  "binocolo",
  "biologo",
  "bipede",
  "bipolare",
  "birbante",
  "birra",
  "biscotto",
  "bisesto",
  "bisnonno",
  "bisonte",
  "bisturi",
  "bizzarro",
  "blando",
  "blatta",
  "bollito",
  "bonifico",
  "bordo",
  "bosco",
  "botanico",
  "bottino",
  "bozzolo",
  "braccio",
  "bradipo",
  "brama",
  "branca",
  "bravura",
  "bretella",
  "brevetto",
  "brezza",
  "briglia",
  "brillante",
  "brindare",
  "broccolo",
  "brodo",
  "bronzina",
  "brullo",
  "bruno",
  "bubbone",
  "buca",
  "budino",
  "buffone",
  "buio",
  "bulbo",
  "buono",
  "burlone",
  "burrasca",
  "bussola",
  "busta",
  "cadetto",
  "caduco",
  "calamaro",
  "calcolo",
  "calesse",
  "calibro",
  "calmo",
  "caloria",
  "cambusa",
  "camerata",
  "camicia",
  "cammino",
  "camola",
  "campale",
  "canapa",
  "candela",
  "cane",
  "canino",
  "canotto",
  "cantina",
  "capace",
  "capello",
  "capitolo",
  "capogiro",
  "cappero",
  "capra",
  "capsula",
  "carapace",
  "carcassa",
  "cardo",
  "carisma",
  "carovana",
  "carretto",
  "cartolina",
  "casaccio",
  "cascata",
  "caserma",
  "caso",
  "cassone",
  "castello",
  "casuale",
  "catasta",
  "catena",
  "catrame",
  "cauto",
  "cavillo",
  "cedibile",
  "cedrata",
  "cefalo",
  "celebre",
  "cellulare",
  "cena",
  "cenone",
  "centesimo",
  "ceramica",
  "cercare",
  "certo",
  "cerume",
  "cervello",
  "cesoia",
  "cespo",
  "ceto",
  "chela",
  "chiaro",
  "chicca",
  "chiedere",
  "chimera",
  "china",
  "chirurgo",
  "chitarra",
  "ciao",
  "ciclismo",
  "cifrare",
  "cigno",
  "cilindro",
  "ciottolo",
  "circa",
  "cirrosi",
  "citrico",
  "cittadino",
  "ciuffo",
  "civetta",
  "civile",
  "classico",
  "clinica",
  "cloro",
  "cocco",
  "codardo",
  "codice",
  "coerente",
  "cognome",
  "collare",
  "colmato",
  "colore",
  "colposo",
  "coltivato",
  "colza",
  "coma",
  "cometa",
  "commando",
  "comodo",
  "computer",
  "comune",
  "conciso",
  "condurre",
  "conferma",
  "congelare",
  "coniuge",
  "connesso",
  "conoscere",
  "consumo",
  "continuo",
  "convegno",
  "coperto",
  "copione",
  "coppia",
  "copricapo",
  "corazza",
  "cordata",
  "coricato",
  "cornice",
  "corolla",
  "corpo",
  "corredo",
  "corsia",
  "cortese",
  "cosmico",
  "costante",
  "cottura",
  "covato",
  "cratere",
  "cravatta",
  "creato",
  "credere",
  "cremoso",
  "crescita",
  "creta",
  "criceto",
  "crinale",
  "crisi",
  "critico",
  "croce",
  "cronaca",
  "crostata",
  "cruciale",
  "crusca",
  "cucire",
  "cuculo",
  "cugino",
  "cullato",
  "cupola",
  "curatore",
  "cursore",
  "curvo",
  "cuscino",
  "custode",
  "dado",
  "daino",
  "dalmata",
  "damerino",
  "daniela",
  "dannoso",
  "danzare",
  "datato",
  "davanti",
  "davvero",
  "debutto",
  "decennio",
  "deciso",
  "declino",
  "decollo",
  "decreto",
  "dedicato",
  "definito",
  "deforme",
  "degno",
  "delegare",
  "delfino",
  "delirio",
  "delta",
  "demenza",
  "denotato",
  "dentro",
  "deposito",
  "derapata",
  "derivare",
  "deroga",
  "descritto",
  "deserto",
  "desiderio",
  "desumere",
  "detersivo",
  "devoto",
  "diametro",
  "dicembre",
  "diedro",
  "difeso",
  "diffuso",
  "digerire",
  "digitale",
  "diluvio",
  "dinamico",
  "dinnanzi",
  "dipinto",
  "diploma",
  "dipolo",
  "diradare",
  "dire",
  "dirotto",
  "dirupo",
  "disagio",
  "discreto",
  "disfare",
  "disgelo",
  "disposto",
  "distanza",
  "disumano",
  "dito",
  "divano",
  "divelto",
  "dividere",
  "divorato",
  "doblone",
  "docente",
  "doganale",
  "dogma",
  "dolce",
  "domato",
  "domenica",
  "dominare",
  "dondolo",
  "dono",
  "dormire",
  "dote",
  "dottore",
  "dovuto",
  "dozzina",
  "drago",
  "druido",
  "dubbio",
  "dubitare",
  "ducale",
  "duna",
  "duomo",
  "duplice",
  "duraturo",
  "ebano",
  "eccesso",
  "ecco",
  "eclissi",
  "economia",
  "edera",
  "edicola",
  "edile",
  "editoria",
  "educare",
  "egemonia",
  "egli",
  "egoismo",
  "egregio",
  "elaborato",
  "elargire",
  "elegante",
  "elencato",
  "eletto",
  "elevare",
  "elfico",
  "elica",
  "elmo",
  "elsa",
  "eluso",
  "emanato",
  "emblema",
  "emesso",
  "emiro",
  "emotivo",
  "emozione",
  "empirico",
  "emulo",
  "endemico",
  "enduro",
  "energia",
  "enfasi",
  "enoteca",
  "entrare",
  "enzima",
  "epatite",
  "epilogo",
  "episodio",
  "epocale",
  "eppure",
  "equatore",
  "erario",
  "erba",
  "erboso",
  "erede",
  "eremita",
  "erigere",
  "ermetico",
  "eroe",
  "erosivo",
  "errante",
  "esagono",
  "esame",
  "esanime",
  "esaudire",
  "esca",
  "esempio",
  "esercito",
  "esibito",
  "esigente",
  "esistere",
  "esito",
  "esofago",
  "esortato",
  "esoso",
  "espanso",
  "espresso",
  "essenza",
  "esso",
  "esteso",
  "estimare",
  "estonia",
  "estroso",
  "esultare",
  "etilico",
  "etnico",
  "etrusco",
  "etto",
  "euclideo",
  "europa",
  "evaso",
  "evidenza",
  "evitato",
  "evoluto",
  "evviva",
  "fabbrica",
  "faccenda",
  "fachiro",
  "falco",
  "famiglia",
  "fanale",
  "fanfara",
  "fango",
  "fantasma",
  "fare",
  "farfalla",
  "farinoso",
  "farmaco",
  "fascia",
  "fastoso",
  "fasullo",
  "faticare",
  "fato",
  "favoloso",
  "febbre",
  "fecola",
  "fede",
  "fegato",
  "felpa",
  "feltro",
  "femmina",
  "fendere",
  "fenomeno",
  "fermento",
  "ferro",
  "fertile",
  "fessura",
  "festivo",
  "fetta",
  "feudo",
  "fiaba",
  "fiducia",
  "fifa",
  "figurato",
  "filo",
  "finanza",
  "finestra",
  "finire",
  "fiore",
  "fiscale",
  "fisico",
  "fiume",
  "flacone",
  "flamenco",
  "flebo",
  "flemma",
  "florido",
  "fluente",
  "fluoro",
  "fobico",
  "focaccia",
  "focoso",
  "foderato",
  "foglio",
  "folata",
  "folclore",
  "folgore",
  "fondente",
  "fonetico",
  "fonia",
  "fontana",
  "forbito",
  "forchetta",
  "foresta",
  "formica",
  "fornaio",
  "foro",
  "fortezza",
  "forzare",
  "fosfato",
  "fosso",
  "fracasso",
  "frana",
  "frassino",
  "fratello",
  "freccetta",
  "frenata",
  "fresco",
  "frigo",
  "frollino",
  "fronde",
  "frugale",
  "frutta",
  "fucilata",
  "fucsia",
  "fuggente",
  "fulmine",
  "fulvo",
  "fumante",
  "fumetto",
  "fumoso",
  "fune",
  "funzione",
  "fuoco",
  "furbo",
  "furgone",
  "furore",
  "fuso",
  "futile",
  "gabbiano",
  "gaffe",
  "galateo",
  "gallina",
  "galoppo",
  "gambero",
  "gamma",
  "garanzia",
  "garbo",
  "garofano",
  "garzone",
  "gasdotto",
  "gasolio",
  "gastrico",
  "gatto",
  "gaudio",
  "gazebo",
  "gazzella",
  "geco",
  "gelatina",
  "gelso",
  "gemello",
  "gemmato",
  "gene",
  "genitore",
  "gennaio",
  "genotipo",
  "gergo",
  "ghepardo",
  "ghiaccio",
  "ghisa",
  "giallo",
  "gilda",
  "ginepro",
  "giocare",
  "gioiello",
  "giorno",
  "giove",
  "girato",
  "girone",
  "gittata",
  "giudizio",
  "giurato",
  "giusto",
  "globulo",
  "glutine",
  "gnomo",
  "gobba",
  "golf",
  "gomito",
  "gommone",
  "gonfio",
  "gonna",
  "governo",
  "gracile",
  "grado",
  "grafico",
  "grammo",
  "grande",
  "grattare",
  "gravoso",
  "grazia",
  "greca",
  "gregge",
  "grifone",
  "grigio",
  "grinza",
  "grotta",
  "gruppo",
  "guadagno",
  "guaio",
  "guanto",
  "guardare",
  "gufo",
  "guidare",
  "ibernato",
  "icona",
  "identico",
  "idillio",
  "idolo",
  "idra",
  "idrico",
  "idrogeno",
  "igiene",
  "ignaro",
  "ignorato",
  "ilare",
  "illeso",
  "illogico",
  "illudere",
  "imballo",
  "imbevuto",
  "imbocco",
  "imbuto",
  "immane",
  "immerso",
  "immolato",
  "impacco",
  "impeto",
  "impiego",
  "importo",
  "impronta",
  "inalare",
  "inarcare",
  "inattivo",
  "incanto",
  "incendio",
  "inchino",
  "incisivo",
  "incluso",
  "incontro",
  "incrocio",
  "incubo",
  "indagine",
  "india",
  "indole",
  "inedito",
  "infatti",
  "infilare",
  "inflitto",
  "ingaggio",
  "ingegno",
  "inglese",
  "ingordo",
  "ingrosso",
  "innesco",
  "inodore",
  "inoltrare",
  "inondato",
  "insano",
  "insetto",
  "insieme",
  "insonnia",
  "insulina",
  "intasato",
  "intero",
  "intonaco",
  "intuito",
  "inumidire",
  "invalido",
  "invece",
  "invito",
  "iperbole",
  "ipnotico",
  "ipotesi",
  "ippica",
  "iride",
  "irlanda",
  "ironico",
  "irrigato",
  "irrorare",
  "isolato",
  "isotopo",
  "isterico",
  "istituto",
  "istrice",
  "italia",
  "iterare",
  "labbro",
  "labirinto",
  "lacca",
  "lacerato",
  "lacrima",
  "lacuna",
  "laddove",
  "lago",
  "lampo",
  "lancetta",
  "lanterna",
  "lardoso",
  "larga",
  "laringe",
  "lastra",
  "latenza",
  "latino",
  "lattuga",
  "lavagna",
  "lavoro",
  "legale",
  "leggero",
  "lembo",
  "lentezza",
  "lenza",
  "leone",
  "lepre",
  "lesivo",
  "lessato",
  "lesto",
  "letterale",
  "leva",
  "levigato",
  "libero",
  "lido",
  "lievito",
  "lilla",
  "limatura",
  "limitare",
  "limpido",
  "lineare",
  "lingua",
  "liquido",
  "lira",
  "lirica",
  "lisca",
  "lite",
  "litigio",
  "livrea",
  "locanda",
  "lode",
  "logica",
  "lombare",
  "londra",
  "longevo",
  "loquace",
  "lorenzo",
  "loto",
  "lotteria",
  "luce",
  "lucidato",
  "lumaca",
  "luminoso",
  "lungo",
  "lupo",
  "luppolo",
  "lusinga",
  "lusso",
  "lutto",
  "macabro",
  "macchina",
  "macero",
  "macinato",
  "madama",
  "magico",
  "maglia",
  "magnete",
  "magro",
  "maiolica",
  "malafede",
  "malgrado",
  "malinteso",
  "malsano",
  "malto",
  "malumore",
  "mana",
  "mancia",
  "mandorla",
  "mangiare",
  "manifesto",
  "mannaro",
  "manovra",
  "mansarda",
  "mantide",
  "manubrio",
  "mappa",
  "maratona",
  "marcire",
  "maretta",
  "marmo",
  "marsupio",
  "maschera",
  "massaia",
  "mastino",
  "materasso",
  "matricola",
  "mattone",
  "maturo",
  "mazurca",
  "meandro",
  "meccanico",
  "mecenate",
  "medesimo",
  "meditare",
  "mega",
  "melassa",
  "melis",
  "melodia",
  "meninge",
  "meno",
  "mensola",
  "mercurio",
  "merenda",
  "merlo",
  "meschino",
  "mese",
  "messere",
  "mestolo",
  "metallo",
  "metodo",
  "mettere",
  "miagolare",
  "mica",
  "micelio",
  "michele",
  "microbo",
  "midollo",
  "miele",
  "migliore",
  "milano",
  "milite",
  "mimosa",
  "minerale",
  "mini",
  "minore",
  "mirino",
  "mirtillo",
  "miscela",
  "missiva",
  "misto",
  "misurare",
  "mitezza",
  "mitigare",
  "mitra",
  "mittente",
  "mnemonico",
  "modello",
  "modifica",
  "modulo",
  "mogano",
  "mogio",
  "mole",
  "molosso",
  "monastero",
  "monco",
  "mondina",
  "monetario",
  "monile",
  "monotono",
  "monsone",
  "montato",
  "monviso",
  "mora",
  "mordere",
  "morsicato",
  "mostro",
  "motivato",
  "motosega",
  "motto",
  "movenza",
  "movimento",
  "mozzo",
  "mucca",
  "mucosa",
  "muffa",
  "mughetto",
  "mugnaio",
  "mulatto",
  "mulinello",
  "multiplo",
  "mummia",
  "munto",
  "muovere",
  "murale",
  "musa",
  "muscolo",
  "musica",
  "mutevole",
  "muto",
  "nababbo",
  "nafta",
  "nanometro",
  "narciso",
  "narice",
  "narrato",
  "nascere",
  "nastrare",
  "naturale",
  "nautica",
  "naviglio",
  "nebulosa",
  "necrosi",
  "negativo",
  "negozio",
  "nemmeno",
  "neofita",
  "neretto",
  "nervo",
  "nessuno",
  "nettuno",
  "neutrale",
  "neve",
  "nevrotico",
  "nicchia",
  "ninfa",
  "nitido",
  "nobile",
  "nocivo",
  "nodo",
  "nome",
  "nomina",
  "nordico",
  "normale",
  "norvegese",
  "nostrano",
  "notare",
  "notizia",
  "notturno",
  "novella",
  "nucleo",
  "nulla",
  "numero",
  "nuovo",
  "nutrire",
  "nuvola",
  "nuziale",
  "oasi",
  "obbedire",
  "obbligo",
  "obelisco",
  "oblio",
  "obolo",
  "obsoleto",
  "occasione",
  "occhio",
  "occidente",
  "occorrere",
  "occultare",
  "ocra",
  "oculato",
  "odierno",
  "odorare",
  "offerta",
  "offrire",
  "offuscato",
  "oggetto",
  "oggi",
  "ognuno",
  "olandese",
  "olfatto",
  "oliato",
  "oliva",
  "ologramma",
  "oltre",
  "omaggio",
  "ombelico",
  "ombra",
  "omega",
  "omissione",
  "ondoso",
  "onere",
  "onice",
  "onnivoro",
  "onorevole",
  "onta",
  "operato",
  "opinione",
  "opposto",
  "oracolo",
  "orafo",
  "ordine",
  "orecchino",
  "orefice",
  "orfano",
  "organico",
  "origine",
  "orizzonte",
  "orma",
  "ormeggio",
  "ornativo",
  "orologio",
  "orrendo",
  "orribile",
  "ortensia",
  "ortica",
  "orzata",
  "orzo",
  "osare",
  "oscurare",
  "osmosi",
  "ospedale",
  "ospite",
  "ossa",
  "ossidare",
  "ostacolo",
  "oste",
  "otite",
  "otre",
  "ottagono",
  "ottimo",
  "ottobre",
  "ovale",
  "ovest",
  "ovino",
  "oviparo",
  "ovocito",
  "ovunque",
  "ovviare",
  "ozio",
  "pacchetto",
  "pace",
  "pacifico",
  "padella",
  "padrone",
  "paese",
  "paga",
  "pagina",
  "palazzina",
  "palesare",
  "pallido",
  "palo",
  "palude",
  "pandoro",
  "pannello",
  "paolo",
  "paonazzo",
  "paprica",
  "parabola",
  "parcella",
  "parere",
  "pargolo",
  "pari",
  "parlato",
  "parola",
  "partire",
  "parvenza",
  "parziale",
  "passivo",
  "pasticca",
  "patacca",
  "patologia",
  "pattume",
  "pavone",
  "peccato",
  "pedalare",
  "pedonale",
  "peggio",
  "peloso",
  "penare",
  "pendice",
  "penisola",
  "pennuto",
  "penombra",
  "pensare",
  "pentola",
  "pepe",
  "pepita",
  "perbene",
  "percorso",
  "perdonato",
  "perforare",
  "pergamena",
  "periodo",
  "permesso",
  "perno",
  "perplesso",
  "persuaso",
  "pertugio",
  "pervaso",
  "pesatore",
  "pesista",
  "peso",
  "pestifero",
  "petalo",
  "pettine",
  "petulante",
  "pezzo",
  "piacere",
  "pianta",
  "piattino",
  "piccino",
  "picozza",
  "piega",
  "pietra",
  "piffero",
  "pigiama",
  "pigolio",
  "pigro",
  "pila",
  "pilifero",
  "pillola",
  "pilota",
  "pimpante",
  "pineta",
  "pinna",
  "pinolo",
  "pioggia",
  "piombo",
  "piramide",
  "piretico",
  "pirite",
  "pirolisi",
  "pitone",
  "pizzico",
  "placebo",
  "planare",
  "plasma",
  "platano",
  "plenario",
  "pochezza",
  "poderoso",
  "podismo",
  "poesia",
  "poggiare",
  "polenta",
  "poligono",
  "pollice",
  "polmonite",
  "polpetta",
  "polso",
  "poltrona",
  "polvere",
  "pomice",
  "pomodoro",
  "ponte",
  "popoloso",
  "porfido",
  "poroso",
  "porpora",
  "porre",
  "portata",
  "posa",
  "positivo",
  "possesso",
  "postulato",
  "potassio",
  "potere",
  "pranzo",
  "prassi",
  "pratica",
  "precluso",
  "predica",
  "prefisso",
  "pregiato",
  "prelievo",
  "premere",
  "prenotare",
  "preparato",
  "presenza",
  "pretesto",
  "prevalso",
  "prima",
  "principe",
  "privato",
  "problema",
  "procura",
  "produrre",
  "profumo",
  "progetto",
  "prolunga",
  "promessa",
  "pronome",
  "proposta",
  "proroga",
  "proteso",
  "prova",
  "prudente",
  "prugna",
  "prurito",
  "psiche",
  "pubblico",
  "pudica",
  "pugilato",
  "pugno",
  "pulce",
  "pulito",
  "pulsante",
  "puntare",
  "pupazzo",
  "pupilla",
  "puro",
  "quadro",
  "qualcosa",
  "quasi",
  "querela",
  "quota",
  "raccolto",
  "raddoppio",
  "radicale",
  "radunato",
  "raffica",
  "ragazzo",
  "ragione",
  "ragno",
  "ramarro",
  "ramingo",
  "ramo",
  "randagio",
  "rantolare",
  "rapato",
  "rapina",
  "rappreso",
  "rasatura",
  "raschiato",
  "rasente",
  "rassegna",
  "rastrello",
  "rata",
  "ravveduto",
  "reale",
  "recepire",
  "recinto",
  "recluta",
  "recondito",
  "recupero",
  "reddito",
  "redimere",
  "regalato",
  "registro",
  "regola",
  "regresso",
  "relazione",
  "remare",
  "remoto",
  "renna",
  "replica",
  "reprimere",
  "reputare",
  "resa",
  "residente",
  "responso",
  "restauro",
  "rete",
  "retina",
  "retorica",
  "rettifica",
  "revocato",
  "riassunto",
  "ribadire",
  "ribelle",
  "ribrezzo",
  "ricarica",
  "ricco",
  "ricevere",
  "riciclato",
  "ricordo",
  "ricreduto",
  "ridicolo",
  "ridurre",
  "rifasare",
  "riflesso",
  "riforma",
  "rifugio",
  "rigare",
  "rigettato",
  "righello",
  "rilassato",
  "rilevato",
  "rimanere",
  "rimbalzo",
  "rimedio",
  "rimorchio",
  "rinascita",
  "rincaro",
  "rinforzo",
  "rinnovo",
  "rinomato",
  "rinsavito",
  "rintocco",
  "rinuncia",
  "rinvenire",
  "riparato",
  "ripetuto",
  "ripieno",
  "riportare",
  "ripresa",
  "ripulire",
  "risata",
  "rischio",
  "riserva",
  "risibile",
  "riso",
  "rispetto",
  "ristoro",
  "risultato",
  "risvolto",
  "ritardo",
  "ritegno",
  "ritmico",
  "ritrovo",
  "riunione",
  "riva",
  "riverso",
  "rivincita",
  "rivolto",
  "rizoma",
  "roba",
  "robotico",
  "robusto",
  "roccia",
  "roco",
  "rodaggio",
  "rodere",
  "roditore",
  "rogito",
  "rollio",
  "romantico",
  "rompere",
  "ronzio",
  "rosolare",
  "rospo",
  "rotante",
  "rotondo",
  "rotula",
  "rovescio",
  "rubizzo",
  "rubrica",
  "ruga",
  "rullino",
  "rumine",
  "rumoroso",
  "ruolo",
  "rupe",
  "russare",
  "rustico",
  "sabato",
  "sabbiare",
  "sabotato",
  "sagoma",
  "salasso",
  "saldatura",
  "salgemma",
  "salivare",
  "salmone",
  "salone",
  "saltare",
  "saluto",
  "salvo",
  "sapere",
  "sapido",
  "saporito",
  "saraceno",
  "sarcasmo",
  "sarto",
  "sassoso",
  "satellite",
  "satira",
  "satollo",
  "saturno",
  "savana",
  "savio",
  "saziato",
  "sbadiglio",
  "sbalzo",
  "sbancato",
  "sbarra",
  "sbattere",
  "sbavare",
  "sbendare",
  "sbirciare",
  "sbloccato",
  "sbocciato",
  "sbrinare",
  "sbruffone",
  "sbuffare",
  "scabroso",
  "scadenza",
  "scala",
  "scambiare",
  "scandalo",
  "scapola",
  "scarso",
  "scatenare",
  "scavato",
  "scelto",
  "scenico",
  "scettro",
  "scheda",
  "schiena",
  "sciarpa",
  "scienza",
  "scindere",
  "scippo",
  "sciroppo",
  "scivolo",
  "sclerare",
  "scodella",
  "scolpito",
  "scomparto",
  "sconforto",
  "scoprire",
  "scorta",
  "scossone",
  "scozzese",
  "scriba",
  "scrollare",
  "scrutinio",
  "scuderia",
  "scultore",
  "scuola",
  "scuro",
  "scusare",
  "sdebitare",
  "sdoganare",
  "seccatura",
  "secondo",
  "sedano",
  "seggiola",
  "segnalato",
  "segregato",
  "seguito",
  "selciato",
  "selettivo",
  "sella",
  "selvaggio",
  "semaforo",
  "sembrare",
  "seme",
  "seminato",
  "sempre",
  "senso",
  "sentire",
  "sepolto",
  "sequenza",
  "serata",
  "serbato",
  "sereno",
  "serio",
  "serpente",
  "serraglio",
  "servire",
  "sestina",
  "setola",
  "settimana",
  "sfacelo",
  "sfaldare",
  "sfamato",
  "sfarzoso",
  "sfaticato",
  "sfera",
  "sfida",
  "sfilato",
  "sfinge",
  "sfocato",
  "sfoderare",
  "sfogo",
  "sfoltire",
  "sforzato",
  "sfratto",
  "sfruttato",
  "sfuggito",
  "sfumare",
  "sfuso",
  "sgabello",
  "sgarbato",
  "sgonfiare",
  "sgorbio",
  "sgrassato",
  "sguardo",
  "sibilo",
  "siccome",
  "sierra",
  "sigla",
  "signore",
  "silenzio",
  "sillaba",
  "simbolo",
  "simpatico",
  "simulato",
  "sinfonia",
  "singolo",
  "sinistro",
  "sino",
  "sintesi",
  "sinusoide",
  "sipario",
  "sisma",
  "sistole",
  "situato",
  "slitta",
  "slogatura",
  "sloveno",
  "smarrito",
  "smemorato",
  "smentito",
  "smeraldo",
  "smilzo",
  "smontare",
  "smottato",
  "smussato",
  "snellire",
  "snervato",
  "snodo",
  "sobbalzo",
  "sobrio",
  "soccorso",
  "sociale",
  "sodale",
  "soffitto",
  "sogno",
  "soldato",
  "solenne",
  "solido",
  "sollazzo",
  "solo",
  "solubile",
  "solvente",
  "somatico",
  "somma",
  "sonda",
  "sonetto",
  "sonnifero",
  "sopire",
  "soppeso",
  "sopra",
  "sorgere",
  "sorpasso",
  "sorriso",
  "sorso",
  "sorteggio",
  "sorvolato",
  "sospiro",
  "sosta",
  "sottile",
  "spada",
  "spalla",
  "spargere",
  "spatola",
  "spavento",
  "spazzola",
  "specie",
  "spedire",
  "spegnere",
  "spelatura",
  "speranza",
  "spessore",
  "spettrale",
  "spezzato",
  "spia",
  "spigoloso",
  "spillato",
  "spinoso",
  "spirale",
  "splendido",
  "sportivo",
  "sposo",
  "spranga",
  "sprecare",
  "spronato",
  "spruzzo",
  "spuntino",
  "squillo",
  "sradicare",
  "srotolato",
  "stabile",
  "stacco",
  "staffa",
  "stagnare",
  "stampato",
  "stantio",
  "starnuto",
  "stasera",
  "statuto",
  "stelo",
  "steppa",
  "sterzo",
  "stiletto",
  "stima",
  "stirpe",
  "stivale",
  "stizzoso",
  "stonato",
  "storico",
  "strappo",
  "stregato",
  "stridulo",
  "strozzare",
  "strutto",
  "stuccare",
  "stufo",
  "stupendo",
  "subentro",
  "succoso",
  "sudore",
  "suggerito",
  "sugo",
  "sultano",
  "suonare",
  "superbo",
  "supporto",
  "surgelato",
  "surrogato",
  "sussurro",
  "sutura",
  "svagare",
  "svedese",
  "sveglio",
  "svelare",
  "svenuto",
  "svezia",
  "sviluppo",
  "svista",
  "svizzera",
  "svolta",
  "svuotare",
  "tabacco",
  "tabulato",
  "tacciare",
  "taciturno",
  "tale",
  "talismano",
  "tampone",
  "tannino",
  "tara",
  "tardivo",
  "targato",
  "tariffa",
  "tarpare",
  "tartaruga",
  "tasto",
  "tattico",
  "taverna",
  "tavolata",
  "tazza",
  "teca",
  "tecnico",
  "telefono",
  "temerario",
  "tempo",
  "temuto",
  "tendone",
  "tenero",
  "tensione",
  "tentacolo",
  "teorema",
  "terme",
  "terrazzo",
  "terzetto",
  "tesi",
  "tesserato",
  "testato",
  "tetro",
  "tettoia",
  "tifare",
  "tigella",
  "timbro",
  "tinto",
  "tipico",
  "tipografo",
  "tiraggio",
  "tiro",
  "titanio",
  "titolo",
  "titubante",
  "tizio",
  "tizzone",
  "toccare",
  "tollerare",
  "tolto",
  "tombola",
  "tomo",
  "tonfo",
  "tonsilla",
  "topazio",
  "topologia",
  "toppa",
  "torba",
  "tornare",
  "torrone",
  "tortora",
  "toscano",
  "tossire",
  "tostatura",
  "totano",
  "trabocco",
  "trachea",
  "trafila",
  "tragedia",
  "tralcio",
  "tramonto",
  "transito",
  "trapano",
  "trarre",
  "trasloco",
  "trattato",
  "trave",
  "treccia",
  "tremolio",
  "trespolo",
  "tributo",
  "tricheco",
  "trifoglio",
  "trillo",
  "trincea",
  "trio",
  "tristezza",
  "triturato",
  "trivella",
  "tromba",
  "trono",
  "troppo",
  "trottola",
  "trovare",
  "truccato",
  "tubatura",
  "tuffato",
  "tulipano",
  "tumulto",
  "tunisia",
  "turbare",
  "turchino",
  "tuta",
  "tutela",
  "ubicato",
  "uccello",
  "uccisore",
  "udire",
  "uditivo",
  "uffa",
  "ufficio",
  "uguale",
  "ulisse",
  "ultimato",
  "umano",
  "umile",
  "umorismo",
  "uncinetto",
  "ungere",
  "ungherese",
  "unicorno",
  "unificato",
  "unisono",
  "unitario",
  "unte",
  "uovo",
  "upupa",
  "uragano",
  "urgenza",
  "urlo",
  "usanza",
  "usato",
  "uscito",
  "usignolo",
  "usuraio",
  "utensile",
  "utilizzo",
  "utopia",
  "vacante",
  "vaccinato",
  "vagabondo",
  "vagliato",
  "valanga",
  "valgo",
  "valico",
  "valletta",
  "valoroso",
  "valutare",
  "valvola",
  "vampata",
  "vangare",
  "vanitoso",
  "vano",
  "vantaggio",
  "vanvera",
  "vapore",
  "varano",
  "varcato",
  "variante",
  "vasca",
  "vedetta",
  "vedova",
  "veduto",
  "vegetale",
  "veicolo",
  "velcro",
  "velina",
  "velluto",
  "veloce",
  "venato",
  "vendemmia",
  "vento",
  "verace",
  "verbale",
  "vergogna",
  "verifica",
  "vero",
  "verruca",
  "verticale",
  "vescica",
  "vessillo",
  "vestale",
  "veterano",
  "vetrina",
  "vetusto",
  "viandante",
  "vibrante",
  "vicenda",
  "vichingo",
  "vicinanza",
  "vidimare",
  "vigilia",
  "vigneto",
  "vigore",
  "vile",
  "villano",
  "vimini",
  "vincitore",
  "viola",
  "vipera",
  "virgola",
  "virologo",
  "virulento",
  "viscoso",
  "visione",
  "vispo",
  "vissuto",
  "visura",
  "vita",
  "vitello",
  "vittima",
  "vivanda",
  "vivido",
  "viziare",
  "voce",
  "voga",
  "volatile",
  "volere",
  "volpe",
  "voragine",
  "vulcano",
  "zampogna",
  "zanna",
  "zappato",
  "zattera",
  "zavorra",
  "zefiro",
  "zelante",
  "zelo",
  "zenzero",
  "zerbino",
  "zibetto",
  "zinco",
  "zircone",
  "zitto",
  "zolla",
  "zotico",
  "zucchero",
  "zufolo",
  "zulu",
  "zuppa"
], qP = [
  "abaco",
  "abdomen",
  "abeja",
  "abierto",
  "abogado",
  "abono",
  "aborto",
  "abrazo",
  "abrir",
  "abuelo",
  "abuso",
  "acabar",
  "academia",
  "acceso",
  "accion",
  "aceite",
  "acelga",
  "acento",
  "aceptar",
  "acido",
  "aclarar",
  "acne",
  "acoger",
  "acoso",
  "activo",
  "acto",
  "actriz",
  "actuar",
  "acudir",
  "acuerdo",
  "acusar",
  "adicto",
  "admitir",
  "adoptar",
  "adorno",
  "aduana",
  "adulto",
  "aereo",
  "afectar",
  "aficion",
  "afinar",
  "afirmar",
  "agil",
  "agitar",
  "agonia",
  "agosto",
  "agotar",
  "agregar",
  "agrio",
  "agua",
  "agudo",
  "aguila",
  "aguja",
  "ahogo",
  "ahorro",
  "aire",
  "aislar",
  "ajedrez",
  "ajeno",
  "ajuste",
  "alacran",
  "alambre",
  "alarma",
  "alba",
  "album",
  "alcalde",
  "aldea",
  "alegre",
  "alejar",
  "alerta",
  "aleta",
  "alfiler",
  "alga",
  "algodon",
  "aliado",
  "aliento",
  "alivio",
  "alma",
  "almeja",
  "almibar",
  "altar",
  "alteza",
  "altivo",
  "alto",
  "altura",
  "alumno",
  "alzar",
  "amable",
  "amante",
  "amapola",
  "amargo",
  "amasar",
  "ambar",
  "ambito",
  "ameno",
  "amigo",
  "amistad",
  "amor",
  "amparo",
  "amplio",
  "ancho",
  "anciano",
  "ancla",
  "andar",
  "anden",
  "anemia",
  "angulo",
  "anillo",
  "animo",
  "anis",
  "anotar",
  "antena",
  "antiguo",
  "antojo",
  "anual",
  "anular",
  "anuncio",
  "anadir",
  "anejo",
  "ano",
  "apagar",
  "aparato",
  "apetito",
  "apio",
  "aplicar",
  "apodo",
  "aporte",
  "apoyo",
  "aprender",
  "aprobar",
  "apuesta",
  "apuro",
  "arado",
  "arana",
  "arar",
  "arbitro",
  "arbol",
  "arbusto",
  "archivo",
  "arco",
  "arder",
  "ardilla",
  "arduo",
  "area",
  "arido",
  "aries",
  "armonia",
  "arnes",
  "aroma",
  "arpa",
  "arpon",
  "arreglo",
  "arroz",
  "arruga",
  "arte",
  "artista",
  "asa",
  "asado",
  "asalto",
  "ascenso",
  "asegurar",
  "aseo",
  "asesor",
  "asiento",
  "asilo",
  "asistir",
  "asno",
  "asombro",
  "aspero",
  "astilla",
  "astro",
  "astuto",
  "asumir",
  "asunto",
  "atajo",
  "ataque",
  "atar",
  "atento",
  "ateo",
  "atico",
  "atleta",
  "atomo",
  "atraer",
  "atroz",
  "atun",
  "audaz",
  "audio",
  "auge",
  "aula",
  "aumento",
  "ausente",
  "autor",
  "aval",
  "avance",
  "avaro",
  "ave",
  "avellana",
  "avena",
  "avestruz",
  "avion",
  "aviso",
  "ayer",
  "ayuda",
  "ayuno",
  "azafran",
  "azar",
  "azote",
  "azucar",
  "azufre",
  "azul",
  "baba",
  "babor",
  "bache",
  "bahia",
  "baile",
  "bajar",
  "balanza",
  "balcon",
  "balde",
  "bambu",
  "banco",
  "banda",
  "bano",
  "barba",
  "barco",
  "barniz",
  "barro",
  "bascula",
  "baston",
  "basura",
  "batalla",
  "bateria",
  "batir",
  "batuta",
  "baul",
  "bazar",
  "bebe",
  "bebida",
  "bello",
  "besar",
  "beso",
  "bestia",
  "bicho",
  "bien",
  "bingo",
  "blanco",
  "bloque",
  "blusa",
  "boa",
  "bobina",
  "bobo",
  "boca",
  "bocina",
  "boda",
  "bodega",
  "boina",
  "bola",
  "bolero",
  "bolsa",
  "bomba",
  "bondad",
  "bonito",
  "bono",
  "bonsai",
  "borde",
  "borrar",
  "bosque",
  "bote",
  "botin",
  "boveda",
  "bozal",
  "bravo",
  "brazo",
  "brecha",
  "breve",
  "brillo",
  "brinco",
  "brisa",
  "broca",
  "broma",
  "bronce",
  "brote",
  "bruja",
  "brusco",
  "bruto",
  "buceo",
  "bucle",
  "bueno",
  "buey",
  "bufanda",
  "bufon",
  "buho",
  "buitre",
  "bulto",
  "burbuja",
  "burla",
  "burro",
  "buscar",
  "butaca",
  "buzon",
  "caballo",
  "cabeza",
  "cabina",
  "cabra",
  "cacao",
  "cadaver",
  "cadena",
  "caer",
  "cafe",
  "caida",
  "caiman",
  "caja",
  "cajon",
  "cal",
  "calamar",
  "calcio",
  "caldo",
  "calidad",
  "calle",
  "calma",
  "calor",
  "calvo",
  "cama",
  "cambio",
  "camello",
  "camino",
  "campo",
  "cancer",
  "candil",
  "canela",
  "canguro",
  "canica",
  "canto",
  "cana",
  "canon",
  "caoba",
  "caos",
  "capaz",
  "capitan",
  "capote",
  "captar",
  "capucha",
  "cara",
  "carbon",
  "carcel",
  "careta",
  "carga",
  "carino",
  "carne",
  "carpeta",
  "carro",
  "carta",
  "casa",
  "casco",
  "casero",
  "caspa",
  "castor",
  "catorce",
  "catre",
  "caudal",
  "causa",
  "cazo",
  "cebolla",
  "ceder",
  "cedro",
  "celda",
  "celebre",
  "celoso",
  "celula",
  "cemento",
  "ceniza",
  "centro",
  "cerca",
  "cerdo",
  "cereza",
  "cero",
  "cerrar",
  "certeza",
  "cesped",
  "cetro",
  "chacal",
  "chaleco",
  "champu",
  "chancla",
  "chapa",
  "charla",
  "chico",
  "chiste",
  "chivo",
  "choque",
  "choza",
  "chuleta",
  "chupar",
  "ciclon",
  "ciego",
  "cielo",
  "cien",
  "cierto",
  "cifra",
  "cigarro",
  "cima",
  "cinco",
  "cine",
  "cinta",
  "cipres",
  "circo",
  "ciruela",
  "cisne",
  "cita",
  "ciudad",
  "clamor",
  "clan",
  "claro",
  "clase",
  "clave",
  "cliente",
  "clima",
  "clinica",
  "cobre",
  "coccion",
  "cochino",
  "cocina",
  "coco",
  "codigo",
  "codo",
  "cofre",
  "coger",
  "cohete",
  "cojin",
  "cojo",
  "cola",
  "colcha",
  "colegio",
  "colgar",
  "colina",
  "collar",
  "colmo",
  "columna",
  "combate",
  "comer",
  "comida",
  "comodo",
  "compra",
  "conde",
  "conejo",
  "conga",
  "conocer",
  "consejo",
  "contar",
  "copa",
  "copia",
  "corazon",
  "corbata",
  "corcho",
  "cordon",
  "corona",
  "correr",
  "coser",
  "cosmos",
  "costa",
  "craneo",
  "crater",
  "crear",
  "crecer",
  "creido",
  "crema",
  "cria",
  "crimen",
  "cripta",
  "crisis",
  "cromo",
  "cronica",
  "croqueta",
  "crudo",
  "cruz",
  "cuadro",
  "cuarto",
  "cuatro",
  "cubo",
  "cubrir",
  "cuchara",
  "cuello",
  "cuento",
  "cuerda",
  "cuesta",
  "cueva",
  "cuidar",
  "culebra",
  "culpa",
  "culto",
  "cumbre",
  "cumplir",
  "cuna",
  "cuneta",
  "cuota",
  "cupon",
  "cupula",
  "curar",
  "curioso",
  "curso",
  "curva",
  "cutis",
  "dama",
  "danza",
  "dar",
  "dardo",
  "datil",
  "deber",
  "debil",
  "decada",
  "decir",
  "dedo",
  "defensa",
  "definir",
  "dejar",
  "delfin",
  "delgado",
  "delito",
  "demora",
  "denso",
  "dental",
  "deporte",
  "derecho",
  "derrota",
  "desayuno",
  "deseo",
  "desfile",
  "desnudo",
  "destino",
  "desvio",
  "detalle",
  "detener",
  "deuda",
  "dia",
  "diablo",
  "diadema",
  "diamante",
  "diana",
  "diario",
  "dibujo",
  "dictar",
  "diente",
  "dieta",
  "diez",
  "dificil",
  "digno",
  "dilema",
  "diluir",
  "dinero",
  "directo",
  "dirigir",
  "disco",
  "diseno",
  "disfraz",
  "diva",
  "divino",
  "doble",
  "doce",
  "dolor",
  "domingo",
  "don",
  "donar",
  "dorado",
  "dormir",
  "dorso",
  "dos",
  "dosis",
  "dragon",
  "droga",
  "ducha",
  "duda",
  "duelo",
  "dueno",
  "dulce",
  "duo",
  "duque",
  "durar",
  "dureza",
  "duro",
  "ebano",
  "ebrio",
  "echar",
  "eco",
  "ecuador",
  "edad",
  "edicion",
  "edificio",
  "editor",
  "educar",
  "efecto",
  "eficaz",
  "eje",
  "ejemplo",
  "elefante",
  "elegir",
  "elemento",
  "elevar",
  "elipse",
  "elite",
  "elixir",
  "elogio",
  "eludir",
  "embudo",
  "emitir",
  "emocion",
  "empate",
  "empeno",
  "empleo",
  "empresa",
  "enano",
  "encargo",
  "enchufe",
  "encia",
  "enemigo",
  "enero",
  "enfado",
  "enfermo",
  "engano",
  "enigma",
  "enlace",
  "enorme",
  "enredo",
  "ensayo",
  "ensenar",
  "entero",
  "entrar",
  "envase",
  "envio",
  "epoca",
  "equipo",
  "erizo",
  "escala",
  "escena",
  "escolar",
  "escribir",
  "escudo",
  "esencia",
  "esfera",
  "esfuerzo",
  "espada",
  "espejo",
  "espia",
  "esposa",
  "espuma",
  "esqui",
  "estar",
  "este",
  "estilo",
  "estufa",
  "etapa",
  "eterno",
  "etica",
  "etnia",
  "evadir",
  "evaluar",
  "evento",
  "evitar",
  "exacto",
  "examen",
  "exceso",
  "excusa",
  "exento",
  "exigir",
  "exilio",
  "existir",
  "exito",
  "experto",
  "explicar",
  "exponer",
  "extremo",
  "fabrica",
  "fabula",
  "fachada",
  "facil",
  "factor",
  "faena",
  "faja",
  "falda",
  "fallo",
  "falso",
  "faltar",
  "fama",
  "familia",
  "famoso",
  "faraon",
  "farmacia",
  "farol",
  "farsa",
  "fase",
  "fatiga",
  "fauna",
  "favor",
  "fax",
  "febrero",
  "fecha",
  "feliz",
  "feo",
  "feria",
  "feroz",
  "fertil",
  "fervor",
  "festin",
  "fiable",
  "fianza",
  "fiar",
  "fibra",
  "ficcion",
  "ficha",
  "fideo",
  "fiebre",
  "fiel",
  "fiera",
  "fiesta",
  "figura",
  "fijar",
  "fijo",
  "fila",
  "filete",
  "filial",
  "filtro",
  "fin",
  "finca",
  "fingir",
  "finito",
  "firma",
  "flaco",
  "flauta",
  "flecha",
  "flor",
  "flota",
  "fluir",
  "flujo",
  "fluor",
  "fobia",
  "foca",
  "fogata",
  "fogon",
  "folio",
  "folleto",
  "fondo",
  "forma",
  "forro",
  "fortuna",
  "forzar",
  "fosa",
  "foto",
  "fracaso",
  "fragil",
  "franja",
  "frase",
  "fraude",
  "freir",
  "freno",
  "fresa",
  "frio",
  "frito",
  "fruta",
  "fuego",
  "fuente",
  "fuerza",
  "fuga",
  "fumar",
  "funcion",
  "funda",
  "furgon",
  "furia",
  "fusil",
  "futbol",
  "futuro",
  "gacela",
  "gafas",
  "gaita",
  "gajo",
  "gala",
  "galeria",
  "gallo",
  "gamba",
  "ganar",
  "gancho",
  "ganga",
  "ganso",
  "garaje",
  "garza",
  "gasolina",
  "gastar",
  "gato",
  "gavilan",
  "gemelo",
  "gemir",
  "gen",
  "genero",
  "genio",
  "gente",
  "geranio",
  "gerente",
  "germen",
  "gesto",
  "gigante",
  "gimnasio",
  "girar",
  "giro",
  "glaciar",
  "globo",
  "gloria",
  "gol",
  "golfo",
  "goloso",
  "golpe",
  "goma",
  "gordo",
  "gorila",
  "gorra",
  "gota",
  "goteo",
  "gozar",
  "grada",
  "grafico",
  "grano",
  "grasa",
  "gratis",
  "grave",
  "grieta",
  "grillo",
  "gripe",
  "gris",
  "grito",
  "grosor",
  "grua",
  "grueso",
  "grumo",
  "grupo",
  "guante",
  "guapo",
  "guardia",
  "guerra",
  "guia",
  "guino",
  "guion",
  "guiso",
  "guitarra",
  "gusano",
  "gustar",
  "haber",
  "habil",
  "hablar",
  "hacer",
  "hacha",
  "hada",
  "hallar",
  "hamaca",
  "harina",
  "haz",
  "hazana",
  "hebilla",
  "hebra",
  "hecho",
  "helado",
  "helio",
  "hembra",
  "herir",
  "hermano",
  "heroe",
  "hervir",
  "hielo",
  "hierro",
  "higado",
  "higiene",
  "hijo",
  "himno",
  "historia",
  "hocico",
  "hogar",
  "hoguera",
  "hoja",
  "hombre",
  "hongo",
  "honor",
  "honra",
  "hora",
  "hormiga",
  "horno",
  "hostil",
  "hoyo",
  "hueco",
  "huelga",
  "huerta",
  "hueso",
  "huevo",
  "huida",
  "huir",
  "humano",
  "humedo",
  "humilde",
  "humo",
  "hundir",
  "huracan",
  "hurto",
  "icono",
  "ideal",
  "idioma",
  "idolo",
  "iglesia",
  "iglu",
  "igual",
  "ilegal",
  "ilusion",
  "imagen",
  "iman",
  "imitar",
  "impar",
  "imperio",
  "imponer",
  "impulso",
  "incapaz",
  "indice",
  "inerte",
  "infiel",
  "informe",
  "ingenio",
  "inicio",
  "inmenso",
  "inmune",
  "innato",
  "insecto",
  "instante",
  "interes",
  "intimo",
  "intuir",
  "inutil",
  "invierno",
  "ira",
  "iris",
  "ironia",
  "isla",
  "islote",
  "jabali",
  "jabon",
  "jamon",
  "jarabe",
  "jardin",
  "jarra",
  "jaula",
  "jazmin",
  "jefe",
  "jeringa",
  "jinete",
  "jornada",
  "joroba",
  "joven",
  "joya",
  "juerga",
  "jueves",
  "juez",
  "jugador",
  "jugo",
  "juguete",
  "juicio",
  "junco",
  "jungla",
  "junio",
  "juntar",
  "jupiter",
  "jurar",
  "justo",
  "juvenil",
  "juzgar",
  "kilo",
  "koala",
  "labio",
  "lacio",
  "lacra",
  "lado",
  "ladron",
  "lagarto",
  "lagrima",
  "laguna",
  "laico",
  "lamer",
  "lamina",
  "lampara",
  "lana",
  "lancha",
  "langosta",
  "lanza",
  "lapiz",
  "largo",
  "larva",
  "lastima",
  "lata",
  "latex",
  "latir",
  "laurel",
  "lavar",
  "lazo",
  "leal",
  "leccion",
  "leche",
  "lector",
  "leer",
  "legion",
  "legumbre",
  "lejano",
  "lengua",
  "lento",
  "lena",
  "leon",
  "leopardo",
  "lesion",
  "letal",
  "letra",
  "leve",
  "leyenda",
  "libertad",
  "libro",
  "licor",
  "lider",
  "lidiar",
  "lienzo",
  "liga",
  "ligero",
  "lima",
  "limite",
  "limon",
  "limpio",
  "lince",
  "lindo",
  "linea",
  "lingote",
  "lino",
  "linterna",
  "liquido",
  "liso",
  "lista",
  "litera",
  "litio",
  "litro",
  "llaga",
  "llama",
  "llanto",
  "llave",
  "llegar",
  "llenar",
  "llevar",
  "llorar",
  "llover",
  "lluvia",
  "lobo",
  "locion",
  "loco",
  "locura",
  "logica",
  "logro",
  "lombriz",
  "lomo",
  "lonja",
  "lote",
  "lucha",
  "lucir",
  "lugar",
  "lujo",
  "luna",
  "lunes",
  "lupa",
  "lustro",
  "luto",
  "luz",
  "maceta",
  "macho",
  "madera",
  "madre",
  "maduro",
  "maestro",
  "mafia",
  "magia",
  "mago",
  "maiz",
  "maldad",
  "maleta",
  "malla",
  "malo",
  "mama",
  "mambo",
  "mamut",
  "manco",
  "mando",
  "manejar",
  "manga",
  "maniqui",
  "manjar",
  "mano",
  "manso",
  "manta",
  "manana",
  "mapa",
  "maquina",
  "mar",
  "marco",
  "marea",
  "marfil",
  "margen",
  "marido",
  "marmol",
  "marron",
  "martes",
  "marzo",
  "masa",
  "mascara",
  "masivo",
  "matar",
  "materia",
  "matiz",
  "matriz",
  "maximo",
  "mayor",
  "mazorca",
  "mecha",
  "medalla",
  "medio",
  "medula",
  "mejilla",
  "mejor",
  "melena",
  "melon",
  "memoria",
  "menor",
  "mensaje",
  "mente",
  "menu",
  "mercado",
  "merengue",
  "merito",
  "mes",
  "meson",
  "meta",
  "meter",
  "metodo",
  "metro",
  "mezcla",
  "miedo",
  "miel",
  "miembro",
  "miga",
  "mil",
  "milagro",
  "militar",
  "millon",
  "mimo",
  "mina",
  "minero",
  "minimo",
  "minuto",
  "miope",
  "mirar",
  "misa",
  "miseria",
  "misil",
  "mismo",
  "mitad",
  "mito",
  "mochila",
  "mocion",
  "moda",
  "modelo",
  "moho",
  "mojar",
  "molde",
  "moler",
  "molino",
  "momento",
  "momia",
  "monarca",
  "moneda",
  "monja",
  "monto",
  "mono",
  "morada",
  "morder",
  "moreno",
  "morir",
  "morro",
  "morsa",
  "mortal",
  "mosca",
  "mostrar",
  "motivo",
  "mover",
  "movil",
  "mozo",
  "mucho",
  "mudar",
  "mueble",
  "muela",
  "muerte",
  "muestra",
  "mugre",
  "mujer",
  "mula",
  "muleta",
  "multa",
  "mundo",
  "muneca",
  "mural",
  "muro",
  "musculo",
  "museo",
  "musgo",
  "musica",
  "muslo",
  "nacar",
  "nacion",
  "nadar",
  "naipe",
  "naranja",
  "nariz",
  "narrar",
  "nasal",
  "natal",
  "nativo",
  "natural",
  "nausea",
  "naval",
  "nave",
  "navidad",
  "necio",
  "nectar",
  "negar",
  "negocio",
  "negro",
  "neon",
  "nervio",
  "neto",
  "neutro",
  "nevar",
  "nevera",
  "nicho",
  "nido",
  "niebla",
  "nieto",
  "ninez",
  "nino",
  "nitido",
  "nivel",
  "nobleza",
  "noche",
  "nomina",
  "noria",
  "norma",
  "norte",
  "nota",
  "noticia",
  "novato",
  "novela",
  "novio",
  "nube",
  "nuca",
  "nucleo",
  "nudillo",
  "nudo",
  "nuera",
  "nueve",
  "nuez",
  "nulo",
  "numero",
  "nutria",
  "oasis",
  "obeso",
  "obispo",
  "objeto",
  "obra",
  "obrero",
  "observar",
  "obtener",
  "obvio",
  "oca",
  "ocaso",
  "oceano",
  "ochenta",
  "ocho",
  "ocio",
  "ocre",
  "octavo",
  "octubre",
  "oculto",
  "ocupar",
  "ocurrir",
  "odiar",
  "odio",
  "odisea",
  "oeste",
  "ofensa",
  "oferta",
  "oficio",
  "ofrecer",
  "ogro",
  "oido",
  "oir",
  "ojo",
  "ola",
  "oleada",
  "olfato",
  "olivo",
  "olla",
  "olmo",
  "olor",
  "olvido",
  "ombligo",
  "onda",
  "onza",
  "opaco",
  "opcion",
  "opera",
  "opinar",
  "oponer",
  "optar",
  "optica",
  "opuesto",
  "oracion",
  "orador",
  "oral",
  "orbita",
  "orca",
  "orden",
  "oreja",
  "organo",
  "orgia",
  "orgullo",
  "oriente",
  "origen",
  "orilla",
  "oro",
  "orquesta",
  "oruga",
  "osadia",
  "oscuro",
  "osezno",
  "oso",
  "ostra",
  "otono",
  "otro",
  "oveja",
  "ovulo",
  "oxido",
  "oxigeno",
  "oyente",
  "ozono",
  "pacto",
  "padre",
  "paella",
  "pagina",
  "pago",
  "pais",
  "pajaro",
  "palabra",
  "palco",
  "paleta",
  "palido",
  "palma",
  "paloma",
  "palpar",
  "pan",
  "panal",
  "panico",
  "pantera",
  "panuelo",
  "papa",
  "papel",
  "papilla",
  "paquete",
  "parar",
  "parcela",
  "pared",
  "parir",
  "paro",
  "parpado",
  "parque",
  "parrafo",
  "parte",
  "pasar",
  "paseo",
  "pasion",
  "paso",
  "pasta",
  "pata",
  "patio",
  "patria",
  "pausa",
  "pauta",
  "pavo",
  "payaso",
  "peaton",
  "pecado",
  "pecera",
  "pecho",
  "pedal",
  "pedir",
  "pegar",
  "peine",
  "pelar",
  "peldano",
  "pelea",
  "peligro",
  "pellejo",
  "pelo",
  "peluca",
  "pena",
  "pensar",
  "penon",
  "peon",
  "peor",
  "pepino",
  "pequeno",
  "pera",
  "percha",
  "perder",
  "pereza",
  "perfil",
  "perico",
  "perla",
  "permiso",
  "perro",
  "persona",
  "pesa",
  "pesca",
  "pesimo",
  "pestana",
  "petalo",
  "petroleo",
  "pez",
  "pezuna",
  "picar",
  "pichon",
  "pie",
  "piedra",
  "pierna",
  "pieza",
  "pijama",
  "pilar",
  "piloto",
  "pimienta",
  "pino",
  "pintor",
  "pinza",
  "pina",
  "piojo",
  "pipa",
  "pirata",
  "pisar",
  "piscina",
  "piso",
  "pista",
  "piton",
  "pizca",
  "placa",
  "plan",
  "plata",
  "playa",
  "plaza",
  "pleito",
  "pleno",
  "plomo",
  "pluma",
  "plural",
  "pobre",
  "poco",
  "poder",
  "podio",
  "poema",
  "poesia",
  "poeta",
  "polen",
  "policia",
  "pollo",
  "polvo",
  "pomada",
  "pomelo",
  "pomo",
  "pompa",
  "poner",
  "porcion",
  "portal",
  "posada",
  "poseer",
  "posible",
  "poste",
  "potencia",
  "potro",
  "pozo",
  "prado",
  "precoz",
  "pregunta",
  "premio",
  "prensa",
  "preso",
  "previo",
  "primo",
  "principe",
  "prision",
  "privar",
  "proa",
  "probar",
  "proceso",
  "producto",
  "proeza",
  "profesor",
  "programa",
  "prole",
  "promesa",
  "pronto",
  "propio",
  "proximo",
  "prueba",
  "publico",
  "puchero",
  "pudor",
  "pueblo",
  "puerta",
  "puesto",
  "pulga",
  "pulir",
  "pulmon",
  "pulpo",
  "pulso",
  "puma",
  "punto",
  "punal",
  "puno",
  "pupa",
  "pupila",
  "pure",
  "quedar",
  "queja",
  "quemar",
  "querer",
  "queso",
  "quieto",
  "quimica",
  "quince",
  "quitar",
  "rabano",
  "rabia",
  "rabo",
  "racion",
  "radical",
  "raiz",
  "rama",
  "rampa",
  "rancho",
  "rango",
  "rapaz",
  "rapido",
  "rapto",
  "rasgo",
  "raspa",
  "rato",
  "rayo",
  "raza",
  "razon",
  "reaccion",
  "realidad",
  "rebano",
  "rebote",
  "recaer",
  "receta",
  "rechazo",
  "recoger",
  "recreo",
  "recto",
  "recurso",
  "red",
  "redondo",
  "reducir",
  "reflejo",
  "reforma",
  "refran",
  "refugio",
  "regalo",
  "regir",
  "regla",
  "regreso",
  "rehen",
  "reino",
  "reir",
  "reja",
  "relato",
  "relevo",
  "relieve",
  "relleno",
  "reloj",
  "remar",
  "remedio",
  "remo",
  "rencor",
  "rendir",
  "renta",
  "reparto",
  "repetir",
  "reposo",
  "reptil",
  "res",
  "rescate",
  "resina",
  "respeto",
  "resto",
  "resumen",
  "retiro",
  "retorno",
  "retrato",
  "reunir",
  "reves",
  "revista",
  "rey",
  "rezar",
  "rico",
  "riego",
  "rienda",
  "riesgo",
  "rifa",
  "rigido",
  "rigor",
  "rincon",
  "rinon",
  "rio",
  "riqueza",
  "risa",
  "ritmo",
  "rito",
  "rizo",
  "roble",
  "roce",
  "rociar",
  "rodar",
  "rodeo",
  "rodilla",
  "roer",
  "rojizo",
  "rojo",
  "romero",
  "romper",
  "ron",
  "ronco",
  "ronda",
  "ropa",
  "ropero",
  "rosa",
  "rosca",
  "rostro",
  "rotar",
  "rubi",
  "rubor",
  "rudo",
  "rueda",
  "rugir",
  "ruido",
  "ruina",
  "ruleta",
  "rulo",
  "rumbo",
  "rumor",
  "ruptura",
  "ruta",
  "rutina",
  "sabado",
  "saber",
  "sabio",
  "sable",
  "sacar",
  "sagaz",
  "sagrado",
  "sala",
  "saldo",
  "salero",
  "salir",
  "salmon",
  "salon",
  "salsa",
  "salto",
  "salud",
  "salvar",
  "samba",
  "sancion",
  "sandia",
  "sanear",
  "sangre",
  "sanidad",
  "sano",
  "santo",
  "sapo",
  "saque",
  "sardina",
  "sarten",
  "sastre",
  "satan",
  "sauna",
  "saxofon",
  "seccion",
  "seco",
  "secreto",
  "secta",
  "sed",
  "seguir",
  "seis",
  "sello",
  "selva",
  "semana",
  "semilla",
  "senda",
  "sensor",
  "senal",
  "senor",
  "separar",
  "sepia",
  "sequia",
  "ser",
  "serie",
  "sermon",
  "servir",
  "sesenta",
  "sesion",
  "seta",
  "setenta",
  "severo",
  "sexo",
  "sexto",
  "sidra",
  "siesta",
  "siete",
  "siglo",
  "signo",
  "silaba",
  "silbar",
  "silencio",
  "silla",
  "simbolo",
  "simio",
  "sirena",
  "sistema",
  "sitio",
  "situar",
  "sobre",
  "socio",
  "sodio",
  "sol",
  "solapa",
  "soldado",
  "soledad",
  "solido",
  "soltar",
  "solucion",
  "sombra",
  "sondeo",
  "sonido",
  "sonoro",
  "sonrisa",
  "sopa",
  "soplar",
  "soporte",
  "sordo",
  "sorpresa",
  "sorteo",
  "sosten",
  "sotano",
  "suave",
  "subir",
  "suceso",
  "sudor",
  "suegra",
  "suelo",
  "sueno",
  "suerte",
  "sufrir",
  "sujeto",
  "sultan",
  "sumar",
  "superar",
  "suplir",
  "suponer",
  "supremo",
  "sur",
  "surco",
  "sureno",
  "surgir",
  "susto",
  "sutil",
  "tabaco",
  "tabique",
  "tabla",
  "tabu",
  "taco",
  "tacto",
  "tajo",
  "talar",
  "talco",
  "talento",
  "talla",
  "talon",
  "tamano",
  "tambor",
  "tango",
  "tanque",
  "tapa",
  "tapete",
  "tapia",
  "tapon",
  "taquilla",
  "tarde",
  "tarea",
  "tarifa",
  "tarjeta",
  "tarot",
  "tarro",
  "tarta",
  "tatuaje",
  "tauro",
  "taza",
  "tazon",
  "teatro",
  "techo",
  "tecla",
  "tecnica",
  "tejado",
  "tejer",
  "tejido",
  "tela",
  "telefono",
  "tema",
  "temor",
  "templo",
  "tenaz",
  "tender",
  "tener",
  "tenis",
  "tenso",
  "teoria",
  "terapia",
  "terco",
  "termino",
  "ternura",
  "terror",
  "tesis",
  "tesoro",
  "testigo",
  "tetera",
  "texto",
  "tez",
  "tibio",
  "tiburon",
  "tiempo",
  "tienda",
  "tierra",
  "tieso",
  "tigre",
  "tijera",
  "tilde",
  "timbre",
  "timido",
  "timo",
  "tinta",
  "tio",
  "tipico",
  "tipo",
  "tira",
  "tiron",
  "titan",
  "titere",
  "titulo",
  "tiza",
  "toalla",
  "tobillo",
  "tocar",
  "tocino",
  "todo",
  "toga",
  "toldo",
  "tomar",
  "tono",
  "tonto",
  "topar",
  "tope",
  "toque",
  "torax",
  "torero",
  "tormenta",
  "torneo",
  "toro",
  "torpedo",
  "torre",
  "torso",
  "tortuga",
  "tos",
  "tosco",
  "toser",
  "toxico",
  "trabajo",
  "tractor",
  "traer",
  "trafico",
  "trago",
  "traje",
  "tramo",
  "trance",
  "trato",
  "trauma",
  "trazar",
  "trebol",
  "tregua",
  "treinta",
  "tren",
  "trepar",
  "tres",
  "tribu",
  "trigo",
  "tripa",
  "triste",
  "triunfo",
  "trofeo",
  "trompa",
  "tronco",
  "tropa",
  "trote",
  "trozo",
  "truco",
  "trueno",
  "trufa",
  "tuberia",
  "tubo",
  "tuerto",
  "tumba",
  "tumor",
  "tunel",
  "tunica",
  "turbina",
  "turismo",
  "turno",
  "tutor",
  "ubicar",
  "ulcera",
  "umbral",
  "unidad",
  "unir",
  "universo",
  "uno",
  "untar",
  "una",
  "urbano",
  "urbe",
  "urgente",
  "urna",
  "usar",
  "usuario",
  "util",
  "utopia",
  "uva",
  "vaca",
  "vacio",
  "vacuna",
  "vagar",
  "vago",
  "vaina",
  "vajilla",
  "vale",
  "valido",
  "valle",
  "valor",
  "valvula",
  "vampiro",
  "vara",
  "variar",
  "varon",
  "vaso",
  "vecino",
  "vector",
  "vehiculo",
  "veinte",
  "vejez",
  "vela",
  "velero",
  "veloz",
  "vena",
  "vencer",
  "venda",
  "veneno",
  "vengar",
  "venir",
  "venta",
  "venus",
  "ver",
  "verano",
  "verbo",
  "verde",
  "vereda",
  "verja",
  "verso",
  "verter",
  "via",
  "viaje",
  "vibrar",
  "vicio",
  "victima",
  "vida",
  "video",
  "vidrio",
  "viejo",
  "viernes",
  "vigor",
  "vil",
  "villa",
  "vinagre",
  "vino",
  "vinedo",
  "violin",
  "viral",
  "virgo",
  "virtud",
  "visor",
  "vispera",
  "vista",
  "vitamina",
  "viudo",
  "vivaz",
  "vivero",
  "vivir",
  "vivo",
  "volcan",
  "volumen",
  "volver",
  "voraz",
  "votar",
  "voto",
  "voz",
  "vuelo",
  "vulgar",
  "yacer",
  "yate",
  "yegua",
  "yema",
  "yerno",
  "yeso",
  "yodo",
  "yoga",
  "yogur",
  "zafiro",
  "zanja",
  "zapato",
  "zarza",
  "zona",
  "zorro",
  "zumo",
  "zurdo"
], VP = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], WP = [
  "abacate",
  "abaixo",
  "abalar",
  "abater",
  "abduzir",
  "abelha",
  "aberto",
  "abismo",
  "abotoar",
  "abranger",
  "abreviar",
  "abrigar",
  "abrupto",
  "absinto",
  "absoluto",
  "absurdo",
  "abutre",
  "acabado",
  "acalmar",
  "acampar",
  "acanhar",
  "acaso",
  "aceitar",
  "acelerar",
  "acenar",
  "acervo",
  "acessar",
  "acetona",
  "achatar",
  "acidez",
  "acima",
  "acionado",
  "acirrar",
  "aclamar",
  "aclive",
  "acolhida",
  "acomodar",
  "acoplar",
  "acordar",
  "acumular",
  "acusador",
  "adaptar",
  "adega",
  "adentro",
  "adepto",
  "adequar",
  "aderente",
  "adesivo",
  "adeus",
  "adiante",
  "aditivo",
  "adjetivo",
  "adjunto",
  "admirar",
  "adorar",
  "adquirir",
  "adubo",
  "adverso",
  "advogado",
  "aeronave",
  "afastar",
  "aferir",
  "afetivo",
  "afinador",
  "afivelar",
  "aflito",
  "afluente",
  "afrontar",
  "agachar",
  "agarrar",
  "agasalho",
  "agenciar",
  "agilizar",
  "agiota",
  "agitado",
  "agora",
  "agradar",
  "agreste",
  "agrupar",
  "aguardar",
  "agulha",
  "ajoelhar",
  "ajudar",
  "ajustar",
  "alameda",
  "alarme",
  "alastrar",
  "alavanca",
  "albergue",
  "albino",
  "alcatra",
  "aldeia",
  "alecrim",
  "alegria",
  "alertar",
  "alface",
  "alfinete",
  "algum",
  "alheio",
  "aliar",
  "alicate",
  "alienar",
  "alinhar",
  "aliviar",
  "almofada",
  "alocar",
  "alpiste",
  "alterar",
  "altitude",
  "alucinar",
  "alugar",
  "aluno",
  "alusivo",
  "alvo",
  "amaciar",
  "amador",
  "amarelo",
  "amassar",
  "ambas",
  "ambiente",
  "ameixa",
  "amenizar",
  "amido",
  "amistoso",
  "amizade",
  "amolador",
  "amontoar",
  "amoroso",
  "amostra",
  "amparar",
  "ampliar",
  "ampola",
  "anagrama",
  "analisar",
  "anarquia",
  "anatomia",
  "andaime",
  "anel",
  "anexo",
  "angular",
  "animar",
  "anjo",
  "anomalia",
  "anotado",
  "ansioso",
  "anterior",
  "anuidade",
  "anunciar",
  "anzol",
  "apagador",
  "apalpar",
  "apanhado",
  "apego",
  "apelido",
  "apertada",
  "apesar",
  "apetite",
  "apito",
  "aplauso",
  "aplicada",
  "apoio",
  "apontar",
  "aposta",
  "aprendiz",
  "aprovar",
  "aquecer",
  "arame",
  "aranha",
  "arara",
  "arcada",
  "ardente",
  "areia",
  "arejar",
  "arenito",
  "aresta",
  "argiloso",
  "argola",
  "arma",
  "arquivo",
  "arraial",
  "arrebate",
  "arriscar",
  "arroba",
  "arrumar",
  "arsenal",
  "arterial",
  "artigo",
  "arvoredo",
  "asfaltar",
  "asilado",
  "aspirar",
  "assador",
  "assinar",
  "assoalho",
  "assunto",
  "astral",
  "atacado",
  "atadura",
  "atalho",
  "atarefar",
  "atear",
  "atender",
  "aterro",
  "ateu",
  "atingir",
  "atirador",
  "ativo",
  "atoleiro",
  "atracar",
  "atrevido",
  "atriz",
  "atual",
  "atum",
  "auditor",
  "aumentar",
  "aura",
  "aurora",
  "autismo",
  "autoria",
  "autuar",
  "avaliar",
  "avante",
  "avaria",
  "avental",
  "avesso",
  "aviador",
  "avisar",
  "avulso",
  "axila",
  "azarar",
  "azedo",
  "azeite",
  "azulejo",
  "babar",
  "babosa",
  "bacalhau",
  "bacharel",
  "bacia",
  "bagagem",
  "baiano",
  "bailar",
  "baioneta",
  "bairro",
  "baixista",
  "bajular",
  "baleia",
  "baliza",
  "balsa",
  "banal",
  "bandeira",
  "banho",
  "banir",
  "banquete",
  "barato",
  "barbado",
  "baronesa",
  "barraca",
  "barulho",
  "baseado",
  "bastante",
  "batata",
  "batedor",
  "batida",
  "batom",
  "batucar",
  "baunilha",
  "beber",
  "beijo",
  "beirada",
  "beisebol",
  "beldade",
  "beleza",
  "belga",
  "beliscar",
  "bendito",
  "bengala",
  "benzer",
  "berimbau",
  "berlinda",
  "berro",
  "besouro",
  "bexiga",
  "bezerro",
  "bico",
  "bicudo",
  "bienal",
  "bifocal",
  "bifurcar",
  "bigorna",
  "bilhete",
  "bimestre",
  "bimotor",
  "biologia",
  "biombo",
  "biosfera",
  "bipolar",
  "birrento",
  "biscoito",
  "bisneto",
  "bispo",
  "bissexto",
  "bitola",
  "bizarro",
  "blindado",
  "bloco",
  "bloquear",
  "boato",
  "bobagem",
  "bocado",
  "bocejo",
  "bochecha",
  "boicotar",
  "bolada",
  "boletim",
  "bolha",
  "bolo",
  "bombeiro",
  "bonde",
  "boneco",
  "bonita",
  "borbulha",
  "borda",
  "boreal",
  "borracha",
  "bovino",
  "boxeador",
  "branco",
  "brasa",
  "braveza",
  "breu",
  "briga",
  "brilho",
  "brincar",
  "broa",
  "brochura",
  "bronzear",
  "broto",
  "bruxo",
  "bucha",
  "budismo",
  "bufar",
  "bule",
  "buraco",
  "busca",
  "busto",
  "buzina",
  "cabana",
  "cabelo",
  "cabide",
  "cabo",
  "cabrito",
  "cacau",
  "cacetada",
  "cachorro",
  "cacique",
  "cadastro",
  "cadeado",
  "cafezal",
  "caiaque",
  "caipira",
  "caixote",
  "cajado",
  "caju",
  "calafrio",
  "calcular",
  "caldeira",
  "calibrar",
  "calmante",
  "calota",
  "camada",
  "cambista",
  "camisa",
  "camomila",
  "campanha",
  "camuflar",
  "canavial",
  "cancelar",
  "caneta",
  "canguru",
  "canhoto",
  "canivete",
  "canoa",
  "cansado",
  "cantar",
  "canudo",
  "capacho",
  "capela",
  "capinar",
  "capotar",
  "capricho",
  "captador",
  "capuz",
  "caracol",
  "carbono",
  "cardeal",
  "careca",
  "carimbar",
  "carneiro",
  "carpete",
  "carreira",
  "cartaz",
  "carvalho",
  "casaco",
  "casca",
  "casebre",
  "castelo",
  "casulo",
  "catarata",
  "cativar",
  "caule",
  "causador",
  "cautelar",
  "cavalo",
  "caverna",
  "cebola",
  "cedilha",
  "cegonha",
  "celebrar",
  "celular",
  "cenoura",
  "censo",
  "centeio",
  "cercar",
  "cerrado",
  "certeiro",
  "cerveja",
  "cetim",
  "cevada",
  "chacota",
  "chaleira",
  "chamado",
  "chapada",
  "charme",
  "chatice",
  "chave",
  "chefe",
  "chegada",
  "cheiro",
  "cheque",
  "chicote",
  "chifre",
  "chinelo",
  "chocalho",
  "chover",
  "chumbo",
  "chutar",
  "chuva",
  "cicatriz",
  "ciclone",
  "cidade",
  "cidreira",
  "ciente",
  "cigana",
  "cimento",
  "cinto",
  "cinza",
  "ciranda",
  "circuito",
  "cirurgia",
  "citar",
  "clareza",
  "clero",
  "clicar",
  "clone",
  "clube",
  "coado",
  "coagir",
  "cobaia",
  "cobertor",
  "cobrar",
  "cocada",
  "coelho",
  "coentro",
  "coeso",
  "cogumelo",
  "coibir",
  "coifa",
  "coiote",
  "colar",
  "coleira",
  "colher",
  "colidir",
  "colmeia",
  "colono",
  "coluna",
  "comando",
  "combinar",
  "comentar",
  "comitiva",
  "comover",
  "complexo",
  "comum",
  "concha",
  "condor",
  "conectar",
  "confuso",
  "congelar",
  "conhecer",
  "conjugar",
  "consumir",
  "contrato",
  "convite",
  "cooperar",
  "copeiro",
  "copiador",
  "copo",
  "coquetel",
  "coragem",
  "cordial",
  "corneta",
  "coronha",
  "corporal",
  "correio",
  "cortejo",
  "coruja",
  "corvo",
  "cosseno",
  "costela",
  "cotonete",
  "couro",
  "couve",
  "covil",
  "cozinha",
  "cratera",
  "cravo",
  "creche",
  "credor",
  "creme",
  "crer",
  "crespo",
  "criada",
  "criminal",
  "crioulo",
  "crise",
  "criticar",
  "crosta",
  "crua",
  "cruzeiro",
  "cubano",
  "cueca",
  "cuidado",
  "cujo",
  "culatra",
  "culminar",
  "culpar",
  "cultura",
  "cumprir",
  "cunhado",
  "cupido",
  "curativo",
  "curral",
  "cursar",
  "curto",
  "cuspir",
  "custear",
  "cutelo",
  "damasco",
  "datar",
  "debater",
  "debitar",
  "deboche",
  "debulhar",
  "decalque",
  "decimal",
  "declive",
  "decote",
  "decretar",
  "dedal",
  "dedicado",
  "deduzir",
  "defesa",
  "defumar",
  "degelo",
  "degrau",
  "degustar",
  "deitado",
  "deixar",
  "delator",
  "delegado",
  "delinear",
  "delonga",
  "demanda",
  "demitir",
  "demolido",
  "dentista",
  "depenado",
  "depilar",
  "depois",
  "depressa",
  "depurar",
  "deriva",
  "derramar",
  "desafio",
  "desbotar",
  "descanso",
  "desenho",
  "desfiado",
  "desgaste",
  "desigual",
  "deslize",
  "desmamar",
  "desova",
  "despesa",
  "destaque",
  "desviar",
  "detalhar",
  "detentor",
  "detonar",
  "detrito",
  "deusa",
  "dever",
  "devido",
  "devotado",
  "dezena",
  "diagrama",
  "dialeto",
  "didata",
  "difuso",
  "digitar",
  "dilatado",
  "diluente",
  "diminuir",
  "dinastia",
  "dinheiro",
  "diocese",
  "direto",
  "discreta",
  "disfarce",
  "disparo",
  "disquete",
  "dissipar",
  "distante",
  "ditador",
  "diurno",
  "diverso",
  "divisor",
  "divulgar",
  "dizer",
  "dobrador",
  "dolorido",
  "domador",
  "dominado",
  "donativo",
  "donzela",
  "dormente",
  "dorsal",
  "dosagem",
  "dourado",
  "doutor",
  "drenagem",
  "drible",
  "drogaria",
  "duelar",
  "duende",
  "dueto",
  "duplo",
  "duquesa",
  "durante",
  "duvidoso",
  "eclodir",
  "ecoar",
  "ecologia",
  "edificar",
  "edital",
  "educado",
  "efeito",
  "efetivar",
  "ejetar",
  "elaborar",
  "eleger",
  "eleitor",
  "elenco",
  "elevador",
  "eliminar",
  "elogiar",
  "embargo",
  "embolado",
  "embrulho",
  "embutido",
  "emenda",
  "emergir",
  "emissor",
  "empatia",
  "empenho",
  "empinado",
  "empolgar",
  "emprego",
  "empurrar",
  "emulador",
  "encaixe",
  "encenado",
  "enchente",
  "encontro",
  "endeusar",
  "endossar",
  "enfaixar",
  "enfeite",
  "enfim",
  "engajado",
  "engenho",
  "englobar",
  "engomado",
  "engraxar",
  "enguia",
  "enjoar",
  "enlatar",
  "enquanto",
  "enraizar",
  "enrolado",
  "enrugar",
  "ensaio",
  "enseada",
  "ensino",
  "ensopado",
  "entanto",
  "enteado",
  "entidade",
  "entortar",
  "entrada",
  "entulho",
  "envergar",
  "enviado",
  "envolver",
  "enxame",
  "enxerto",
  "enxofre",
  "enxuto",
  "epiderme",
  "equipar",
  "ereto",
  "erguido",
  "errata",
  "erva",
  "ervilha",
  "esbanjar",
  "esbelto",
  "escama",
  "escola",
  "escrita",
  "escuta",
  "esfinge",
  "esfolar",
  "esfregar",
  "esfumado",
  "esgrima",
  "esmalte",
  "espanto",
  "espelho",
  "espiga",
  "esponja",
  "espreita",
  "espumar",
  "esquerda",
  "estaca",
  "esteira",
  "esticar",
  "estofado",
  "estrela",
  "estudo",
  "esvaziar",
  "etanol",
  "etiqueta",
  "euforia",
  "europeu",
  "evacuar",
  "evaporar",
  "evasivo",
  "eventual",
  "evidente",
  "evoluir",
  "exagero",
  "exalar",
  "examinar",
  "exato",
  "exausto",
  "excesso",
  "excitar",
  "exclamar",
  "executar",
  "exemplo",
  "exibir",
  "exigente",
  "exonerar",
  "expandir",
  "expelir",
  "expirar",
  "explanar",
  "exposto",
  "expresso",
  "expulsar",
  "externo",
  "extinto",
  "extrato",
  "fabricar",
  "fabuloso",
  "faceta",
  "facial",
  "fada",
  "fadiga",
  "faixa",
  "falar",
  "falta",
  "familiar",
  "fandango",
  "fanfarra",
  "fantoche",
  "fardado",
  "farelo",
  "farinha",
  "farofa",
  "farpa",
  "fartura",
  "fatia",
  "fator",
  "favorita",
  "faxina",
  "fazenda",
  "fechado",
  "feijoada",
  "feirante",
  "felino",
  "feminino",
  "fenda",
  "feno",
  "fera",
  "feriado",
  "ferrugem",
  "ferver",
  "festejar",
  "fetal",
  "feudal",
  "fiapo",
  "fibrose",
  "ficar",
  "ficheiro",
  "figurado",
  "fileira",
  "filho",
  "filme",
  "filtrar",
  "firmeza",
  "fisgada",
  "fissura",
  "fita",
  "fivela",
  "fixador",
  "fixo",
  "flacidez",
  "flamingo",
  "flanela",
  "flechada",
  "flora",
  "flutuar",
  "fluxo",
  "focal",
  "focinho",
  "fofocar",
  "fogo",
  "foguete",
  "foice",
  "folgado",
  "folheto",
  "forjar",
  "formiga",
  "forno",
  "forte",
  "fosco",
  "fossa",
  "fragata",
  "fralda",
  "frango",
  "frasco",
  "fraterno",
  "freira",
  "frente",
  "fretar",
  "frieza",
  "friso",
  "fritura",
  "fronha",
  "frustrar",
  "fruteira",
  "fugir",
  "fulano",
  "fuligem",
  "fundar",
  "fungo",
  "funil",
  "furador",
  "furioso",
  "futebol",
  "gabarito",
  "gabinete",
  "gado",
  "gaiato",
  "gaiola",
  "gaivota",
  "galega",
  "galho",
  "galinha",
  "galocha",
  "ganhar",
  "garagem",
  "garfo",
  "gargalo",
  "garimpo",
  "garoupa",
  "garrafa",
  "gasoduto",
  "gasto",
  "gata",
  "gatilho",
  "gaveta",
  "gazela",
  "gelado",
  "geleia",
  "gelo",
  "gemada",
  "gemer",
  "gemido",
  "generoso",
  "gengiva",
  "genial",
  "genoma",
  "genro",
  "geologia",
  "gerador",
  "germinar",
  "gesso",
  "gestor",
  "ginasta",
  "gincana",
  "gingado",
  "girafa",
  "girino",
  "glacial",
  "glicose",
  "global",
  "glorioso",
  "goela",
  "goiaba",
  "golfe",
  "golpear",
  "gordura",
  "gorjeta",
  "gorro",
  "gostoso",
  "goteira",
  "governar",
  "gracejo",
  "gradual",
  "grafite",
  "gralha",
  "grampo",
  "granada",
  "gratuito",
  "graveto",
  "graxa",
  "grego",
  "grelhar",
  "greve",
  "grilo",
  "grisalho",
  "gritaria",
  "grosso",
  "grotesco",
  "grudado",
  "grunhido",
  "gruta",
  "guache",
  "guarani",
  "guaxinim",
  "guerrear",
  "guiar",
  "guincho",
  "guisado",
  "gula",
  "guloso",
  "guru",
  "habitar",
  "harmonia",
  "haste",
  "haver",
  "hectare",
  "herdar",
  "heresia",
  "hesitar",
  "hiato",
  "hibernar",
  "hidratar",
  "hiena",
  "hino",
  "hipismo",
  "hipnose",
  "hipoteca",
  "hoje",
  "holofote",
  "homem",
  "honesto",
  "honrado",
  "hormonal",
  "hospedar",
  "humorado",
  "iate",
  "ideia",
  "idoso",
  "ignorado",
  "igreja",
  "iguana",
  "ileso",
  "ilha",
  "iludido",
  "iluminar",
  "ilustrar",
  "imagem",
  "imediato",
  "imenso",
  "imersivo",
  "iminente",
  "imitador",
  "imortal",
  "impacto",
  "impedir",
  "implante",
  "impor",
  "imprensa",
  "impune",
  "imunizar",
  "inalador",
  "inapto",
  "inativo",
  "incenso",
  "inchar",
  "incidir",
  "incluir",
  "incolor",
  "indeciso",
  "indireto",
  "indutor",
  "ineficaz",
  "inerente",
  "infantil",
  "infestar",
  "infinito",
  "inflamar",
  "informal",
  "infrator",
  "ingerir",
  "inibido",
  "inicial",
  "inimigo",
  "injetar",
  "inocente",
  "inodoro",
  "inovador",
  "inox",
  "inquieto",
  "inscrito",
  "inseto",
  "insistir",
  "inspetor",
  "instalar",
  "insulto",
  "intacto",
  "integral",
  "intimar",
  "intocado",
  "intriga",
  "invasor",
  "inverno",
  "invicto",
  "invocar",
  "iogurte",
  "iraniano",
  "ironizar",
  "irreal",
  "irritado",
  "isca",
  "isento",
  "isolado",
  "isqueiro",
  "italiano",
  "janeiro",
  "jangada",
  "janta",
  "jararaca",
  "jardim",
  "jarro",
  "jasmim",
  "jato",
  "javali",
  "jazida",
  "jejum",
  "joaninha",
  "joelhada",
  "jogador",
  "joia",
  "jornal",
  "jorrar",
  "jovem",
  "juba",
  "judeu",
  "judoca",
  "juiz",
  "julgador",
  "julho",
  "jurado",
  "jurista",
  "juro",
  "justa",
  "labareda",
  "laboral",
  "lacre",
  "lactante",
  "ladrilho",
  "lagarta",
  "lagoa",
  "laje",
  "lamber",
  "lamentar",
  "laminar",
  "lampejo",
  "lanche",
  "lapidar",
  "lapso",
  "laranja",
  "lareira",
  "largura",
  "lasanha",
  "lastro",
  "lateral",
  "latido",
  "lavanda",
  "lavoura",
  "lavrador",
  "laxante",
  "lazer",
  "lealdade",
  "lebre",
  "legado",
  "legendar",
  "legista",
  "leigo",
  "leiloar",
  "leitura",
  "lembrete",
  "leme",
  "lenhador",
  "lentilha",
  "leoa",
  "lesma",
  "leste",
  "letivo",
  "letreiro",
  "levar",
  "leveza",
  "levitar",
  "liberal",
  "libido",
  "liderar",
  "ligar",
  "ligeiro",
  "limitar",
  "limoeiro",
  "limpador",
  "linda",
  "linear",
  "linhagem",
  "liquidez",
  "listagem",
  "lisura",
  "litoral",
  "livro",
  "lixa",
  "lixeira",
  "locador",
  "locutor",
  "lojista",
  "lombo",
  "lona",
  "longe",
  "lontra",
  "lorde",
  "lotado",
  "loteria",
  "loucura",
  "lousa",
  "louvar",
  "luar",
  "lucidez",
  "lucro",
  "luneta",
  "lustre",
  "lutador",
  "luva",
  "macaco",
  "macete",
  "machado",
  "macio",
  "madeira",
  "madrinha",
  "magnata",
  "magreza",
  "maior",
  "mais",
  "malandro",
  "malha",
  "malote",
  "maluco",
  "mamilo",
  "mamoeiro",
  "mamute",
  "manada",
  "mancha",
  "mandato",
  "manequim",
  "manhoso",
  "manivela",
  "manobrar",
  "mansa",
  "manter",
  "manusear",
  "mapeado",
  "maquinar",
  "marcador",
  "maresia",
  "marfim",
  "margem",
  "marinho",
  "marmita",
  "maroto",
  "marquise",
  "marreco",
  "martelo",
  "marujo",
  "mascote",
  "masmorra",
  "massagem",
  "mastigar",
  "matagal",
  "materno",
  "matinal",
  "matutar",
  "maxilar",
  "medalha",
  "medida",
  "medusa",
  "megafone",
  "meiga",
  "melancia",
  "melhor",
  "membro",
  "memorial",
  "menino",
  "menos",
  "mensagem",
  "mental",
  "merecer",
  "mergulho",
  "mesada",
  "mesclar",
  "mesmo",
  "mesquita",
  "mestre",
  "metade",
  "meteoro",
  "metragem",
  "mexer",
  "mexicano",
  "micro",
  "migalha",
  "migrar",
  "milagre",
  "milenar",
  "milhar",
  "mimado",
  "minerar",
  "minhoca",
  "ministro",
  "minoria",
  "miolo",
  "mirante",
  "mirtilo",
  "misturar",
  "mocidade",
  "moderno",
  "modular",
  "moeda",
  "moer",
  "moinho",
  "moita",
  "moldura",
  "moleza",
  "molho",
  "molinete",
  "molusco",
  "montanha",
  "moqueca",
  "morango",
  "morcego",
  "mordomo",
  "morena",
  "mosaico",
  "mosquete",
  "mostarda",
  "motel",
  "motim",
  "moto",
  "motriz",
  "muda",
  "muito",
  "mulata",
  "mulher",
  "multar",
  "mundial",
  "munido",
  "muralha",
  "murcho",
  "muscular",
  "museu",
  "musical",
  "nacional",
  "nadador",
  "naja",
  "namoro",
  "narina",
  "narrado",
  "nascer",
  "nativa",
  "natureza",
  "navalha",
  "navegar",
  "navio",
  "neblina",
  "nebuloso",
  "negativa",
  "negociar",
  "negrito",
  "nervoso",
  "neta",
  "neural",
  "nevasca",
  "nevoeiro",
  "ninar",
  "ninho",
  "nitidez",
  "nivelar",
  "nobreza",
  "noite",
  "noiva",
  "nomear",
  "nominal",
  "nordeste",
  "nortear",
  "notar",
  "noticiar",
  "noturno",
  "novelo",
  "novilho",
  "novo",
  "nublado",
  "nudez",
  "numeral",
  "nupcial",
  "nutrir",
  "nuvem",
  "obcecado",
  "obedecer",
  "objetivo",
  "obrigado",
  "obscuro",
  "obstetra",
  "obter",
  "obturar",
  "ocidente",
  "ocioso",
  "ocorrer",
  "oculista",
  "ocupado",
  "ofegante",
  "ofensiva",
  "oferenda",
  "oficina",
  "ofuscado",
  "ogiva",
  "olaria",
  "oleoso",
  "olhar",
  "oliveira",
  "ombro",
  "omelete",
  "omisso",
  "omitir",
  "ondulado",
  "oneroso",
  "ontem",
  "opcional",
  "operador",
  "oponente",
  "oportuno",
  "oposto",
  "orar",
  "orbitar",
  "ordem",
  "ordinal",
  "orfanato",
  "orgasmo",
  "orgulho",
  "oriental",
  "origem",
  "oriundo",
  "orla",
  "ortodoxo",
  "orvalho",
  "oscilar",
  "ossada",
  "osso",
  "ostentar",
  "otimismo",
  "ousadia",
  "outono",
  "outubro",
  "ouvido",
  "ovelha",
  "ovular",
  "oxidar",
  "oxigenar",
  "pacato",
  "paciente",
  "pacote",
  "pactuar",
  "padaria",
  "padrinho",
  "pagar",
  "pagode",
  "painel",
  "pairar",
  "paisagem",
  "palavra",
  "palestra",
  "palheta",
  "palito",
  "palmada",
  "palpitar",
  "pancada",
  "panela",
  "panfleto",
  "panqueca",
  "pantanal",
  "papagaio",
  "papelada",
  "papiro",
  "parafina",
  "parcial",
  "pardal",
  "parede",
  "partida",
  "pasmo",
  "passado",
  "pastel",
  "patamar",
  "patente",
  "patinar",
  "patrono",
  "paulada",
  "pausar",
  "peculiar",
  "pedalar",
  "pedestre",
  "pediatra",
  "pedra",
  "pegada",
  "peitoral",
  "peixe",
  "pele",
  "pelicano",
  "penca",
  "pendurar",
  "peneira",
  "penhasco",
  "pensador",
  "pente",
  "perceber",
  "perfeito",
  "pergunta",
  "perito",
  "permitir",
  "perna",
  "perplexo",
  "persiana",
  "pertence",
  "peruca",
  "pescado",
  "pesquisa",
  "pessoa",
  "petiscar",
  "piada",
  "picado",
  "piedade",
  "pigmento",
  "pilastra",
  "pilhado",
  "pilotar",
  "pimenta",
  "pincel",
  "pinguim",
  "pinha",
  "pinote",
  "pintar",
  "pioneiro",
  "pipoca",
  "piquete",
  "piranha",
  "pires",
  "pirueta",
  "piscar",
  "pistola",
  "pitanga",
  "pivete",
  "planta",
  "plaqueta",
  "platina",
  "plebeu",
  "plumagem",
  "pluvial",
  "pneu",
  "poda",
  "poeira",
  "poetisa",
  "polegada",
  "policiar",
  "poluente",
  "polvilho",
  "pomar",
  "pomba",
  "ponderar",
  "pontaria",
  "populoso",
  "porta",
  "possuir",
  "postal",
  "pote",
  "poupar",
  "pouso",
  "povoar",
  "praia",
  "prancha",
  "prato",
  "praxe",
  "prece",
  "predador",
  "prefeito",
  "premiar",
  "prensar",
  "preparar",
  "presilha",
  "pretexto",
  "prevenir",
  "prezar",
  "primata",
  "princesa",
  "prisma",
  "privado",
  "processo",
  "produto",
  "profeta",
  "proibido",
  "projeto",
  "prometer",
  "propagar",
  "prosa",
  "protetor",
  "provador",
  "publicar",
  "pudim",
  "pular",
  "pulmonar",
  "pulseira",
  "punhal",
  "punir",
  "pupilo",
  "pureza",
  "puxador",
  "quadra",
  "quantia",
  "quarto",
  "quase",
  "quebrar",
  "queda",
  "queijo",
  "quente",
  "querido",
  "quimono",
  "quina",
  "quiosque",
  "rabanada",
  "rabisco",
  "rachar",
  "racionar",
  "radial",
  "raiar",
  "rainha",
  "raio",
  "raiva",
  "rajada",
  "ralado",
  "ramal",
  "ranger",
  "ranhura",
  "rapadura",
  "rapel",
  "rapidez",
  "raposa",
  "raquete",
  "raridade",
  "rasante",
  "rascunho",
  "rasgar",
  "raspador",
  "rasteira",
  "rasurar",
  "ratazana",
  "ratoeira",
  "realeza",
  "reanimar",
  "reaver",
  "rebaixar",
  "rebelde",
  "rebolar",
  "recado",
  "recente",
  "recheio",
  "recibo",
  "recordar",
  "recrutar",
  "recuar",
  "rede",
  "redimir",
  "redonda",
  "reduzida",
  "reenvio",
  "refinar",
  "refletir",
  "refogar",
  "refresco",
  "refugiar",
  "regalia",
  "regime",
  "regra",
  "reinado",
  "reitor",
  "rejeitar",
  "relativo",
  "remador",
  "remendo",
  "remorso",
  "renovado",
  "reparo",
  "repelir",
  "repleto",
  "repolho",
  "represa",
  "repudiar",
  "requerer",
  "resenha",
  "resfriar",
  "resgatar",
  "residir",
  "resolver",
  "respeito",
  "ressaca",
  "restante",
  "resumir",
  "retalho",
  "reter",
  "retirar",
  "retomada",
  "retratar",
  "revelar",
  "revisor",
  "revolta",
  "riacho",
  "rica",
  "rigidez",
  "rigoroso",
  "rimar",
  "ringue",
  "risada",
  "risco",
  "risonho",
  "robalo",
  "rochedo",
  "rodada",
  "rodeio",
  "rodovia",
  "roedor",
  "roleta",
  "romano",
  "roncar",
  "rosado",
  "roseira",
  "rosto",
  "rota",
  "roteiro",
  "rotina",
  "rotular",
  "rouco",
  "roupa",
  "roxo",
  "rubro",
  "rugido",
  "rugoso",
  "ruivo",
  "rumo",
  "rupestre",
  "russo",
  "sabor",
  "saciar",
  "sacola",
  "sacudir",
  "sadio",
  "safira",
  "saga",
  "sagrada",
  "saibro",
  "salada",
  "saleiro",
  "salgado",
  "saliva",
  "salpicar",
  "salsicha",
  "saltar",
  "salvador",
  "sambar",
  "samurai",
  "sanar",
  "sanfona",
  "sangue",
  "sanidade",
  "sapato",
  "sarda",
  "sargento",
  "sarjeta",
  "saturar",
  "saudade",
  "saxofone",
  "sazonal",
  "secar",
  "secular",
  "seda",
  "sedento",
  "sediado",
  "sedoso",
  "sedutor",
  "segmento",
  "segredo",
  "segundo",
  "seiva",
  "seleto",
  "selvagem",
  "semanal",
  "semente",
  "senador",
  "senhor",
  "sensual",
  "sentado",
  "separado",
  "sereia",
  "seringa",
  "serra",
  "servo",
  "setembro",
  "setor",
  "sigilo",
  "silhueta",
  "silicone",
  "simetria",
  "simpatia",
  "simular",
  "sinal",
  "sincero",
  "singular",
  "sinopse",
  "sintonia",
  "sirene",
  "siri",
  "situado",
  "soberano",
  "sobra",
  "socorro",
  "sogro",
  "soja",
  "solda",
  "soletrar",
  "solteiro",
  "sombrio",
  "sonata",
  "sondar",
  "sonegar",
  "sonhador",
  "sono",
  "soprano",
  "soquete",
  "sorrir",
  "sorteio",
  "sossego",
  "sotaque",
  "soterrar",
  "sovado",
  "sozinho",
  "suavizar",
  "subida",
  "submerso",
  "subsolo",
  "subtrair",
  "sucata",
  "sucesso",
  "suco",
  "sudeste",
  "sufixo",
  "sugador",
  "sugerir",
  "sujeito",
  "sulfato",
  "sumir",
  "suor",
  "superior",
  "suplicar",
  "suposto",
  "suprimir",
  "surdina",
  "surfista",
  "surpresa",
  "surreal",
  "surtir",
  "suspiro",
  "sustento",
  "tabela",
  "tablete",
  "tabuada",
  "tacho",
  "tagarela",
  "talher",
  "talo",
  "talvez",
  "tamanho",
  "tamborim",
  "tampa",
  "tangente",
  "tanto",
  "tapar",
  "tapioca",
  "tardio",
  "tarefa",
  "tarja",
  "tarraxa",
  "tatuagem",
  "taurino",
  "taxativo",
  "taxista",
  "teatral",
  "tecer",
  "tecido",
  "teclado",
  "tedioso",
  "teia",
  "teimar",
  "telefone",
  "telhado",
  "tempero",
  "tenente",
  "tensor",
  "tentar",
  "termal",
  "terno",
  "terreno",
  "tese",
  "tesoura",
  "testado",
  "teto",
  "textura",
  "texugo",
  "tiara",
  "tigela",
  "tijolo",
  "timbrar",
  "timidez",
  "tingido",
  "tinteiro",
  "tiragem",
  "titular",
  "toalha",
  "tocha",
  "tolerar",
  "tolice",
  "tomada",
  "tomilho",
  "tonel",
  "tontura",
  "topete",
  "tora",
  "torcido",
  "torneio",
  "torque",
  "torrada",
  "torto",
  "tostar",
  "touca",
  "toupeira",
  "toxina",
  "trabalho",
  "tracejar",
  "tradutor",
  "trafegar",
  "trajeto",
  "trama",
  "trancar",
  "trapo",
  "traseiro",
  "tratador",
  "travar",
  "treino",
  "tremer",
  "trepidar",
  "trevo",
  "triagem",
  "tribo",
  "triciclo",
  "tridente",
  "trilogia",
  "trindade",
  "triplo",
  "triturar",
  "triunfal",
  "trocar",
  "trombeta",
  "trova",
  "trunfo",
  "truque",
  "tubular",
  "tucano",
  "tudo",
  "tulipa",
  "tupi",
  "turbo",
  "turma",
  "turquesa",
  "tutelar",
  "tutorial",
  "uivar",
  "umbigo",
  "unha",
  "unidade",
  "uniforme",
  "urologia",
  "urso",
  "urtiga",
  "urubu",
  "usado",
  "usina",
  "usufruir",
  "vacina",
  "vadiar",
  "vagaroso",
  "vaidoso",
  "vala",
  "valente",
  "validade",
  "valores",
  "vantagem",
  "vaqueiro",
  "varanda",
  "vareta",
  "varrer",
  "vascular",
  "vasilha",
  "vassoura",
  "vazar",
  "vazio",
  "veado",
  "vedar",
  "vegetar",
  "veicular",
  "veleiro",
  "velhice",
  "veludo",
  "vencedor",
  "vendaval",
  "venerar",
  "ventre",
  "verbal",
  "verdade",
  "vereador",
  "vergonha",
  "vermelho",
  "verniz",
  "versar",
  "vertente",
  "vespa",
  "vestido",
  "vetorial",
  "viaduto",
  "viagem",
  "viajar",
  "viatura",
  "vibrador",
  "videira",
  "vidraria",
  "viela",
  "viga",
  "vigente",
  "vigiar",
  "vigorar",
  "vilarejo",
  "vinco",
  "vinheta",
  "vinil",
  "violeta",
  "virada",
  "virtude",
  "visitar",
  "visto",
  "vitral",
  "viveiro",
  "vizinho",
  "voador",
  "voar",
  "vogal",
  "volante",
  "voleibol",
  "voltagem",
  "volumoso",
  "vontade",
  "vulto",
  "vuvuzela",
  "xadrez",
  "xarope",
  "xeque",
  "xeretar",
  "xerife",
  "xingar",
  "zangado",
  "zarpar",
  "zebu",
  "zelador",
  "zombar",
  "zoologia",
  "zumbido"
], GP = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
Object.defineProperty(tr, "__esModule", { value: !0 });
const yr = {};
tr.wordlists = yr;
let ct;
var mn = tr._default = ct;
try {
  mn = tr._default = ct = LP, yr.czech = ct;
} catch {
}
try {
  mn = tr._default = ct = zP, yr.chinese_simplified = ct;
} catch {
}
try {
  mn = tr._default = ct = jP, yr.chinese_traditional = ct;
} catch {
}
try {
  mn = tr._default = ct = DP, yr.korean = ct;
} catch {
}
try {
  mn = tr._default = ct = MP, yr.french = ct;
} catch {
}
try {
  mn = tr._default = ct = KP, yr.italian = ct;
} catch {
}
try {
  mn = tr._default = ct = qP, yr.spanish = ct;
} catch {
}
try {
  mn = tr._default = ct = VP, yr.japanese = ct, yr.JA = ct;
} catch {
}
try {
  mn = tr._default = ct = WP, yr.portuguese = ct;
} catch {
}
try {
  mn = tr._default = ct = GP, yr.english = ct, yr.EN = ct;
} catch {
}
Object.defineProperty(gn, "__esModule", { value: !0 });
const ZP = Mr, ey = Nt, ty = Uu, XP = Bi, Wc = tr;
let Js = Wc._default;
const T1 = "Invalid mnemonic", Qi = "Invalid entropy", YP = "Invalid mnemonic checksum", ry = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function Qs(e) {
  return (e || "").normalize("NFKD");
}
function ny(e, t, r) {
  for (; e.length < r; )
    e = t + e;
  return e;
}
function iy(e) {
  return parseInt(e, 2);
}
function oy(e) {
  return e.map((t) => ny(t.toString(2), "0", 8)).join("");
}
function sy(e) {
  const r = e.length * 8 / 32, n = ZP.sha256(Uint8Array.from(e));
  return oy(Array.from(n)).slice(0, r);
}
function ay(e) {
  return "mnemonic" + (e || "");
}
function JP(e, t) {
  const r = Uint8Array.from(Buffer.from(Qs(e), "utf8")), n = Uint8Array.from(Buffer.from(ay(Qs(t)), "utf8")), i = ty.pbkdf2(ey.sha512, r, n, {
    c: 2048,
    dkLen: 64
  });
  return Buffer.from(i);
}
gn.mnemonicToSeedSync = JP;
function QP(e, t) {
  const r = Uint8Array.from(Buffer.from(Qs(e), "utf8")), n = Uint8Array.from(Buffer.from(ay(Qs(t)), "utf8"));
  return ty.pbkdf2Async(ey.sha512, r, n, {
    c: 2048,
    dkLen: 64
  }).then((i) => Buffer.from(i));
}
var eI = gn.mnemonicToSeed = QP;
function cy(e, t) {
  if (t = t || Js, !t)
    throw new Error(ry);
  const r = Qs(e).split(" ");
  if (r.length % 3 !== 0)
    throw new Error(T1);
  const n = r.map((f) => {
    const l = t.indexOf(f);
    if (l === -1)
      throw new Error(T1);
    return ny(l.toString(2), "0", 11);
  }).join(""), i = Math.floor(n.length / 33) * 32, o = n.slice(0, i), s = n.slice(i), a = o.match(/(.{1,8})/g).map(iy);
  if (a.length < 16)
    throw new Error(Qi);
  if (a.length > 32)
    throw new Error(Qi);
  if (a.length % 4 !== 0)
    throw new Error(Qi);
  const c = Buffer.from(a);
  if (sy(c) !== s)
    throw new Error(YP);
  return c.toString("hex");
}
gn.mnemonicToEntropy = cy;
function uy(e, t) {
  if (Buffer.isBuffer(e) || (e = Buffer.from(e, "hex")), t = t || Js, !t)
    throw new Error(ry);
  if (e.length < 16)
    throw new TypeError(Qi);
  if (e.length > 32)
    throw new TypeError(Qi);
  if (e.length % 4 !== 0)
    throw new TypeError(Qi);
  const r = oy(Array.from(e)), n = sy(e), s = (r + n).match(/(.{1,11})/g).map((a) => {
    const c = iy(a);
    return t[c];
  });
  return t[0] === "" ? s.join("") : s.join(" ");
}
var tI = gn.entropyToMnemonic = uy;
function rI(e, t, r) {
  if (e = e || 128, e % 32 !== 0)
    throw new TypeError(Qi);
  return t = t || ((n) => Buffer.from(XP.randomBytes(n))), uy(t(e / 8), r);
}
gn.generateMnemonic = rI;
function nI(e, t) {
  try {
    cy(e, t);
  } catch {
    return !1;
  }
  return !0;
}
gn.validateMnemonic = nI;
function iI(e) {
  const t = Wc.wordlists[e];
  if (t)
    Js = t;
  else
    throw new Error('Could not find wordlist for language "' + e + '"');
}
gn.setDefaultWordlist = iI;
function oI() {
  if (!Js)
    throw new Error("No Default Wordlist set");
  return Object.keys(Wc.wordlists).filter((e) => e === "JA" || e === "EN" ? !1 : Wc.wordlists[e].every((t, r) => t === Js[r]))[0];
}
gn.getDefaultWordlist = oI;
var sI = tr;
gn.wordlists = sI.wordlists;
function aI(e) {
  return xp(Ut(e));
}
function C1(e, t) {
  return Sd(Uv, e, t);
}
const Se = (e) => Iw(e);
function cI(e) {
  if (kt(e.isPoint(Se("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), kt(!e.isPoint(Se("030000000000000000000000000000000000000000000000000000000000000005"))), kt(e.isPrivate(Se("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), kt(e.isPrivate(Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), kt(!e.isPrivate(Se("0000000000000000000000000000000000000000000000000000000000000000"))), kt(!e.isPrivate(Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), kt(!e.isPrivate(Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), kt(wn(e.pointFromScalar(Se("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), Se("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
    kt(e.xOnlyPointAddTweak(Se("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let t = e.xOnlyPointAddTweak(Se("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), Se("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    kt(wn(t.xOnlyPubkey, Se("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(Se("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), Se("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  kt(wn(e.pointAddScalar(Se("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), Se("0000000000000000000000000000000000000000000000000000000000000003")), Se("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), kt(wn(e.privateAdd(Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), Se("0000000000000000000000000000000000000000000000000000000000000002")), Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && (kt(wn(e.privateNegate(Se("0000000000000000000000000000000000000000000000000000000000000001")), Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), kt(wn(e.privateNegate(Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), Se("0000000000000000000000000000000000000000000000000000000000000003")) === 0), kt(wn(e.privateNegate(Se("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), Se("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), kt(wn(e.sign(Se("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), Se("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), Se("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), kt(e.verify(Se("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), Se("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), Se("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && kt(wn(e.signSchnorr(Se("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), Se("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), Se("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), Se("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && kt(e.verifySchnorr(Se("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), Se("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), Se("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function kt(e) {
  if (!e)
    throw new Error("ecc library invalid");
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Jf(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function ly(...e) {
  const t = (o) => o, r = (o, s) => (a) => o(s(a)), n = e.map((o) => o.encode).reduceRight(r, t), i = e.map((o) => o.decode).reduce(r, t);
  return { encode: n, decode: i };
}
// @__NO_SIDE_EFFECTS__
function uI(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function lI(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function P1(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const i = [], o = Array.from(e);
  for (o.forEach((s) => {
    if (s < 0 || s >= t)
      throw new Error(`Wrong integer: ${s}`);
  }); ; ) {
    let s = 0, a = !0;
    for (let c = n; c < o.length; c++) {
      const u = o[c], f = t * s + u;
      if (!Number.isSafeInteger(f) || t * s / t !== s || f - u !== t * s)
        throw new Error("convertRadix: carry overflow");
      s = f % r;
      const l = Math.floor(f / r);
      if (o[c] = l, !Number.isSafeInteger(l) || l * r + s !== f)
        throw new Error("convertRadix: carry overflow");
      if (a)
        l ? a = !1 : n = c;
      else continue;
    }
    if (i.push(s), a)
      break;
  }
  for (let s = 0; s < e.length - 1 && e[s] === 0; s++)
    i.push(0);
  return i.reverse();
}
// @__NO_SIDE_EFFECTS__
function fI(e) {
  return {
    encode: (t) => {
      if (!Jf(t))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ P1(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ P1(t, e, 2 ** 8));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function dI(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!Jf(r))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), i = new Uint8Array(r.length + e);
      return i.set(r), i.set(n, r.length), i;
    },
    decode(r) {
      if (!Jf(r))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), i = t(n).slice(0, e), o = r.slice(-e);
      for (let s = 0; s < e; s++)
        if (i[s] !== o[s])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
const hI = (e) => /* @__PURE__ */ ly(/* @__PURE__ */ fI(58), /* @__PURE__ */ uI(e), /* @__PURE__ */ lI("")), pI = /* @__PURE__ */ hI("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), gI = (e) => /* @__PURE__ */ ly(/* @__PURE__ */ dI(4, (t) => e(e(t))), pI), mI = gI;
var En;
function bI(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? (En == null ? void 0 : En.lang),
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (En == null ? void 0 : En.abortEarly),
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (En == null ? void 0 : En.abortPipeEarly)
  };
}
var Wl;
function yI(e) {
  return Wl == null ? void 0 : Wl.get(e);
}
var Gl;
function wI(e) {
  return Gl == null ? void 0 : Gl.get(e);
}
var Zl;
function vI(e, t) {
  var r;
  return (r = Zl == null ? void 0 : Zl.get(e)) == null ? void 0 : r.get(t);
}
function ea(e) {
  var r, n;
  const t = typeof e;
  return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function jn(e, t, r, n, i) {
  const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? ea(o), c = {
    kind: e.kind,
    type: e.type,
    input: o,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: i == null ? void 0 : i.path,
    issues: i == null ? void 0 : i.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", f = (i == null ? void 0 : i.message) ?? // @ts-expect-error
  e.message ?? vI(e.reference, c.lang) ?? (u ? wI(c.lang) : null) ?? n.message ?? yI(c.lang);
  f && (c.message = typeof f == "function" ? f(c) : f), u && (r.typed = !1), r.issues ? r.issues.push(c) : r.issues = [c];
}
var xI = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(t) {
    super(t[0].message);
    /**
     * The error issues.
     */
    Le(this, "issues");
    this.name = "ValiError", this.issues = t;
  }
};
function Fu(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: Fu,
    async: !1,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && jn(this, "integer", t, r), t;
    }
  };
}
function Hh(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: Hh,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && jn(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function Hu(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: Hu,
    async: !1,
    expects: `<=${e instanceof Date ? e.toJSON() : ea(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && jn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : ea(r.value)
      }), r;
    }
  };
}
function Ru(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: Ru,
    async: !1,
    expects: `>=${e instanceof Date ? e.toJSON() : ea(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && jn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : ea(r.value)
      }), r;
    }
  };
}
function fy(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: fy,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && jn(this, "format", r, n), r;
    }
  };
}
function Lu(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: Lu,
    expects: e.name,
    async: !1,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = !0 : jn(this, "type", r, n), r;
    }
  };
}
function zu(e) {
  return {
    kind: "schema",
    type: "number",
    reference: zu,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : jn(this, "type", t, r), t;
    }
  };
}
function Qf(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Qf,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const f of c.issues)
              f.path ? f.path.unshift(u) : f.path = [u], (o = r.issues) == null || o.push(f);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
      } else
        jn(this, "type", r, n);
      return r;
    }
  };
}
function dy(e) {
  return {
    kind: "schema",
    type: "string",
    reference: dy,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : jn(this, "type", t, r), t;
    }
  };
}
function An(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    bI(r)
  );
  if (n.issues)
    throw new xI(n.issues);
  return n.value;
}
function fs(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = !1;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
const ed = fs(zu(), Fu(), Ru(0), Hu(4294967295)), EI = fs(zu(), Fu(), Ru(0), Hu(2147483647)), AI = fs(zu(), Fu(), Ru(0), Hu(255)), Xl = fs(Lu(Uint8Array), Hh(32)), SI = fs(Lu(Uint8Array), Hh(33)), _I = Qf({
  wif: AI,
  bip32: Qf({
    public: ed,
    private: ed
  })
}), kI = fs(dy(), fy(/^(m\/)?(\d+'?\/)*\d+'?$/));
function TI(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  var n = new Uint8Array(34), i = new DataView(n.buffer);
  return i.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function CI(e) {
  return Ho.encode(TI(e.version, e.privateKey));
}
const I1 = mI(Ut), B1 = {
  encode: (e) => I1.encode(e),
  decode: (e) => I1.decode(e)
};
function PI(e) {
  cI(e);
  const t = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, r = 2147483648;
  function n(h) {
    return h.length === 32 ? h : h.slice(1, 33);
  }
  class i {
    constructor(m, y) {
      Le(this, "__D");
      Le(this, "__Q");
      Le(this, "lowR", !1);
      this.__D = m, this.__Q = y;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, !0)), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(m, y) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (y === void 0 && (y = this.lowR), y === !1)
        return e.sign(m, this.privateKey);
      {
        let b = e.sign(m, this.privateKey);
        const g = new Uint8Array(32);
        let v = 0;
        for (; b[0] > 127; )
          v++, Hi(g, 0, v, "LE"), b = e.sign(m, this.privateKey, g);
        return b;
      }
    }
    signSchnorr(m) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!e.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return e.signSchnorr(m, this.privateKey);
    }
    verify(m, y) {
      return e.verify(m, this.publicKey, y);
    }
    verifySchnorr(m, y) {
      if (!e.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e.verifySchnorr(m, this.publicKey.subarray(1, 33), y);
    }
  }
  class o extends i {
    constructor(y, b, g, v, _ = 0, x = 0, k = 0) {
      super(y, b);
      Le(this, "chainCode");
      Le(this, "network");
      Le(this, "__DEPTH");
      Le(this, "__INDEX");
      Le(this, "__PARENT_FINGERPRINT");
      this.chainCode = g, this.network = v, this.__DEPTH = _, this.__INDEX = x, this.__PARENT_FINGERPRINT = k, An(_I, v);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return aI(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return !0;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return f(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const y = this.network, b = this.isNeutered() ? y.bip32.public : y.bip32.private, g = new Uint8Array(78);
      return Hi(g, 0, b, "BE"), a0(g, 4, this.depth), Hi(g, 5, this.parentFingerprint, "BE"), Hi(g, 9, this.index, "BE"), g.set(this.chainCode, 13), this.isNeutered() ? g.set(this.publicKey, 45) : (a0(g, 45, 0), g.set(this.privateKey, 46)), B1.encode(g);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return CI({
        version: this.network.wif,
        privateKey: this.privateKey,
        compressed: !0
      });
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(y) {
      An(ed, y);
      const b = y >= r, g = new Uint8Array(37);
      if (b) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        g[0] = 0, g.set(this.privateKey, 1), Hi(g, 33, y, "BE");
      } else
        g.set(this.publicKey, 0), Hi(g, 33, y, "BE");
      const v = C1(this.chainCode, g), _ = v.slice(0, 32), x = v.slice(32);
      if (!e.isPrivate(_))
        return this.derive(y + 1);
      let k;
      if (this.isNeutered()) {
        const P = e.pointAddScalar(this.publicKey, _, !0);
        if (P === null)
          return this.derive(y + 1);
        k = f(P, x, this.network, this.depth + 1, y, To(this.fingerprint, 0, "BE"));
      } else {
        const P = e.privateAdd(this.privateKey, _);
        if (P == null)
          return this.derive(y + 1);
        k = c(P, x, this.network, this.depth + 1, y, To(this.fingerprint, 0, "BE"));
      }
      return k;
    }
    deriveHardened(y) {
      if (typeof An(EI, y) == "number")
        return this.derive(y + r);
      throw new TypeError("Expected UInt31, got " + y);
    }
    derivePath(y) {
      An(kI, y);
      let b = y.split("/");
      if (b[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        b = b.slice(1);
      }
      return b.reduce((g, v) => {
        let _;
        return v.slice(-1) === "'" ? (_ = parseInt(v.slice(0, -1), 10), g.deriveHardened(_)) : (_ = parseInt(v, 10), g.derive(_));
      }, this);
    }
    tweak(y) {
      return this.privateKey ? this.tweakFromPrivateKey(y) : this.tweakFromPublicKey(y);
    }
    tweakFromPublicKey(y) {
      const b = n(this.publicKey);
      if (!e.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const g = e.xOnlyPointAddTweak(b, y);
      if (!g || g.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const v = Uint8Array.from([
        g.parity === 0 ? 2 : 3
      ]), _ = Pw([
        v,
        g.xOnlyPubkey
      ]);
      return new i(void 0, _);
    }
    tweakFromPrivateKey(y) {
      const b = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, g = (() => {
        if (b) {
          if (e.privateNegate)
            return e.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        } else return this.privateKey;
      })(), v = e.privateAdd(g, y);
      if (!v)
        throw new Error("Invalid tweaked private key!");
      return new i(v, void 0);
    }
  }
  function s(h, m) {
    const y = B1.decode(h);
    if (y.length !== 78)
      throw new TypeError("Invalid buffer length");
    m = m || t;
    const b = To(y, 0, "BE");
    if (b !== m.bip32.private && b !== m.bip32.public)
      throw new TypeError("Invalid network version");
    const g = y[4], v = To(y, 5, "BE");
    if (g === 0 && v !== 0)
      throw new TypeError("Invalid parent fingerprint");
    const _ = To(y, 9, "BE");
    if (g === 0 && _ !== 0)
      throw new TypeError("Invalid index");
    const x = y.slice(13, 45);
    let k;
    if (b === m.bip32.private) {
      if (y[45] !== 0)
        throw new TypeError("Invalid private key");
      const P = y.slice(46, 78);
      k = c(P, x, m, g, _, v);
    } else {
      const P = y.slice(45, 78);
      k = f(P, x, m, g, _, v);
    }
    return k;
  }
  function a(h, m, y) {
    return c(h, m, y);
  }
  function c(h, m, y, b, g, v) {
    if (An(Xl, h), An(Xl, m), y = y || t, !e.isPrivate(h))
      throw new TypeError("Private key not in range [1, n)");
    return new o(h, void 0, m, y, b, g, v);
  }
  function u(h, m, y) {
    return f(h, m, y);
  }
  function f(h, m, y, b, g, v) {
    if (An(SI, h), An(Xl, m), y = y || t, !e.isPoint(h))
      throw new TypeError("Point is not on the curve");
    return new o(void 0, h, m, y, b, g, v);
  }
  function l(h, m) {
    if (An(Lu(Uint8Array), h), h.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (h.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    m = m || t;
    const y = C1(Cw("Bitcoin seed"), h), b = y.slice(0, 32), g = y.slice(32);
    return a(b, g, m);
  }
  return {
    fromSeed: l,
    fromBase58: s,
    fromPublicKey: u,
    fromPrivateKey: a
  };
}
const II = PI(Eh);
Sp(Eh);
const BI = async ({ contentBase64: e, mimeType: t, quantity: r = 1, inscriptions: n, ordinalAddress: i, paymentAddress: o, paymentPublicKey: s, signPsbt: a, network: c = Ue }) => {
  try {
    if (!e && !n)
      throw new Error("contentBase64 or inscriptions is required");
    const u = await NI(c), f = Buffer.from(u).toString("hex"), l = n || Array(r).fill({
      content: e,
      mimeType: t
    }), h = await OI({
      inscriptions: l,
      paymentAddress: o,
      paymentPublicKey: s,
      privKey: f,
      network: c
    });
    if (!h || !(h != null && h.psbtHex))
      throw new Error("couldn't get commit tx");
    const m = String(h == null ? void 0 : h.psbtHex), y = String(h == null ? void 0 : h.psbtBase64), b = await a("", m, y, !0, !1, c);
    if (!b)
      throw new Error("sign psbt failed");
    const v = Qe.fromHex((b == null ? void 0 : b.signedPsbtHex) || "").extractTransaction(), _ = await $h(v.toHex(), c);
    if (!_)
      throw new Error("commit tx failed");
    return await $I({
      inscriptions: l,
      ordinalAddress: i,
      privKey: f,
      commitTxId: _,
      network: c
    });
  } catch (u) {
    throw u;
  }
}, OI = async ({ inscriptions: e, paymentAddress: t, paymentPublicKey: r, privKey: n, network: i }) => {
  try {
    const o = e.length, s = e.reduce((I, R) => I + Buffer.from(R.content).length, 0);
    if (s > 39e4)
      throw new Error("Content size is too large, must be less than 390kb");
    const { fastestFee: a } = await HI(i), c = kg(String(n), !0), u = new Qe({
      network: Ot(i)
    }), { inscriberAddress: f } = UI(c, e, i), l = 5 * 34 * o, h = Math.floor(l * a * o), m = Math.floor(s * a / 3) + 1e3 + 546 * o, y = Math.floor(h + m), g = (await Bh(t, i)).filter((I) => I.value > 3e3).sort((I, R) => R.value - I.value), v = IP(g);
    if (v === 0)
      throw new Error("insufficient funds");
    if (v < y)
      throw new Error("insufficient funds");
    let _ = 0;
    const x = await yd(t, Ot(i));
    let k = 0;
    for await (const I of g) {
      const R = BP(t, i);
      if (console.log({ paymentAddressType: R }), u.addInput({
        hash: I.txid,
        index: I.vout,
        witnessUtxo: { value: BigInt(I.value), script: x }
      }), R === Ss && u.updateInput(k, {
        tapInternalKey: Ts(Buffer.from(r, "hex"))
      }), R === X1) {
        let j = Tb(r, i);
        u.updateInput(k, { redeemScript: j });
      }
      if (k++, _ += I.value, _ > y)
        break;
    }
    const P = _ - y;
    return u.addOutput({
      value: BigInt(m),
      address: f
    }), P > 546 && u.addOutput({
      value: BigInt(P),
      address: t
    }), {
      psbtHex: u.toHex(),
      psbtBase64: u.toBase64()
    };
  } catch (o) {
    throw o;
  }
}, $I = async ({ inscriptions: e, ordinalAddress: t, commitTxId: r, privKey: n, network: i, isDry: o }) => {
  try {
    const s = Fv(n), a = kg(n, !0), c = hy(a, e), u = Oc.encodeScript(c), [f, l] = Oc.getPubKey(a, { target: u });
    if (!await FI(String(r), i))
      throw new Error("ERROR WAITING FOR COMMIT TX");
    const m = await RI(r, 0, i);
    if (m === 0 || !m)
      throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const y = zr.create({
      vin: [
        {
          txid: r,
          vout: 0,
          prevout: {
            value: m,
            scriptPubKey: ["OP_1", f]
          }
        }
      ],
      vout: [
        ...Array(e.length).fill({
          value: 546,
          scriptPubKey: w2.toScriptPubKey(t)
        })
      ]
    }), b = m_.taproot.sign(s, y, 0, { extension: u });
    return y.vin[0].witness = [b, c, l], o ? zr.util.getTxid(y) : await $h(zr.encode(y).hex, i);
  } catch (s) {
    throw s;
  }
};
async function NI(e) {
  const t = crypto.getRandomValues(new Uint8Array(32)), r = tI(Buffer.from(t)), n = await eI(r), i = II.fromSeed(n, Ot(e));
  return i == null ? void 0 : i.derivePath("m/44'/0'/0'/0/0").privateKey;
}
const hy = (e, t) => {
  const r = new TextEncoder(), n = r.encode("ord"), i = 546, o = (a, c) => {
    let u;
    if (c === CP) {
      const l = Buffer.from(a, "base64").toString("utf-8");
      u = Buffer.from(l, "utf-8");
    } else
      u = Buffer.from(a, "base64");
    const f = [];
    for (let l = 0; l < u.length; l += 520)
      f.push(u.slice(l, l + 520));
    return f;
  }, s = [e, "OP_CHECKSIG"];
  return t.forEach((a, c) => {
    const { content: u, mimeType: f } = a, l = o(u, f);
    if (s.push("OP_0", "OP_IF", n, "01", r.encode(f), "OP_0"), c > 0) {
      const h = i * (c + 1), m = Buffer.from([h]);
      s.push(Buffer.from([2])), s.push(m);
    }
    s.push(...l.map((h) => h), "OP_ENDIF");
  }), s;
}, UI = (e, t, r = Ue) => {
  const n = hy(e, t), i = Oc.encodeScript(n), [o] = Oc.getPubKey(e, { target: i });
  return {
    inscriberAddress: w2.p2tr.fromPubKey(o, qT(r)),
    tpubkey: o,
    tapleaf: i
  };
};
async function py(e, t = Ue) {
  try {
    return await ft.get(`${$u(t)}/api/tx/${e}`).then((r) => r.data);
  } catch (r) {
    throw r;
  }
}
async function FI(e, t) {
  const n = Date.now();
  for (; ; )
    try {
      if (await py(e, t))
        return console.log("Transaction found in mempool:", e), !0;
      if (Date.now() - n > 6e4)
        return !1;
      await new Promise((o) => setTimeout(o, 5e3));
    } catch {
      if (Date.now() - n > 6e4)
        return !1;
      await new Promise((o) => setTimeout(o, 5e3));
    }
}
const HI = async (e) => await ft.get(`${$u(e)}/api/v1/fees/recommended`, {
  headers: {
    "Content-Type": "application/json"
  }
}).then((t) => t.data);
async function RI(e, t, r) {
  const i = Date.now();
  for (; ; )
    try {
      const o = await py(e, r);
      if (o && o.vout && o.vout.length > 0)
        return Math.floor(o.vout[t].value);
      if (Date.now() - i > 6e4)
        return null;
      await new Promise((s) => setTimeout(s, 5e3));
    } catch (o) {
      if (console.error("Error fetching transaction output value:", o), Date.now() - i > 6e4)
        return null;
      await new Promise((s) => setTimeout(s, 5e3));
    }
}
const td = new Error("The connected wallet doesn't support this method..."), LI = new Error("Wallet is not installed");
class Br {
  constructor(t, r, n) {
    Object.defineProperty(this, "parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "$store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$network", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.$store = t.$store, this.$network = t.$network, this.initialize();
  }
  disconnect() {
  }
  async requestAccounts() {
    return [this.$store.get().address, this.$store.get().paymentAddress];
  }
  async switchNetwork(t) {
    throw this.parent.disconnect(), td;
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Ge, Et, Bt, At].includes(this.$network.get()) ? this.$network.get() : Ue;
  }
  async getPublicKey() {
    return this.$store.get().publicKey;
  }
  async getBalance() {
    const { paymentAddress: t } = this.$store.get();
    return await ls(t, this.$network.get());
  }
  async getInscriptions(t, r) {
    throw console.log("getInscriptions not implemented", t, r), td;
  }
  async pushPsbt(t) {
    let r = t;
    return r.startsWith("02") || (console.log("extracting tx..."), r = Qe.fromHex(r).extractTransaction().toHex()), await $h(r, this.$network.get());
  }
  async inscribe(t, r) {
    return await BI({
      contentBase64: t,
      mimeType: r,
      ordinalAddress: this.$store.get().address,
      paymentAddress: this.$store.get().paymentAddress,
      paymentPublicKey: this.$store.get().paymentPublicKey,
      signPsbt: this.signPsbt.bind(this),
      network: this.$network.get()
    });
  }
}
class zI extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window.unisat;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [gi]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      if (t.provider !== gi) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(gi) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = Kc(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(gi);
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Unisat isn't installed");
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    await this.getNetwork().then((i) => {
      this.network !== i && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n)
      throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", gi), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getChain());
    return t ? Kc(t.enum) : this.network;
  }
  async sendBTC(t, r) {
    var i;
    const n = await ((i = this.library) == null ? void 0 : i.sendBitcoin(t, r));
    if (!n)
      throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, i, o) {
    var c;
    const s = await ((c = this.library) == null ? void 0 : c.signPsbt(r, {
      autoFinalized: i
    })), a = Qe.fromHex(s);
    if (i && o) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: a.toHex(),
        signedPsbtBase64: a.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, i = r || 10;
    return await this.library.getInscriptions(n, i);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var n;
    const r = rb(t);
    await ((n = this.library) == null ? void 0 : n.switchChain(r)), this.$network.set(t);
  }
}
const jI = (e) => /^(?:[A-Za-z0-9+\/]{4})*?(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(e), DI = (e) => /^[a-fA-F0-9]+$/.test(e);
function MI(e) {
  typeof window < "u" && typeof localStorage < "u" && setTimeout(() => {
    const t = document.createTextNode(" ");
    document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
  }, 1500);
}
function gy() {
  return {
    $store: Z1({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      connected: !1,
      isConnecting: !1,
      isInitializing: !0,
      accounts: [],
      balance: void 0,
      hasProvider: {
        [Di]: !1,
        [gi]: !1,
        [kn]: !1,
        [Mi]: !1,
        [wi]: !1,
        [yi]: !1,
        [ji]: !1,
        [vi]: !0,
        [bi]: !1,
        [Ki]: !1,
        [mi]: !1,
        [Ri]: !1
      }
    }),
    $network: sc(Ue),
    $library: sc(void 0)
  };
}
function KI({ network: e }) {
  return {
    network: e
  };
}
const cr = [
  "address",
  "paymentAddress",
  "publicKey",
  "paymentPublicKey",
  "balance"
], qI = (e) => {
  const t = e.match(/.{1,2}/g);
  if (!t)
    throw new Error("Invalid hex string");
  return Uint8Array.from(t.map((r) => parseInt(r, 16)));
};
var Yl;
function VI(e) {
  return Yl == null ? void 0 : Yl.get(e);
}
var Jl;
function WI(e) {
  return Jl == null ? void 0 : Jl.get(e);
}
var Ql;
function GI(e, t) {
  var r;
  return (r = Ql == null ? void 0 : Ql.get(e)) == null ? void 0 : r.get(t);
}
function ju(e) {
  var r, n;
  let t = typeof e;
  return t === "object" && (t = (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null"), t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t;
}
function ur(e, t, r, n, i) {
  const o = i && "input" in i ? i.input : r.value, s = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? ju(o), c = {
    kind: e.kind,
    type: e.type,
    input: o,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: i == null ? void 0 : i.path,
    issues: i == null ? void 0 : i.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", f = (i == null ? void 0 : i.message) ?? // @ts-expect-error
  e.message ?? GI(e.reference, c.lang) ?? (u ? WI(c.lang) : null) ?? n.message ?? VI(c.lang);
  f && (c.message = typeof f == "function" ? f(c) : f), u && (r.typed = !1), r.issues ? r.issues.push(c) : r.issues = [c];
}
function ZI(e, t) {
  return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function my(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function O1(e, t) {
  return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
}
function Vr(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: Vr,
    expects: "Array",
    async: !1,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        for (let s = 0; s < i.length; s++) {
          const a = i[s], c = this.item._run({ typed: !1, value: a }, n);
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const f of c.issues)
              f.path ? f.path.unshift(u) : f.path = [u], (o = r.issues) == null || o.push(f);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
      } else
        ur(this, "type", r, n);
      return r;
    }
  };
}
function by(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: by,
    expects: "boolean",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "boolean" ? t.typed = !0 : ur(this, "type", t, r), t;
    }
  };
}
function ao(e, t) {
  const r = Object.entries(e).filter(([n]) => isNaN(+n)).map(([, n]) => n);
  return {
    kind: "schema",
    type: "enum",
    reference: ao,
    expects: r.map(ju).join(" | ") || "never",
    async: !1,
    enum: e,
    options: r,
    message: t,
    _run(n, i) {
      return this.options.includes(n.value) ? n.typed = !0 : ur(this, "type", n, i), n;
    }
  };
}
function dt(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: dt,
    expects: ju(e),
    async: !1,
    literal: e,
    message: t,
    _run(r, n) {
      return r.value === this.literal ? r.typed = !0 : ur(this, "type", r, n), r;
    }
  };
}
function yy(e, t) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: yy,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const f of c.issues)
              f.path ? f.path.unshift(u) : f.path = [u], (o = r.issues) == null || o.push(f);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
        if (!r.issues || !n.abortEarly)
          for (const s in i)
            ZI(i, s) && !(s in this.entries) && (r.value[s] = i[s]);
      } else
        ur(this, "type", r, n);
      return r;
    }
  };
}
function Rh(e, t) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: Rh,
    expects: "!undefined",
    async: !1,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === void 0 ? (ur(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function go(e) {
  return {
    kind: "schema",
    type: "null",
    reference: go,
    expects: "null",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === null ? t.typed = !0 : ur(this, "type", t, r), t;
    }
  };
}
function mo(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: mo,
    expects: `${e.expects} | null | undefined`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = my(
        this,
        n,
        i
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function un(e) {
  return {
    kind: "schema",
    type: "number",
    reference: un,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : ur(this, "type", t, r), t;
    }
  };
}
function ae(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: ae,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const f of c.issues)
              f.path ? f.path.unshift(u) : f.path = [u], (o = r.issues) == null || o.push(f);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
      } else
        ur(this, "type", r, n);
      return r;
    }
  };
}
function Wr(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: Wr,
    expects: `${e.expects} | undefined`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return n.value === void 0 && ("default" in this && (n.value = my(
        this,
        n,
        i
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function wy(e, t) {
  return {
    kind: "schema",
    type: "picklist",
    reference: wy,
    expects: e.map(ju).join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      return this.options.includes(r.value) ? r.typed = !0 : ur(this, "type", r, n), r;
    }
  };
}
function fe(e) {
  return {
    kind: "schema",
    type: "string",
    reference: fe,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : ur(this, "type", t, r), t;
    }
  };
}
function Lh(e) {
  return {
    kind: "schema",
    type: "undefined",
    reference: Lh,
    expects: "undefined",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === void 0 ? t.typed = !0 : ur(this, "type", t, r), t;
    }
  };
}
function $1(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function Du(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: Du,
    expects: [...new Set(e.map((r) => r.expects))].join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      let i, o, s;
      for (const a of this.options) {
        const c = a._run(
          { typed: !1, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            o ? o.push(c) : o = [c];
          else {
            i = c;
            break;
          }
        else
          s ? s.push(c) : s = [c];
      }
      if (i)
        return i;
      if (o) {
        if (o.length === 1)
          return o[0];
        ur(this, "type", r, n, {
          issues: $1(o)
        }), r.typed = !0;
      } else {
        if ((s == null ? void 0 : s.length) === 1)
          return s[0];
        ur(this, "type", r, n, {
          issues: $1(s)
        });
      }
      return r;
    }
  };
}
function Mu() {
  return {
    kind: "schema",
    type: "unknown",
    reference: Mu,
    expects: "unknown",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
var vr = {}, Yo = {}, Xt = {};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.decode = Xt.encode = Xt.unescape = Xt.escape = Xt.pad = void 0;
const vy = as;
function zh(e) {
  return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
Xt.pad = zh;
function xy(e) {
  return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
Xt.escape = xy;
function Ey(e) {
  return zh(e).replace(/-/g, "+").replace(/_/g, "/");
}
Xt.unescape = Ey;
function XI(e) {
  return xy((0, vy.fromByteArray)(new TextEncoder().encode(e)));
}
Xt.encode = XI;
function YI(e) {
  return new TextDecoder().decode((0, vy.toByteArray)(zh(Ey(e))));
}
Xt.decode = YI;
var Ku = {}, qu = {}, Jo = {};
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.joseToDer = Jo.derToJose = void 0;
const Ay = as, Sy = Xt;
function ef(e) {
  return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
const JI = {
  ES256: ef(256),
  ES384: ef(384),
  ES512: ef(521)
};
function _y(e) {
  const t = JI[e];
  if (t)
    return t;
  throw new Error(`Unknown algorithm "${e}"`);
}
const Gc = 128, ky = 0, QI = 32, eB = 16, tB = 2, Ty = eB | QI | ky << 6, Zc = tB | ky << 6;
function Cy(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, Ay.toByteArray)((0, Sy.pad)(e));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function rB(e, t) {
  const r = Cy(e), n = _y(t), i = n + 1, o = r.length;
  let s = 0;
  if (r[s++] !== Ty)
    throw new Error('Could not find expected "seq"');
  let a = r[s++];
  if (a === (Gc | 1) && (a = r[s++]), o - s < a)
    throw new Error(`"seq" specified length of "${a}", only "${o - s}" remaining`);
  if (r[s++] !== Zc)
    throw new Error('Could not find expected "int" for "r"');
  const c = r[s++];
  if (o - s - 2 < c)
    throw new Error(`"r" specified length of "${c}", only "${o - s - 2}" available`);
  if (i < c)
    throw new Error(`"r" specified length of "${c}", max of "${i}" is acceptable`);
  const u = s;
  if (s += c, r[s++] !== Zc)
    throw new Error('Could not find expected "int" for "s"');
  const f = r[s++];
  if (o - s !== f)
    throw new Error(`"s" specified length of "${f}", expected "${o - s}"`);
  if (i < f)
    throw new Error(`"s" specified length of "${f}", max of "${i}" is acceptable`);
  const l = s;
  if (s += f, s !== o)
    throw new Error(`Expected to consume entire array, but "${o - s}" bytes remain`);
  const h = n - c, m = n - f, y = new Uint8Array(h + c + m + f);
  for (s = 0; s < h; ++s)
    y[s] = 0;
  y.set(r.subarray(u + Math.max(-h, 0), u + c), s), s = n;
  for (const b = s; s < b + m; ++s)
    y[s] = 0;
  return y.set(r.subarray(l + Math.max(-m, 0), l + f), s), (0, Sy.escape)((0, Ay.fromByteArray)(y));
}
Jo.derToJose = rB;
function N1(e, t, r) {
  let n = 0;
  for (; t + n < r && e[t + n] === 0; )
    ++n;
  return e[t + n] >= Gc && --n, n;
}
function nB(e, t) {
  e = Cy(e);
  const r = _y(t), n = e.length;
  if (n !== r * 2)
    throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
  const i = N1(e, 0, r), o = N1(e, r, e.length), s = r - i, a = r - o, c = 2 + s + 1 + 1 + a, u = c < Gc, f = new Uint8Array((u ? 2 : 3) + c);
  let l = 0;
  return f[l++] = Ty, u ? f[l++] = c : (f[l++] = Gc | 1, f[l++] = c & 255), f[l++] = Zc, f[l++] = s, i < 0 ? (f[l++] = 0, f.set(e.subarray(0, r), l), l += r) : (f.set(e.subarray(i, r), l), l += r - i), f[l++] = Zc, f[l++] = a, o < 0 ? (f[l++] = 0, f.set(e.subarray(r), l)) : f.set(e.subarray(r + o), l), f;
}
Jo.joseToDer = nB;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.InvalidTokenError = Hn.MissingParametersError = void 0;
class iB extends Error {
  constructor(t) {
    super(), this.name = "MissingParametersError", this.message = t || "";
  }
}
Hn.MissingParametersError = iB;
class oB extends Error {
  constructor(t) {
    super(), this.name = "InvalidTokenError", this.message = t || "";
  }
}
Hn.InvalidTokenError = oB;
Object.defineProperty(qu, "__esModule", { value: !0 });
qu.SECP256K1Client = void 0;
const sB = vu, aB = Mr, oc = hh, U1 = Jo, F1 = Hn, H1 = Bi;
oc.utils.hmacSha256Sync = (e, ...t) => {
  const r = sB.hmac.create(aB.sha256, e);
  return t.forEach((n) => r.update(n)), r.digest();
};
class Py {
  static derivePublicKey(t, r = !0) {
    return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, H1.bytesToHex)(oc.getPublicKey(t, r));
  }
  static signHash(t, r, n = "jose") {
    if (!t || !r)
      throw new F1.MissingParametersError("a signing input hash and private key are all required");
    const i = oc.signSync(t, r.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (n === "der")
      return (0, H1.bytesToHex)(i);
    if (n === "jose")
      return (0, U1.derToJose)(i, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(t) {
    return (0, U1.joseToDer)(t, "ES256");
  }
  static verifyHash(t, r, n) {
    if (!t || !r || !n)
      throw new F1.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return oc.verify(r, t, n, { strict: !1 });
  }
}
qu.SECP256K1Client = Py;
Py.algorithmName = "ES256K";
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.cryptoClients = e.SECP256K1Client = void 0;
  const t = qu;
  Object.defineProperty(e, "SECP256K1Client", { enumerable: !0, get: function() {
    return t.SECP256K1Client;
  } });
  const r = {
    ES256K: t.SECP256K1Client
  };
  e.cryptoClients = r;
})(Ku);
var co = {}, cB = we && we.__awaiter || function(e, t, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(s) {
      s(o);
    });
  }
  return new (r || (r = Promise))(function(o, s) {
    function a(f) {
      try {
        u(n.next(f));
      } catch (l) {
        s(l);
      }
    }
    function c(f) {
      try {
        u(n.throw(f));
      } catch (l) {
        s(l);
      }
    }
    function u(f) {
      f.done ? o(f.value) : i(f.value).then(a, c);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(co, "__esModule", { value: !0 });
co.hashSha256Async = co.hashSha256 = void 0;
const uB = Mr;
function Iy(e) {
  return (0, uB.sha256)(e);
}
co.hashSha256 = Iy;
function lB(e) {
  return cB(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const r = typeof e == "string" ? new TextEncoder().encode(e) : e, n = yield crypto.subtle.digest("SHA-256", r);
        return new Uint8Array(n);
      } else {
        const r = H2;
        if (!r.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(r.createHash("sha256").update(e).digest());
      }
    } catch (t) {
      return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(Iy(e));
    }
  });
}
co.hashSha256Async = lB;
var fB = we && we.__awaiter || function(e, t, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(s) {
      s(o);
    });
  }
  return new (r || (r = Promise))(function(o, s) {
    function a(f) {
      try {
        u(n.next(f));
      } catch (l) {
        s(l);
      }
    }
    function c(f) {
      try {
        u(n.throw(f));
      } catch (l) {
        s(l);
      }
    }
    function u(f) {
      f.done ? o(f.value) : i(f.value).then(a, c);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.TokenSigner = Yo.createUnsecuredToken = void 0;
const rd = Xt, R1 = Ku, dB = Hn, L1 = co;
function nd(e, t) {
  const r = [], n = rd.encode(JSON.stringify(t));
  r.push(n);
  const i = rd.encode(JSON.stringify(e));
  return r.push(i), r.join(".");
}
function hB(e) {
  return nd(e, { typ: "JWT", alg: "none" }) + ".";
}
Yo.createUnsecuredToken = hB;
class pB {
  constructor(t, r) {
    if (!(t && r))
      throw new dB.MissingParametersError("a signing algorithm and private key are required");
    if (typeof t != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (t = t.toUpperCase(), !R1.cryptoClients.hasOwnProperty(t))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = R1.cryptoClients[t], this.rawPrivateKey = r;
  }
  header(t = {}) {
    const r = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, r, t);
  }
  sign(t, r = !1, n = {}) {
    const i = this.header(n), o = nd(t, i), s = (0, L1.hashSha256)(o);
    return this.createWithSignedHash(t, r, i, o, s);
  }
  signAsync(t, r = !1, n = {}) {
    return fB(this, void 0, void 0, function* () {
      const i = this.header(n), o = nd(t, i), s = yield (0, L1.hashSha256Async)(o);
      return this.createWithSignedHash(t, r, i, o, s);
    });
  }
  createWithSignedHash(t, r, n, i, o) {
    const s = this.cryptoClient.signHash(o, this.rawPrivateKey);
    return r ? {
      header: [rd.encode(JSON.stringify(n))],
      payload: JSON.stringify(t),
      signature: [s]
    } : [i, s].join(".");
  }
}
Yo.TokenSigner = pB;
var Vu = {};
Object.defineProperty(Vu, "__esModule", { value: !0 });
Vu.TokenVerifier = void 0;
const gB = Xt, z1 = Ku, mB = Hn, Va = co;
class bB {
  constructor(t, r) {
    if (!(t && r))
      throw new mB.MissingParametersError("a signing algorithm and public key are required");
    if (typeof t != "string")
      throw "signing algorithm parameter must be a string";
    if (t = t.toUpperCase(), !z1.cryptoClients.hasOwnProperty(t))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = z1.cryptoClients[t], this.rawPublicKey = r;
  }
  verify(t) {
    return typeof t == "string" ? this.verifyCompact(t, !1) : typeof t == "object" ? this.verifyExpanded(t, !1) : !1;
  }
  verifyAsync(t) {
    return typeof t == "string" ? this.verifyCompact(t, !0) : typeof t == "object" ? this.verifyExpanded(t, !0) : Promise.resolve(!1);
  }
  verifyCompact(t, r) {
    const n = t.split("."), i = n[0] + "." + n[1], o = (s) => {
      const a = this.cryptoClient.loadSignature(n[2]);
      return this.cryptoClient.verifyHash(s, a, this.rawPublicKey);
    };
    if (r)
      return (0, Va.hashSha256Async)(i).then((s) => o(s));
    {
      const s = (0, Va.hashSha256)(i);
      return o(s);
    }
  }
  verifyExpanded(t, r) {
    const n = [t.header.join("."), gB.encode(t.payload)].join(".");
    let i = !0;
    const o = (s) => (t.signature.map((a) => {
      const c = this.cryptoClient.loadSignature(a);
      this.cryptoClient.verifyHash(s, c, this.rawPublicKey) || (i = !1);
    }), i);
    if (r)
      return (0, Va.hashSha256Async)(n).then((s) => o(s));
    {
      const s = (0, Va.hashSha256)(n);
      return o(s);
    }
  }
}
Vu.TokenVerifier = bB;
var Wu = {};
Object.defineProperty(Wu, "__esModule", { value: !0 });
Wu.decodeToken = void 0;
const Wa = Xt;
function yB(e) {
  if (typeof e == "string") {
    const t = e.split("."), r = JSON.parse(Wa.decode(t[0])), n = JSON.parse(Wa.decode(t[1])), i = t[2];
    return {
      header: r,
      payload: n,
      signature: i
    };
  } else if (typeof e == "object") {
    if (typeof e.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let t = e.payload;
    e.payload[0] !== "{" && (t = Wa.decode(t));
    const r = [];
    return e.header.map((n) => {
      const i = JSON.parse(Wa.decode(n));
      r.push(i);
    }), {
      header: r,
      payload: JSON.parse(t),
      signature: e.signature
    };
  }
}
Wu.decodeToken = yB;
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(n, i, o, s) {
    s === void 0 && (s = o);
    var a = Object.getOwnPropertyDescriptor(i, o);
    (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return i[o];
    } }), Object.defineProperty(n, s, a);
  } : function(n, i, o, s) {
    s === void 0 && (s = o), n[s] = i[o];
  }), r = we && we.__exportStar || function(n, i) {
    for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Yo, e), r(Vu, e), r(Wu, e), r(Hn, e), r(Ku, e);
})(vr);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var j1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const e = Array(256).fill(-1);
  for (let t = 0; t < j1.length; ++t) e[j1.charCodeAt(t)] = t;
})();
var D1, tf, Ga, jh = (D1 = function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.bech32m = t.bech32 = void 0;
  const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
  for (let l = 0; l < 32; l++) {
    const h = r.charAt(l);
    n[h] = l;
  }
  function i(l) {
    const h = l >> 25;
    return (33554431 & l) << 5 ^ 996825010 & -(h >> 0 & 1) ^ 642813549 & -(h >> 1 & 1) ^ 513874426 & -(h >> 2 & 1) ^ 1027748829 & -(h >> 3 & 1) ^ 705979059 & -(h >> 4 & 1);
  }
  function o(l) {
    let h = 1;
    for (let m = 0; m < l.length; ++m) {
      const y = l.charCodeAt(m);
      if (y < 33 || y > 126) return "Invalid prefix (" + l + ")";
      h = i(h) ^ y >> 5;
    }
    h = i(h);
    for (let m = 0; m < l.length; ++m) {
      const y = l.charCodeAt(m);
      h = i(h) ^ 31 & y;
    }
    return h;
  }
  function s(l, h, m, y) {
    let b = 0, g = 0;
    const v = (1 << m) - 1, _ = [];
    for (let x = 0; x < l.length; ++x) for (b = b << h | l[x], g += h; g >= m; ) g -= m, _.push(b >> g & v);
    if (y) g > 0 && _.push(b << m - g & v);
    else {
      if (g >= h) return "Excess padding";
      if (b << m - g & v) return "Non-zero padding";
    }
    return _;
  }
  function a(l) {
    return s(l, 8, 5, !0);
  }
  function c(l) {
    const h = s(l, 5, 8, !1);
    if (Array.isArray(h)) return h;
  }
  function u(l) {
    const h = s(l, 5, 8, !1);
    if (Array.isArray(h)) return h;
    throw new Error(h);
  }
  function f(l) {
    let h;
    function m(y, b) {
      if (b = b || 90, y.length < 8) return y + " too short";
      if (y.length > b) return "Exceeds length limit";
      const g = y.toLowerCase(), v = y.toUpperCase();
      if (y !== g && y !== v) return "Mixed-case string " + y;
      const _ = (y = g).lastIndexOf("1");
      if (_ === -1) return "No separator character for " + y;
      if (_ === 0) return "Missing prefix for " + y;
      const x = y.slice(0, _), k = y.slice(_ + 1);
      if (k.length < 6) return "Data too short";
      let P = o(x);
      if (typeof P == "string") return P;
      const I = [];
      for (let R = 0; R < k.length; ++R) {
        const j = k.charAt(R), W = n[j];
        if (W === void 0) return "Unknown character " + j;
        P = i(P) ^ W, R + 6 >= k.length || I.push(W);
      }
      return P !== h ? "Invalid checksum for " + y : { prefix: x, words: I };
    }
    return h = l === "bech32" ? 1 : 734539939, { decodeUnsafe: function(y, b) {
      const g = m(y, b);
      if (typeof g == "object") return g;
    }, decode: function(y, b) {
      const g = m(y, b);
      if (typeof g == "object") return g;
      throw new Error(g);
    }, encode: function(y, b, g) {
      if (g = g || 90, y.length + 7 + b.length > g) throw new TypeError("Exceeds length limit");
      let v = o(y = y.toLowerCase());
      if (typeof v == "string") throw new Error(v);
      let _ = y + "1";
      for (let x = 0; x < b.length; ++x) {
        const k = b[x];
        if (k >> 5) throw new Error("Non 5-bit word");
        v = i(v) ^ k, _ += r.charAt(k);
      }
      for (let x = 0; x < 6; ++x) v = i(v);
      v ^= h;
      for (let x = 0; x < 6; ++x) _ += r.charAt(v >> 5 * (5 - x) & 31);
      return _;
    }, toWords: a, fromWordsUnsafe: c, fromWords: u };
  }
  t.bech32 = f("bech32"), t.bech32m = f("bech32m");
}, D1(tf = { exports: {} }, tf.exports), tf.exports);
(Ga = jh) && Ga.__esModule && Object.prototype.hasOwnProperty.call(Ga, "default") && Ga.default;
jh.bech32m;
jh.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var Io, Bo;
(function(e) {
  e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Io || (Io = {})), function(e) {
  e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(Bo || (Bo = {}));
Bo.p2pkh, Io.mainnet, Bo.p2pkh, Io.testnet, Bo.p2sh, Io.mainnet, Bo.p2sh, Io.testnet;
var wB = "accountChange";
ae({
  type: dt(wB)
});
var vB = "networkChange";
ae({
  type: dt(vB)
});
var xB = "disconnect";
ae({
  type: dt(xB)
});
async function Gu(e) {
  var r;
  const t = await (e == null ? void 0 : e()) || ((r = window.XverseProviders) == null ? void 0 : r.BitcoinProvider) || window.BitcoinProvider;
  if (!t)
    throw new Error("No Bitcoin wallet installed");
  return t;
}
var By = /* @__PURE__ */ ((e) => (e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Signet = "Signet", e))(By || {}), Dh = Wr(Du([fe(), un(), go()])), dr = ae({
  jsonrpc: dt("2.0"),
  method: fe(),
  params: Wr(
    Du([
      Vr(Mu()),
      yy({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      go()
    ])
  ),
  id: Dh
}), Ps = /* @__PURE__ */ ((e) => (e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(Ps || {}), Oy = ae({
  jsonrpc: dt("2.0"),
  result: Rh(Mu()),
  id: Dh
}), $y = ae({
  jsonrpc: dt("2.0"),
  error: Rh(Mu()),
  id: Dh
});
Du([
  Oy,
  $y
]);
var Zu = /* @__PURE__ */ ((e) => (e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(Zu || {}), Ny = /* @__PURE__ */ ((e) => (e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(Ny || {}), EB = ae({
  address: fe(),
  publicKey: fe(),
  purpose: ao(Zu),
  addressType: ao(Ny)
}), Uy = async (e) => {
  var n, i;
  const t = await Gu(e.getProvider), { purposes: r } = e.payload;
  if (!r)
    throw new Error("Address purposes are required");
  try {
    const o = vr.createUnsecuredToken(e.payload), s = await t.connect(o);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (o) {
    console.error("[Connect] Error during address request", o), (i = e.onCancel) == null || i.call(e);
  }
}, AB = "stx_getAddresses", SB = mo(
  ae({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: Wr(fe())
  })
);
ae({
  ...dr.entries,
  ...ae({
    method: dt(AB),
    params: SB,
    id: fe()
  }).entries
});
var _B = "stx_signTransaction", kB = ae({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: fe(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: Wr(fe()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: Wr(by())
});
ae({
  ...dr.entries,
  ...ae({
    method: dt(_B),
    params: kB,
    id: fe()
  }).entries
});
var TB = ["software", "ledger"], CB = wy(TB), PB = "getInfo", IB = mo(go());
ae({
  /**
   * Version of the wallet.
   */
  version: fe(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: Wr(Vr(fe())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: Vr(fe())
});
ae({
  ...dr.entries,
  ...ae({
    method: dt(PB),
    params: IB,
    id: fe()
  }).entries
});
var BB = "getAddresses", OB = ae({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: Vr(ao(Zu)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: Wr(fe())
});
ae({
  ...dr.entries,
  ...ae({
    method: dt(BB),
    params: OB,
    id: fe()
  }).entries
});
var $B = "signMessage", va = /* @__PURE__ */ ((e) => (e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(va || {}), NB = ae({
  /**
   * The address used for signing.
   **/
  address: fe(),
  /**
   * The message to sign.
   **/
  message: fe(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: Wr(ao(va))
});
ae({
  /**
   * The signature of the message.
   */
  signature: fe(),
  /**
   * hash of the message.
   */
  messageHash: fe(),
  /**
   * The address used for signing.
   */
  address: fe(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: ao(va)
});
ae({
  ...dr.entries,
  ...ae({
    method: dt($B),
    params: NB,
    id: fe()
  }).entries
});
var UB = "getAccounts", FB = ae({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: Vr(ao(Zu)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: Wr(fe())
});
Vr(
  ae({
    ...EB.entries,
    ...ae({
      walletType: CB
    }).entries
  })
);
ae({
  ...dr.entries,
  ...ae({
    method: dt(UB),
    params: FB,
    id: fe()
  }).entries
});
var HB = "getBalance";
mo(go());
ae({
  ...dr.entries,
  ...ae({
    method: dt(HB),
    id: fe()
  }).entries
});
var RB = "wallet_requestPermissions", LB = Lh();
dt(!0);
ae({
  ...dr.entries,
  ...ae({
    method: dt(RB),
    params: LB,
    id: fe()
  }).entries
});
var zB = "wallet_renouncePermissions", jB = Lh();
dt(!0);
ae({
  ...dr.entries,
  ...ae({
    method: dt(zB),
    params: jB,
    id: fe()
  }).entries
});
var DB = "wallet_getWalletType";
mo(go());
ae({
  ...dr.entries,
  ...ae({
    method: dt(DB),
    id: fe()
  }).entries
});
var MB = "runes_getBalance", KB = mo(go());
ae({
  balances: Vr(
    ae({
      runeName: fe(),
      amount: fe(),
      divisibility: un(),
      symbol: fe(),
      inscriptionId: mo(fe())
    })
  )
});
ae({
  ...dr.entries,
  ...ae({
    method: dt(MB),
    params: KB,
    id: fe()
  }).entries
});
var qB = "runes_transfer", VB = ae({
  recipients: Vr(
    ae({
      runeName: fe(),
      amount: fe(),
      address: fe()
    })
  )
});
ae({
  ...dr.entries,
  ...ae({
    method: dt(qB),
    params: VB,
    id: fe()
  }).entries
});
var WB = "ord_getInscriptions", GB = ae({
  offset: un(),
  limit: un()
});
ae({
  total: un(),
  limit: un(),
  offset: un(),
  inscriptions: Vr(
    ae({
      inscriptionId: fe(),
      inscriptionNumber: fe(),
      address: fe(),
      collectionName: Wr(fe()),
      postage: fe(),
      contentLength: fe(),
      contentType: fe(),
      timestamp: un(),
      offset: un(),
      genesisTransaction: fe(),
      output: fe()
    })
  )
});
ae({
  ...dr.entries,
  ...ae({
    method: dt(WB),
    params: GB,
    id: fe()
  }).entries
});
var ZB = "ord_sendInscriptions", XB = ae({
  transfers: Vr(
    ae({
      address: fe(),
      inscriptionId: fe()
    })
  )
});
ae({
  ...dr.entries,
  ...ae({
    method: dt(ZB),
    params: XB,
    id: fe()
  }).entries
});
var Za = async (e, t, r) => {
  var o;
  let n = ((o = window.XverseProviders) == null ? void 0 : o.BitcoinProvider) || window.BitcoinProvider;
  if (!n)
    throw new Error("no wallet provider was found");
  if (!e)
    throw new Error("A wallet method is required");
  const i = await n.request(e, t);
  return O1($y, i) ? {
    status: "error",
    error: i.error
  } : O1(Oy, i) ? {
    status: "success",
    result: i.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: i
    }
  };
}, YB = async (e) => {
  var i, o;
  const t = await Gu(e.getProvider), { address: r, message: n } = e.payload;
  if (!r)
    throw new Error("An address is required to sign a message");
  if (!n)
    throw new Error("A message to be signed is required");
  try {
    const s = vr.createUnsecuredToken(e.payload), a = await t.signMessage(s);
    (i = e.onFinish) == null || i.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign message request", s), (o = e.onCancel) == null || o.call(e);
  }
}, JB = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
}), QB = async (e) => {
  var s, a;
  const t = await Gu(e.getProvider), { recipients: r, senderAddress: n, network: i, message: o } = e.payload;
  if (!r || r.length === 0)
    throw new Error("At least one recipient is required");
  if (r.some(
    (c) => typeof c.address != "string" || typeof c.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!n)
    throw new Error("The sender address is required");
  try {
    const c = JB(r), u = {
      network: i,
      senderAddress: n,
      message: o,
      recipients: c
    }, f = vr.createUnsecuredToken(u), l = await t.sendBtcTransaction(f);
    (s = e.onFinish) == null || s.call(e, l);
  } catch (c) {
    console.error("[Connect] Error during send BTC transaction request", c), (a = e.onCancel) == null || a.call(e);
  }
}, eO = async (e) => {
  var i, o;
  const t = await Gu(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
  if (!r)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!n)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const s = vr.createUnsecuredToken(e.payload), a = await t.signTransaction(s);
    (i = e.onFinish) == null || i.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign transaction request", s), (o = e.onCancel) == null || o.call(e);
  }
};
let M1 = (e) => e, As = {}, hi = { addEventListener() {
}, removeEventListener() {
} };
function tO() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
tO() && (As = localStorage);
let rO = {
  addEventListener(e, t, r) {
    window.addEventListener("storage", t), window.addEventListener("pageshow", r);
  },
  removeEventListener(e, t, r) {
    window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
  }
};
typeof window < "u" && (hi = rO);
function bo(e, t = {}, r = {}) {
  let n = r.encode || M1, i = r.decode || M1, o = Z1(), s = o.setKey, a = (l, h) => {
    typeof h > "u" ? (r.listen !== !1 && hi.perKey && hi.removeEventListener(e + l, u, f), delete As[e + l]) : (r.listen !== !1 && hi.perKey && !(l in o.value) && hi.addEventListener(e + l, u, f), As[e + l] = n(h));
  };
  o.setKey = (l, h) => {
    a(l, h), s(l, h);
  };
  let c = o.set;
  o.set = function(l) {
    for (let h in l)
      a(h, l[h]);
    for (let h in o.value)
      h in l || a(h, void 0);
    c(l);
  };
  function u(l) {
    l.key ? l.key.startsWith(e) && (l.newValue === null ? s(l.key.slice(e.length), void 0) : s(l.key.slice(e.length), i(l.newValue))) : c({});
  }
  function f() {
    let l = { ...t };
    for (let h in As)
      h.startsWith(e) && (l[h.slice(e.length)] = i(As[h]));
    for (let h in l)
      o.setKey(h, l[h]);
  }
  return W1(o, () => {
    if (f(), r.listen !== !1)
      return hi.addEventListener(e, u, f), () => {
        hi.removeEventListener(e, u, f);
        for (let l in o.value)
          hi.removeEventListener(e + l, u, f);
      };
  }), o;
}
const nO = "XVERSE_CONNECTED_WALLET_STATE";
class iO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bo(nO, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window == null ? void 0 : window.BitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of cr)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey("accounts", [t.address, t.paymentAddress].filter(Boolean));
  }
  watchStateChange(t, r, n) {
    var i, o;
    n && t.provider === mi && (n === "balance" ? this.$valueStore.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : cr.includes(n) && this.$valueStore.setKey(n, ((o = t[n]) == null ? void 0 : o.toString()) ?? ""));
  }
  initialize() {
    lr(this.$store, ["provider"], (t) => {
      t.provider !== mi ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r, n;
      ((r = window == null ? void 0 : window.XverseProviders) == null ? void 0 : r.BitcoinProvider) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [mi]: !0
      }), (n = this.observer) == null || n.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 }));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && Uh(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), ls(n, this.network).then((s) => {
            this.$store.setKey("balance", s);
          });
          return;
        }
      let i = rc(this.network || Ue);
      await Uy({
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: i
          }
        },
        onFinish: (s) => {
          const a = Ph(s.addresses), c = Ih(s.addresses);
          if (!a || !c)
            throw new Error("Could not find the addresses");
          a && c && (this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", c.address), this.$store.setKey("accounts", [
            a.address,
            c.address
          ])), this.$store.setKey("publicKey", String(s.addresses[0].publicKey)), this.$store.setKey("paymentPublicKey", String(s.addresses[1].publicKey));
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${mi} wallet`);
        },
        onError: (s) => {
          throw new Error(`Can't lasereyes to ${mi} wallet`);
        }
      });
    } catch (i) {
      throw i;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Ge, Et, Bt, At].includes(this.network) ? this.network : Ue;
  }
  async sendBTC(t, r) {
    const n = await Za("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    });
    if (n.status === "success")
      return n.result.txid;
    throw n.error.code === Ps.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + n.error.message);
  }
  async signMessage(t, r) {
    const n = r || this.$store.get().paymentAddress, i = await Za("signMessage", {
      address: n,
      message: t,
      protocol: va.BIP322
    });
    if (i.status === "success")
      return i.result.signature;
    throw i.error.code === Ps.USER_REJECTION ? new Error("User rejected the request") : new Error("Error signing message: " + i.error.message);
  }
  async signPsbt(t, r, n, i, o) {
    try {
      const s = Qe.fromBase64(String(n), {
        network: Ot(this.network)
      }), a = this.$store.get().address, c = this.$store.get().paymentAddress, u = s.data.inputs;
      let f = {};
      const l = {
        [a]: []
      }, h = {
        [c]: []
      };
      let m = 0;
      for await (let x of u) {
        if (x.witnessUtxo === void 0)
          h[c].push(Number(m));
        else {
          const { script: k } = x.witnessUtxo, P = sa(k, Ot(this.network));
          P === c ? h[c].push(Number(m)) : P === a && l[a].push(Number(m));
        }
        m++;
      }
      l[a].length > 0 && (f = { ...f, ...l }), h[c].length > 0 && (f = { ...f, ...h });
      let y, b, g, v;
      const _ = await Za("signPsbt", {
        psbt: n,
        broadcast: !!o,
        signInputs: f
      });
      if (_.status === "success")
        v = Qe.fromBase64(_.result.psbt, {
          network: Ot(this.network)
        }), y = _.result.txid;
      else
        throw _.error.code === Ps.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return i && !y ? (v.finalizeAllInputs(), b = v.toHex(), g = v.toBase64()) : (b = v.toHex(), g = v.toBase64()), {
        signedPsbtHex: b,
        signedPsbtBase64: g,
        txId: y
      };
    } catch (s) {
      throw console.error(s), s;
    }
  }
  async getInscriptions(t, r) {
    const o = await Za("ord_getInscriptions", {
      offset: t || 0,
      limit: r || 10
    });
    if (o.status === "success")
      return console.log(o.result), o.result.inscriptions;
    throw console.error(o.error), new Error("Error getting inscriptions");
  }
}
class oO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window.wizz;
  }
  get network() {
    return this.$network.get();
  }
  handleNetworkChanged(t) {
    this.parent.connect(Ki);
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && this.$store.setKey("accounts", t);
  }
  initialize() {
    lr(this.$store, ["provider"], (t) => {
      t.provider === Ki ? this.addLibraryListeners() : this.removeLibraryListeners();
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Ki]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 }));
  }
  removeLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.removeListener("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.removeListener("accountsChanged", this.handleAccountsChanged.bind(this));
  }
  addLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.on("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeLibraryListeners();
  }
  async connect() {
    if (!this.library)
      throw LI;
    const t = await this.library.requestAccounts();
    if (!t)
      throw new Error("No accounts found");
    const r = await this.library.getPublicKey();
    if (!r)
      throw new Error("No public key found");
    this.$store.setKey("accounts", t), this.$store.setKey("address", t[0]), this.$store.setKey("paymentAddress", t[0]), this.$store.setKey("publicKey", r), this.$store.setKey("paymentPublicKey", r), this.$store.setKey("provider", Ki), await this.getNetwork().then((n) => {
      var i;
      n && ((i = this.config) == null ? void 0 : i.network) !== n && this.parent.switchNetwork(n);
    }), this.$store.setKey("connected", !0);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getNetwork());
    return t ? d1(t) : void 0;
  }
  async switchNetwork(t) {
    var n;
    if (t === At || t === fr)
      return await this.library.switchNetwork(Cs);
    const r = d1(t);
    await ((n = this.library) == null ? void 0 : n.switchNetwork(r)), this.$network.set(t), await this.parent.getBalance();
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, i = r || 10;
    return await this.library.getInscriptions(n, i);
  }
  async sendBTC(t, r) {
    var i;
    const n = await ((i = this.library) == null ? void 0 : i.sendBitcoin(t, r));
    if (n)
      return n;
    throw new Error("Error sending BTC");
  }
  async signMessage(t) {
    var r;
    return await ((r = this.library) == null ? void 0 : r.signMessage(t));
  }
  async signPsbt(t, r, n, i, o) {
    var u;
    const s = await ((u = this.library) == null ? void 0 : u.signPsbt(r, {
      autoFinalized: i,
      broadcast: !1
    })), a = Qe.fromHex(s);
    let c;
    return i && o && (c = await this.pushPsbt(s)), {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: c
    };
  }
}
const sO = "OYL_CONNECTED_WALLET_STATE";
class aO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bo(sO, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window.oyl;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of cr)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var i, o;
    n && t.provider === ji && (n === "balance" ? this.$valueStore.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : cr.includes(n) && this.$valueStore.setKey(n, ((o = t[n]) == null ? void 0 : o.toString()) ?? ""));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      (window == null ? void 0 : window.oyl) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [ji]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      t.provider !== ji ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Oyl isn't installed");
    if (Nh(this.network))
      throw new Error(`${this.network} is not supported by Oyl`);
    const { nativeSegwit: r, taproot: n } = await this.library.getAddresses();
    if (!r || !n)
      throw new Error("No accounts found");
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", r.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), this.$store.setKey("provider", ji), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await Oh(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), i = await this.signPsbt("", n, "", !0, !0);
    if (!i)
      throw new Error("Error sending BTC");
    return i.txId;
  }
  async signMessage(t, r) {
    const n = r || this.$store.get().paymentAddress;
    return (await this.library.signMessage({
      address: n,
      message: t
    })).signature;
  }
  async signPsbt(t, r, n, i, o) {
    const { psbt: s, txid: a } = await this.library.signPsbt({
      psbt: r,
      finalize: i,
      broadcast: o
    }), c = Qe.fromHex(s);
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: a
    };
  }
  async pushPsbt(t) {
    return (await this.library.pushPsbt({ psbt: t })).txid;
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    const { total: t } = await this.library.getBalance();
    return this.$store.setKey("balance", t), t;
  }
  async getInscriptions(t, r) {
    const n = t || 0, i = r || 10;
    return await this.library.getInscriptions(n, i);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork() {
    throw td;
  }
}
const cO = "LEATHER_CONNECTED_WALLET_STATE";
class uO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bo(cO, {
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window.LeatherProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of cr)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var i, o;
    n && t.provider === Di && (n === "balance" ? this.$valueStore.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : cr.includes(n) && this.$valueStore.setKey(n, ((o = t[n]) == null ? void 0 : o.toString()) ?? ""));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      (window == null ? void 0 : window.LeatherProvider) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Di]: !0
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      t.provider !== Di ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    var c;
    if (!this.library)
      throw new Error("Leather isn't installed");
    const r = await this.library.request("getAddresses");
    if (!r)
      throw new Error("No accounts found");
    const i = r.result.addresses, o = i.map((u) => u.address), s = i.find((u) => u.type === Ss), a = i.find((u) => u.type === nf);
    if (!(s != null && s.publicKey) || !(a != null && a.publicKey))
      throw new Error("No accounts found");
    if ((c = String(s == null ? void 0 : s.address)) != null && c.startsWith("tb") && this.network !== Ge && this.network !== Et && this.network !== Bt)
      throw new Error(`Please switch networks to ${this.network} in the wallet settings.`);
    this.$store.setKey("accounts", o), this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", a.address), this.$store.setKey("publicKey", s.publicKey), this.$store.setKey("paymentPublicKey", a.publicKey), this.$store.setKey("provider", Di), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    var i, o;
    const n = await ((i = this.library) == null ? void 0 : i.request("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    }));
    if ((o = n == null ? void 0 : n.result) != null && o.txid)
      return n.result.txid;
    throw n.error.code === Ps.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + n.error.message);
  }
  async signMessage(t, r) {
    var o;
    const n = r === this.$store.get().address ? Ss : nf;
    if (r !== this.$store.get().address && r !== this.$store.get().paymentAddress)
      throw new Error("Invalid address to sign message");
    const i = await this.library.request("signMessage", {
      message: t,
      paymentType: n
    });
    return (o = i == null ? void 0 : i.result) == null ? void 0 : o.signature;
  }
  async signPsbt(t, r, n, i, o) {
    const s = {
      hex: r,
      broadcast: !1,
      network: this.network
    }, u = (await this.library.request("signPsbt", s)).result.hex, f = Qe.fromHex(String(u));
    if (i && o) {
      const l = f.finalizeAllInputs(), h = await this.pushPsbt(l.toHex());
      return {
        signedPsbtHex: f.toHex(),
        signedPsbtBase64: f.toBase64(),
        txId: h
      };
    } else if (i) {
      const l = f.finalizeAllInputs();
      return {
        signedPsbtHex: l.toHex(),
        signedPsbtBase64: l.toBase64(),
        txId: void 0
      };
    } else
      return {
        signedPsbtHex: f.toHex(),
        signedPsbtBase64: f.toBase64(),
        txId: void 0
      };
  }
  async getPublicKey() {
    const { result: t } = await this.library.request("getAddresses"), n = t.addresses.find((i) => i.type === Ss);
    if (!(n != null && n.publicKey))
      throw new Error("No accounts found");
    return n.publicKey;
  }
  async getBalance() {
    const t = await ls(this.$store.get().paymentAddress, this.network);
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    const { result: t } = await this.library.request("getAddresses"), n = t.addresses.map((i) => i.address);
    return this.$store.setKey("accounts", n), n;
  }
}
var Is = {}, Fy = {}, Xr = {}, Hy = {};
Object.defineProperty(Hy, "__esModule", { value: !0 });
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var f = Object.getOwnPropertyDescriptor(a, c);
    (!f || ("get" in f ? !a.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, f);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = we && we.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
  async function n(s) {
    var c, u;
    if (s) {
      const f = await s();
      if (f)
        return f;
    }
    const a = window.OrangeBitcoinProvider || ((c = window.OrangecryptoProviders) == null ? void 0 : c.BitcoinProvider) || ((u = window.OrangeWalletProviders) == null ? void 0 : u.OrangeBitcoinProvider);
    if (!a)
      throw new Error("No Orange Bitcoin wallet installed");
    return a;
  }
  e.getProviderOrThrow = n;
  function i() {
    return window.btc_providers || (window.btc_providers = []), window.btc_providers;
  }
  e.getProviders = i;
  function o(s) {
    var a;
    if (Array.isArray(window.btc_providers)) {
      const c = window.btc_providers.find((u) => u.id === s);
      return (a = c == null ? void 0 : c.id) == null ? void 0 : a.split(".").reduce((u, f) => u == null ? void 0 : u[f], window);
    } else {
      console.log("window.btc_providers is not defined or not an array");
      return;
    }
  }
  e.getProviderById = o, r(Hy, e);
})(Xr);
var Ry = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.AddressType = e.AddressPurpose = void 0, function(t) {
    t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
  }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
    t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
  }(e.AddressType || (e.AddressType = {}));
})(Ry);
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var f = Object.getOwnPropertyDescriptor(a, c);
    (!f || ("get" in f ? !a.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, f);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = we && we.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getAddress = void 0;
  const n = vr, i = Xr, o = async (s) => {
    var u, f;
    const a = await (0, i.getProviderOrThrow)(s.getProvider), { purposes: c } = s.payload;
    if (!c)
      throw new Error("Address purposes are required");
    try {
      const l = (0, n.createUnsecuredToken)(s.payload), h = await a.connect(l);
      (u = s.onFinish) == null || u.call(s, h);
    } catch (l) {
      console.error("[Connect] Error during address request", l), (f = s.onCancel) == null || f.call(s);
    }
  };
  e.getAddress = o, r(Ry, e);
})(Fy);
var Ly = {}, zy = {}, jy = {};
Object.defineProperty(jy, "__esModule", { value: !0 });
var Dy = {};
Object.defineProperty(Dy, "__esModule", { value: !0 });
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(n, i, o, s) {
    s === void 0 && (s = o);
    var a = Object.getOwnPropertyDescriptor(i, o);
    (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return i[o];
    } }), Object.defineProperty(n, s, a);
  } : function(n, i, o, s) {
    s === void 0 && (s = o), n[s] = i[o];
  }), r = we && we.__exportStar || function(n, i) {
    for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(jy, e), r(Dy, e);
})(zy);
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var f = Object.getOwnPropertyDescriptor(a, c);
    (!f || ("get" in f ? !a.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, f);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = we && we.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.request = void 0;
  const n = Xr, i = async (s, a, c) => {
    var l;
    let u = ((l = window.OrangecryptoProviders) == null ? void 0 : l.BitcoinProvider) || window.OrangeBitcoinProvider;
    if (c && (u = await (0, n.getProviderById)(c)), !u)
      throw new Error("no wallet provider was found");
    if (!s)
      throw new Error("A wallet method is required");
    const f = await u.request(s, a);
    return o(f) ? {
      status: "success",
      result: f.result
    } : {
      status: "error",
      error: f.error
    };
  };
  e.request = i;
  const o = (s) => Object.hasOwn(s, "result") && !!s.result;
  r(zy, e);
})(Ly);
var My = {}, Ky = {};
Object.defineProperty(Ky, "__esModule", { value: !0 });
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(a, c, u, f) {
    f === void 0 && (f = u);
    var l = Object.getOwnPropertyDescriptor(c, u);
    (!l || ("get" in l ? !c.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return c[u];
    } }), Object.defineProperty(a, f, l);
  } : function(a, c, u, f) {
    f === void 0 && (f = u), a[f] = c[u];
  }), r = we && we.__exportStar || function(a, c) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(c, u) && t(c, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getCapabilities = void 0;
  const n = vr, i = Xr, o = (a, c) => {
    const u = (l) => !(!a[l] || c && !c.has(l)), f = {
      request: u("request"),
      connect: u("connect"),
      signMessage: u("signMessage"),
      signTransaction: u("signTransaction"),
      sendBtcTransaction: u("sendBtcTransaction"),
      createInscription: u("createInscription"),
      createRepeatInscriptions: u("createRepeatInscriptions"),
      signMultipleTransactions: u("signMultipleTransactions")
    };
    return Object.entries(f).reduce((l, [h, m]) => m ? [...l, h] : l, []);
  }, s = async (a) => {
    var f, l, h;
    const c = await (0, i.getProviderOrThrow)(a.getProvider), u = (0, n.createUnsecuredToken)(a.payload);
    if (c.getCapabilities)
      try {
        const m = await c.getCapabilities(u);
        (f = a.onFinish) == null || f.call(a, o(c, new Set(m)));
      } catch (m) {
        console.error("[Connect] Error during capabilities request", m);
      }
    try {
      const m = o(c);
      (l = a.onFinish) == null || l.call(a, m);
    } catch (m) {
      console.error("[Connect] Error during capabilities request", m), (h = a.onCancel) == null || h.call(a);
    }
  };
  e.getCapabilities = s, r(Ky, e);
})(My);
var qy = {}, Xu = {}, xa = {};
Object.defineProperty(xa, "__esModule", { value: !0 });
xa.validateInscriptionPayload = void 0;
const lO = 4e5, fO = 6e4, dO = (e) => {
  const { contentType: t, content: r, payloadType: n, network: i, appFeeAddress: o, appFee: s } = e;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t))
    throw new Error("Invalid content type detected");
  if (!r || r.length === 0)
    throw new Error("Empty content not allowed");
  if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT")
    throw new Error("Empty invalid payloadType specified");
  if (r.length > (i.type === "Mainnet" ? lO : fO))
    throw new Error("Content too large");
  if (((o == null ? void 0 : o.length) ?? 0) > 0 && (s ?? 0) <= 0)
    throw new Error("Invalid combination of app fee address and fee provided");
};
xa.validateInscriptionPayload = dO;
Object.defineProperty(Xu, "__esModule", { value: !0 });
Xu.createInscription = void 0;
const hO = vr, pO = Xr, gO = xa, mO = async (e) => {
  var n, i;
  const { getProvider: t } = e, r = await (0, pO.getProviderOrThrow)(t);
  (0, gO.validateInscriptionPayload)(e.payload);
  try {
    const o = (0, hO.createUnsecuredToken)(e.payload), s = await r.createInscription(o);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (o) {
    console.error("[Connect] Error during create inscription", o), (i = e.onCancel) == null || i.call(e);
  }
};
Xu.createInscription = mO;
var Yu = {};
Object.defineProperty(Yu, "__esModule", { value: !0 });
Yu.createRepeatInscriptions = void 0;
const bO = Xr, yO = vr, wO = xa, vO = async (e) => {
  var n, i;
  const { getProvider: t } = e, r = await (0, bO.getProviderOrThrow)(t);
  (0, wO.validateInscriptionPayload)(e.payload);
  try {
    const o = (0, yO.createUnsecuredToken)(e.payload), s = await r.createRepeatInscriptions(o);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (o) {
    console.error("[Connect] Error during create repeat inscriptions", o), (i = e.onCancel) == null || i.call(e);
  }
};
Yu.createRepeatInscriptions = vO;
var Vy = {};
Object.defineProperty(Vy, "__esModule", { value: !0 });
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(n, i, o, s) {
    s === void 0 && (s = o);
    var a = Object.getOwnPropertyDescriptor(i, o);
    (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return i[o];
    } }), Object.defineProperty(n, s, a);
  } : function(n, i, o, s) {
    s === void 0 && (s = o), n[s] = i[o];
  }), r = we && we.__exportStar || function(n, i) {
    for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Xu, e), r(Yu, e), r(Vy, e);
})(qy);
var Wy = {}, Gy = {};
Object.defineProperty(Gy, "__esModule", { value: !0 });
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var f = Object.getOwnPropertyDescriptor(a, c);
    (!f || ("get" in f ? !a.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, f);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = we && we.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.signMessage = void 0;
  const n = vr, i = Xr, o = async (s) => {
    var f, l;
    const a = await (0, i.getProviderOrThrow)(s.getProvider), { address: c, message: u } = s.payload;
    if (!c)
      throw new Error("An address is required to sign a message");
    if (!u)
      throw new Error("A message to be signed is required");
    try {
      const h = (0, n.createUnsecuredToken)(s.payload), m = await a.signMessage(h);
      (f = s.onFinish) == null || f.call(s, m);
    } catch (h) {
      console.error("[Connect] Error during sign message request", h), (l = s.onCancel) == null || l.call(s);
    }
  };
  e.signMessage = o, r(Gy, e);
})(Wy);
var Zy = {}, Ju = {};
Object.defineProperty(Ju, "__esModule", { value: !0 });
Ju.sendBtcTransaction = void 0;
const xO = vr, EO = Xr, AO = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
}), SO = async (e) => {
  var s, a;
  const t = await (0, EO.getProviderOrThrow)(e.getProvider), { recipients: r, senderAddress: n, network: i, message: o } = e.payload;
  if (!r || r.length === 0)
    throw new Error("At least one recipient is required");
  if (r.some((c) => typeof c.address != "string" || typeof c.amountSats != "bigint"))
    throw new Error("Incorrect recipient format");
  if (!n)
    throw new Error("The sender address is required");
  try {
    const c = AO(r), u = {
      network: i,
      senderAddress: n,
      message: o,
      recipients: c
    }, f = (0, xO.createUnsecuredToken)(u), l = await t.sendBtcTransaction(f);
    (s = e.onFinish) == null || s.call(e, l);
  } catch (c) {
    console.error("[Connect] Error during send BTC transaction request", c), (a = e.onCancel) == null || a.call(e);
  }
};
Ju.sendBtcTransaction = SO;
var Qu = {};
Object.defineProperty(Qu, "__esModule", { value: !0 });
Qu.signTransaction = void 0;
const _O = vr, kO = Xr, TO = async (e) => {
  var i, o;
  const t = await (0, kO.getProviderOrThrow)(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
  if (!r)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!n)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const s = (0, _O.createUnsecuredToken)(e.payload), a = await t.signTransaction(s);
    (i = e.onFinish) == null || i.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign transaction request", s), (o = e.onCancel) == null || o.call(e);
  }
};
Qu.signTransaction = TO;
var el = {};
Object.defineProperty(el, "__esModule", { value: !0 });
el.signMultipleTransactions = void 0;
const CO = vr, PO = Xr, IO = async (e) => {
  var n, i;
  const t = await (0, PO.getProviderOrThrow)(e.getProvider), { psbts: r } = e.payload;
  if (!r || !r.length)
    throw new Error("psbts array is required");
  if (r.length > 100)
    throw new Error("psbts array must contain less than 100 psbts");
  try {
    const o = (0, CO.createUnsecuredToken)(e.payload), s = await t.signMultipleTransactions(o);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (o) {
    console.error("[Connect] Error during sign Multiple transactions request", o), (i = e.onCancel) == null || i.call(e);
  }
};
el.signMultipleTransactions = IO;
var Xy = {};
Object.defineProperty(Xy, "__esModule", { value: !0 });
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(n, i, o, s) {
    s === void 0 && (s = o);
    var a = Object.getOwnPropertyDescriptor(i, o);
    (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return i[o];
    } }), Object.defineProperty(n, s, a);
  } : function(n, i, o, s) {
    s === void 0 && (s = o), n[s] = i[o];
  }), r = we && we.__exportStar || function(n, i) {
    for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Ju, e), r(Qu, e), r(el, e), r(Xy, e);
})(Zy);
var Yy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
    t.Mainnet = "Mainnet", t.Testnet = "Testnet";
  }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
    t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
  }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(Yy);
(function(e) {
  var t = we && we.__createBinding || (Object.create ? function(n, i, o, s) {
    s === void 0 && (s = o);
    var a = Object.getOwnPropertyDescriptor(i, o);
    (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return i[o];
    } }), Object.defineProperty(n, s, a);
  } : function(n, i, o, s) {
    s === void 0 && (s = o), n[s] = i[o];
  }), r = we && we.__exportStar || function(n, i) {
    for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(i, o) && t(i, n, o);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), r(Fy, e), r(Ly, e), r(My, e), r(qy, e), r(Wy, e), r(Xr, e), r(Zy, e), r(Yy, e);
})(Is);
const BO = /* @__PURE__ */ vw(Is), { signMessage: OO, sendBtcTransaction: $O } = BO, NO = "ORANGE_CONNECTED_WALLET_STATE";
class UO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bo(NO, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : t.OrangeBitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of cr)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var i, o;
    n && t.provider === yi && (n === "balance" ? this.$valueStore.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : cr.includes(n) && this.$valueStore.setKey(n, ((o = t[n]) == null ? void 0 : o.toString()) ?? ""));
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var n;
      (window == null ? void 0 : window.OrangeBitcoinProvider) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [yi]: !0
      }), (n = this.observer) == null || n.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (r) => {
      r.provider !== yi ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r) {
        this.restorePersistedValues(), ls(n, this.network).then((s) => {
          this.$store.setKey("balance", s);
        });
        return;
      }
      let i = Dl(this.network || Ue);
      const o = {
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Address for receiving Ordinals and payments",
          network: {
            type: i
          }
        },
        onFinish: (s) => {
          const a = Ph(s.addresses), c = Ih(s.addresses);
          if (!a || !(c != null && c.address))
            throw new Error("Could not find addresses");
          a && c && (this.$store.setKey("provider", yi), this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", c.address)), this.$store.setKey("publicKey", String(a.publicKey)), this.$store.setKey("paymentPublicKey", String(c.publicKey));
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${yi} wallet`);
        }
      };
      await Is.getAddress(o), this.$store.setKey("connected", !0);
    } catch (i) {
      throw i;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Ge, Et, Bt, At].includes(this.network) ? this.network : Ue;
  }
  async sendBTC(t, r) {
    let n = "";
    const i = {
      payload: {
        network: {
          type: Dl(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (o) => {
        n = o;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await $O(i), n;
  }
  async signMessage(t, r) {
    let n = "";
    const i = r || this.$store.get().paymentAddress, o = {
      payload: {
        network: {
          type: Dl(this.network)
        },
        address: i,
        message: t
      },
      onFinish: (s) => {
        n = s;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await OO(o), n;
  }
  async signPsbt(t, r, n, i, o) {
    try {
      const s = Qe.fromBase64(String(n), {
        network: Ot(this.network)
      }), a = this.$store.get().address, c = this.$store.get().paymentAddress, u = s.data.inputs;
      let f = {};
      const l = {
        [a]: []
      }, h = {
        [c]: []
      };
      let m = 0;
      for await (let x of u) {
        if (x.witnessUtxo === void 0)
          h[c].push(Number(m));
        else {
          const { script: k } = x.witnessUtxo, P = sa(k, Ot(this.network));
          P === c ? h[c].push(Number(m)) : P === a && l[a].push(Number(m));
        }
        m++;
      }
      l[a].length > 0 && (f = { ...f, ...l }), h[c].length > 0 && (f = { ...f, ...h });
      let y, b, g, v;
      const _ = await Is.request("signPsbt", {
        psbt: n,
        broadcast: !!o,
        signInputs: f
      });
      if (_.status === "success")
        v = Qe.fromBase64(_.result.psbt, {
          network: Ot(this.network)
        }), y = _.result.txid;
      else
        throw _.error.code === Is.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return i && !y ? (v.finalizeAllInputs(), b = v.toHex(), g = v.toBase64()) : (b = v.toHex(), g = v.toBase64()), {
        signedPsbtHex: b,
        signedPsbtBase64: g,
        txId: y
      };
    } catch (s) {
      throw console.error(s), s;
    }
  }
}
const FO = "OKX_CONNECTED_WALLET_STATE";
class HO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bo(FO, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    var r, n;
    let t;
    return this.network === Ge || this.network === Et || this.network === Bt || this.network === At ? t = (r = window == null ? void 0 : window.okxwallet) == null ? void 0 : r.bitcoinTestnet : (this.network === Ue || this.network === fr) && (t = (n = window == null ? void 0 : window.okxwallet) == null ? void 0 : n.bitcoin), t;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of cr)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var i, o;
    n && t.provider === Mi && (n === "balance" ? this.$valueStore.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : cr.includes(n) && this.$valueStore.setKey(n, ((o = t[n]) == null ? void 0 : o.toString()) ?? ""));
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var n;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Mi]: !0
      }), (n = this.observer) == null || n.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (r) => {
      r.provider !== Mi ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const r = await this.library.connect();
      if (!r)
        throw new Error("No accounts found");
      this.$store.setKey("address", r.address), this.$store.setKey("paymentAddress", r.address), this.$store.setKey("publicKey", r.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), this.$store.setKey("accounts", [r]), this.$store.setKey("provider", Mi), this.$store.setKey("connected", !0);
    } catch (r) {
      throw r;
    }
  }
  async requestAccounts() {
    const t = this.library, r = this.network;
    return r === Ge || r === Et || r === At ? await t.connect() : await t.requestAccounts();
  }
  async getNetwork() {
    const { address: t } = this.$store.get(), r = this.network;
    if (t.slice(0, 1) === "t")
      return r === Ge ? Ge : r === Et ? Et : r === Bt ? Bt : r === At ? At : Ge;
    const n = await this.library.getNetwork();
    return VT(n);
  }
  async getPublicKey() {
    const t = this.library;
    return await (t == null ? void 0 : t.getPublicKey());
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async sendBTC(t, r) {
    const i = await this.library.sendBitcoin(t, r);
    if (!i)
      throw new Error("Transaction failed");
    return i;
  }
  async signMessage(t, r) {
    const n = this.library;
    return await (n == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, i, o) {
    const a = await this.library.signPsbt(r, {
      autoFinalized: i
    }), c = Qe.fromHex(a);
    if (i && o) {
      const u = await this.pushPsbt(a);
      return {
        signedPsbtHex: c.toHex(),
        signedPsbtBase64: c.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: void 0
    };
  }
}
const RO = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
class LO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bo(RO, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.magicEden) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of cr) {
      if (r === "balance") {
        this.$store.setKey(r, BigInt(t[r]));
        continue;
      }
      this.$store.setKey(r, t[r]);
    }
    this.$store.setKey("accounts", [t.address, t.paymentAddress].filter(Boolean));
  }
  watchStateChange(t, r, n) {
    var i, o, s;
    t.provider === kn && (n ? n === "balance" ? this.$valueStore.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : cr.includes(n) && this.$valueStore.setKey(n, ((o = t[n]) == null ? void 0 : o.toString()) ?? "") : this.$valueStore.set({
      address: t.address,
      paymentAddress: t.paymentAddress,
      paymentPublicKey: t.paymentPublicKey,
      publicKey: t.publicKey,
      balance: ((s = t.balance) == null ? void 0 : s.toString()) ?? ""
    }));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r, n;
      ((r = window == null ? void 0 : window.magicEden) == null ? void 0 : r.bitcoin) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [kn]: !0
      }), (n = this.observer) == null || n.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      t.provider !== kn ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && Uh(this.network))
          this.disconnect();
        else {
          ls(n, this.network).then((s) => {
            this.$store.setKey("balance", s);
          }), this.restorePersistedValues();
          return;
        }
      if (Nh(this.network))
        throw new Error(`${this.network} is not supported by ${kn}`);
      let i = rc(this.network || Ue);
      await Uy({
        getProvider: async () => this.library,
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: i
          }
        },
        onFinish: (s) => {
          const a = Ph(s.addresses), c = Ih(s.addresses);
          if (!a || !c)
            throw new Error("No address found");
          a && c && (this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", c.address), this.$store.setKey("accounts", [
            a.address,
            c.address
          ])), this.$store.setKey("publicKey", String(s.addresses[0].publicKey)), this.$store.setKey("paymentPublicKey", String(s.addresses[1].publicKey));
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${kn} wallet`);
        },
        onError: (s) => {
          throw new Error(`Can't lasereyes to ${kn} wallet`);
        }
      });
    } catch (i) {
      throw i;
    }
  }
  async sendBTC(t, r) {
    let n;
    if (await QB({
      getProvider: async () => this.library,
      payload: {
        network: {
          type: rc(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (i) => {
        n = i;
      },
      onCancel: () => {
        throw console.error("Request canceled"), new Error("User canceled the request");
      }
    }), !n)
      throw new Error("Error sending BTC");
    return n.txid;
  }
  async signMessage(t, r) {
    try {
      const n = r || this.$store.get().paymentAddress;
      let i = "";
      return await YB({
        getProvider: async () => this.library,
        payload: {
          network: {
            type: By.Mainnet
          },
          address: n,
          message: t,
          protocol: va.BIP322
        },
        onFinish: (o) => {
          i = o;
        },
        onCancel: () => {
          throw console.error("Request canceled"), new Error("User canceled the request");
        }
      }), i;
    } catch (n) {
      throw n;
    }
  }
  async signPsbt(t, r, n, i, o) {
    console.log("signPsbt", n, i, o);
    const { address: s, paymentAddress: a } = this.$store.get(), c = Qe.fromBase64(String(n), {
      network: Ot(this.network)
    }), u = c.data.inputs, f = [], l = {
      address: s,
      signingIndexes: []
    }, h = {
      address: a,
      signingIndexes: []
    };
    let m = 0;
    for await (let k of u) {
      const { script: P } = k.witnessUtxo, I = sa(P, Ot(this.network));
      I === a ? (h.signingIndexes.push(Number(m)), k.sighashType && (console.log("Updating sigHash for paymentsAddressData"), h.sigHash = k.sighashType)) : I === s && (l.signingIndexes.push(Number(m)), k.sighashType && (console.log("Updating sigHash for ordinalAddressData"), l.sigHash = k.sighashType)), m++;
    }
    l.signingIndexes.length > 0 && f.push(l), h.signingIndexes.length > 0 && f.push(h);
    let y, b, g, v;
    const _ = rc(this.network), x = {
      getProvider: async () => this.library,
      payload: {
        network: {
          type: _
        },
        message: "Sign Transaction",
        psbtBase64: c.toBase64(),
        broadcast: o,
        inputsToSign: f
      },
      onFinish: async (k) => {
        k.psbtBase64 && (v = Qe.fromBase64(String(k.psbtBase64), {
          network: Ot(this.network)
        }), b = v.toHex(), g = v.toBase64());
      },
      onCancel: () => {
        throw console.log("Canceled"), new Error("User canceled the request");
      },
      onError: (k) => {
        throw console.log("error", k), k;
      }
    };
    if (await eO(x), !v)
      throw new Error("signature failed");
    return i || o ? (v.finalizeAllInputs(), b = v.extractTransaction().toHex(), o ? (y = await this.pushPsbt(b), {
      signedPsbtHex: b,
      signedPsbtBase64: g,
      txId: y
    }) : {
      signedPsbtHex: b,
      signedPsbtBase64: g,
      txId: y
    }) : {
      signedPsbtHex: b,
      signedPsbtBase64: g,
      txId: y
    };
  }
}
class zO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.phantom) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [bi]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      t.provider === bi && this.library.requestAccounts().then((r) => {
        this.handleAccountsChanged(r);
      });
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(bi) : this.parent.disconnect());
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Phantom isn't installed");
    if (Nh(this.network))
      throw new Error(`${this.network} is not supported by ${bi}`);
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    this.$store.setKey("accounts", r);
    const n = r.find((o) => o.purpose === "ordinals"), i = r.find((o) => o.purpose === "payment");
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", i.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", i.publicKey), this.$store.setKey("provider", bi), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    return this.$store.get().address.slice(0, 1) === "t" ? Ge : Ue;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await Oh(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), i = await this.signPsbt("", n, "", !0, !0);
    if (!i)
      throw new Error("Error sending BTC");
    return i.txId;
  }
  async signMessage(t, r) {
    var c;
    const n = new TextEncoder().encode(t), i = new Uint8Array(n), o = r || this.$store.get().paymentAddress, s = await ((c = this.library) == null ? void 0 : c.signMessage(o, i)), a = String.fromCharCode(...s.signature);
    return btoa(a);
  }
  async signPsbt(t, r, n, i, o) {
    const { address: s, paymentAddress: a } = this.$store.get(), u = Qe.fromHex(String(r), {
      network: Ot(this.network)
    }).data.inputs, f = [], l = {
      address: s,
      signingIndexes: []
    }, h = {
      address: a,
      signingIndexes: []
    };
    let m = 0;
    for await (let g of u) {
      const { script: v } = g.witnessUtxo, _ = sa(v, Ot(this.network));
      _ === a ? h.signingIndexes.push(Number(m)) : _ === s && l.signingIndexes.push(Number(m)), m++;
    }
    l.signingIndexes.length > 0 && f.push(l), h.signingIndexes.length > 0 && f.push(h);
    const y = await this.library.signPSBT(qI(r), {
      inputsToSign: f
    }), b = Qe.fromBuffer(y);
    if (i && f.forEach((g) => {
      g.signingIndexes.forEach((v) => {
        b.finalizeInput(v);
      });
    }), o) {
      const g = await this.pushPsbt(b.toHex());
      return {
        signedPsbtHex: b.toHex(),
        signedPsbtBase64: b.toBase64(),
        txId: g
      };
    }
    return {
      signedPsbtHex: b.toHex(),
      signedPsbtBase64: b.toBase64(),
      txId: void 0
    };
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
}
class jO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window == null ? void 0 : window.opnet;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [wi]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      if (t.provider !== wi) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(wi) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = Kc(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(wi);
  }
  async connect(t) {
    if (!this.library)
      throw new Error("OP_NET isn't installed");
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    const n = await this.library.getPublicKey();
    if (!n)
      throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", wi), await this.getNetwork().then((i) => {
      var o;
      ((o = this.config) == null ? void 0 : o.network) !== i && this.switchNetwork(i);
    }), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getChain());
    return t ? Kc(t.enum) : this.network;
  }
  async sendBTC(t, r) {
    var i;
    const n = await ((i = this.library) == null ? void 0 : i.sendBitcoin(t, r));
    if (!n)
      throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, i, o) {
    var c;
    const s = await ((c = this.library) == null ? void 0 : c.signPsbt(r, {
      autoFinalized: i
    })), a = Qe.fromHex(s);
    if (i && o) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: a.toHex(),
        signedPsbtBase64: a.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var n;
    const r = rb(t);
    await ((n = this.library) == null ? void 0 : n.switchChain(r)), this.$network.set(t);
  }
}
const Xa = {};
function xs(e) {
  if (Xa[e])
    return console.warn(`Multiple requests for "${e}" detected`), Xa[e];
  const t = new Promise((r) => {
    const n = console.log;
    console.log = (...i) => {
      i.length > 0 && typeof i[0] == "string" && (console.log = n, Xa[e] = void 0, r(i[0]));
    }, n(`Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`);
  });
  return Xa[e] = t, t;
}
class DO {
  async requestAccounts() {
    const t = await xs("address");
    if (!t)
      throw new Error("No address provided");
    const r = await xs("paymentAddress");
    if (!r)
      throw new Error("No payment address provided");
    return [t, r];
  }
  async signMessage(t) {
    return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await xs("message to sign");
  }
  async signPsbt(t) {
    return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await xs("signed psbt hex");
  }
  async getPublicKey() {
    const t = await xs("publicKey");
    if (!t)
      throw new Error("No public key provided");
    return t;
  }
  // TODO: Implement network switching between mainnet and testnet
  async getNetwork() {
    return "mainnet";
  }
  async switchNetwork(t) {
  }
}
const MO = "SPARROW_CONNECTED_WALLET_STATE";
class KO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bo(MO, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window == null ? void 0 : window.SparrowWalletProvider;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library || (window.SparrowWalletProvider = new DO()), this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [vi]: !0
      }), (t = this.observer) == null || t.disconnect();
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      t.provider !== vi ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  watchStateChange(t, r, n) {
    var i, o;
    n && t.provider === vi && (n === "balance" ? this.$valueStore.setKey("balance", ((i = t.balance) == null ? void 0 : i.toString()) ?? "") : cr.includes(n) && this.$valueStore.setKey(n, ((o = t[n]) == null ? void 0 : o.toString()) ?? ""));
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of cr)
      this.$store.setKey(r, t[r]);
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const { address: r, paymentAddress: n } = this.$valueStore.get();
      if (r && n)
        if (r.startsWith("tb1") && Uh(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), this.$store.setKey("provider", vi), this.$store.setKey("connected", !0);
          return;
        }
      if (!this.library)
        throw new Error("Sparrow wallet isn't supported");
      const i = await this.library.requestAccounts();
      if (!i)
        throw new Error("No accounts found");
      await this.getNetwork().then((s) => {
        this.network !== s && this.switchNetwork(this.network);
      });
      const o = await this.library.getPublicKey();
      if (!o)
        throw new Error("No public key found");
      this.$store.setKey("accounts", i), this.$store.setKey("address", i[0]), this.$store.setKey("paymentAddress", i[1]), this.$store.setKey("publicKey", o), this.$store.setKey("paymentPublicKey", o);
    } catch (r) {
      this.disconnect(), console.error("Error during connect:", r);
    }
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtBase64: n } = await Oh(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), i = await this.library.signPsbt(n);
    if (!i)
      throw new Error("No signed PSBT provided");
    const o = await this.pushPsbt(i);
    if (!o)
      throw new Error("send failed, no txid returned");
    return o;
  }
  async signMessage(t, r) {
    return await this.library.signMessage(t);
  }
  async signPsbt(t, r, n, i, o) {
    const s = Qe.fromBase64(n), a = await this.library.signPsbt(n);
    if (i && o) {
      const c = await this.pushPsbt(a);
      return {
        signedPsbtHex: a,
        signedPsbtBase64: s.toBase64(),
        txId: c
      };
    }
    return {
      signedPsbtHex: a,
      signedPsbtBase64: s.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    const t = await this.library.getPublicKey();
    return this.$store.setKey("publicKey", t), t;
  }
  async getBalance() {
    const t = await ls(this.$store.get().paymentAddress, this.network);
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    return await this.connect(vi), this.$store.get().accounts;
  }
}
class qO extends Br {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  get library() {
    return window.glittr;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Ri]: !0
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: !0, subtree: !0 })), lr(this.$store, ["provider"], (t) => {
      if (t.provider !== Ri) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Ri) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = f1(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(Ri);
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Glittr Wallet isn't installed");
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    await this.getNetwork().then((i) => {
      this.network !== i && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n)
      throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", Ri), this.$store.setKey("connected", !0);
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getChain());
    return t ? f1(t.enum) : this.network;
  }
  async sendBTC(t, r) {
    var i;
    const n = await ((i = this.library) == null ? void 0 : i.sendBitcoin(t, r));
    if (!n)
      throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, i, o) {
    var c;
    const s = await ((c = this.library) == null ? void 0 : c.signPsbt(r, {
      autoFinalized: i
    })), a = Qe.fromHex(s);
    if (i && o) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: a.toHex(),
        signedPsbtBase64: a.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, i = r || 10;
    return await this.library.getInscriptions(n, i);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var n;
    const r = KT(t);
    await ((n = this.library) == null ? void 0 : n.switchChain(r)), this.$network.set(t);
  }
}
class VO {
  dispose() {
    this.disposed = !0, Object.values(this.$providerMap).forEach((t) => t == null ? void 0 : t.dispose());
  }
  constructor(t, r) {
    Object.defineProperty(this, "config", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "$store", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$network", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "$providerMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this.$store = t.$store, this.$network = t.$network, G1(this.$store), this.$providerMap = {
      [Di]: new uO(t, this, r),
      [kn]: new LO(t, this, r),
      [Mi]: new HO(t, this, r),
      [wi]: new jO(t, this, r),
      [yi]: new UO(t, this, r),
      [ji]: new aO(t, this, r),
      [bi]: new zO(t, this, r),
      [vi]: new KO(t, this, r),
      [gi]: new zI(t, this, r),
      [mi]: new iO(t, this, r),
      [Ki]: new oO(t, this, r),
      [Ri]: new qO(t, this, r)
    };
  }
  initialize() {
    this.$network.listen(this.watchNetworkChange.bind(this)), lr(this.$store, ["isInitializing"], (t, r) => {
      if (!this.disposed && t.isInitializing !== r.isInitializing)
        return this.handleIsInitializingChanged(t.isInitializing);
    }), this.config && this.config.network && (this.$network.set(this.config.network), this.getNetwork().then((t) => {
      try {
        this.config.network !== t && this.switchNetwork(this.config.network);
      } catch {
        this.disconnect();
      }
    })), MI(() => this.$store.setKey("isInitializing", !1));
  }
  handleIsInitializingChanged(t) {
    if (typeof window < "u" && typeof localStorage < "u" && !t) {
      const r = localStorage == null ? void 0 : localStorage.getItem(il);
      r && this.connect(r);
    }
  }
  async connect(t) {
    if (this.disposed) {
      console.warn("Client disposed, cannot connect");
      return;
    }
    this.$store.setKey("isConnecting", !0);
    try {
      if (localStorage == null || localStorage.setItem(il, t), !this.$providerMap[t])
        throw new Error("Unsupported wallet provider");
      const r = this.$providerMap[t];
      await (r == null ? void 0 : r.connect(t)), this.$store.setKey("connected", !0), this.$store.setKey("provider", t);
    } catch (r) {
      throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", !1), this.disconnect(), r;
    } finally {
      this.$store.setKey("isConnecting", !1);
    }
  }
  async requestAccounts() {
    var t;
    if (!this.$store.get().provider)
      throw new Error("No wallet provider connected");
    try {
      return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.requestAccounts());
    } catch (r) {
      throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : r;
    }
  }
  disconnect() {
    this.$store.set({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      balance: void 0,
      accounts: [],
      connected: !1,
      isConnecting: !1,
      isInitializing: !1,
      hasProvider: this.$store.get().hasProvider
    }), localStorage == null || localStorage.removeItem(il);
  }
  async switchNetwork(t) {
    var r;
    try {
      this.$store.get().provider && await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.switchNetwork(t));
    } catch (n) {
      throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error("The connected wallet doesn't support programmatic network changes..")) : n;
    }
  }
  watchNetworkChange() {
    this.$store.setKey("balance", void 0);
  }
  async getNetwork() {
    var t;
    return this.$store.get().provider && this.$providerMap[this.$store.get().provider] ? await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getNetwork()) : this.$network.get();
  }
  async sendBTC(t, r) {
    var n;
    if (r <= 0)
      throw new Error("Amount must be greater than 0");
    if (!Number.isInteger(r))
      throw new Error("Amount must be an integer");
    if (!this.$store.get().provider)
      throw new Error("No wallet connected");
    if (this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.sendBTC(t, r));
      } catch (i) {
        throw i instanceof Error && i.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending BTC...") : i;
      }
  }
  async signMessage(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.signMessage(t, r));
      } catch (i) {
        throw i instanceof Error && i.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support message signing...") : i;
      }
  }
  async signPsbt(t, r = !1, n = !1) {
    var s;
    let i, o;
    if (!t)
      throw new Error("No PSBT provided");
    if (DI(t))
      o = Qe.fromHex(t).toBase64(), i = t;
    else if (jI(t))
      o = t, i = Qe.fromBase64(t).toHex();
    else
      throw new Error("Invalid PSBT format");
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((s = this.$providerMap[this.$store.get().provider]) == null ? void 0 : s.signPsbt(t, i, o, r, n));
      } catch (a) {
        throw a instanceof Error && a.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : a;
      }
    else
      throw new Error("No wallet provider connected");
  }
  async pushPsbt(t) {
    var r;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.pushPsbt(t));
      } catch (n) {
        throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : n;
      }
  }
  async inscribe(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.inscribe(t, r));
      } catch (i) {
        throw i instanceof Error && i.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support inscribing...") : i;
      }
  }
  async getPublicKey() {
    var t;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getPublicKey());
      } catch (r) {
        throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : r;
      }
  }
  async getBalance() {
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        const t = await this.$providerMap[this.$store.get().provider].getBalance();
        return this.$store.setKey("balance", BigInt(t)), t;
      } catch (t) {
        throw t instanceof Error && t.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : t;
      }
  }
  async getInscriptions(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.getInscriptions(t, r));
      } catch (i) {
        throw i instanceof Error && i.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : i;
      }
  }
}
const { $store: WO, $network: GO } = gy(), kr = {
  connect: async () => {
  },
  disconnect: () => {
  },
  getBalance: async () => "",
  getInscriptions: async () => [],
  getNetwork: async () => "",
  getPublicKey: async () => "",
  pushPsbt: async () => "",
  signMessage: async () => "",
  requestAccounts: async () => [],
  sendBTC: async () => "",
  signPsbt: async () => ({
    signedPsbtBase64: "",
    signedPsbtHex: ""
  }),
  switchNetwork: async () => {
  },
  inscribe: async () => ""
}, Jy = r5({
  $store: WO,
  $network: GO,
  client: null,
  methods: kr
});
function ZO(e, t = {}) {
  let r = rr(
    (i) => t.keys ? lr(e, t.keys, i) : e.listen(i),
    [t.keys, e]
  ), n = e.get.bind(e);
  return n5(r, n, n);
}
function K1(e, t) {
  return Object.keys(e).every(function(r) {
    return Object.prototype.hasOwnProperty.call(t, r) && (t[r] === e[r] || typeof e[r] == "number" && typeof t[r] == "number" && isNaN(t[r]) && isNaN(e[r]));
  });
}
function XO(e, t) {
  return typeof e == "object" && typeof t == "object" ? K1(e, t) && K1(t, e) : e === t;
}
function LN(e) {
  const { $network: t, $store: r, methods: n } = i5(Jy), i = Ya(() => {
    const o = h5([r, t], (s, a) => {
      const c = {
        paymentAddress: s.paymentAddress,
        address: s.address,
        publicKey: s.publicKey,
        paymentPublicKey: s.paymentPublicKey,
        library: {},
        network: a,
        accounts: s.accounts,
        balance: Number(s.balance),
        connected: s.connected,
        isConnecting: s.isConnecting,
        isInitializing: s.isInitializing,
        provider: s.provider,
        hasLeather: s.hasProvider.leather ?? !1,
        hasMagicEden: s.hasProvider["magic-eden"] ?? !1,
        hasOkx: s.hasProvider.okx ?? !1,
        hasOyl: s.hasProvider.oyl ?? !1,
        hasOrange: s.hasProvider.orange ?? !1,
        hasOpNet: s.hasProvider.op_net ?? !1,
        hasPhantom: s.hasProvider.phantom ?? !1,
        hasUnisat: s.hasProvider.unisat ?? !1,
        hasSparrow: s.hasProvider.sparrow ?? !1,
        hasWizz: s.hasProvider.wizz ?? !1,
        hasXverse: s.hasProvider.xverse ?? !1,
        hasGlittr: s.hasProvider.glittr ?? !1,
        ...n
      };
      return typeof e == "function" ? e(c) : c;
    });
    return G1(o), l5(o, ({ oldValue: s, abort: a }) => {
      XO(s, o.value) && a();
    }), o;
  }, [t, r, e, n]);
  return ZO(i);
}
function zN({
  config: e,
  children: t
}) {
  const r = Ya(() => gy(), []), n = Ya(
    () => KI(e ?? { network: Ue }),
    [e]
  ), [i, o] = o5(null);
  s5(() => {
    const k = new VO(r, n);
    return o(() => k), k.initialize(), () => k.dispose();
  }, [n, r]);
  const s = rr(
    async (k) => await (i == null ? void 0 : i.connect(k)),
    [i]
  ), a = rr(() => i == null ? void 0 : i.disconnect(), [i]), c = rr(
    async () => {
      var k;
      return ((k = await ((i == null ? void 0 : i.getBalance()) ?? kr.getBalance())) == null ? void 0 : k.toString()) ?? "";
    },
    [i]
  ), u = rr(
    async (k, P) => await (i == null ? void 0 : i.getInscriptions(k, P)) ?? kr.getInscriptions(),
    [i]
  ), f = rr(
    () => (i == null ? void 0 : i.getNetwork()) ?? kr.getNetwork(),
    [i]
  ), l = rr(
    async () => await (i == null ? void 0 : i.getPublicKey()) ?? kr.getPublicKey(),
    [i]
  ), h = rr(
    (k) => (i == null ? void 0 : i.pushPsbt(k)) ?? kr.pushPsbt(),
    [i]
  ), m = rr(
    async (k, P) => await (i == null ? void 0 : i.signMessage(k, P)) ?? kr.signMessage(),
    [i]
  ), y = rr(
    async () => await (i == null ? void 0 : i.requestAccounts()) ?? kr.requestAccounts(),
    [i]
  ), b = rr(
    async (k, P) => await (i == null ? void 0 : i.sendBTC.call(i, k, P)) ?? kr.sendBTC(),
    [i]
  ), g = rr(
    async (k, P, I) => await (i == null ? void 0 : i.signPsbt.call(i, k, P, I)) ?? kr.signPsbt(),
    [i]
  ), v = rr(
    async (k) => await (i == null ? void 0 : i.switchNetwork.call(i, k)),
    [i]
  ), _ = rr(
    async (k, P) => await (i == null ? void 0 : i.inscribe.call(i, k, P)) ?? kr.inscribe(),
    [i]
  ), x = Ya(() => i ? {
    connect: s,
    disconnect: a,
    getBalance: c,
    getInscriptions: u,
    getNetwork: f,
    getPublicKey: l,
    pushPsbt: h,
    signMessage: m,
    requestAccounts: y,
    sendBTC: b,
    signPsbt: g,
    switchNetwork: v,
    inscribe: _
  } : kr, [
    i,
    s,
    a,
    c,
    u,
    f,
    l,
    _,
    h,
    y,
    b,
    m,
    g,
    v
  ]);
  return /* @__PURE__ */ S(
    Jy.Provider,
    {
      value: {
        $store: r.$store,
        $network: r.$network,
        client: i,
        methods: x
      },
      children: t
    }
  );
}
const YO = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ S(
        "rect",
        {
          width: "42",
          height: "42",
          rx: "10",
          fill: "#090A0C",
          style: { fill: "#090A0C", fillOpacity: 1 }
        }
      ),
      /* @__PURE__ */ S(
        "path",
        {
          d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
          fill: "white",
          style: { fill: "white", fillOpacity: 1 }
        }
      )
    ]
  }
) : /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ S(
        "rect",
        {
          width: "42",
          height: "42",
          rx: "10",
          fill: "white",
          style: { fill: "white", fillOpacity: 1 }
        }
      ),
      /* @__PURE__ */ S(
        "path",
        {
          d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
          fill: "#090A0C",
          style: { fill: "#090A0C", fillOpacity: 1 }
        }
      )
    ]
  }
), q1 = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ S("rect", { width: "128", height: "128", rx: "26.8387", fill: "#12100F" }),
      /* @__PURE__ */ S(
        "path",
        {
          d: "M74.9171 52.7114C82.4766 51.5408 93.4087 43.5804 93.4087 37.3761C93.4087 35.5031 91.8968 34.2154 89.6871 34.2154C85.5004 34.2154 78.4061 40.5368 74.9171 52.7114ZM39.911 83.4991C30.0256 83.4991 29.2115 93.3324 39.0969 93.3324C43.5163 93.3324 48.8661 91.5764 51.6573 88.4157C47.5868 84.9038 44.2141 83.4991 39.911 83.4991ZM102.829 79.2848C103.41 95.7907 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.0249C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8463 40.0273 72.8463C45.3771 72.8463 49.9128 74.2511 55.7277 77.88L59.5656 64.4177C43.7489 60.0864 35.8405 47.9118 43.6326 30.4693H56.1929C49.215 42.0586 53.9832 51.6578 62.822 52.7114C67.5903 35.7372 77.8246 22.509 91.4316 22.509C99.1074 22.509 105.155 27.5428 105.155 36.6737C105.155 51.3066 86.0819 63.2471 71.6607 64.4177L65.7295 85.3721C72.4748 93.2153 91.199 100.824 91.199 79.2848H102.829Z",
          fill: "#F5F1ED"
        }
      )
    ]
  }
) : /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ S("rect", { width: "128", height: "128", rx: "26.8387", fill: "#F5F1ED" }),
      /* @__PURE__ */ S(
        "path",
        {
          d: "M74.9171 52.7115C82.4766 51.5409 93.4087 43.5806 93.4087 37.3762C93.4087 35.5032 91.8968 34.2155 89.6871 34.2155C85.5004 34.2155 78.4061 40.5369 74.9171 52.7115ZM39.911 83.4992C30.0256 83.4992 29.2115 93.3325 39.0969 93.3325C43.5163 93.3325 48.8661 91.5766 51.6573 88.4159C47.5868 84.904 44.2141 83.4992 39.911 83.4992ZM102.829 79.2849C103.41 95.7908 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.025C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8464 40.0273 72.8464C45.3771 72.8464 49.9128 74.2512 55.7277 77.8801L59.5656 64.4179C43.7489 60.0865 35.8405 47.9119 43.6326 30.4695H56.1929C49.215 42.0587 53.9832 51.6579 62.822 52.7115C67.5903 35.7373 77.8246 22.5092 91.4316 22.5092C99.1074 22.5092 105.155 27.5429 105.155 36.6738C105.155 51.3068 86.0819 63.2472 71.6607 64.4179L65.7295 85.3722C72.4748 93.2155 91.199 100.825 91.199 79.2849H102.829Z",
          fill: "#12100F"
        }
      )
    ]
  }
), JO = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Ne("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#AB9FF2",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#FFFDF8",
            fillRule: "evenodd",
            d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
            clipRule: "evenodd"
          }
        )
      ] }),
      /* @__PURE__ */ S("defs", { children: /* @__PURE__ */ S("clipPath", { id: "a", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }) })
    ]
  }
) : /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Ne("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#FFFDF8",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#AB9FF2",
            fillRule: "evenodd",
            d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
            clipRule: "evenodd"
          }
        )
      ] }),
      /* @__PURE__ */ S("defs", { children: /* @__PURE__ */ S("clipPath", { id: "a", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }) })
    ]
  }
), QO = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      /* @__PURE__ */ Ne("g", { clipPath: "url(#clip0_3_53)", children: [
        /* @__PURE__ */ S(
          "path",
          {
            d: "M32 0H10C4.47715 0 0 4.47715 0 10V32C0 37.5228 4.47715 42 10 42H32C37.5228 42 42 37.5228 42 32V10C42 4.47715 37.5228 0 32 0Z",
            fill: "#181818"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            d: "M32 31.6745V27.6829C32 27.5233 31.9203 27.3636 31.8406 27.2438L14.8225 10.1597C14.7029 10.0399 14.5435 10 14.3841 10H10.3986C10.1993 10 10.0399 10.1597 10.0399 10.3592V14.0715C10.0399 14.2311 10.1196 14.3908 10.1993 14.5105L16.2971 20.6177C16.4565 20.7774 16.4565 20.977 16.2971 21.1366L10.1196 27.3237C10.0399 27.4035 10 27.4834 10 27.5632V31.6346C10 31.8342 10.1594 31.9939 10.3587 31.9939H17.0544C17.2536 31.9939 17.413 31.8342 17.413 31.6346V29.2396C17.413 29.1598 17.4529 29.0401 17.5326 29.0002L20.8406 25.6871C21 25.5275 21.1993 25.5275 21.3587 25.6871L27.4964 31.8342C27.6159 31.954 27.7753 31.9939 27.9348 31.9939H31.6413C31.8406 32.0337 32 31.8741 32 31.6745Z",
            fill: "white"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            d: "M23.3406 15.0793H26.5592C26.7507 15.0793 26.9039 15.2333 26.9039 15.4257V18.658C26.9039 18.9658 27.2871 19.1197 27.4788 18.8888L31.8851 14.4637C31.9617 14.3867 32 14.3097 32 14.2328V10.3463C32 10.1539 31.8468 10 31.6552 10H27.7469C27.6703 10 27.5554 10.0385 27.5171 10.1154L23.1107 14.5021C22.8808 14.6945 23.0341 15.0793 23.3406 15.0793Z",
            fill: "#EE7A30"
          }
        )
      ] }),
      /* @__PURE__ */ S("defs", { children: /* @__PURE__ */ S("clipPath", { id: "clip0_3_53", children: /* @__PURE__ */ S("rect", { width: "42", height: "42", fill: "white" }) }) })
    ]
  }
), e$ = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Ne("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            fill: "url(#b)",
            d: "m25.517 9.483 5.759 5.611c.49.477.731.959.724 1.445-.008.486-.219.929-.631 1.33-.431.421-.897.634-1.395.644-.497.007-.992-.228-1.482-.705l-5.89-5.738c-.669-.652-1.315-1.114-1.936-1.385a2.873 2.873 0 0 0-1.96-.127c-.685.185-1.42.662-2.21 1.428-1.086 1.06-1.605 2.054-1.552 2.983.053.929.593 1.893 1.617 2.89l5.938 5.786c.496.482.74.964.732 1.443-.008.48-.22.923-.64 1.332-.419.408-.88.62-1.382.638-.502.016-1.001-.217-1.495-.7l-5.76-5.61c-.936-.912-1.613-1.776-2.029-2.59-.416-.815-.572-1.737-.464-2.765.097-.88.384-1.732.863-2.558.477-.827 1.161-1.671 2.048-2.537C15.43 9.268 16.438 8.48 17.4 7.93c.96-.55 1.889-.854 2.786-.917.899-.064 1.784.112 2.66.527.876.415 1.765 1.061 2.67 1.943h.002Z"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            fill: "url(#c)",
            d: "m16.482 32.123-5.758-5.611c-.49-.479-.731-.959-.724-1.445.008-.486.219-.929.631-1.33.431-.421.897-.634 1.395-.644.498-.007.992.227 1.482.705l5.888 5.738c.671.652 1.315 1.114 1.936 1.385.622.27 1.276.312 1.962.127.685-.185 1.42-.662 2.21-1.43 1.086-1.06 1.605-2.054 1.552-2.983-.053-.929-.593-1.893-1.617-2.891l-3.164-3.056c-.496-.482-.74-.964-.732-1.443.008-.48.22-.923.64-1.332.419-.408.88-.62 1.382-.638.502-.016 1.002.217 1.496.7l2.983 2.88c.936.912 1.613 1.775 2.03 2.59.415.815.571 1.736.463 2.764a6.477 6.477 0 0 1-.863 2.559c-.477.826-1.16 1.67-2.048 2.536-1.057 1.03-2.066 1.819-3.027 2.368-.962.55-1.89.856-2.79.92-.898.063-1.784-.113-2.66-.527-.876-.415-1.765-1.062-2.67-1.944l.003.002Z"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            fill: "url(#d)",
            d: "M20.073 17.645c1.168 0 2.115-.93 2.115-2.08 0-1.149-.947-2.08-2.115-2.08-1.168 0-2.115.931-2.115 2.08 0 1.15.947 2.08 2.115 2.08Z"
          }
        )
      ] }),
      /* @__PURE__ */ Ne("defs", { children: [
        /* @__PURE__ */ Ne(
          "linearGradient",
          {
            id: "b",
            x1: 30.329,
            x2: 12.579,
            y1: 12.752,
            y2: 20.772,
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ S("stop", { stopColor: "#201C1B" }),
              /* @__PURE__ */ S("stop", { offset: 0.36, stopColor: "#77390D" }),
              /* @__PURE__ */ S("stop", { offset: 0.67, stopColor: "#EA8101" }),
              /* @__PURE__ */ S("stop", { offset: 1, stopColor: "#F4B852" })
            ]
          }
        ),
        /* @__PURE__ */ Ne(
          "linearGradient",
          {
            id: "c",
            x1: 12.163,
            x2: 32.789,
            y1: 29.085,
            y2: 22.844,
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ S("stop", { stopColor: "#1F1D1C" }),
              /* @__PURE__ */ S("stop", { offset: 0.37, stopColor: "#77390D" }),
              /* @__PURE__ */ S("stop", { offset: 0.67, stopColor: "#EA8101" }),
              /* @__PURE__ */ S("stop", { offset: 1, stopColor: "#F4FB52" })
            ]
          }
        ),
        /* @__PURE__ */ Ne(
          "radialGradient",
          {
            id: "d",
            cx: 0,
            cy: 0,
            r: 1,
            gradientTransform: "matrix(2.11484 0 0 2.08019 20.073 15.567)",
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ S("stop", { stopColor: "#F4B852" }),
              /* @__PURE__ */ S("stop", { offset: 0.33, stopColor: "#EA8101" }),
              /* @__PURE__ */ S("stop", { offset: 0.64, stopColor: "#77390D" }),
              /* @__PURE__ */ S("stop", { offset: 1, stopColor: "#211C1D" })
            ]
          }
        ),
        /* @__PURE__ */ S("clipPath", { id: "a", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
), t$ = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Ne("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ Ne("g", { fillRule: "evenodd", clipPath: "url(#b)", clipRule: "evenodd", children: [
          /* @__PURE__ */ S(
            "path",
            {
              fill: "#FFD815",
              d: "m26.507 17.74-1.623-1.623-1.624 1.623 1.623 1.623 1.624 1.624 1.623-1.624-1.623-1.623Z"
            }
          ),
          /* @__PURE__ */ S(
            "path",
            {
              fill: "#FF9813",
              d: "m26.507 8-1.624 1.623 1.624 1.624 1.623-1.624L26.507 8ZM33 14.493l-1.623-1.623-1.624 1.623 1.624 1.623L33 14.493ZM23.26 27.48l1.623 1.623 1.624-1.623-1.623-1.624-1.624 1.624ZM11.897 16.117l1.623 1.623 1.623-1.623-1.623-1.624-1.623 1.624ZM20.014 8 18.39 9.623l1.624 1.624 1.623-1.624L20.014 8ZM13.52 11.247l1.624 1.623 1.623-1.623-1.623-1.624-1.624 1.624ZM31.377 19.363l-1.624 1.623 1.624 1.624L33 20.987l-1.623-1.624ZM28.13 25.856l1.623 1.624 1.624-1.624-1.624-1.623-1.623 1.623Z"
            }
          ),
          /* @__PURE__ */ S(
            "path",
            {
              fill: "#5B5B72",
              d: "m26.507 20.986-1.624-1.623-1.623 1.623-1.623-1.623-1.623-1.623 1.623-1.624-1.623-1.623-1.624-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623 1.623-.812-.811-1.623 1.623 1.623 1.623-1.623 1.624-1.543 1.542-1.542 1.543-1.624 1.623L8 31.377 9.623 33l1.624-1.623 1.623-1.624 1.543-1.542.08-.08 1.462-1.463.08-.08 1.544-1.543 1.623 1.623 1.623-1.623-.811-.812 1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
            }
          ),
          /* @__PURE__ */ S(
            "path",
            {
              fill: "#FF9813",
              d: "m26.507 14.493-1.624-1.623-1.623 1.623-1.623-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623 1.623 1.623 1.623-1.623-1.623-1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ Ne("defs", { children: [
        /* @__PURE__ */ S("clipPath", { id: "a", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }),
        /* @__PURE__ */ S("clipPath", { id: "b", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M8 8h25v25H8z" }) })
      ] })
    ]
  }
), r$ = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Ne("g", { clipPath: "url(#a)", children: [
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ S("g", { fill: "#fff", clipPath: "url(#b)", children: /* @__PURE__ */ S("path", { d: "M24.578 17.052h-6.787a.523.523 0 0 0-.52.52v6.788c0 .286.235.52.52.52h6.787c.286 0 .521-.234.521-.52v-6.787a.523.523 0 0 0-.52-.521ZM16.733 9.223H9.946a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.285 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM32.424 9.223h-6.787a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.286 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM16.733 24.898H9.946a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.285 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52ZM32.424 24.898h-6.787a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.286 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52Z" }) })
      ] }),
      /* @__PURE__ */ Ne("defs", { children: [
        /* @__PURE__ */ S("clipPath", { id: "a", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }),
        /* @__PURE__ */ S("clipPath", { id: "b", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
), n$ = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    className: r,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      /* @__PURE__ */ Ne("g", { clipPath: "url(#clip0_17_93)", children: [
        /* @__PURE__ */ S(
          "path",
          {
            fill: "#070C34",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            fill: "url(#paint0_linear_17_93)",
            d: "m27.666 16.837 1.874 2.177c.215.245.404.446.483.562.56.55.874 1.293.874 2.07-.053.915-.657 1.54-1.213 2.205l-1.311 1.521-.685.79a.184.184 0 0 0 .046.281c.033.02.07.028.107.026h6.835c1.045 0 2.36.868 2.283 2.184 0 .597-.247 1.171-.68 1.595a2.36 2.36 0 0 1-1.637.664H23.936c-.704 0-2.598.076-3.128-1.521a1.841 1.841 0 0 1-.043-1.035 4.5 4.5 0 0 1 .72-1.404 65.543 65.543 0 0 1 1.695-2.343c.741-1.002 1.503-1.971 2.251-2.992a.19.19 0 0 0 .04-.116.19.19 0 0 0-.04-.116l-2.72-3.156a.192.192 0 0 0-.153-.073.192.192 0 0 0-.152.073c-.728.96-3.917 5.203-4.598 6.063-.68.86-2.355.907-3.283 0l-4.255-4.161a.197.197 0 0 0-.1-.053.195.195 0 0 0-.2.082.192.192 0 0 0-.032.106v8a2.678 2.678 0 0 1-.494 1.594c-.33.466-.804.823-1.352 1.014a2.375 2.375 0 0 1-2.111-.293 2.271 2.271 0 0 1-.72-.805A2.22 2.22 0 0 1 5 28.736V14.349a2.416 2.416 0 0 1 .548-1.422c.33-.406.785-.7 1.298-.841a2.632 2.632 0 0 1 2.502.664l6.54 6.381c.019.02.043.034.07.043a.197.197 0 0 0 .161-.013.188.188 0 0 0 .061-.054l4.646-6.27c.215-.254.485-.46.79-.601.304-.142.636-.217.976-.221H34.68c.33 0 .657.07.959.204a2.31 2.31 0 0 1 1.263 1.409c.096.309.122.633.079.952a2.288 2.288 0 0 1-.813 1.42c-.439.364-.996.56-1.572.551h-6.768a.188.188 0 0 0-.163.099.187.187 0 0 0-.022.095c0 .032.013.065.032.093h-.008Z"
          }
        )
      ] }),
      /* @__PURE__ */ Ne("defs", { children: [
        /* @__PURE__ */ Ne(
          "linearGradient",
          {
            id: "paint0_linear_17_93",
            x1: "-0.315",
            x2: "35.366",
            y1: "9.343",
            y2: "30.176",
            gradientUnits: "userSpaceOnUse",
            children: [
              /* @__PURE__ */ S("stop", { offset: "0.23", stopColor: "#FF0074" }),
              /* @__PURE__ */ S("stop", { offset: "0.26", stopColor: "#FF0068" }),
              /* @__PURE__ */ S("stop", { offset: "0.32", stopColor: "#FF0048" }),
              /* @__PURE__ */ S("stop", { offset: "0.39", stopColor: "#FF0015" }),
              /* @__PURE__ */ S("stop", { offset: "0.41", stopColor: "#FF0009" }),
              /* @__PURE__ */ S("stop", { offset: "0.43", stopColor: "#FF0908" }),
              /* @__PURE__ */ S("stop", { offset: "0.54", stopColor: "#FF4003" }),
              /* @__PURE__ */ S("stop", { offset: "0.62", stopColor: "#FF6201" }),
              /* @__PURE__ */ S("stop", { offset: "0.66", stopColor: "#FF6F00" }),
              /* @__PURE__ */ S("stop", { offset: "0.72", stopColor: "#FF8700" }),
              /* @__PURE__ */ S("stop", { offset: "0.83", stopColor: "#FFAB00" }),
              /* @__PURE__ */ S("stop", { offset: "0.92", stopColor: "#FFC100" }),
              /* @__PURE__ */ S("stop", { offset: "0.98", stopColor: "#FFCA00" })
            ]
          }
        ),
        /* @__PURE__ */ S("clipPath", { id: "clip0_17_93", children: /* @__PURE__ */ S("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
), i$ = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    ...n,
    children: [
      /* @__PURE__ */ Ne("defs", { children: [
        /* @__PURE__ */ S("clipPath", { id: "clip1", children: /* @__PURE__ */ S("path", { d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 " }) }),
        /* @__PURE__ */ Ne(
          "radialGradient",
          {
            id: "radial0",
            gradientUnits: "userSpaceOnUse",
            cx: 0,
            cy: 0,
            fx: 0,
            fy: 0,
            r: 1,
            gradientTransform: "matrix(0.000000000000001938,31.643555,-31.643555,0.000000000000001938,21,5.578125)",
            children: [
              /* @__PURE__ */ S(
                "stop",
                {
                  offset: 0,
                  style: {
                    stopColor: "rgb(5.098039%,5.490196%,7.058824%)",
                    stopOpacity: 1
                  }
                }
              ),
              /* @__PURE__ */ S(
                "stop",
                {
                  offset: 1,
                  style: {
                    stopColor: "rgb(0%,0%,0%)",
                    stopOpacity: 1
                  }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image91",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAIOUlEQVRYhe2YW4jcVx3HP+fyv8785z+XveUm040xaWraitaHFmkfpKCI6LMgLWq9IUUpiA9CwRdfiqBPtbbWy5MKhRbxnuZFRUSMxhBr2nR6Sdrd2ezOzs7szP9yzvFhdus2TEzWJD7l+zQw53/Oh+/vcjg/uKmbuqmbuqlrkbhB+8o2+CFUUoj6EEWgAQ/Ah2IMpQcbS5C9CkMg/3+Cyjb4GpIE4gLSCsROkyKJLCilAEHpWwbS0M8LNvrQG0KvAxngbiTo2wBzaISahpGknqTxxGE1RLoPSCkWcIwN7p9hYX/54Asc0YKLOuPNElYL6P0J+jcCVLQhKCFOoQo0Ak3NSGaUZPbJI2qolXvECXHnlG83TemeeOxf9jcvlXh+zvk+LC9B9wJsXk9Qrw2VBsQWGnriYAvJ7FOH6ChfPSIE91/pDGF57tNnzO8Cy8tRxusZLGdw8Y8wulZQeRgqGioGalWol4pZJ5n77iKnKon6jIVPAuHVbmgL99jDZ+252PCyzni1AW8uwvBRGL916G4A2xC+E1oRtBTsjTW3FB6HF2PUj2+TrShRz1p4aDeQANITn/pWmxdKzXwY0ahCDISnwd9eo69iH9HeysPKVh4qTVNK5oxg9odH1UUh3TecELfvBu4S1YUv3++UHStHWvjUKj7ZiQHl821k0sJcCVQuQpJCRUBqoYnPjJPMf+8Q5zxfPegE94O45u4h4BCWV0pN4kHse4RH6+TeALHBf3fU2w+JDzULc2I7D2/hVCVRH7aObztBcK2Ab4EKAqEIlCASkghDMLJ4PeBjUFwO1HsHVJtQk7BgfPYeDBl//aDcJ6X4poW5631VGMuKAO05VAAq9FAzErWi4LfruKmg+0HLSagXrE/7+0c47/nqMeCu64s3kXMUFPaMZ2kriUsDpK/xuhnBLGSHUsTUqs8gDaFlFXuevJVz2lc/uFGQAM7y+6+8xj2BoKhpjK9xkUMuhojcw39hk2AqaAoVH1KjWQi0+pqAW24UJM69bo15JpYM6ophYskrAtP0EP0YX1nkYnwZR0tIjKLxs8P8A8FHbhikdWeKsf3OV1/mfVXJeiLpJyGjhocFSD1EWIdzGj01R32olpJ6oeSt8up67a7kHD1n3XOPv277ZzPuqCuWZwQrDUV/XrM5F5LrEreaIRohbHqoqRAStIVQKnHg+hKSO2uP58Yd//JL3BspaGi6s4qlpsdaXdGvK8ZNR+4iysEIt33FTQV1IAVojSvK69OHnLXur6a0z37hJe6OFXc1PN6oC1Ybkm7dY63hc3HWsZEKRmODnSsxmcD1AJddpj0BTkgsjrPXymmte8VYnvn8WXssktzRUlxINOtVyWoq6DV91usevaZjY49g5DvyekzZHeH2B+QXMhziMo7mYHxLMSrsSc9T6wjSXRM61p11P3/8Nds/NeJgy+N8LOinirUU1hKf/oxgPQgYzVoGM5KRceR7fcbnR7h9AdmFDOfJSWFN9esgvNdTvKsQvPund8hEC/GlXQDmztrj49I9//A57qsq1iqKfl2ylkCv7rOeKjbSkEHdMYgtxYJi2DeYGUeWCdzMDsh2SNEdgpp2VgqpllSlJPzbqjv/waasIK/YSx2WvxSlefJzL3LgxDozDc1KU9KdlSzNKJZnQ7rzMavzgn7VMJqHYaoZeZBXLIWRGOnIhxa7GJMXGbZbQCZwU0FjiJRDe4JwxdL+eOCekr6QUoojTEsX614sS55+6KxNjq9TTxUXm5qVumKppVieDViZ16w0fQZzJcMFGLY8htKjqOdkQzCxIyvAlAo7YykubAFmY+xRTT419A1IF2DOwn5f0baKtpXs/dERfq2Q9wopDipBaKy9WFpx5osv2veEgmGsGMSCjZpmvQ69xKdfE6zXAsbzgmFLMKpCtiGxiaUsS8y+kHFnDEphZg1FF7ACl4+wx0KKHtDpXCZH2xCOoNaA+QjmpWKfUewVihaCVAgCZVFK4gJJEQpGFcFmRdBvSjZqIesVwaAZMW5YhrGjmFcMNkpsVVEGhtJITGgphhLbsuTbgGYTl4wpjMD1etADhmCnVn0HsvugfxrkASi1wcSKgRDMCEcqJaH2UNpCJCgriix1jFKPfkMxjAKyBclAG0wDxqEm146iBWbksB7kpcO1KmR2CF2gGGG3AZfWcUvgMnAJuHugvGyXdCCOQLU+eb/Uqh71miIpJUkoCYXDqypcoBBVQdHyGDcjxg1N5hlMXTD2FIUwmKqlGEnsnE/+5iVh3gm40ns74F1QdoBT4K7UzsV9UGmDthE1rYlSjR8pvMwQxwEqFbhEYGcEpe9jW4rCCRyWMjGUmcDtD8gul4cHxhSdHnTBbYDdBjwBbOyYmlzVvfMohBF4pkqofIKaRYceXsUhIx9RGHTFh5ai9H3IczBbDo7HMJTYd0Tk3eFkyFSMsEcj8k4POr1JDvpgpwGubv2+6gvyNPjLILsQHAKxXMXfHyHXSvy4jhAjRBhOkj9k8iBXCgMwrZpPdiZrV8Fsu/jcFMBdOfoW7G348RD59w6eraOCEM8ZVJvJW7pSgXMZej6gXMrQSUkJb3dxu910JyBmZx5eCrlnt6HfqZ/chj88jXygDb/o4++xyDvr8Ac1GRYoO9lTOoQVk4N29sSTnUmoE3C3Q3GC/4R6p4vbkJ+FAnY3KQFgMcS9AvbpDnyoRv6GxJ7swdGE/O6EPFdYI3GFwuYj7GFHdiycFMyfO7gh2E9AXtuCnKZLIeF/HJI9Dl4G8hiIB9rwqwHeG1VUfev/+iXrOz0oBW5zDftRKDrANuSlbk6DBPg3vtO3svqbCX0AAAAASUVORK5CYII="
          }
        ),
        /* @__PURE__ */ S(
          "filter",
          {
            id: "alpha",
            filterUnits: "objectBoundingBox",
            x: "0%",
            y: "0%",
            width: "100%",
            height: "100%",
            children: /* @__PURE__ */ S(
              "feColorMatrix",
              {
                type: "matrix",
                in: "SourceGraphic",
                values: "0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"
              }
            )
          }
        ),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image170",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACtklEQVRYhWNgGAWjYBSMglEwCkYcmGslLagZ26TedkTUMOD/H11nY2a5Sb+/sJBiBiOtHMfAwMCg73JCaNrNdN2kh/eF0eXKFXf+qZBhvfbqqMkdYsxior7zGBjUK65yXtwsbBq4/7wDNkcyMDAwdN53ZxE87KQX4tNtRIyZVA1Rc3M7ZpZn5eoNd1lVc1hCmInVJ7ov4fwRl0n38amhWoiyP3kmPbfVyfXNw0gNUhzJwMDA8D/3q1bnt2a8bqE4RFPWPhRMLPDTwxXFxIKtN84cUdFSe4VLnuwQhaVDmbBtjpQ6koGBgWHPo6d8+ORJKiIYGBDp0CgsQTXM4Dczw+9y8l2HBB4kJFEv6p2NmeVYi1m170ewcVLmLEzw6HHhye/yjU9xyRMV9XaXNnLcmHTA9slpbhNaONLtgvpfZV5TnOmTgYGIEP3LGciWdPSB/QmDu7zUcxoquNv66c6fWoZL+NQQDNFwZysdWjpS8mnzhzsL664RUoc3M9ld2sixVWiFvBz13IUC2HjqXtzv4z+jcCf/DyG1eKOeb66bnGTiCRPqOQ0Ccpjzvq3gTr5y9IviE2L14I163YZ8HsqdhQDP3hn9vf8m5tq3r+y7SHEkAwOBqH/ncPYvZU6DgEjWToYZ/8UefWbsusrwd9p3ckpevCEqdNL9E5lug4N58opvn6zy2v/iX/AZhr8nv5NrDl6H7vx0/ZXyhqBf5BisuOLXdxnTr2esH188OCdY/j15zkMAguUoX8haFclViXrEGvjsndHfn/+0bjbzSN4q56r9R5nzEICoKlQvzsrk54IreEspWDp8wdh1lZIoxgWIrusrJBTVpl6R15QSOofR1qzc+eH1kW+Pr1AjiqkCJv3+wuJszCwnwaeq23ZE1JC9Q0ktq+09/0C7axSMglEwCkbBKKA/AABq8ekilgplTAAAAABJRU5ErkJggg=="
          }
        ),
        /* @__PURE__ */ S("mask", { id: "mask0", children: /* @__PURE__ */ S("g", { filter: "url(#alpha)", children: /* @__PURE__ */ S("use", { xlinkHref: "#image170" }) }) }),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image125",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEF0lEQVRYhe2WTYscVRSGn3NvVXdPzySabwQN2SlGkQgjCC4EFWMU/A+CG925EhN0JSiof8BtxC8SSVZZiK7MRjRElPwEF8Ik0z3d9XXPOS6qJhM1pHucGXHRLxRFN9Sth/d977kFCy200EILLfR/kvwXL/n69NFvs6Y56MmGjUIlsU55TK9998eT866xp6DfvHTkcm9Snop1epBkqDuNQulCHWNT9Xq/s5FOv/7rxo1Za2V7AXjhzLEv+pPy5ODm+KSoSlQDdZI5GCQVCtdcKzuuw/5V4MCsNXfV0S9feeD8YKM4vlKVq5J0kJsR3Ajq4JAcygSjBOMkbEhEl3Ky+5dGb/6wdt+91t41Ry8+f+jS8tr6M3nTHNwEjO5EBxdwQFwIAcBxcxSjqY1Q6vKs9XcMevHMka+WxtPV/mh8IqiSWwcISJdXCIFkYIB5+5/jaHJSdIJa3DPQCy8f+3w4nj7auzl6PDYq0YzMncwcCYBDkIAByaAxaBxq2/pdG6iC2ez3bRv0dg/X1p8KSfu5GcGMgBMFEBAEFyG1ewg1qB3qBJVCqU6lLbDOCbEt0AvPHbyyf219Nd7Rw+BOJrQOGnjnYrfRW/e8A0zOVJ0iQaFQK7hu1WHHoJ+9ePTKynjy8HC0cSIzpff3HhpICLc7qNbu8Mah0TbmonEKc6YJxg1MGiikBWiH1g5Bz79w7Pul9Y3Hsro+nJkykLv38E4HN11sNmO21sVJgo0E0wSlQQpCiELMg+4Y1CfFQxTN4dyULBhBWhfv1sOmm5W1Qp2c0pxSaSEVyqaNfCqCBSH2I/kg03wQZ87ze4J++uzhn8NocsJUMTcQcAOTgPtfY07eRlwlpzYo7ujitLuXBjWCx0DWjwxX8rRvf+5vXV3r7Qg01WlfXVmM6m2sgAQB6SB9K+5aodqMWWHadIDWXgnBsoDkgf4g08Ew0+u/jT++DO/MgpwJqrUNK3OkcfIAwQR1QLbibiHbmKvOvYlCqVAZ1CZoDHge6PWi5ctZWh5mcvanW/15AOcCTU5UBVOQbozkAuCdm23MlbbRFtqe5UWCMggmAoNA7EUfLGVpaZhx7tr6tgDnArUQaFyoVUjm1Or0usPuzsgLawHL7rSpRPAQyHqRwXKWloaZvXt99K8A5wINecg0hFQgWZmEQpzYQOiiT9qC1d7GnOSfPfzlxviDS8Z7O4GEOT7z3n9i/6hcr/bV0wZJRugect8aRykIEgOSBXr9aPnwdg9n7uZdA3018MapR1Y+KTaaflMlUmrnknePexQkD/Ty6P1hloZLkXPX1ncNcG5QgI+ePlSMxrVURerVlYl3oCEIsRfo92MaDqKf3QPAbYFu6sPVA1XdKEk9OEgWxXt54O0fb+V7BbjQQgsttNBC/0/9CbvrotNPsOneAAAAAElFTkSuQmCC"
          }
        ),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image142",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAAmklEQVRYhe2U0QqAIBAE1/7/n+tFIaQyur21aAdEX4RhDgWMMemUul7BkciZ3JopMqKXGhWcJltOzldMkS3dfhe5bOTBSGWXwF3pjxARBYSyUVFAJMsQBQSyLNF0mKKpVdlF02R/OfpGStWsonTZX4++Qa3qohVaVRfdQanqoh3hqi7KRikaGr+LslGLPh6/i7KxKBuLsvmM6AZK+AVU/UCtAQAAAABJRU5ErkJggg=="
          }
        ),
        /* @__PURE__ */ S("mask", { id: "mask1", children: /* @__PURE__ */ S("g", { filter: "url(#alpha)", children: /* @__PURE__ */ S(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.6,
              stroke: "none"
            }
          }
        ) }) }),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image148",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEI0lEQVRYhe3XTW4kuREF4I9kZqX+7B61gAFGR5CWPsucZ9zn6Sv4Ct5ZfQAv1IABuaftaUlVmWR4kZS6tPKitBjDegCRZBaT9RA/Lxi84Q1veMMbDkF6msTTPPChz28kP+NTX99+3/+MSwGuhI+47utfhETS169BNEgvCF5JPkluJZeSO8lF/+3rHtl3ncSdcCHcCpfCjXAtXpPs8ILkjeRa8kVyJ7uUkE0SknvJuz2idzgWJg3hUkNzLlxpPiBEJOlQsilI/txJnu+RI7tXJPl5TJKtZJaMwiRshdCE5lhF8141aT4LNL+IlA4jml+QnGRfFQwejE6Mso1qMplwpDl2tj6POTKZVJNs49GIwd8NPituJVfSc0gdgAFcd9d+lb1T/GpwrPhmlAyKwaKoiiy7lxTxsNX626paDDJmZ9At/hd80Q4lmt30pCErsgdFMUg2Tm1kR5IjyYlwKpwa+zOcSk40xzbdst9sMLhXDD2Ufj6UJsOe/GRniq3BHwxmG4uNbFKMFhvJICua1L+omA3mHsfJpsflieY3zZ32LG8HEf0keS/5Z0+gSTEbVWNfTZpJ6cRDUSRNqKowS7bmrh5VM/dwyKqLZ48dSPR2T3pWCsXOIPdEaibVUSe9urVKslAsmkHuKlBVG7MHA93Kt3KXrQOJ/gnfJA/dootiUIRBMqg2hp75q2WH7vjAIssDbVlUYbE1SP2cU0k93Jor0c/doqw2mCRNlrtMMQijbBRGYUDWRElSJRYWydzTsXhUjJLHfu7d4WTz8+xYspEsUo/B78KvOzo6kbyGSE2KppT9fbV/v3StuH8di+b/vuX3ge9EH4SdMAhVyF1mnsYabVXrI9QSa2bX/X2lfz8Ij8LJ69yesp+EP/bDRmHutbuqWDzFXzMXdpoZO9murlV/HWHp9WmVplk46udevMLtyV+td8roFhlUO1W2CItit+a2VJNQ1C74a9aHnWRnsFN7mZi79R+Ef4leUg8keim8F/4h/KiiShbVjNKTg6RZVHlP8Jsqm4WtpRN+tGiq0ndcam5fw6JXwifhx27RrWoy00siqxgtandz2RP8JptVs9HWbKeYHVlQewmN5y7gIKIfcd4vvb+piuTfXU/HnhBh0SxjUebaLVp7smXLJsy7MCt2dmajxb2qai6Eq9cguvY4659WyZnqV0kI30SX/8Fonmu/SDdPJaIJdRe95ofFqRmLE9Vd99LHQ2k+ydNN73cWzVfVD6sFLXaKrerR4MHkXnP/4jl4UD0abTU7T0qxhlF77p8OxP9QK8La2l6LfhNvflLdqU7Mjs0WO5Ote1uTrTOPJlt3/f1i57i7nMXfNOf9rN6JHoohWbtEIXwA4Vzq7W9yqdlKziQnXrbLT0K+Fc722uUvXUleubd/wxve8IY3/B/gP+5/MI8x65+AAAAAAElFTkSuQmCC"
          }
        ),
        /* @__PURE__ */ S("mask", { id: "mask2", children: /* @__PURE__ */ S("g", { filter: "url(#alpha)", children: /* @__PURE__ */ S(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.701961,
              stroke: "none"
            }
          }
        ) }) }),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image154",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAA/ElEQVRYhe2VwW7DIAxAn9M0qcSN///G3JDaFEIPwRvqoUHdWKXJT/IhMokeNiZgGIZhGIZh/EPkVTLnLGWNxvD0Ti6xAVlEtk6eDA1rBDgBZ2ACZu/9DMzleSz5lm+9zVFFh0pyrELYK5m89/dlWSIQRWT9lOipiE1VnCvRCKwaInLtJXrULj2Xdesn4EJpvXPuT1o/NqxR2Vp4YB+gLYSgki+781PeqUL+dYsGWkT1+tmAxH4uNZJzLpVc1w0ctV4lE3Dne4i+himEEEu+2x0KxxV9Fr0B1ypu3vuVvbpdRVv+TDpEGvXmdBMJ2EQkdvI0DMMwDMMwjI/yAInrT4nWGUiJAAAAAElFTkSuQmCC"
          }
        ),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image160",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
          }
        ),
        /* @__PURE__ */ S("mask", { id: "mask3", children: /* @__PURE__ */ S("g", { filter: "url(#alpha)", children: /* @__PURE__ */ S(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.2,
              stroke: "none"
            }
          }
        ) }) }),
        /* @__PURE__ */ S(
          "image",
          {
            id: "image166",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
          }
        ),
        /* @__PURE__ */ S("clipPath", { id: "clip2", children: /* @__PURE__ */ S("rect", { x: 0, y: 0, width: 42, height: 42 }) }),
        /* @__PURE__ */ Ne("g", { id: "surface169", clipPath: "url(#clip2)", children: [
          /* @__PURE__ */ S("use", { xlinkHref: "#image125" }),
          /* @__PURE__ */ S("use", { xlinkHref: "#image142" }),
          /* @__PURE__ */ S("use", { xlinkHref: "#image148", mask: "url(#mask1)" }),
          /* @__PURE__ */ S("use", { xlinkHref: "#image154", mask: "url(#mask2)" }),
          /* @__PURE__ */ S("use", { xlinkHref: "#image160" }),
          /* @__PURE__ */ S("use", { xlinkHref: "#image166", mask: "url(#mask3)" })
        ] })
      ] }),
      /* @__PURE__ */ S("g", { id: "surface1", children: /* @__PURE__ */ Ne("g", { clipPath: "url(#clip1)", clipRule: "nonzero", children: [
        /* @__PURE__ */ S(
          "path",
          {
            style: {
              stroke: "none",
              fillRule: "nonzero",
              fill: "url(#radial0)"
            },
            d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 "
          }
        ),
        /* @__PURE__ */ S("use", { xlinkHref: "#image42" }),
        /* @__PURE__ */ S("use", { xlinkHref: "#image91" }),
        /* @__PURE__ */ S("use", { xlinkHref: "#surface169", mask: "url(#mask0)" })
      ] }) })
    ]
  }
), o$ = [
  { transform: "translate(40.2375 0.627991) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.627991)",
    fill: "#FFDE31"
  },
  { transform: "translate(63.9086 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 16.4087) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4087)",
    fill: "#FFF065"
  },
  { transform: "translate(32.3471 16.4087) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4087)",
    fill: "#FFDE31"
  },
  { transform: "translate(32.3471 32.1895) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 32.1895) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 16.4087) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4087)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.1895) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(32.3471 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.0798) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.0798)",
    fill: "#FFDE31"
  },
  { transform: "translate(24.4567 32.1895) rotate(-180)", fill: "#FFF065" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(40.2375 47.9702) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.9702)",
    fill: "#FFDE31"
  },
  { transform: "translate(16.5664 32.1895) rotate(-180)", fill: "#FFF065" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(8.67601 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 8.51831) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.51831)",
    fill: "#FFDE31"
  },
  { transform: "translate(56.0182 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 24.2991) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.2991)",
    fill: "#FFF065"
  }
], s$ = [
  { transform: "translate(40.2375 0.232574) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.232574)",
    fill: "#00E45D"
  },
  { transform: "translate(63.9086 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 16.0133) rotate(90)", fill: "#8AFF76" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.0133)",
    fill: "#8AFF76"
  },
  { transform: "translate(32.3471 16.0133) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.0133)",
    fill: "#00E45D"
  },
  { transform: "translate(32.3471 31.794) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 31.794) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 16.0133) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.0133)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 31.794) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.794)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.794) rotate(90)", fill: "#8AFF76" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(32.3471 31.794) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.794)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.6844) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6844)",
    fill: "#00E45D"
  },
  { transform: "translate(24.4567 31.794) rotate(-180)", fill: "#8AFF76" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(40.2375 47.5748) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.5748)",
    fill: "#00E45D"
  },
  { transform: "translate(16.5664 31.794) rotate(-180)", fill: "#8AFF76" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(8.67601 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 8.12296) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.12296)",
    fill: "#00E45D"
  },
  { transform: "translate(56.0182 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 23.9037) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.9037)",
    fill: "#FFF065"
  }
], a$ = [
  { transform: "translate(40.2375 0.395386) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.395386)",
    fill: "#FF701E"
  },
  { transform: "translate(63.9086 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 16.1761) rotate(90)", fill: "#FF9345" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.1761)",
    fill: "#FF9345"
  },
  { transform: "translate(32.3471 16.1761) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.1761)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 31.9568) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 31.9568) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 16.1761) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.1761)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 31.9568) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.9568)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.9568) rotate(90)", fill: "#FF9345" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(32.3471 31.9568) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.9568)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.8472) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.8472)",
    fill: "#FF701E"
  },
  { transform: "translate(24.4567 31.9568) rotate(-180)", fill: "#FF9345" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(40.2375 47.7375) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.7375)",
    fill: "#FF701E"
  },
  { transform: "translate(16.5664 31.9568) rotate(-180)", fill: "#FF9345" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(8.67601 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 8.28577) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.28577)",
    fill: "#FF701E"
  },
  { transform: "translate(56.0182 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 24.0665) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.0665)",
    fill: "#FFF065"
  }
], c$ = [
  { transform: "translate(40.2375) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0)",
    fill: "#F42F3B"
  },
  { transform: "translate(63.9086 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 15.7807) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.7807)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 15.7807) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.7807)",
    fill: "#F42F3B"
  },
  { transform: "translate(32.3471 31.5615) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 31.5615) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 15.7807) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.7807)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 31.5615) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.5615)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.5615) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 31.5615) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.5615)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.4518) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.4518)",
    fill: "#F42F3B"
  },
  { transform: "translate(24.4567 31.5615) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 47.3422) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.3422)",
    fill: "#F42F3B"
  },
  { transform: "translate(16.5664 31.5615) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(8.67601 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 7.89038) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 7.89038)",
    fill: "#F42F3B"
  },
  { transform: "translate(56.0182 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 23.6711) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.6711)",
    fill: "#FFF065"
  }
], u$ = [
  { transform: "translate(40.2375 0.465149) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.465149)",
    fill: "#36DBFF"
  },
  { transform: "translate(63.9086 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 16.2459) rotate(90)", fill: "#7FE8FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.2459)",
    fill: "#7FE8FF"
  },
  { transform: "translate(32.3471 16.2459) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.2459)",
    fill: "#36DBFF"
  },
  { transform: "translate(32.3471 32.0266) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 32.0266) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 16.2459) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.2459)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 32.0266) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.0266)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.0266) rotate(90)", fill: "#7FE8FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(32.3471 32.0266) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.0266)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.917) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.917)",
    fill: "#36DBFF"
  },
  { transform: "translate(24.4567 32.0266) rotate(-180)", fill: "#7FE8FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(40.2375 47.8073) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.8073)",
    fill: "#36DBFF"
  },
  { transform: "translate(16.5664 32.0266) rotate(-180)", fill: "#7FE8FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(8.67601 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 8.35553) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.35553)",
    fill: "#36DBFF"
  },
  { transform: "translate(56.0182 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 24.1363) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.1363)",
    fill: "#FFF065"
  }
], l$ = [
  { transform: "translate(40.2375 0.697693) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.697693)",
    fill: "#1657FF"
  },
  { transform: "translate(63.9086 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 16.4785) rotate(90)", fill: "#3AA0FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4785)",
    fill: "#3AA0FF"
  },
  { transform: "translate(32.3471 16.4785) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4785)",
    fill: "#1657FF"
  },
  { transform: "translate(32.3471 32.2592) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 32.2592) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 16.4785) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4785)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 32.2592) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.2592)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.2592) rotate(90)", fill: "#3AA0FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(32.3471 32.2592) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.2592)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.1495) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.1495)",
    fill: "#1657FF"
  },
  { transform: "translate(24.4567 32.2592) rotate(-180)", fill: "#3AA0FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(40.2375 48.0399) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.0399)",
    fill: "#1657FF"
  },
  { transform: "translate(16.5664 32.2592) rotate(-180)", fill: "#3AA0FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(8.67601 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 8.58807) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.58807)",
    fill: "#1657FF"
  },
  { transform: "translate(56.0182 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 24.3688) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.3688)",
    fill: "#FFF065"
  }
], f$ = [
  { transform: "translate(40.2375 0.930267) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.930267)",
    fill: "#A528F2"
  },
  { transform: "translate(63.9086 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 16.711) rotate(90)", fill: "#BF58FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.711)",
    fill: "#BF58FF"
  },
  { transform: "translate(32.3471 16.711) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.711)",
    fill: "#A528F2"
  },
  { transform: "translate(32.3471 32.4917) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 32.4917) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 16.711) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.711)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 32.4917) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.4917)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.4917) rotate(90)", fill: "#BF58FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(32.3471 32.4917) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.4917)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.3821) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.3821)",
    fill: "#A528F2"
  },
  { transform: "translate(24.4567 32.4917) rotate(-180)", fill: "#BF58FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(40.2375 48.2725) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.2725)",
    fill: "#A528F2"
  },
  { transform: "translate(16.5664 32.4917) rotate(-180)", fill: "#BF58FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(8.67601 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 8.82065) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.82065)",
    fill: "#A528F2"
  },
  { transform: "translate(56.0182 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 24.6014) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.6014)",
    fill: "#FFF065"
  }
], Qy = [
  { transform: "translate(40.2375 0.162842) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.162842)",
    fill: "#FB51C1"
  },
  { transform: "translate(63.9086 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 15.9436) rotate(90)", fill: "#FF7CD2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.9436)",
    fill: "#FF7CD2"
  },
  { transform: "translate(32.3471 15.9436) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.9436)",
    fill: "#FB51C1"
  },
  { transform: "translate(32.3471 31.7243) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 31.7243) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 15.9436) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.9436)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 31.7243) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.7243)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.7243) rotate(90)", fill: "#FF7CD2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(32.3471 31.7243) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.7243)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.6147) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6147)",
    fill: "#FB51C1"
  },
  { transform: "translate(24.4567 31.7243) rotate(-180)", fill: "#FF7CD2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(40.2375 47.505) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.505)",
    fill: "#FB51C1"
  },
  { transform: "translate(16.5664 31.7243) rotate(-180)", fill: "#FF7CD2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(8.67601 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 8.05322) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.05322)",
    fill: "#FB51C1"
  },
  { transform: "translate(56.0182 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 23.834) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.834)",
    fill: "#FFF065"
  }
], d$ = {
  pink: Qy,
  purple: f$,
  darkBlue: l$,
  blue: u$,
  red: c$,
  orange: a$,
  green: s$,
  yellow: o$
}, jN = ({
  width: e = 135,
  height: t,
  className: r = "",
  color: n = "green"
}) => {
  const i = 2.4107142857142856, o = t || e / i, s = e || t * i, a = d$[n] || Qy;
  return /* @__PURE__ */ S(
    "svg",
    {
      width: s,
      height: o,
      viewBox: "0 0 135 56",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: r,
      children: a.map((c, u) => /* @__PURE__ */ S(
        "rect",
        {
          width: 7.89036,
          height: 7.89036,
          transform: c.transform,
          fill: c.fill
        },
        u
      ))
    }
  );
}, h$ = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    id: "Ebene_2",
    "data-name": "Ebene 2",
    viewBox: "0 0 314.29 111.66",
    width: e,
    height: e,
    ...n,
    children: [
      /* @__PURE__ */ S("defs", { children: /* @__PURE__ */ S("style", { children: ".cls-1{fill:#fff;stroke-width:0}" }) }),
      /* @__PURE__ */ Ne("g", { id: "Ebene_1-2", "data-name": "Ebene 1", children: [
        /* @__PURE__ */ S(
          "path",
          {
            d: "M118.13 0c-8.69-.1-16.81 2.21-23.8 6.26-2.57 1.49-3.29 4.91-1.55 7.33 3.44 4.8 6.15 10.15 7.97 15.9 1.01 3.2 4.82 4.23 7.65 2.43 3.55-2.25 7.97-3.25 12.67-2.33 6.53 1.27 11.95 6.44 13.44 12.93 2.61 11.39-5.97 21.5-16.91 21.5-3.41 0-6.58-.99-9.24-2.7-2.82-1.8-6.61-.66-7.63 2.53-4.48 14.04-14.26 25.71-27.02 32.66-1.67.91-2.75 2.6-2.75 4.5v5.58c0 2.8 2.27 5.07 5.07 5.07h19.13c2.8 0 5.07-2.27 5.07-5.07v-9.76c0-3.35 3.16-5.67 6.42-4.87 3.52.86 7.18 1.32 10.96 1.32 26.19 0 47.34-21.59 46.62-47.95C163.55 20.67 142.8.28 118.13 0Z",
            style: {
              fill: "#ff7900",
              strokeWidth: 0
            }
          }
        ),
        /* @__PURE__ */ S(
          "path",
          {
            d: "M46.64 0C20.88 0 0 20.88 0 46.64s20.88 46.64 46.64 46.64S93.28 72.4 93.28 46.64 72.4 0 46.64 0Zm0 64.03c-9.6 0-17.38-7.78-17.38-17.39s7.78-17.39 17.38-17.39 17.39 7.78 17.39 17.39-7.78 17.39-17.39 17.39ZM188.46 41.7l20.14 33.14h11.26V18.5h-13.02v34.05L185.9 18.5h-10.38v56.34h12.94V41.7zM265.74 63.57h-24.29V51.9h15.46V40.8h-15.46V29.77h24.29V18.5h-37.88v56.34h37.88V63.57zM286.16 74.84h14.06V29.77h14.07V18.5H272.1v11.27h14.06v45.07z",
            className: "cls-1"
          }
        )
      ] })
    ]
  }
), p$ = ({
  size: e = 42,
  className: t,
  ...r
}) => /* @__PURE__ */ Ne(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 200 200",
    fill: "none",
    ...r,
    children: [
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.14
          },
          fill: "#090a0b",
          d: "M 81.5,9.5 C 82.2423,11.4258 83.2423,13.2591 84.5,15C 82.7184,15.1218 81.0518,14.6218 79.5,13.5C 79.2291,11.6203 79.8958,10.287 81.5,9.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#4f585a",
          d: "M 125.5,38.5 C 112.548,31.863 99.8817,25.0297 87.5,18C 100.667,29.0023 113.667,40.1689 126.5,51.5C 127.634,54.3704 128.3,57.3704 128.5,60.5C 126.668,59.7515 125.001,58.7515 123.5,57.5C 110.167,46.8333 96.8333,36.1667 83.5,25.5C 80.3626,22.7015 78.0293,19.3681 76.5,15.5C 76.9731,14.0937 77.9731,13.427 79.5,13.5C 81.0518,14.6218 82.7184,15.1218 84.5,15C 83.2423,13.2591 82.2423,11.4258 81.5,9.5C 83.4346,8.29099 85.4346,8.45766 87.5,10C 100.414,19.2774 113.08,28.7774 125.5,38.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.161
          },
          fill: "#08090a",
          d: "M 76.5,15.5 C 78.0293,19.3681 80.3626,22.7015 83.5,25.5C 80.5498,24.6916 77.8831,23.3582 75.5,21.5C 73.9378,19.0993 74.2712,17.0993 76.5,15.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#778085",
          d: "M 75.5,21.5 C 77.8831,23.3582 80.5498,24.6916 83.5,25.5C 96.8333,36.1667 110.167,46.8333 123.5,57.5C 118.285,55.5594 113.285,53.0594 108.5,50C 99.2121,47.5708 90.0454,44.7374 81,41.5C 80.2352,41.5699 79.7352,41.9033 79.5,42.5C 75.0157,41.6841 72.6824,39.0174 72.5,34.5C 72.8417,33.6618 73.5084,33.3284 74.5,33.5C 77.4258,34.868 80.4258,35.7013 83.5,36C 80.3333,32.8333 77.1667,29.6667 74,26.5C 73.51,25.2068 73.3433,23.8734 73.5,22.5C 73.8417,21.6618 74.5084,21.3284 75.5,21.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.165
          },
          fill: "#070809",
          d: "M 73.5,22.5 C 73.3433,23.8734 73.51,25.2068 74,26.5C 77.1667,29.6667 80.3333,32.8333 83.5,36C 80.4258,35.7013 77.4258,34.868 74.5,33.5C 73.2222,31.2009 71.8889,28.8676 70.5,26.5C 71.0351,24.739 72.0351,23.4057 73.5,22.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#8d9999",
          d: "M 125.5,38.5 C 126.125,42.3258 126.791,46.1592 127.5,50C 127.43,50.7648 127.097,51.2648 126.5,51.5C 113.667,40.1689 100.667,29.0023 87.5,18C 99.8817,25.0297 112.548,31.863 125.5,38.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#8e9a9a",
          d: "M 123.5,57.5 C 125.001,58.7515 126.668,59.7515 128.5,60.5C 128.5,61.8333 128.5,63.1667 128.5,64.5C 128.5,65.8333 128.5,67.1667 128.5,68.5C 112.879,61.0229 97.5452,53.0229 82.5,44.5C 81.2905,44.0679 80.2905,43.4013 79.5,42.5C 79.7352,41.9033 80.2352,41.5699 81,41.5C 90.0454,44.7374 99.2121,47.5708 108.5,50C 113.285,53.0594 118.285,55.5594 123.5,57.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#777f85",
          d: "M 125.5,38.5 C 129.5,41.5 133.5,44.5 137.5,47.5C 136.428,51.7555 134.261,55.4222 131,58.5C 130.155,60.6115 129.322,62.6115 128.5,64.5C 128.5,63.1667 128.5,61.8333 128.5,60.5C 128.3,57.3704 127.634,54.3704 126.5,51.5C 127.097,51.2648 127.43,50.7648 127.5,50C 126.791,46.1592 126.125,42.3258 125.5,38.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.997
          },
          fill: "#888889",
          d: "M 58.5,63.5 C 48.5374,62.2002 38.7041,60.2002 29,57.5C 27.9302,57.528 27.0968,57.8614 26.5,58.5C 24.2459,57.5849 22.2459,56.2516 20.5,54.5C 18.4985,51.6662 15.9985,49.3329 13,47.5C 12.51,46.2068 12.3433,44.8734 12.5,43.5C 13.2506,42.4265 14.2506,42.2599 15.5,43C 29.1035,51.4694 43.4368,58.3027 58.5,63.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.17
          },
          fill: "#0e0f0f",
          d: "M 12.5,43.5 C 12.3433,44.8734 12.51,46.2068 13,47.5C 15.9985,49.3329 18.4985,51.6662 20.5,54.5C 20.44,55.0431 20.1067,55.3764 19.5,55.5C 16.3707,53.6001 13.0373,52.2667 9.5,51.5C 10.7279,49.9902 10.7279,48.4902 9.5,47C 10.1634,45.4815 11.1634,44.3149 12.5,43.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7b848a",
          d: "M 82.5,44.5 C 97.5452,53.0229 112.879,61.0229 128.5,68.5C 128.72,71.4005 128.054,74.0671 126.5,76.5C 113.14,69.1544 99.8062,61.8211 86.5,54.5C 83.5279,52.6778 80.5279,50.8445 77.5,49C 76.6198,47.6439 76.2865,46.1439 76.5,44.5C 78.7411,44.9539 80.7411,44.9539 82.5,44.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.153
          },
          fill: "#050506",
          d: "M 72.5,34.5 C 72.6824,39.0174 75.0157,41.6841 79.5,42.5C 80.2905,43.4013 81.2905,44.0679 82.5,44.5C 80.7411,44.9539 78.7411,44.9539 76.5,44.5C 76.2865,46.1439 76.6198,47.6439 77.5,49C 80.5279,50.8445 83.5279,52.6778 86.5,54.5C 86.2774,59.2804 87.944,63.2804 91.5,66.5C 91.1496,69.4534 92.1496,71.7867 94.5,73.5C 92.4471,73.5979 90.7804,72.9313 89.5,71.5C 89.6495,70.448 89.4828,69.448 89,68.5C 85.7393,65.9786 84.0726,62.6453 84,58.5C 80.5991,56.6387 77.5991,54.3053 75,51.5C 74.2419,49.2305 74.4086,47.0639 75.5,45C 70.4866,42.378 69.4866,38.878 72.5,34.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.016
          },
          fill: "#0f1010",
          d: "M 138.5,48.5 C 140.539,49.911 141.539,51.911 141.5,54.5C 139.992,52.8185 138.992,50.8185 138.5,48.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#343f49",
          d: "M 9.5,51.5 C 13.0373,52.2667 16.3707,53.6001 19.5,55.5C 20.1067,55.3764 20.44,55.0431 20.5,54.5C 22.2459,56.2516 24.2459,57.5849 26.5,58.5C 35.1667,62.8333 43.8333,67.1667 52.5,71.5C 56.6478,75.4041 60.9811,79.0708 65.5,82.5C 65.5,82.8333 65.5,83.1667 65.5,83.5C 50.001,77.6719 34.6676,71.6719 19.5,65.5C 16.9116,63.4392 14.0783,60.7726 11,57.5C 9.87201,55.6547 9.37201,53.6547 9.5,51.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.191
          },
          fill: "#070809",
          d: "M 9.5,51.5 C 9.37201,53.6547 9.87201,55.6547 11,57.5C 14.0783,60.7726 16.9116,63.4392 19.5,65.5C 16.2854,65.0951 13.2854,64.0951 10.5,62.5C 8.3912,60.8783 7.3912,58.7116 7.5,56C 7.30684,53.9919 7.9735,52.4919 9.5,51.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.05
          },
          fill: "#060707",
          d: "M 141.5,54.5 C 142.633,56.0552 143.299,57.8886 143.5,60C 142.418,65.9944 141.418,71.9944 140.5,78C 140.899,79.7275 141.566,81.2275 142.5,82.5C 142.167,83.5 141.5,84.1667 140.5,84.5C 140.046,81.1349 139.38,77.8015 138.5,74.5C 139.874,67.8812 140.874,61.2146 141.5,54.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#c9cbcb",
          d: "M 26.5,58.5 C 27.0968,57.8614 27.9302,57.528 29,57.5C 38.7041,60.2002 48.5374,62.2002 58.5,63.5C 61.221,63.9628 63.8877,64.6295 66.5,65.5C 72.5358,70.1912 78.8691,74.5245 85.5,78.5C 74.6653,76.7183 63.6653,74.385 52.5,71.5C 43.8333,67.1667 35.1667,62.8333 26.5,58.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#929294",
          d: "M 10.5,62.5 C 13.2854,64.0951 16.2854,65.0951 19.5,65.5C 34.6676,71.6719 50.001,77.6719 65.5,83.5C 63.9504,84.7199 62.2837,84.7199 60.5,83.5C 47.2117,81.5939 34.2117,78.5939 21.5,74.5C 15.1127,73.7734 10.7793,70.4401 8.5,64.5C 8.83333,63.5 9.5,62.8333 10.5,62.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#494f51",
          d: "M 137.5,47.5 C 138.167,47.5 138.5,47.8333 138.5,48.5C 138.992,50.8185 139.992,52.8185 141.5,54.5C 140.874,61.2146 139.874,67.8812 138.5,74.5C 139.38,77.8015 140.046,81.1349 140.5,84.5C 138.83,87.0016 136.664,89.0016 134,90.5C 132.478,88.2591 131.145,85.9258 130,83.5C 128.544,86.0324 127.377,88.6991 126.5,91.5C 115.094,82.7537 103.427,74.4203 91.5,66.5C 87.944,63.2804 86.2774,59.2804 86.5,54.5C 99.8062,61.8211 113.14,69.1544 126.5,76.5C 128.054,74.0671 128.72,71.4005 128.5,68.5C 128.5,67.1667 128.5,65.8333 128.5,64.5C 129.322,62.6115 130.155,60.6115 131,58.5C 134.261,55.4222 136.428,51.7555 137.5,47.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.183
          },
          fill: "#060606",
          d: "M 8.5,64.5 C 10.7793,70.4401 15.1127,73.7734 21.5,74.5C 19.3021,75.1653 16.9688,75.8319 14.5,76.5C 16.3737,81.6139 20.0404,84.6139 25.5,85.5C 26.5,85.5 27.5,85.5 28.5,85.5C 28.2627,86.791 28.596,87.791 29.5,88.5C 29.5106,90.0174 30.1772,91.1841 31.5,92C 34.7365,93.7862 38.0698,95.2862 41.5,96.5C 41.5,97.1667 41.8333,97.5 42.5,97.5C 42.5494,100.099 43.5494,102.266 45.5,104C 48.8168,104.498 52.1501,104.665 55.5,104.5C 55.2627,105.791 55.596,106.791 56.5,107.5C 56.9528,108.458 57.6195,109.292 58.5,110C 61.3771,111.127 64.3771,111.794 67.5,112C 68.9852,114.237 70.9852,115.737 73.5,116.5C 76.9386,117.019 80.272,118.019 83.5,119.5C 87.2508,121.079 91.2508,122.079 95.5,122.5C 95.5,122.833 95.5,123.167 95.5,123.5C 92.5715,130.285 90.2382,137.285 88.5,144.5C 88.1667,145.167 87.8333,145.833 87.5,146.5C 87.1667,146.5 86.8333,146.5 86.5,146.5C 87.7936,139.786 89.7936,133.286 92.5,127C 87.5169,126.897 83.1836,125.23 79.5,122C 74.2686,122.485 69.9353,120.819 66.5,117C 60.8614,116.865 56.528,114.531 53.5,110C 50.1853,109.059 46.852,108.226 43.5,107.5C 41.5592,105.166 39.8925,102.666 38.5,100C 32.4206,98.8085 28.0872,95.4752 25.5,90C 17.189,88.6898 12.689,83.8564 12,75.5C 9.28221,73.2292 7.44888,70.3958 6.5,67C 7.06594,66.0053 7.73261,65.172 8.5,64.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#b8b6ac",
          d: "M 52.5,71.5 C 63.6653,74.385 74.6653,76.7183 85.5,78.5C 89.228,81.5589 93.228,84.2256 97.5,86.5C 91.3341,87.3789 85.0007,87.3789 78.5,86.5C 75.3915,86.7359 72.3915,86.4025 69.5,85.5C 68.205,84.5116 66.8717,83.5116 65.5,82.5C 60.9811,79.0708 56.6478,75.4041 52.5,71.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343f48",
          d: "M 21.5,74.5 C 34.2117,78.5939 47.2117,81.5939 60.5,83.5C 48.8333,84.1667 37.1667,84.8333 25.5,85.5C 20.0404,84.6139 16.3737,81.6139 14.5,76.5C 16.9688,75.8319 19.3021,75.1653 21.5,74.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#565a5e",
          d: "M 66.5,65.5 C 74.1667,67.5 81.8333,69.5 89.5,71.5C 90.7804,72.9313 92.4471,73.5979 94.5,73.5C 104.436,81.5934 114.269,89.9267 124,98.5C 124.333,100.5 124.667,102.5 125,104.5C 127.25,100.332 129.75,96.3318 132.5,92.5C 130.604,91.5344 128.604,91.2011 126.5,91.5C 127.377,88.6991 128.544,86.0324 130,83.5C 131.145,85.9258 132.478,88.2591 134,90.5C 136.664,89.0016 138.83,87.0016 140.5,84.5C 141.5,84.1667 142.167,83.5 142.5,82.5C 146.184,80.4717 149.85,78.4717 153.5,76.5C 153.5,76.8333 153.5,77.1667 153.5,77.5C 150.542,81.6911 148.542,86.3578 147.5,91.5C 151.5,90.5 155.5,89.5 159.5,88.5C 160.492,88.3284 161.158,88.6618 161.5,89.5C 160.26,90.6588 158.926,91.6588 157.5,92.5C 154.615,92.1936 151.948,92.5269 149.5,93.5C 148.391,93.4431 147.391,93.1098 146.5,92.5C 142.6,91.5701 138.6,91.2367 134.5,91.5C 134.46,94.8806 134.793,98.2139 135.5,101.5C 135.5,102.833 135.5,104.167 135.5,105.5C 131.563,105.207 127.73,105.54 124,106.5C 115.993,99.572 107.493,93.2387 98.5,87.5C 98.5,86.8333 98.1667,86.5 97.5,86.5C 93.228,84.2256 89.228,81.5589 85.5,78.5C 78.8691,74.5245 72.5358,70.1912 66.5,65.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#c0bbb1",
          d: "M 153.5,76.5 C 156.5,76.5 159.5,76.5 162.5,76.5C 164.526,80.5813 165.526,84.9146 165.5,89.5C 164.167,89.5 162.833,89.5 161.5,89.5C 161.158,88.6618 160.492,88.3284 159.5,88.5C 157.5,84.8333 155.5,81.1667 153.5,77.5C 153.5,77.1667 153.5,76.8333 153.5,76.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7c858b",
          d: "M 153.5,77.5 C 155.5,81.1667 157.5,84.8333 159.5,88.5C 155.5,89.5 151.5,90.5 147.5,91.5C 148.542,86.3578 150.542,81.6911 153.5,77.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.996
          },
          fill: "#898a89",
          d: "M 162.5,76.5 C 167.023,78.0073 171.523,79.674 176,81.5C 177.03,81.8361 177.53,82.5028 177.5,83.5C 177.992,85.8185 178.992,87.8185 180.5,89.5C 181.338,89.8417 181.672,90.5084 181.5,91.5C 178.012,91.7054 174.679,92.5387 171.5,94C 176.66,95.6954 181.66,97.5287 186.5,99.5C 181.93,100.441 177.263,100.774 172.5,100.5C 171.793,98.2186 170.793,96.0519 169.5,94C 165.534,93.1721 161.534,92.6721 157.5,92.5C 158.926,91.6588 160.26,90.6588 161.5,89.5C 162.184,91.1852 163.517,92.1852 165.5,92.5C 168.012,91.2162 168.012,90.2162 165.5,89.5C 165.526,84.9146 164.526,80.5813 162.5,76.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c676f",
          d: "M 65.5,82.5 C 66.8717,83.5116 68.205,84.5116 69.5,85.5C 66.8333,87.5 64.1667,89.5 61.5,91.5C 51.2474,90.3957 41.0808,88.729 31,86.5C 29.9701,86.8361 29.4701,87.5028 29.5,88.5C 28.596,87.791 28.2627,86.791 28.5,85.5C 27.5,85.5 26.5,85.5 25.5,85.5C 37.1667,84.8333 48.8333,84.1667 60.5,83.5C 62.2837,84.7199 63.9504,84.7199 65.5,83.5C 65.5,83.1667 65.5,82.8333 65.5,82.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.018
          },
          fill: "#191919",
          d: "M 177.5,83.5 C 179.539,84.911 180.539,86.911 180.5,89.5C 178.992,87.8185 177.992,85.8185 177.5,83.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#cdcfd0",
          d: "M 61.5,91.5 C 64.3522,93.0765 67.3522,94.5765 70.5,96C 60.8391,96.4998 51.1724,96.6665 41.5,96.5C 38.0698,95.2862 34.7365,93.7862 31.5,92C 30.1772,91.1841 29.5106,90.0174 29.5,88.5C 29.4701,87.5028 29.9701,86.8361 31,86.5C 41.0808,88.729 51.2474,90.3957 61.5,91.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7c858b",
          d: "M 78.5,86.5 C 85.0007,87.3789 91.3341,87.3789 97.5,86.5C 98.1667,86.5 98.5,86.8333 98.5,87.5C 95.9058,93.1859 92.9058,98.6859 89.5,104C 89.7284,104.399 90.0618,104.565 90.5,104.5C 94.7789,107.029 99.1122,109.363 103.5,111.5C 97.296,115.128 90.6293,117.795 83.5,119.5C 80.272,118.019 76.9386,117.019 73.5,116.5C 76.1873,116.664 78.854,116.497 81.5,116C 83.5871,112.492 85.9204,109.158 88.5,106C 88.2716,105.601 87.9382,105.435 87.5,105.5C 87.5,104.833 87.5,104.167 87.5,103.5C 87.9382,103.565 88.2716,103.399 88.5,103C 84.7673,97.6938 81.434,92.1938 78.5,86.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#3c413e",
          d: "M 91.5,66.5 C 103.427,74.4203 115.094,82.7537 126.5,91.5C 128.604,91.2011 130.604,91.5344 132.5,92.5C 129.75,96.3318 127.25,100.332 125,104.5C 124.667,102.5 124.333,100.5 124,98.5C 114.269,89.9267 104.436,81.5934 94.5,73.5C 92.1496,71.7867 91.1496,69.4534 91.5,66.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#e2730e",
          d: "M 161.5,89.5 C 162.833,89.5 164.167,89.5 165.5,89.5C 168.012,90.2162 168.012,91.2162 165.5,92.5C 163.517,92.1852 162.184,91.1852 161.5,89.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#b7b5ac",
          d: "M 146.5,92.5 C 147.265,95.0961 147.599,97.7628 147.5,100.5C 147.5,100.833 147.5,101.167 147.5,101.5C 143.569,102.132 140.235,103.799 137.5,106.5C 137.167,106.5 136.833,106.5 136.5,106.5C 136.784,104.585 136.451,102.919 135.5,101.5C 134.793,98.2139 134.46,94.8806 134.5,91.5C 138.6,91.2367 142.6,91.5701 146.5,92.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.998
          },
          fill: "#babbba",
          d: "M 181.5,91.5 C 184.81,93.4821 187.81,95.8154 190.5,98.5C 189.432,99.4345 188.099,99.7678 186.5,99.5C 181.66,97.5287 176.66,95.6954 171.5,94C 174.679,92.5387 178.012,91.7054 181.5,91.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#353f49",
          d: "M 146.5,92.5 C 147.391,93.1098 148.391,93.4431 149.5,93.5C 153.167,94.1667 156.833,94.8333 160.5,95.5C 156.624,98.1293 152.29,99.796 147.5,100.5C 147.599,97.7628 147.265,95.0961 146.5,92.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#d0c9c0",
          d: "M 149.5,93.5 C 151.948,92.5269 154.615,92.1936 157.5,92.5C 161.534,92.6721 165.534,93.1721 169.5,94C 170.793,96.0519 171.793,98.2186 172.5,100.5C 168.52,98.8702 164.52,97.2035 160.5,95.5C 156.833,94.8333 153.167,94.1667 149.5,93.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7e8182",
          d: "M 160.5,95.5 C 164.52,97.2035 168.52,98.8702 172.5,100.5C 172.5,101.167 172.167,101.5 171.5,101.5C 163.981,101.175 156.648,101.508 149.5,102.5C 148.833,102.167 148.167,101.833 147.5,101.5C 147.5,101.167 147.5,100.833 147.5,100.5C 152.29,99.796 156.624,98.1293 160.5,95.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c666f",
          d: "M 42.5,97.5 C 52.1724,97.3335 61.8391,97.5002 71.5,98C 66.7133,99.8932 62.0466,102.06 57.5,104.5C 56.6143,105.325 56.281,106.325 56.5,107.5C 55.596,106.791 55.2627,105.791 55.5,104.5C 52.1501,104.665 48.8168,104.498 45.5,104C 43.5494,102.266 42.5494,100.099 42.5,97.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d6871",
          d: "M 87.5,103.5 C 87.5,104.167 87.5,104.833 87.5,105.5C 81.5738,106.774 75.7404,108.441 70,110.5C 69.5,110.167 69,109.833 68.5,109.5C 69.9376,105.167 71.9376,101.167 74.5,97.5C 78.9793,99.2405 83.3126,101.24 87.5,103.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.165
          },
          fill: "#070707",
          d: "M 190.5,98.5 C 192.676,99.7133 193.009,101.38 191.5,103.5C 185.274,105.018 178.94,105.852 172.5,106C 168.352,109.314 164.352,112.814 160.5,116.5C 157.833,124.323 154.667,131.99 151,139.5C 147.796,142.369 144.963,145.535 142.5,149C 139.761,150.026 137.428,151.526 135.5,153.5C 134.609,152.89 133.609,152.557 132.5,152.5C 131.833,152.5 131.167,152.5 130.5,152.5C 130.5,151.833 130.5,151.167 130.5,150.5C 131.167,150.5 131.5,150.167 131.5,149.5C 139.372,146.766 145.372,141.766 149.5,134.5C 150.167,134.5 150.5,134.167 150.5,133.5C 153.099,127.704 155.099,121.704 156.5,115.5C 157.167,115.5 157.5,115.167 157.5,114.5C 157.833,113.5 158.5,112.833 159.5,112.5C 163.5,108.833 167.5,105.167 171.5,101.5C 172.167,101.5 172.5,101.167 172.5,100.5C 177.263,100.774 181.93,100.441 186.5,99.5C 188.099,99.7678 189.432,99.4345 190.5,98.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#cdcfcf",
          d: "M 147.5,101.5 C 148.167,101.833 148.833,102.167 149.5,102.5C 153.14,105.473 156.473,108.806 159.5,112.5C 158.5,112.833 157.833,113.5 157.5,114.5C 150.833,111.833 144.167,109.167 137.5,106.5C 140.235,103.799 143.569,102.132 147.5,101.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343e48",
          d: "M 171.5,101.5 C 167.5,105.167 163.5,108.833 159.5,112.5C 156.473,108.806 153.14,105.473 149.5,102.5C 156.648,101.508 163.981,101.175 171.5,101.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#969798",
          d: "M 69.5,85.5 C 72.3915,86.4025 75.3915,86.7359 78.5,86.5C 81.434,92.1938 84.7673,97.6938 88.5,103C 88.2716,103.399 87.9382,103.565 87.5,103.5C 83.3126,101.24 78.9793,99.2405 74.5,97.5C 71.9376,101.167 69.9376,105.167 68.5,109.5C 69,109.833 69.5,110.167 70,110.5C 75.7404,108.441 81.5738,106.774 87.5,105.5C 87.9382,105.435 88.2716,105.601 88.5,106C 85.9204,109.158 83.5871,112.492 81.5,116C 78.854,116.497 76.1873,116.664 73.5,116.5C 70.9852,115.737 68.9852,114.237 67.5,112C 64.3771,111.794 61.3771,111.127 58.5,110C 57.6195,109.292 56.9528,108.458 56.5,107.5C 56.281,106.325 56.6143,105.325 57.5,104.5C 62.0466,102.06 66.7133,99.8932 71.5,98C 61.8391,97.5002 52.1724,97.3335 42.5,97.5C 41.8333,97.5 41.5,97.1667 41.5,96.5C 51.1724,96.6665 60.8391,96.4998 70.5,96C 67.3522,94.5765 64.3522,93.0765 61.5,91.5C 64.1667,89.5 66.8333,87.5 69.5,85.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#bfc2c4",
          d: "M 90.5,104.5 C 100.989,105.041 111.322,105.707 121.5,106.5C 115.431,107.914 109.431,109.581 103.5,111.5C 99.1122,109.363 94.7789,107.029 90.5,104.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d6870",
          d: "M 98.5,87.5 C 107.493,93.2387 115.993,99.572 124,106.5C 127.73,105.54 131.563,105.207 135.5,105.5C 135.5,104.167 135.5,102.833 135.5,101.5C 136.451,102.919 136.784,104.585 136.5,106.5C 135.724,113.137 135.391,119.804 135.5,126.5C 129.121,126.038 122.788,125.538 116.5,125C 118.606,128.039 120.106,131.205 121,134.5C 116.332,132.082 111.499,130.082 106.5,128.5C 106.5,128.167 106.5,127.833 106.5,127.5C 106.5,126.833 106.833,126.5 107.5,126.5C 110.315,126.796 112.982,125.796 115.5,123.5C 114.639,121.089 113.306,119.089 111.5,117.5C 115.841,114.189 119.174,110.522 121.5,106.5C 111.322,105.707 100.989,105.041 90.5,104.5C 90.0618,104.565 89.7284,104.399 89.5,104C 92.9058,98.6859 95.9058,93.1859 98.5,87.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#959697",
          d: "M 136.5,106.5 C 136.833,106.5 137.167,106.5 137.5,106.5C 144.167,109.167 150.833,111.833 157.5,114.5C 157.5,115.167 157.167,115.5 156.5,115.5C 150.409,118.408 144.409,121.574 138.5,125C 137.619,125.708 136.953,126.542 136.5,127.5C 131.952,129.107 127.619,131.274 123.5,134C 127.152,134.499 130.818,134.665 134.5,134.5C 131.038,135.482 127.371,135.815 123.5,135.5C 121.308,139.098 120.308,143.098 120.5,147.5C 119.869,149.934 118.869,152.268 117.5,154.5C 116.833,155.5 116.167,156.5 115.5,157.5C 114.18,156.058 112.514,155.392 110.5,155.5C 108.704,154.207 107.037,152.707 105.5,151C 108.833,150.667 112.167,150.333 115.5,150C 107.624,149.113 99.7911,147.946 92,146.5C 90.6244,146.316 89.7911,145.649 89.5,144.5C 95.1404,139.195 100.807,133.861 106.5,128.5C 111.499,130.082 116.332,132.082 121,134.5C 120.106,131.205 118.606,128.039 116.5,125C 122.788,125.538 129.121,126.038 135.5,126.5C 135.391,119.804 135.724,113.137 136.5,106.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#56595b",
          d: "M 121.5,106.5 C 119.174,110.522 115.841,114.189 111.5,117.5C 106.167,119.167 100.833,120.833 95.5,122.5C 91.2508,122.079 87.2508,121.079 83.5,119.5C 90.6293,117.795 97.296,115.128 103.5,111.5C 109.431,109.581 115.431,107.914 121.5,106.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#56585a",
          d: "M 156.5,115.5 C 155.099,121.704 153.099,127.704 150.5,133.5C 145.597,132.048 140.93,130.048 136.5,127.5C 136.953,126.542 137.619,125.708 138.5,125C 144.409,121.574 150.409,118.408 156.5,115.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#858689",
          d: "M 111.5,117.5 C 110.16,120.529 108.827,123.529 107.5,126.5C 106.833,126.5 106.5,126.833 106.5,127.5C 102.721,126.442 99.0541,125.109 95.5,123.5C 95.5,123.167 95.5,122.833 95.5,122.5C 100.833,120.833 106.167,119.167 111.5,117.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#37414b",
          d: "M 111.5,117.5 C 113.306,119.089 114.639,121.089 115.5,123.5C 112.982,125.796 110.315,126.796 107.5,126.5C 108.827,123.529 110.16,120.529 111.5,117.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343e48",
          d: "M 95.5,123.5 C 99.0541,125.109 102.721,126.442 106.5,127.5C 106.5,127.833 106.5,128.167 106.5,128.5C 100.807,133.861 95.1404,139.195 89.5,144.5C 89.1667,144.5 88.8333,144.5 88.5,144.5C 90.2382,137.285 92.5715,130.285 95.5,123.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#ced0d0",
          d: "M 136.5,127.5 C 140.93,130.048 145.597,132.048 150.5,133.5C 150.5,134.167 150.167,134.5 149.5,134.5C 144.5,134.5 139.5,134.5 134.5,134.5C 130.818,134.665 127.152,134.499 123.5,134C 127.619,131.274 131.952,129.107 136.5,127.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7b8389",
          d: "M 134.5,134.5 C 139.5,134.5 144.5,134.5 149.5,134.5C 145.372,141.766 139.372,146.766 131.5,149.5C 128.406,145.074 125.739,140.407 123.5,135.5C 127.371,135.815 131.038,135.482 134.5,134.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#36414b",
          d: "M 123.5,135.5 C 125.739,140.407 128.406,145.074 131.5,149.5C 131.5,150.167 131.167,150.5 130.5,150.5C 126.881,150.119 123.548,149.119 120.5,147.5C 120.308,143.098 121.308,139.098 123.5,135.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d676f",
          d: "M 88.5,144.5 C 88.8333,144.5 89.1667,144.5 89.5,144.5C 89.7911,145.649 90.6244,146.316 92,146.5C 99.7911,147.946 107.624,149.113 115.5,150C 112.167,150.333 108.833,150.667 105.5,151C 107.037,152.707 108.704,154.207 110.5,155.5C 107.085,162 103.418,168.333 99.5,174.5C 101.095,168.717 103.095,163.051 105.5,157.5C 103.5,156.833 101.5,156.167 99.5,155.5C 101.316,154.185 102.983,152.685 104.5,151C 99.8333,150.333 95.1667,150.333 90.5,151C 91.4118,153.205 92.7451,155.038 94.5,156.5C 94.5,157.167 94.1667,157.5 93.5,157.5C 83.3942,165.095 73.3942,172.928 63.5,181C 62.8333,181.667 62.1667,181.667 61.5,181C 69.3025,172.197 77.4691,163.697 86,155.5C 87.1821,153.656 88.3488,151.823 89.5,150C 89.1918,148.541 88.5251,147.374 87.5,146.5C 87.8333,145.833 88.1667,145.167 88.5,144.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#5e686e",
          d: "M 120.5,147.5 C 123.548,149.119 126.881,150.119 130.5,150.5C 130.5,151.167 130.5,151.833 130.5,152.5C 129.039,151.314 127.705,151.314 126.5,152.5C 123.402,152.756 120.402,153.422 117.5,154.5C 118.869,152.268 119.869,149.934 120.5,147.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.961
          },
          fill: "#b3afa3",
          d: "M 130.5,152.5 C 131.167,152.5 131.833,152.5 132.5,152.5C 133.306,153.728 134.306,154.728 135.5,155.5C 132.145,155.31 129.145,154.31 126.5,152.5C 127.705,151.314 129.039,151.314 130.5,152.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.988
          },
          fill: "#686b65",
          d: "M 132.5,152.5 C 133.609,152.557 134.609,152.89 135.5,153.5C 137.292,153.366 138.958,153.699 140.5,154.5C 139.789,156.03 138.789,157.363 137.5,158.5C 134.932,158.594 133.432,159.928 133,162.5C 131.794,159.162 132.96,157.329 136.5,157C 135.944,156.617 135.611,156.117 135.5,155.5C 134.306,154.728 133.306,153.728 132.5,152.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.176
          },
          fill: "#030404",
          d: "M 110.5,155.5 C 112.514,155.392 114.18,156.058 115.5,157.5C 117.986,159.155 119.986,161.322 121.5,164C 119.419,166.818 119.085,169.818 120.5,173C 121.167,173.667 121.833,173.667 122.5,173C 120.775,166.133 122.608,164.966 128,169.5C 129.505,171.298 129.672,173.132 128.5,175C 132.204,174.516 132.538,172.849 129.5,170C 132.657,170.176 134.157,172.009 134,175.5C 135.689,173.68 135.855,171.68 134.5,169.5C 137.686,172.399 138.02,175.566 135.5,179C 132.207,179.826 128.874,180.326 125.5,180.5C 127.089,177.036 126.589,174.036 124,171.5C 125.225,174.331 124.559,176.664 122,178.5C 119.086,177.252 117.253,175.086 116.5,172C 117.791,169.95 118.291,167.783 118,165.5C 116.316,163.649 114.483,161.982 112.5,160.5C 111.522,160.977 110.689,161.643 110,162.5C 105.922,170.991 101.588,179.324 97,187.5C 95.786,189.049 94.286,190.215 92.5,191C 77.4054,197.181 62.9054,196.014 49,187.5C 48.1742,184.788 48.6742,182.455 50.5,180.5C 50.238,181.978 50.5713,183.311 51.5,184.5C 56.3296,185.951 60.9962,187.617 65.5,189.5C 70.2981,190.744 74.9648,190.744 79.5,189.5C 82.9419,190.172 85.6086,189.172 87.5,186.5C 90.1569,186.838 92.4902,186.171 94.5,184.5C 96.705,181.423 98.3716,178.09 99.5,174.5C 103.418,168.333 107.085,162 110.5,155.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#555759",
          d: "M 94.5,156.5 C 96.0481,156.821 96.7148,157.821 96.5,159.5C 89.8331,168.856 83.4997,178.523 77.5,188.5C 77.9569,189.298 78.6236,189.631 79.5,189.5C 74.9648,190.744 70.2981,190.744 65.5,189.5C 68.4045,187.101 71.2379,184.435 74,181.5C 80.2688,173.286 86.7688,165.286 93.5,157.5C 94.1667,157.5 94.5,157.167 94.5,156.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.99
          },
          fill: "#2d363e",
          d: "M 140.5,154.5 C 143.802,155.294 147.135,155.96 150.5,156.5C 149.645,158.787 149.478,161.12 150,163.5C 148.334,164.34 148.167,163.84 149.5,162C 148.25,159.375 146.25,158.375 143.5,159C 146.47,162.145 145.97,164.645 142,166.5C 141.667,164.953 142.167,163.62 143.5,162.5C 142.833,159.167 140.833,157.833 137.5,158.5C 138.789,157.363 139.789,156.03 140.5,154.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#898f8c",
          d: "M 99.5,174.5 C 98.3716,178.09 96.705,181.423 94.5,184.5C 92.4902,186.171 90.1569,186.838 87.5,186.5C 90.2985,177.438 93.2985,168.438 96.5,159.5C 96.7148,157.821 96.0481,156.821 94.5,156.5C 92.7451,155.038 91.4118,153.205 90.5,151C 95.1667,150.333 99.8333,150.333 104.5,151C 102.983,152.685 101.316,154.185 99.5,155.5C 101.5,156.167 103.5,156.833 105.5,157.5C 103.095,163.051 101.095,168.717 99.5,174.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 0.132
          },
          fill: "#040505",
          d: "M 126.5,152.5 C 129.145,154.31 132.145,155.31 135.5,155.5C 135.611,156.117 135.944,156.617 136.5,157C 132.96,157.329 131.794,159.162 133,162.5C 133.432,159.928 134.932,158.594 137.5,158.5C 140.833,157.833 142.833,159.167 143.5,162.5C 142.167,163.62 141.667,164.953 142,166.5C 145.97,164.645 146.47,162.145 143.5,159C 146.25,158.375 148.25,159.375 149.5,162C 148.167,163.84 148.334,164.34 150,163.5C 149.478,161.12 149.645,158.787 150.5,156.5C 153.859,160.675 153.525,164.842 149.5,169C 146.36,168.418 143.36,168.751 140.5,170C 139.351,168.396 139.351,166.73 140.5,165C 140.387,163.72 139.72,162.887 138.5,162.5C 136.599,164.006 134.932,165.673 133.5,167.5C 132.29,167.068 131.29,166.401 130.5,165.5C 130.784,163.123 130.784,160.956 130.5,159C 128.722,158.296 126.888,157.796 125,157.5C 123.301,157.387 122.134,158.053 121.5,159.5C 119.413,158.415 118.08,156.749 117.5,154.5C 120.402,153.422 123.402,152.756 126.5,152.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#828688",
          d: "M 86.5,146.5 C 86.8333,146.5 87.1667,146.5 87.5,146.5C 88.5251,147.374 89.1918,148.541 89.5,150C 88.3488,151.823 87.1821,153.656 86,155.5C 77.4691,163.697 69.3025,172.197 61.5,181C 62.1667,181.667 62.8333,181.667 63.5,181C 73.3942,172.928 83.3942,165.095 93.5,157.5C 86.7688,165.286 80.2688,173.286 74,181.5C 71.2379,184.435 68.4045,187.101 65.5,189.5C 60.9962,187.617 56.3296,185.951 51.5,184.5C 50.5713,183.311 50.238,181.978 50.5,180.5C 62.1716,168.829 74.1716,157.495 86.5,146.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c666f",
          d: "M 96.5,159.5 C 93.2985,168.438 90.2985,177.438 87.5,186.5C 85.6086,189.172 82.9419,190.172 79.5,189.5C 78.6236,189.631 77.9569,189.298 77.5,188.5C 83.4997,178.523 89.8331,168.856 96.5,159.5 Z"
        }
      ) }),
      /* @__PURE__ */ S("g", { children: /* @__PURE__ */ S(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#3b4346",
          d: "M 117.5,154.5 C 118.08,156.749 119.413,158.415 121.5,159.5C 124.328,161.748 127.328,163.748 130.5,165.5C 131.29,166.401 132.29,167.068 133.5,167.5C 133.833,168.167 134.167,168.833 134.5,169.5C 135.855,171.68 135.689,173.68 134,175.5C 134.157,172.009 132.657,170.176 129.5,170C 132.538,172.849 132.204,174.516 128.5,175C 129.672,173.132 129.505,171.298 128,169.5C 122.608,164.966 120.775,166.133 122.5,173C 121.833,173.667 121.167,173.667 120.5,173C 119.085,169.818 119.419,166.818 121.5,164C 119.986,161.322 117.986,159.155 115.5,157.5C 116.167,156.5 116.833,155.5 117.5,154.5 Z"
        }
      ) })
    ]
  }
), DN = ({
  size: e,
  className: t,
  variant: r,
  walletName: n
}) => n === mi ? /* @__PURE__ */ S(QO, { size: e, className: t, variant: r }) : n === Ki ? /* @__PURE__ */ S(t$, { size: e, className: t, variant: r }) : n === Di ? /* @__PURE__ */ S(q1, { size: e, className: t, variant: r }) : n === kn ? /* @__PURE__ */ S(n$, { size: e, className: t, variant: r }) : n === Mi ? /* @__PURE__ */ S(r$, { size: e, className: t, variant: r }) : n === vi ? /* @__PURE__ */ S(p$, { size: e, className: t, variant: r }) : n === bi ? /* @__PURE__ */ S(JO, { size: e, className: t, variant: r }) : n === gi ? /* @__PURE__ */ S(e$, { size: e, className: t, variant: r }) : n === ji ? /* @__PURE__ */ S(YO, { size: e, className: t, variant: r }) : n === yi ? /* @__PURE__ */ S(i$, { size: e, className: t, variant: r }) : n === wi ? /* @__PURE__ */ S(h$, { size: e, className: t, variant: r }) : /* @__PURE__ */ S(q1, { size: e, className: t, variant: r });
export {
  AN as APPLICATION_ATOM_XML,
  SN as APPLICATION_FORM_URLENCODED,
  vN as APPLICATION_GZIP,
  mN as APPLICATION_JAVASCRIPT,
  gN as APPLICATION_JSON,
  _N as APPLICATION_OCTET_STREAM,
  yN as APPLICATION_PDF,
  EN as APPLICATION_RSS_XML,
  xN as APPLICATION_XHTML_XML,
  bN as APPLICATION_XML,
  wN as APPLICATION_ZIP,
  UN as AUDIO_MP3,
  HN as AUDIO_OGG,
  FN as AUDIO_WAV,
  Ma as CMDRUID_MAINNET,
  MT as CMDRUID_SIGNET,
  l1 as CMDRUID_TESTNET,
  fr as FRACTAL_MAINNET,
  At as FRACTAL_TESTNET,
  Ri as GLITTR,
  tb as GLITTR_DEVNET,
  Y2 as GLITTR_WALLET_DEVNET,
  CN as IMAGE_GIF,
  BN as IMAGE_ICON,
  kN as IMAGE_JPEG,
  TN as IMAGE_PNG,
  PN as IMAGE_SVG_XML,
  IN as IMAGE_WEBP,
  Di as LEATHER,
  Mf as LEATHER_MAINNET,
  eb as LEATHER_TESTNET,
  il as LOCAL_STORAGE_DEFAULT_WALLET,
  VO as LaserEyesClient,
  jN as LaserEyesLogo,
  zN as LaserEyesProvider,
  q1 as LeatherLogo,
  kn as MAGIC_EDEN,
  Ue as MAINNET,
  RN as MULTIPART_FORM_DATA,
  n$ as MagicEdenLogo,
  Mi as OKX,
  jT as OKX_MAINNET,
  DT as OKX_TESTNET,
  wi as OP_NET,
  iN as OP_WALLET_MAINNET,
  oN as OP_WALLET_TESTNET,
  yi as ORANGE,
  Da as ORANGE_MAINNET,
  jl as ORANGE_TESTNET,
  ji as OYL,
  r$ as OkxLogo,
  YO as OylLogo,
  p5 as P2PKH,
  w$ as P2PSH,
  X1 as P2SH,
  g5 as P2SH_P2WPKH,
  Ss as P2TR,
  nf as P2WPKH,
  m5 as P2WSH,
  bi as PHANTOM,
  JO as PhantomLogo,
  sN as REGTEST,
  Bt as SIGNET,
  vi as SPARROW,
  v$ as SUPPORTED_WALLETS,
  Ge as TESTNET,
  Et as TESTNET4,
  dN as TEXT_CSS,
  fN as TEXT_HTML,
  hN as TEXT_JAVASCRIPT,
  pN as TEXT_MARKDOWN,
  CP as TEXT_PLAIN,
  gi as UNISAT,
  ku as UNISAT_FRACTAL_MAINNET,
  Tu as UNISAT_FRACTAL_TESTNET,
  Xo as UNISAT_MAINNET,
  _u as UNISAT_SIGNET,
  Au as UNISAT_TESTNET,
  Su as UNISAT_TESTNET4,
  td as UNSUPPORTED_PROVIDER_METHOD_ERROR,
  e$ as UnisatLogo,
  ON as VIDEO_MP4,
  NN as VIDEO_OGG,
  $N as VIDEO_WEBM,
  LI as WALLET_NOT_INSTALLED_ERROR,
  Ki as WIZZ,
  Cs as WIZZ_MAINNET,
  Q2 as WIZZ_SIGNET,
  Df as WIZZ_TESTNET,
  J2 as WIZZ_TESTNET4,
  DN as WalletIcon,
  Br as WalletProvider,
  t$ as WizzLogo,
  mi as XVERSE,
  Es as XVERSE_MAINNET,
  nN as XVERSE_NETWORK,
  zT as XVERSE_SIGNET,
  jf as XVERSE_TESTNET,
  QO as XverseLogo,
  KI as createConfig,
  gy as createStores,
  qT as getCmDruidNetwork,
  KT as getGlittrNetwork,
  aN as getLeatherNetwork,
  f1 as getNetworkForGlittr,
  lN as getNetworkForLeather,
  VT as getNetworkForOkx,
  Kc as getNetworkForUnisat,
  d1 as getNetworkForWizz,
  uN as getNetworkForXverse,
  Dl as getOrangeNetwork,
  rc as getSatsConnectNetwork,
  rb as getUnisatNetwork,
  cN as getWizzNetwork,
  LN as useLaserEyes
};
