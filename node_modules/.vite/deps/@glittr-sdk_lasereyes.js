import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

"use client";
import {
  require_jsx_runtime
} from "./chunk-6JFMAHPS.js";
import {
  require_react
} from "./chunk-WOK4IPW7.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-RQJETXQX.js";

// node_modules/@glittr-sdk/lasereyes/dist/index.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var OC = Object.defineProperty;
var BC = (e, t, r) => t in e ? OC(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var Pt = (e, t, r) => BC(e, typeof t != "symbol" ? t + "" : t, r);
function zC(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const o in n)
        if (o !== "default" && !(o in e)) {
          const i = Object.getOwnPropertyDescriptor(n, o);
          i && Object.defineProperty(e, o, i.get ? i : {
            enumerable: true,
            get: () => n[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Xy = Symbol("clean");
var qo = [];
var aa = 0;
var dp = 4;
var Yy = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let i = aa + dp; i < qo.length; )
          qo[i] === n ? qo.splice(i, dp) : i += dp;
        let o = t.indexOf(n);
        ~o && (t.splice(o, 1), --r.lc || r.off());
      };
    },
    notify(n, o) {
      let i = !qo.length;
      for (let s of t)
        qo.push(
          s,
          r.value,
          n,
          o
        );
      if (i) {
        for (aa = 0; aa < qo.length; aa += dp)
          qo[aa](
            qo[aa + 1],
            qo[aa + 2],
            qo[aa + 3]
          );
        qo.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let o = r.value;
      o !== n && (r.value = n, r.notify(o));
    },
    subscribe(n) {
      let o = r.listen(n);
      return n(r.value), o;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[Xy] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
var HC = 5;
var al = 6;
var hp = 10;
var LC = (e, t, r, n) => (e.events = e.events || {}, e.events[r + hp] || (e.events[r + hp] = n((o) => {
  e.events[r].reduceRight((i, s) => (s(i), i), {
    shared: {},
    ...o
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let o = e.events[r], i = o.indexOf(t);
  o.splice(i, 1), o.length || (delete e.events[r], e.events[r + hp](), delete e.events[r + hp]);
});
var jC = 1e3;
var FC = (e, t) => LC(e, (n) => {
  let o = t(n);
  o && e.events[al].push(o);
}, HC, (n) => {
  let o = e.listen;
  e.listen = (...s) => (!e.lc && !e.active && (e.active = true, n()), o(...s));
  let i = e.off;
  if (e.events[al] = [], e.off = () => {
    i(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = false;
        for (let s of e.events[al]) s();
        e.events[al] = [];
      }
    }, jC);
  }, process.env.NODE_ENV !== "production") {
    let s = e[Xy];
    e[Xy] = () => {
      for (let a of e.events[al]) a();
      e.events[al] = [], e.active = false, s();
    };
  }
  return () => {
    e.listen = o, e.off = i;
  };
});
var DC = (e) => {
  e.listen(() => {
  });
};
function Eo(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((o, i, s) => {
    n.has(s) && r(o, i, s);
  });
}
var kx = (e = {}) => {
  let t = Yy(e);
  return t.setKey = function(r, n) {
    let o = t.value;
    typeof n > "u" && r in t.value ? (t.value = { ...t.value }, delete t.value[r], t.notify(o, r)) : t.value[r] !== n && (t.value = {
      ...t.value,
      [r]: n
    }, t.notify(o, r));
  }, t;
};
var xl = "oyl";
var Vc = "unisat";
var Gc = "glittr";
var Wc = "xverse";
var Zc = "phantom";
var kl = "leather";
var oc = "magic-eden";
var Al = "okx";
var Sl = "wizz";
var Xc = "orange";
var Yc = "op_net";
var Jc = "sparrow";
var bd = "p2tr";
var KC = "p2pkh";
var MC = "p2sh-p2wpkh";
var Jy = "p2wpkh";
var Kye = "p2psh";
var qC = "p2wsh";
var Ax = "p2sh";
var qt;
(function(e) {
  e.LEATHER = "leather", e.MAGIC_EDEN = "magic-eden", e.OKX = "okx", e.OP_NET = "op_net", e.ORANGE = "orange", e.OYL = "oyl", e.SPARROW = "sparrow", e.PHANTOM = "phantom", e.UNISAT = "unisat", e.WIZZ = "wizz", e.XVERSE = "xverse", e.GLITTR = "glittr";
})(qt || (qt = {}));
var Mye = {
  [qt.LEATHER]: {
    name: qt.LEATHER,
    url: "https://leather.io/install-extension"
  },
  [qt.MAGIC_EDEN]: {
    name: qt.MAGIC_EDEN,
    url: "https://wallet.magiceden.io/"
  },
  [qt.OKX]: {
    name: qt.OKX,
    url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge"
  },
  [qt.OP_NET]: {
    name: qt.OP_NET,
    url: "https://opnet.org/"
  },
  [qt.ORANGE]: {
    name: qt.ORANGE,
    url: "https://www.orangewallet.com/"
  },
  [qt.OYL]: {
    name: qt.OYL,
    url: "https://www.oyl.io/#get-wallet"
  },
  [qt.PHANTOM]: {
    name: qt.PHANTOM,
    url: "https://phantom.app/download"
  },
  [qt.SPARROW]: {
    name: qt.SPARROW,
    url: "https://sparrowwallet.com/"
  },
  [qt.UNISAT]: {
    name: qt.UNISAT,
    url: "https://unisat.io/download"
  },
  [qt.WIZZ]: {
    name: qt.WIZZ,
    url: "https://wizzwallet.io/#extension"
  },
  [qt.XVERSE]: {
    name: qt.XVERSE,
    url: "https://www.xverse.app/download"
  },
  [qt.GLITTR]: {
    name: qt.GLITTR,
    url: "https://glittr.fi"
  }
};
var fb = "defaultWallet";
var Ei = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
var VC = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function GC(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return false;
  const t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return false;
  const r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function WC(e) {
  if (e.length < 8) throw new Error("DER sequence length is too short");
  if (e.length > 72) throw new Error("DER sequence length is too long");
  if (e[0] !== 48) throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2)
    throw new Error("DER sequence length is invalid");
  if (e[2] !== 2) throw new Error("Expected DER integer");
  const t = e[3];
  if (t === 0) throw new Error("R length is zero");
  if (5 + t >= e.length) throw new Error("R length is too long");
  if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
  const r = e[5 + t];
  if (r === 0) throw new Error("S length is zero");
  if (6 + t + r !== e.length) throw new Error("S length is invalid");
  if (e[4] & 128) throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128) throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.slice(4, 4 + t),
    s: e.slice(6 + t)
  };
}
function ZC(e, t) {
  const r = e.length, n = t.length;
  if (r === 0) throw new Error("R length is zero");
  if (n === 0) throw new Error("S length is zero");
  if (r > 33) throw new Error("R length is too long");
  if (n > 33) throw new Error("S length is too long");
  if (e[0] & 128) throw new Error("R value is negative");
  if (t[0] & 128) throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128))
    throw new Error("R value excessively padded");
  if (n > 1 && t[0] === 0 && !(t[1] & 128))
    throw new Error("S value excessively padded");
  const o = new Uint8Array(6 + r + n);
  return o[0] = 48, o[1] = o.length - 2, o[2] = 2, o[3] = e.length, o.set(e, 4), o[4 + r] = 2, o[5 + r] = t.length, o.set(t, 6 + r), o;
}
var Rt = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
var Sx = {};
for (const e of Object.keys(Rt)) {
  const t = Rt[e];
  Sx[t] = e;
}
var k0 = "0123456789abcdefABCDEF";
var A0 = k0.split("").map((e) => e.codePointAt(0));
var S0 = Array(256).fill(true).map((e, t) => {
  const r = String.fromCodePoint(t), n = k0.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
var _x = new TextEncoder();
var Tx = new TextDecoder();
function XC(e) {
  return Tx.decode(e);
}
function YC(e) {
  return _x.encode(e);
}
function fr(e) {
  const t = e.reduce((o, i) => o + i.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function Fe(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? QC(t) : JC(t);
}
function JC(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += k0[S0[A0[e[r] >> 4]]], t += k0[S0[A0[e[r] & 15]]];
  return t;
}
function QC(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = A0[e[r] >> 4], t[r * 2 + 1] = A0[e[r] & 15];
  return Tx.decode(t);
}
function Js(e) {
  const t = _x.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = S0[t[n * 2]], i = S0[t[n * 2 + 1]];
    if (o === void 0 || i === void 0)
      break;
    r[n] = o << 4 | i;
  }
  return n === r.length ? r : r.slice(0, n);
}
function eN(e) {
  return btoa(String.fromCharCode(...e));
}
function Px(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
function fe(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function ho(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function tN(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function Ah(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function rN(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function Ks(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function nN(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Ef(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function Ix(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function Ox(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function oN(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? n : n - 4294967296;
  } else {
    const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? n : n - 4294967296;
  }
}
function Bx(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let n = 0n;
  if (r === "LE")
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
  {
    let o = 0n;
    return o = (o << 8n) + BigInt(e[t]), o = (o << 8n) + BigInt(e[t + 1]), o = (o << 8n) + BigInt(e[t + 2]), o = (o << 8n) + BigInt(e[t + 3]), o = (o << 8n) + BigInt(e[t + 4]), o = (o << 8n) + BigInt(e[t + 5]), o = (o << 8n) + BigInt(e[t + 6]), o = (o << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? o : o - 0x10000000000000000n;
  }
}
function Cx(e) {
  return e < Rt.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function iN(e, t, r) {
  const n = Cx(t);
  return n === 1 ? ho(e, r, t) : n === 2 ? (ho(e, r, Rt.OP_PUSHDATA1), ho(e, r + 1, t)) : n === 3 ? (ho(e, r, Rt.OP_PUSHDATA2), tN(e, r + 1, t, "LE")) : (ho(e, r, Rt.OP_PUSHDATA4), Ah(e, r + 1, t, "LE")), n;
}
function sN(e, t) {
  const r = Ks(e, t);
  let n, o;
  if (r < Rt.OP_PUSHDATA1)
    n = r, o = 1;
  else if (r === Rt.OP_PUSHDATA1) {
    if (t + 2 > e.length) return null;
    n = Ks(e, t + 1), o = 2;
  } else if (r === Rt.OP_PUSHDATA2) {
    if (t + 3 > e.length) return null;
    n = nN(e, t + 1, "LE"), o = 3;
  } else {
    if (t + 5 > e.length) return null;
    if (r !== Rt.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    n = Ef(e, t + 1, "LE"), o = 5;
  }
  return {
    opcode: r,
    number: n,
    size: o
  };
}
function aN(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function cN(e) {
  let t = Math.abs(e);
  const r = aN(t), n = new Uint8Array(r), o = e < 0;
  for (let i = 0; i < r; ++i)
    ho(n, i, t & 255), t >>= 8;
  return n[r - 1] & 128 ? ho(n, r - 1, o ? 128 : 0) : o && (n[r - 1] |= 128), n;
}
var ps;
function uN(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? (ps == null ? void 0 : ps.lang),
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (ps == null ? void 0 : ps.abortEarly),
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (ps == null ? void 0 : ps.abortPipeEarly)
  };
}
var db;
function lN(e) {
  return db == null ? void 0 : db.get(e);
}
var hb;
function fN(e) {
  return hb == null ? void 0 : hb.get(e);
}
var pb;
function dN(e, t) {
  var r;
  return (r = pb == null ? void 0 : pb.get(e)) == null ? void 0 : r.get(t);
}
function Od(e) {
  var r, n;
  const t = typeof e;
  return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function vn(e, t, r, n, o) {
  const i = o && "input" in o ? o.input : r.value, s = (o == null ? void 0 : o.expected) ?? e.expects ?? null, a = (o == null ? void 0 : o.received) ?? Od(i), c = {
    kind: e.kind,
    type: e.type,
    input: i,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", l = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? dN(e.reference, c.lang) ?? (u ? fN(c.lang) : null) ?? n.message ?? lN(c.lang);
  l && (c.message = typeof l == "function" ? l(c) : l), u && (r.typed = false), r.issues ? r.issues.push(c) : r.issues = [c];
}
function hN(e, t) {
  const r = [...new Set(e)];
  return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var pN = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(r) {
    super(r[0].message);
    Pt(this, "issues");
    this.name = "ValiError", this.issues = r;
  }
};
function Nx(e, t) {
  return {
    kind: "validation",
    type: "every_item",
    reference: Nx,
    async: false,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.every(this.requirement) && vn(this, "item", r, n), r;
    }
  };
}
function Q2(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: Q2,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && vn(this, "integer", t, r), t;
    }
  };
}
function Ux(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: Ux,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && vn(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function t1(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: t1,
    async: false,
    expects: `<=${e instanceof Date ? e.toJSON() : Od(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && vn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Od(r.value)
      }), r;
    }
  };
}
function r1(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: r1,
    async: false,
    expects: `>=${e instanceof Date ? e.toJSON() : Od(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && vn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Od(r.value)
      }), r;
    }
  };
}
function $x(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: $x,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && vn(this, "format", r, n), r;
    }
  };
}
function ev(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function n1(e, t) {
  return !e._run({ typed: false, value: t }, { abortEarly: true }).issues;
}
function Rx() {
  return {
    kind: "schema",
    type: "any",
    reference: Rx,
    expects: "any",
    async: false,
    _run(e) {
      return e.typed = true, e;
    }
  };
}
function qn(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: qn,
    expects: "Array",
    async: false,
    item: e,
    message: t,
    _run(r, n) {
      var i;
      const o = r.value;
      if (Array.isArray(o)) {
        r.typed = true, r.value = [];
        for (let s = 0; s < o.length; s++) {
          const a = o[s], c = this.item._run({ typed: false, value: a }, n);
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: o,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (i = r.issues) == null || i.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), r.value.push(c.value);
        }
      } else
        vn(this, "type", r, n);
      return r;
    }
  };
}
function zx(e) {
  return {
    kind: "schema",
    type: "bigint",
    reference: zx,
    expects: "bigint",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "bigint" ? t.typed = true : vn(this, "type", t, r), t;
    }
  };
}
function hi(e, t) {
  return {
    kind: "schema",
    type: "custom",
    reference: hi,
    expects: "unknown",
    async: false,
    check: e,
    message: t,
    _run(r, n) {
      return this.check(r.value) ? r.typed = true : vn(this, "type", r, n), r;
    }
  };
}
function o1(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: o1,
    expects: e.name,
    async: false,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = true : vn(this, "type", r, n), r;
    }
  };
}
function Qy(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullable",
    reference: Qy,
    expects: `(${e.expects} | null)`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return n.value === null && ("default" in this && (n.value = ev(
        this,
        n,
        o
      )), n.value === null) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Hx(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: Hx,
    expects: `(${e.expects} | null | undefined)`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = ev(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Kn(e) {
  return {
    kind: "schema",
    type: "number",
    reference: Kn,
    expects: "number",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : vn(this, "type", t, r), t;
    }
  };
}
function Or(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Or,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var i;
      const o = r.value;
      if (o && typeof o == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = o[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: o,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (i = r.issues) == null || i.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in o) && (r.value[s] = c.value);
        }
      } else
        vn(this, "type", r, n);
      return r;
    }
  };
}
function _0(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: _0,
    expects: `(${e.expects} | undefined)`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = ev(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Mu(e) {
  return {
    kind: "schema",
    type: "string",
    reference: Mu,
    expects: "string",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = true : vn(this, "type", t, r), t;
    }
  };
}
function Fi(e, t) {
  return {
    kind: "schema",
    type: "tuple",
    reference: Fi,
    expects: "Array",
    async: false,
    items: e,
    message: t,
    _run(r, n) {
      var i;
      const o = r.value;
      if (Array.isArray(o)) {
        r.typed = true, r.value = [];
        for (let s = 0; s < this.items.length; s++) {
          const a = o[s], c = this.items[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: o,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (i = r.issues) == null || i.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), r.value.push(c.value);
        }
      } else
        vn(this, "type", r, n);
      return r;
    }
  };
}
function k5(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function tv(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: tv,
    expects: hN(
      e.map((r) => r.expects),
      "|"
    ),
    async: false,
    options: e,
    message: t,
    _run(r, n) {
      let o, i, s;
      for (const a of this.options) {
        const c = a._run(
          { typed: false, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            i ? i.push(c) : i = [c];
          else {
            o = c;
            break;
          }
        else
          s ? s.push(c) : s = [c];
      }
      if (o)
        return o;
      if (i) {
        if (i.length === 1)
          return i[0];
        vn(this, "type", r, n, {
          issues: k5(i)
        }), r.typed = true;
      } else {
        if ((s == null ? void 0 : s.length) === 1)
          return s[0];
        vn(this, "type", r, n, {
          issues: k5(s)
        });
      }
      return r;
    }
  };
}
function nr(e, t, r) {
  const n = e._run(
    { typed: false, value: t },
    uN(r)
  );
  if (n.issues)
    throw new pN(n.issues);
  return n.value;
}
function bc(e, t) {
  const r = {};
  for (const n in e.entries)
    r[n] = _0(e.entries[n]);
  return { ...e, entries: r };
}
function xf(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = false;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
var A5 = new Uint8Array(32);
var S5 = Js(
  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
);
var Fr = (e) => xf(o1(Uint8Array), Ux(e));
function Bd(e, t) {
  return e.length !== t.length ? false : e.every((r, n) => fe(r, t[n]) === 0);
}
function ni(e) {
  if (!(e instanceof Uint8Array) || e.length < 33) return false;
  const t = e[0], r = e.slice(1, 33);
  if (fe(A5, r) === 0 || fe(r, S5) >= 0) return false;
  if ((t === 2 || t === 3) && e.length === 33)
    return true;
  const n = e.slice(33);
  return fe(A5, n) === 0 || fe(n, S5) >= 0 ? false : t === 4 && e.length === 65;
}
var a0 = 254;
function rv(e) {
  return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? false : e.version !== void 0 ? (e.version & a0) === e.version : true;
}
function Lx(e) {
  return Array.isArray(e) ? e.length !== 2 ? false : e.every((t) => Lx(t)) : rv(e);
}
var gN = Fr(32);
var mN = Fr(20);
var _5 = Fr(32);
var Ut = o1(Uint8Array);
xf(Mu(), $x(/^([0-9a-f]{2})+$/i));
var bN = xf(
  Kn(),
  Q2(),
  r1(0),
  t1(255)
);
var _s = xf(
  Kn(),
  Q2(),
  r1(0),
  t1(4294967295)
);
var gb = xf(
  zx(),
  r1(0n),
  t1(0x7fffffffffffffffn)
);
var T5 = (e) => Or(
  Object.entries(e).reduce(
    (t, r) => ({ ...t, [r[0]]: Hx(r[1]) }),
    {}
  )
);
var P5 = new Uint8Array(1);
function I5(e) {
  let t = 0;
  for (; e[t] === 0; ) ++t;
  return t === e.length ? P5 : (e = e.slice(t), e[0] & 128 ? fr([P5, e]) : e);
}
function O5(e) {
  e[0] === 0 && (e = e.slice(1));
  const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
  return t.set(e, r), t;
}
function yN(e) {
  const t = Ks(e, e.length - 1);
  if (!ov(t))
    throw new Error("Invalid hashType " + t);
  const r = WC(e.subarray(0, -1)), n = O5(r.r), o = O5(r.s);
  return { signature: fr([n, o]), hashType: t };
}
function wN(e, t) {
  if (nr(
    Or({
      signature: Fr(64),
      hashType: bN
    }),
    { signature: e, hashType: t }
  ), !ov(t))
    throw new Error("Invalid hashType " + t);
  const r = new Uint8Array(1);
  ho(r, 0, t);
  const n = I5(e.slice(0, 32)), o = I5(e.slice(32, 64));
  return fr([ZC(n, o), r]);
}
var vN = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: yN,
  encode: wN
}, Symbol.toStringTag, { value: "Module" }));
var jx = Rt.OP_RESERVED;
var Fx = qn(tv([o1(Uint8Array), Kn()]));
function EN(e) {
  return n1(Kn(), e) && (e === Rt.OP_0 || e >= Rt.OP_1 && e <= Rt.OP_16 || e === Rt.OP_1NEGATE);
}
function Dx(e) {
  return n1(Ut, e) || EN(e);
}
function nv(e) {
  return n1(xf(Rx(), Nx(Dx)), e);
}
function Kx(e) {
  return e.length - e.filter(Dx).length;
}
function T0(e) {
  if (e.length === 0) return Rt.OP_0;
  if (e.length === 1) {
    if (e[0] >= 1 && e[0] <= 16) return jx + e[0];
    if (e[0] === 129) return Rt.OP_1NEGATE;
  }
}
function Mx(e) {
  return e instanceof Uint8Array;
}
function xN(e) {
  return n1(Fx, e);
}
function P0(e) {
  return e instanceof Uint8Array;
}
function Vn(e) {
  if (Mx(e)) return e;
  nr(Fx, e);
  const t = e.reduce((o, i) => P0(i) ? i.length === 1 && T0(i) !== void 0 ? o + 1 : o + Cx(i.length) + i.length : o + 1, 0), r = new Uint8Array(t);
  let n = 0;
  if (e.forEach((o) => {
    if (P0(o)) {
      const i = T0(o);
      if (i !== void 0) {
        ho(r, n, i), n += 1;
        return;
      }
      n += iN(r, o.length, n), r.set(o, n), n += o.length;
    } else
      ho(r, n, o), n += 1;
  }), n !== r.length) throw new Error("Could not decode chunks");
  return r;
}
function ar(e) {
  if (xN(e)) return e;
  nr(Ut, e);
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const n = e[r];
    if (n > Rt.OP_0 && n <= Rt.OP_PUSHDATA4) {
      const o = sN(e, r);
      if (o === null || (r += o.size, r + o.number > e.length)) return null;
      const i = e.slice(r, r + o.number);
      r += o.number;
      const s = T0(i);
      s !== void 0 ? t.push(s) : t.push(i);
    } else
      t.push(n), r += 1;
  }
  return t;
}
function kN(e) {
  if (Mx(e) && (e = ar(e)), !e)
    throw new Error("Could not convert invalid chunks to ASM");
  return e.map((t) => {
    if (P0(t)) {
      const r = T0(t);
      if (r === void 0) return Fe(t);
      t = r;
    }
    return Sx[t];
  }).join(" ");
}
function AN(e) {
  return e = ar(e), nr(hi(nv), e), e.map((t) => P0(t) ? t : t === Rt.OP_0 ? new Uint8Array(0) : cN(t - jx));
}
function SN(e) {
  return ni(e);
}
function ov(e) {
  const t = e & -129;
  return t > 0 && t < 4;
}
function Ms(e) {
  return !(e instanceof Uint8Array) || !ov(e[e.length - 1]) ? false : GC(e.slice(0, -1));
}
var yd = vN;
function Ce(e, t, r) {
  Object.defineProperty(e, t, {
    configurable: true,
    enumerable: true,
    get() {
      const n = r.call(this);
      return this[t] = n, n;
    },
    set(n) {
      Object.defineProperty(this, t, {
        configurable: true,
        enumerable: true,
        value: n,
        writable: true
      });
    }
  });
}
function Ho(e) {
  let t;
  return () => (t !== void 0 || (t = e()), t);
}
var ml = Rt;
var pp = ml.OP_RESERVED;
function i1(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {});
  function r(c) {
    return Ms(c) || (t.allowIncomplete && c === ml.OP_0) !== void 0;
  }
  nr(
    bc(
      Or({
        network: Or({}),
        m: Kn(),
        n: Kn(),
        output: Ut,
        pubkeys: qn(hi(ni), "Received invalid pubkey"),
        signatures: qn(
          hi(r),
          "Expected signature to be of type isAcceptableSignature"
        ),
        input: Ut
      })
    ),
    e
  );
  const o = { network: e.network || Ei };
  let i = [], s = false;
  function a(c) {
    s || (s = true, i = ar(c), o.m = i[0] - pp, o.n = i[i.length - 2] - pp, o.pubkeys = i.slice(1, -2));
  }
  if (Ce(o, "output", () => {
    if (e.m && o.n && e.pubkeys)
      return Vn(
        [].concat(
          pp + e.m,
          e.pubkeys,
          pp + o.n,
          ml.OP_CHECKMULTISIG
        )
      );
  }), Ce(o, "m", () => {
    if (o.output)
      return a(o.output), o.m;
  }), Ce(o, "n", () => {
    if (o.pubkeys)
      return o.pubkeys.length;
  }), Ce(o, "pubkeys", () => {
    if (e.output)
      return a(e.output), o.pubkeys;
  }), Ce(o, "signatures", () => {
    if (e.input)
      return ar(e.input).slice(1);
  }), Ce(o, "input", () => {
    if (e.signatures)
      return Vn([ml.OP_0].concat(e.signatures));
  }), Ce(o, "witness", () => {
    if (o.input)
      return [];
  }), Ce(o, "name", () => {
    if (!(!o.m || !o.n))
      return `p2ms(${o.m} of ${o.n})`;
  }), t.validate) {
    if (e.output) {
      if (a(e.output), nr(Kn(), i[0], { message: "Output is invalid" }), nr(Kn(), i[i.length - 2], {
        message: "Output is invalid"
      }), i[i.length - 1] !== ml.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== i.length - 3)
        throw new TypeError("Output is invalid");
      if (!o.pubkeys.every((c) => ni(c)))
        throw new TypeError("Output is invalid");
      if (e.m !== void 0 && e.m !== o.m) throw new TypeError("m mismatch");
      if (e.n !== void 0 && e.n !== o.n) throw new TypeError("n mismatch");
      if (e.pubkeys && !Bd(e.pubkeys, o.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (e.pubkeys) {
      if (e.n !== void 0 && e.n !== e.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (o.n = e.pubkeys.length, o.n < o.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (e.signatures) {
      if (e.signatures.length < o.m)
        throw new TypeError("Not enough signatures provided");
      if (e.signatures.length > o.m)
        throw new TypeError("Too many signatures provided");
    }
    if (e.input) {
      if (e.input[0] !== ml.OP_0) throw new TypeError("Input is invalid");
      if (o.signatures.length === 0 || !o.signatures.every(r))
        throw new TypeError("Input has invalid signature(s)");
      if (e.signatures && !Bd(e.signatures, o.signatures))
        throw new TypeError("Signature mismatch");
      if (e.m !== void 0 && e.m !== e.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(o, e);
}
var B5 = Rt;
function qx(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), nr(
    bc(
      Or({
        network: Or({}),
        output: Ut,
        pubkey: hi(ni, "invalid pubkey"),
        signature: hi(
          Ms,
          "Expected signature to be of type isCanonicalScriptSignature"
        ),
        input: Ut
      })
    ),
    e
  );
  const r = Ho(() => ar(e.input)), o = { name: "p2pk", network: e.network || Ei };
  if (Ce(o, "output", () => {
    if (e.pubkey)
      return Vn([e.pubkey, B5.OP_CHECKSIG]);
  }), Ce(o, "pubkey", () => {
    if (e.output)
      return e.output.slice(1, -1);
  }), Ce(o, "signature", () => {
    if (e.input)
      return r()[0];
  }), Ce(o, "input", () => {
    if (e.signature)
      return Vn([e.signature]);
  }), Ce(o, "witness", () => {
    if (o.input)
      return [];
  }), t.validate) {
    if (e.output) {
      if (e.output[e.output.length - 1] !== B5.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!ni(o.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (e.pubkey && fe(e.pubkey, o.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
    }
    if (e.signature && e.input && fe(e.input, o.input) !== 0)
      throw new TypeError("Signature mismatch");
    if (e.input) {
      if (r().length !== 1) throw new TypeError("Input is invalid");
      if (!Ms(o.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(o, e);
}
function C5(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function _N(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function s1(e, ...t) {
  if (!_N(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function TN(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  C5(e.outputLen), C5(e.blockLen);
}
function I0(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function PN(e, t) {
  s1(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var cl = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var mb = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Ti = (e, t) => e << 32 - t | e >>> t;
var gp = (e, t) => e << t | e >>> 32 - t >>> 0;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function IN(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function iv(e) {
  return typeof e == "string" && (e = IN(e)), s1(e), e;
}
function ON(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    s1(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const i = e[n];
    r.set(i, o), o += i.length;
  }
  return r;
}
var Vx = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function sv(e) {
  const t = (n) => e().update(iv(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function BN(e = 32) {
  if (cl && typeof cl.getRandomValues == "function")
    return cl.getRandomValues(new Uint8Array(e));
  if (cl && typeof cl.randomBytes == "function")
    return cl.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function CN(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var NN = (e, t, r) => e & t ^ ~e & r;
var UN = (e, t, r) => e & t ^ e & r ^ t & r;
var av = class extends Vx {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = mb(this.buffer);
  }
  update(t) {
    I0(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = iv(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = mb(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    I0(this), PN(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    CN(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = mb(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
var $N = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Gx = new Uint8Array(new Array(16).fill(0).map((e, t) => t));
var RN = Gx.map((e) => (9 * e + 5) % 16);
var cv = [Gx];
var uv = [RN];
for (let e = 0; e < 4; e++)
  for (let t of [cv, uv])
    t.push(t[e].map((r) => $N[r]));
var Wx = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e));
var zN = cv.map((e, t) => e.map((r) => Wx[t][r]));
var HN = uv.map((e, t) => e.map((r) => Wx[t][r]));
var LN = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var jN = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function N5(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
var mp = new Uint32Array(16);
var FN = class extends av {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: o, h4: i } = this;
    return [t, r, n, o, i];
  }
  set(t, r, n, o, i) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = o | 0, this.h4 = i | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4)
      mp[m] = t.getUint32(r, true);
    let n = this.h0 | 0, o = n, i = this.h1 | 0, s = i, a = this.h2 | 0, c = a, u = this.h3 | 0, l = u, f = this.h4 | 0, d = f;
    for (let m = 0; m < 5; m++) {
      const y = 4 - m, b = LN[m], w = jN[m], v = cv[m], k = uv[m], x = zN[m], _ = HN[m];
      for (let I = 0; I < 16; I++) {
        const P = gp(n + N5(m, i, a, u) + mp[v[I]] + b, x[I]) + f | 0;
        n = f, f = u, u = gp(a, 10) | 0, a = i, i = P;
      }
      for (let I = 0; I < 16; I++) {
        const P = gp(o + N5(y, s, c, l) + mp[k[I]] + w, _[I]) + d | 0;
        o = d, d = l, l = gp(c, 10) | 0, c = s, s = P;
      }
    }
    this.set(this.h1 + a + l | 0, this.h2 + u + d | 0, this.h3 + f + o | 0, this.h4 + n + s | 0, this.h0 + i + c | 0);
  }
  roundClean() {
    mp.fill(0);
  }
  destroy() {
    this.destroyed = true, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
var Zx = sv(() => new FN());
var DN = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var ca = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var ua = new Uint32Array(64);
var KN = class extends av {
  constructor() {
    super(64, 32, 8, false), this.A = ca[0] | 0, this.B = ca[1] | 0, this.C = ca[2] | 0, this.D = ca[3] | 0, this.E = ca[4] | 0, this.F = ca[5] | 0, this.G = ca[6] | 0, this.H = ca[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      ua[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = ua[f - 15], m = ua[f - 2], y = Ti(d, 7) ^ Ti(d, 18) ^ d >>> 3, b = Ti(m, 17) ^ Ti(m, 19) ^ m >>> 10;
      ua[f] = b + ua[f - 7] + y + ua[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = Ti(a, 6) ^ Ti(a, 11) ^ Ti(a, 25), m = l + d + NN(a, c, u) + DN[f] + ua[f] | 0, b = (Ti(n, 2) ^ Ti(n, 13) ^ Ti(n, 22)) + UN(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + b | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    ua.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Qr = sv(() => new KN());
function zs(e) {
  return Zx(Qr(e));
}
function Dc(e) {
  return Qr(Qr(e));
}
var MN = {
  "BIP0340/challenge": Uint8Array.from([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": Uint8Array.from([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": Uint8Array.from([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: Uint8Array.from([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: Uint8Array.from([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: Uint8Array.from([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: Uint8Array.from([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": Uint8Array.from([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": Uint8Array.from([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function a1(e, t) {
  return Qr(fr([MN[e], t]));
}
function qN(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let u = 0; u < t.length; u++)
    t[u] = 255;
  for (let u = 0; u < e.length; u++) {
    const l = e.charAt(u), f = l.charCodeAt(0);
    if (t[f] !== 255)
      throw new TypeError(l + " is ambiguous");
    t[f] = u;
  }
  const r = e.length, n = e.charAt(0), o = Math.log(r) / Math.log(256), i = Math.log(256) / Math.log(r);
  function s(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u.length === 0)
      return "";
    let l = 0, f = 0, d = 0;
    const m = u.length;
    for (; d !== m && u[d] === 0; )
      d++, l++;
    const y = (m - d) * i + 1 >>> 0, b = new Uint8Array(y);
    for (; d !== m; ) {
      let k = u[d], x = 0;
      for (let _ = y - 1; (k !== 0 || x < f) && _ !== -1; _--, x++)
        k += 256 * b[_] >>> 0, b[_] = k % r >>> 0, k = k / r >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      f = x, d++;
    }
    let w = y - f;
    for (; w !== y && b[w] === 0; )
      w++;
    let v = n.repeat(l);
    for (; w < y; ++w)
      v += e.charAt(b[w]);
    return v;
  }
  function a(u) {
    if (typeof u != "string")
      throw new TypeError("Expected String");
    if (u.length === 0)
      return new Uint8Array();
    let l = 0, f = 0, d = 0;
    for (; u[l] === n; )
      f++, l++;
    const m = (u.length - l) * o + 1 >>> 0, y = new Uint8Array(m);
    for (; u[l]; ) {
      let k = t[u.charCodeAt(l)];
      if (k === 255)
        return;
      let x = 0;
      for (let _ = m - 1; (k !== 0 || x < d) && _ !== -1; _--, x++)
        k += r * y[_] >>> 0, y[_] = k % 256 >>> 0, k = k / 256 >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      d = x, l++;
    }
    let b = m - d;
    for (; b !== m && y[b] === 0; )
      b++;
    const w = new Uint8Array(f + (m - b));
    let v = f;
    for (; b !== m; )
      w[v++] = y[b++];
    return w;
  }
  function c(u) {
    const l = a(u);
    if (l)
      return l;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: a,
    decode: c
  };
}
var VN = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bb = qN(VN);
function GN(e) {
  function t(i) {
    var s = Uint8Array.from(i), a = e(s), c = s.length + 4, u = new Uint8Array(c);
    return u.set(s, 0), u.set(a.subarray(0, 4), s.length), bb.encode(u);
  }
  function r(i) {
    var s = i.slice(0, -4), a = i.slice(-4), c = e(s);
    if (!(a[0] ^ c[0] | a[1] ^ c[1] | a[2] ^ c[2] | a[3] ^ c[3]))
      return s;
  }
  function n(i) {
    var s = bb.decodeUnsafe(i);
    if (s != null)
      return r(s);
  }
  function o(i) {
    var s = bb.decode(i), a = r(s);
    if (a == null)
      throw new Error("Invalid checksum");
    return a;
  }
  return {
    encode: t,
    decode: o,
    decodeUnsafe: n
  };
}
function WN(e) {
  return Qr(Qr(e));
}
var Dl = GN(WN);
var la = Rt;
function Sh(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), nr(
    bc(
      Or({
        network: Or({}),
        address: Mu(),
        hash: mN,
        output: Fr(25),
        pubkey: hi(ni),
        signature: hi(Ms),
        input: Ut
      })
    ),
    e
  );
  const r = Ho(() => {
    const s = Dl.decode(e.address), a = Ks(s, 0), c = s.slice(1);
    return { version: a, hash: c };
  }), n = Ho(() => ar(e.input)), o = e.network || Ei, i = { name: "p2pkh", network: o };
  if (Ce(i, "address", () => {
    if (!i.hash) return;
    const s = new Uint8Array(21);
    return ho(s, 0, o.pubKeyHash), s.set(i.hash, 1), Dl.encode(s);
  }), Ce(i, "hash", () => {
    if (e.output) return e.output.slice(3, 23);
    if (e.address) return r().hash;
    if (e.pubkey || i.pubkey) return zs(e.pubkey || i.pubkey);
  }), Ce(i, "output", () => {
    if (i.hash)
      return Vn([
        la.OP_DUP,
        la.OP_HASH160,
        i.hash,
        la.OP_EQUALVERIFY,
        la.OP_CHECKSIG
      ]);
  }), Ce(i, "pubkey", () => {
    if (e.input)
      return n()[1];
  }), Ce(i, "signature", () => {
    if (e.input)
      return n()[0];
  }), Ce(i, "input", () => {
    if (e.pubkey && e.signature)
      return Vn([e.signature, e.pubkey]);
  }), Ce(i, "witness", () => {
    if (i.input)
      return [];
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (r().version !== o.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r().hash.length !== 20) throw new TypeError("Invalid address");
      s = r().hash;
    }
    if (e.hash) {
      if (s.length > 0 && fe(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 25 || e.output[0] !== la.OP_DUP || e.output[1] !== la.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== la.OP_EQUALVERIFY || e.output[24] !== la.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const a = e.output.slice(3, 23);
      if (s.length > 0 && fe(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.pubkey) {
      const a = zs(e.pubkey);
      if (s.length > 0 && fe(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.input) {
      const a = n();
      if (a.length !== 2) throw new TypeError("Input is invalid");
      if (!Ms(a[0]))
        throw new TypeError("Input has invalid signature");
      if (!ni(a[1])) throw new TypeError("Input has invalid pubkey");
      if (e.signature && fe(e.signature, a[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && fe(e.pubkey, a[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const c = zs(a[1]);
      if (s.length > 0 && fe(s, c) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(i, e);
}
var Xf = Rt;
function kf(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), nr(
    bc(
      Or({
        network: Or({}),
        address: Mu(),
        hash: Fr(20),
        output: Fr(23),
        redeem: bc(
          Or({
            network: Or({}),
            output: Ut,
            input: Ut,
            witness: qn(Ut)
          })
        ),
        input: Ut,
        witness: qn(Ut)
      })
    ),
    e
  );
  let r = e.network;
  r || (r = e.redeem && e.redeem.network || Ei);
  const n = { network: r }, o = Ho(() => {
    const a = Dl.decode(e.address), c = Ks(a, 0), u = a.slice(1);
    return { version: c, hash: u };
  }), i = Ho(() => ar(e.input)), s = Ho(() => {
    const a = i(), c = a[a.length - 1];
    return {
      network: r,
      output: c === Xf.OP_FALSE ? Uint8Array.from([]) : c,
      input: Vn(a.slice(0, -1)),
      witness: e.witness || []
    };
  });
  if (Ce(n, "address", () => {
    if (!n.hash) return;
    const a = new Uint8Array(21);
    return ho(a, 0, n.network.scriptHash), a.set(n.hash, 1), Dl.encode(a);
  }), Ce(n, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return o().hash;
    if (n.redeem && n.redeem.output) return zs(n.redeem.output);
  }), Ce(n, "output", () => {
    if (n.hash)
      return Vn([Xf.OP_HASH160, n.hash, Xf.OP_EQUAL]);
  }), Ce(n, "redeem", () => {
    if (e.input)
      return s();
  }), Ce(n, "input", () => {
    if (!(!e.redeem || !e.redeem.input || !e.redeem.output))
      return Vn(
        [].concat(ar(e.redeem.input), e.redeem.output)
      );
  }), Ce(n, "witness", () => {
    if (n.redeem && n.redeem.witness) return n.redeem.witness;
    if (n.input) return [];
  }), Ce(n, "name", () => {
    const a = ["p2sh"];
    return n.redeem !== void 0 && n.redeem.name !== void 0 && a.push(n.redeem.name), a.join("-");
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (o().version !== r.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (o().hash.length !== 20) throw new TypeError("Invalid address");
      a = o().hash;
    }
    if (e.hash) {
      if (a.length > 0 && fe(a, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      a = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 23 || e.output[0] !== Xf.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== Xf.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const u = e.output.slice(2, 22);
      if (a.length > 0 && fe(a, u) !== 0)
        throw new TypeError("Hash mismatch");
      a = u;
    }
    const c = (u) => {
      if (u.output) {
        const l = ar(u.output);
        if (!l || l.length < 1)
          throw new TypeError("Redeem.output too short");
        if (u.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (Kx(l) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const f = zs(u.output);
        if (a.length > 0 && fe(a, f) !== 0)
          throw new TypeError("Hash mismatch");
        a = f;
      }
      if (u.input) {
        const l = u.input.length > 0, f = u.witness && u.witness.length > 0;
        if (!l && !f) throw new TypeError("Empty input");
        if (l && f)
          throw new TypeError("Input and witness provided");
        if (l) {
          const d = ar(u.input);
          if (!nv(d))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (e.input) {
      const u = i();
      if (!u || u.length < 1) throw new TypeError("Input too short");
      if (!(s().output instanceof Uint8Array))
        throw new TypeError("Input is invalid");
      c(s());
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== r)
        throw new TypeError("Network mismatch");
      if (e.input) {
        const u = s();
        if (e.redeem.output && fe(e.redeem.output, u.output) !== 0)
          throw new TypeError("Redeem.output mismatch");
        if (e.redeem.input && fe(e.redeem.input, u.input) !== 0)
          throw new TypeError("Redeem.input mismatch");
      }
      c(e.redeem);
    }
    if (e.witness && e.redeem && e.redeem.witness && !Bd(e.redeem.witness, e.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(n, e);
}
var Xe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ZN(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function XN(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: true }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: true,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var Cd = {};
Object.defineProperty(Cd, "__esModule", { value: true });
var Nd = Cd.bech32m = go = Cd.bech32 = void 0;
var O0 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var Xx = {};
for (let e = 0; e < O0.length; e++) {
  const t = O0.charAt(e);
  Xx[t] = e;
}
function Cl(e) {
  const t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function U5(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + e + ")";
    t = Cl(t) ^ n >> 5;
  }
  t = Cl(t);
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    t = Cl(t) ^ n & 31;
  }
  return t;
}
function lv(e, t, r, n) {
  let o = 0, i = 0;
  const s = (1 << r) - 1, a = [];
  for (let c = 0; c < e.length; ++c)
    for (o = o << t | e[c], i += t; i >= r; )
      i -= r, a.push(o >> i & s);
  if (n)
    i > 0 && a.push(o << r - i & s);
  else {
    if (i >= t)
      return "Excess padding";
    if (o << r - i & s)
      return "Non-zero padding";
  }
  return a;
}
function YN(e) {
  return lv(e, 8, 5, true);
}
function JN(e) {
  const t = lv(e, 5, 8, false);
  if (Array.isArray(t))
    return t;
}
function QN(e) {
  const t = lv(e, 5, 8, false);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function Yx(e) {
  let t;
  e === "bech32" ? t = 1 : t = 734539939;
  function r(s, a, c) {
    if (c = c || 90, s.length + 7 + a.length > c)
      throw new TypeError("Exceeds length limit");
    s = s.toLowerCase();
    let u = U5(s);
    if (typeof u == "string")
      throw new Error(u);
    let l = s + "1";
    for (let f = 0; f < a.length; ++f) {
      const d = a[f];
      if (d >> 5)
        throw new Error("Non 5-bit word");
      u = Cl(u) ^ d, l += O0.charAt(d);
    }
    for (let f = 0; f < 6; ++f)
      u = Cl(u);
    u ^= t;
    for (let f = 0; f < 6; ++f) {
      const d = u >> (5 - f) * 5 & 31;
      l += O0.charAt(d);
    }
    return l;
  }
  function n(s, a) {
    if (a = a || 90, s.length < 8)
      return s + " too short";
    if (s.length > a)
      return "Exceeds length limit";
    const c = s.toLowerCase(), u = s.toUpperCase();
    if (s !== c && s !== u)
      return "Mixed-case string " + s;
    s = c;
    const l = s.lastIndexOf("1");
    if (l === -1)
      return "No separator character for " + s;
    if (l === 0)
      return "Missing prefix for " + s;
    const f = s.slice(0, l), d = s.slice(l + 1);
    if (d.length < 6)
      return "Data too short";
    let m = U5(f);
    if (typeof m == "string")
      return m;
    const y = [];
    for (let b = 0; b < d.length; ++b) {
      const w = d.charAt(b), v = Xx[w];
      if (v === void 0)
        return "Unknown character " + w;
      m = Cl(m) ^ v, !(b + 6 >= d.length) && y.push(v);
    }
    return m !== t ? "Invalid checksum for " + s : { prefix: f, words: y };
  }
  function o(s, a) {
    const c = n(s, a);
    if (typeof c == "object")
      return c;
  }
  function i(s, a) {
    const c = n(s, a);
    if (typeof c == "object")
      return c;
    throw new Error(c);
  }
  return {
    decodeUnsafe: o,
    decode: i,
    encode: r,
    toWords: YN,
    fromWordsUnsafe: JN,
    fromWords: QN
  };
}
var go = Cd.bech32 = Yx("bech32");
Nd = Cd.bech32m = Yx("bech32m");
var $5 = Rt;
var eU = new Uint8Array(0);
function _h(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), nr(
    bc(
      Or({
        address: Mu(),
        hash: Fr(20),
        input: Fr(0),
        network: Or({}),
        output: Fr(22),
        pubkey: hi(ni, "Not a valid pubkey"),
        signature: hi(Ms),
        witness: qn(Ut)
      })
    ),
    e
  );
  const r = Ho(() => {
    const i = go.decode(e.address), s = i.words.shift(), a = go.fromWords(i.words);
    return {
      version: s,
      prefix: i.prefix,
      data: Uint8Array.from(a)
    };
  }), n = e.network || Ei, o = { name: "p2wpkh", network: n };
  if (Ce(o, "address", () => {
    if (!o.hash) return;
    const i = go.toWords(o.hash);
    return i.unshift(0), go.encode(n.bech32, i);
  }), Ce(o, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return r().data;
    if (e.pubkey || o.pubkey) return zs(e.pubkey || o.pubkey);
  }), Ce(o, "output", () => {
    if (o.hash)
      return Vn([$5.OP_0, o.hash]);
  }), Ce(o, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.witness)
      return e.witness[1];
  }), Ce(o, "signature", () => {
    if (e.witness)
      return e.witness[0];
  }), Ce(o, "input", () => {
    if (o.witness)
      return eU;
  }), Ce(o, "witness", () => {
    if (e.pubkey && e.signature)
      return [e.signature, e.pubkey];
  }), t.validate) {
    let i = Uint8Array.from([]);
    if (e.address) {
      if (n && n.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 20)
        throw new TypeError("Invalid address data");
      i = r().data;
    }
    if (e.hash) {
      if (i.length > 0 && fe(i, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 22 || e.output[0] !== $5.OP_0 || e.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (i.length > 0 && fe(i, e.output.slice(2)) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.output.slice(2);
    }
    if (e.pubkey) {
      const s = zs(e.pubkey);
      if (i.length > 0 && fe(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      if (i = s, !ni(e.pubkey) || e.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (e.witness) {
      if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!Ms(e.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!ni(e.witness[1]) || e.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (e.signature && fe(e.signature, e.witness[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && fe(e.pubkey, e.witness[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const s = zs(e.witness[1]);
      if (i.length > 0 && fe(i, s) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(o, e);
}
var R5 = Rt;
var yb = new Uint8Array(0);
function bp(e) {
  return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && ni(e));
}
function Th(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), nr(
    T5({
      network: Or({}),
      address: Mu(),
      hash: gN,
      output: Fr(34),
      redeem: T5({
        input: Ut,
        network: Or({}),
        output: Ut,
        witness: qn(Ut)
      }),
      input: Fr(0),
      witness: qn(Ut)
    }),
    e
  );
  const r = Ho(() => {
    const s = go.decode(e.address), a = s.words.shift(), c = go.fromWords(s.words);
    return {
      version: a,
      prefix: s.prefix,
      data: Uint8Array.from(c)
    };
  }), n = Ho(() => ar(e.redeem.input));
  let o = e.network;
  o || (o = e.redeem && e.redeem.network || Ei);
  const i = { network: o };
  if (Ce(i, "address", () => {
    if (!i.hash) return;
    const s = go.toWords(i.hash);
    return s.unshift(0), go.encode(o.bech32, s);
  }), Ce(i, "hash", () => {
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (i.redeem && i.redeem.output) return Qr(i.redeem.output);
  }), Ce(i, "output", () => {
    if (i.hash)
      return Vn([R5.OP_0, i.hash]);
  }), Ce(i, "redeem", () => {
    if (e.witness)
      return {
        output: e.witness[e.witness.length - 1],
        input: yb,
        witness: e.witness.slice(0, -1)
      };
  }), Ce(i, "input", () => {
    if (i.witness)
      return yb;
  }), Ce(i, "witness", () => {
    if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
      const s = AN(n());
      return i.redeem = Object.assign({ witness: s }, e.redeem), i.redeem.input = yb, [].concat(s, e.redeem.output);
    }
    if (e.redeem && e.redeem.output && e.redeem.witness)
      return [].concat(e.redeem.witness, e.redeem.output);
  }), Ce(i, "name", () => {
    const s = ["p2wsh"];
    return i.redeem !== void 0 && i.redeem.name !== void 0 && s.push(i.redeem.name), s.join("-");
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (r().prefix !== o.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      s = r().data;
    }
    if (e.hash) {
      if (s.length > 0 && fe(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== R5.OP_0 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const a = e.output.slice(2);
      if (s.length > 0 && fe(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== o)
        throw new TypeError("Network mismatch");
      if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (e.redeem.output) {
        const a = ar(e.redeem.output);
        if (!a || a.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (e.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (Kx(a) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const c = Qr(e.redeem.output);
        if (s.length > 0 && fe(s, c) !== 0)
          throw new TypeError("Hash mismatch");
        s = c;
      }
      if (e.redeem.input && !nv(n()))
        throw new TypeError("Non push-only scriptSig");
      if (e.witness && e.redeem.witness && !Bd(e.witness, e.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (e.redeem.input && n().some(bp) || e.redeem.output && (ar(e.redeem.output) || []).some(
        bp
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (e.witness && e.witness.length > 0) {
      const a = e.witness[e.witness.length - 1];
      if (e.redeem && e.redeem.output && fe(e.redeem.output, a) !== 0)
        throw new TypeError("Witness and redeem.output mismatch");
      if (e.witness.some(bp) || (ar(a) || []).some(bp))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(i, e);
}
var wd = {};
function Jx(e) {
  e ? e !== wd.eccLib && (tU(e), wd.eccLib = e) : wd.eccLib = e;
}
function ew() {
  if (!wd.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return wd.eccLib;
}
var gs = (e) => Js(e);
function tU(e) {
  To(typeof e.isXOnlyPoint == "function"), To(
    e.isXOnlyPoint(
      gs("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), To(
    e.isXOnlyPoint(
      gs("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), To(
    e.isXOnlyPoint(
      gs("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), To(
    e.isXOnlyPoint(
      gs("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), To(
    !e.isXOnlyPoint(
      gs("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), To(
    !e.isXOnlyPoint(
      gs("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), To(typeof e.xOnlyPointAddTweak == "function"), rU.forEach((t) => {
    const r = e.xOnlyPointAddTweak(gs(t.pubkey), gs(t.tweak));
    t.result === null ? To(r === null) : (To(r !== null), To(r.parity === t.parity), To(fe(r.xOnlyPubkey, gs(t.result)) === 0));
  });
}
function To(e) {
  if (!e) throw new Error("ecc library invalid");
}
var rU = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var Qx = "0123456789abcdefABCDEF";
Qx.split("").map((e) => e.codePointAt(0));
var z5 = Array(256).fill(true).map((e, t) => {
  const r = String.fromCodePoint(t), n = Qx.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
var e7 = new TextEncoder();
new TextDecoder();
function nU(e) {
  return e7.encode(e);
}
function oU(e) {
  const t = e.reduce((o, i) => o + i.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function iU(e) {
  const t = e7.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = z5[t[n * 2]], i = z5[t[n * 2 + 1]];
    if (o === void 0 || i === void 0)
      break;
    r[n] = o << 4 | i;
  }
  return n === r.length ? r : r.slice(0, n);
}
function ms(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function H5(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  e[t] = r;
}
function sU(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Mc(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function aU(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function cU(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function bl(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function uU(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
var lU = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function fU(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function t7(e) {
  typeof e == "number" ? fU(e) : lU(e);
}
function yc(e, t, r) {
  t7(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(jo(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), sU(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), Mc(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), aU(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function Af(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = cU(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = bl(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = uU(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function jo(e) {
  return t7(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
var dU = 9007199254740991;
function hU(e, t) {
  if (typeof e != "number" && typeof e != "bigint")
    throw new Error("cannot write a non-number as a number");
  if (e < 0 && e < BigInt(0))
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t && e > BigInt(t))
    throw new Error("RangeError: value out of range");
  if (Math.floor(Number(e)) !== Number(e))
    throw new Error("value has a fractional component");
}
function fv(e) {
  if (e.length < 1) return e;
  let t = e.length - 1, r = 0;
  for (let n = 0; n < e.length / 2; n++)
    r = e[n], e[n] = e[t], e[t] = r, t--;
  return e;
}
function L5(e) {
  const t = new Uint8Array(e.length);
  return t.set(e), t;
}
var gn = class _gn {
  constructor(t, r = 0) {
    Pt(this, "buffer");
    Pt(this, "offset");
    this.buffer = t, this.offset = r, nr(Fi([Ut, _s]), [
      t,
      r
    ]);
  }
  static withCapacity(t) {
    return new _gn(new Uint8Array(t));
  }
  writeUInt8(t) {
    this.offset = ho(this.buffer, this.offset, t);
  }
  writeInt32(t) {
    this.offset = Ix(this.buffer, this.offset, t, "LE");
  }
  writeInt64(t) {
    this.offset = Ox(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeUInt32(t) {
    this.offset = Ah(this.buffer, this.offset, t, "LE");
  }
  writeUInt64(t) {
    this.offset = rN(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeVarInt(t) {
    const { bytes: r } = yc(t, this.buffer, this.offset);
    this.offset += r;
  }
  writeSlice(t) {
    if (this.buffer.length < this.offset + t.length)
      throw new Error("Cannot write slice out of bounds");
    this.buffer.set(t, this.offset), this.offset += t.length;
  }
  writeVarSlice(t) {
    this.writeVarInt(t.length), this.writeSlice(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length), t.forEach((r) => this.writeVarSlice(r));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
};
var pU = class {
  constructor(t, r = 0) {
    Pt(this, "buffer");
    Pt(this, "offset");
    this.buffer = t, this.offset = r, nr(Fi([Ut, _s]), [
      t,
      r
    ]);
  }
  readUInt8() {
    const t = Ks(this.buffer, this.offset);
    return this.offset++, t;
  }
  readInt32() {
    const t = oN(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readUInt32() {
    const t = Ef(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readInt64() {
    const t = Bx(this.buffer, this.offset, "LE");
    return this.offset += 8, t;
  }
  readVarInt() {
    const { bigintValue: t, bytes: r } = Af(this.buffer, this.offset);
    return this.offset += r, t;
  }
  readSlice(t) {
    hU(t, dU);
    const r = Number(t);
    if (this.buffer.length < this.offset + r)
      throw new Error("Cannot read slice out of bounds");
    const n = this.buffer.slice(this.offset, this.offset + r);
    return this.offset += r, n;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let n = 0; n < t; n++) r.push(this.readVarSlice());
    return r;
  }
};
var r7 = 192;
var gU = 128;
var mU = (e) => "left" in e && "right" in e;
function tw(e, t) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const r = (e.length - 33) / 32;
  let n = t;
  for (let o = 0; o < r; o++) {
    const i = e.slice(33 + 32 * o, 65 + 32 * o);
    fe(n, i) < 0 ? n = nw(n, i) : n = nw(i, n);
  }
  return n;
}
function rw(e) {
  if (rv(e)) return { hash: $s(e) };
  const t = [rw(e[0]), rw(e[1])];
  t.sort((o, i) => fe(o.hash, i.hash));
  const [r, n] = t;
  return {
    hash: nw(r.hash, n.hash),
    left: r,
    right: n
  };
}
function B0(e, t) {
  if (mU(e)) {
    const r = B0(e.left, t);
    if (r !== void 0) return [...r, e.right.hash];
    const n = B0(e.right, t);
    if (n !== void 0) return [...n, e.left.hash];
  } else if (fe(e.hash, t) === 0)
    return [];
}
function $s(e) {
  const t = e.version || r7;
  return a1(
    "TapLeaf",
    fr([Uint8Array.from([t]), yU(e.output)])
  );
}
function bU(e, t) {
  return a1(
    "TapTweak",
    fr(t ? [e, t] : [e])
  );
}
function yp(e, t) {
  if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
  const r = bU(e, t), n = ew().xOnlyPointAddTweak(e, r);
  return !n || n.xOnlyPubkey === null ? null : {
    parity: n.parity,
    x: Uint8Array.from(n.xOnlyPubkey)
  };
}
function nw(e, t) {
  return a1("TapBranch", fr([e, t]));
}
function yU(e) {
  const t = jo(e.length), r = new Uint8Array(t);
  return yc(e.length, r), fr([r, e]);
}
var j5 = Rt;
var F5 = 1;
var wU = 80;
function Ph(e, t) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), nr(
    bc(
      Or({
        address: Mu(),
        input: Fr(0),
        network: Or({}),
        output: Fr(34),
        internalPubkey: Fr(32),
        hash: Fr(32),
        // merkle root hash, the tweak
        pubkey: Fr(32),
        // tweaked with `hash` from `internalPubkey`
        signature: tv([
          Fr(64),
          Fr(65)
        ]),
        witness: qn(Ut),
        scriptTree: hi(Lx, "Taptree is not of type isTaptree"),
        redeem: bc(
          Or({
            output: Ut,
            // tapleaf script
            redeemVersion: Kn(),
            // tapleaf version
            witness: qn(Ut)
          })
        ),
        redeemVersion: Kn()
      })
    ),
    e
  );
  const r = Ho(() => dv(e.address)), n = Ho(() => {
    if (!(!e.witness || !e.witness.length))
      return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === wU ? e.witness.slice(0, -1) : e.witness.slice();
  }), o = Ho(() => {
    if (e.scriptTree) return rw(e.scriptTree);
    if (e.hash) return { hash: e.hash };
  }), i = e.network || Ei, s = { name: "p2tr", network: i };
  if (Ce(s, "address", () => {
    if (!s.pubkey) return;
    const a = Nd.toWords(s.pubkey);
    return a.unshift(F5), Nd.encode(i.bech32, a);
  }), Ce(s, "hash", () => {
    const a = o();
    if (a) return a.hash;
    const c = n();
    if (c && c.length > 1) {
      const u = c[c.length - 1], l = u[0] & a0, f = c[c.length - 2], d = $s({ output: f, version: l });
      return tw(u, d);
    }
    return null;
  }), Ce(s, "output", () => {
    if (s.pubkey)
      return Vn([j5.OP_1, s.pubkey]);
  }), Ce(s, "redeemVersion", () => e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : r7), Ce(s, "redeem", () => {
    const a = n();
    if (!(!a || a.length < 2))
      return {
        output: a[a.length - 2],
        witness: a.slice(0, -2),
        redeemVersion: a[a.length - 1][0] & a0
      };
  }), Ce(s, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (s.internalPubkey) {
      const a = yp(s.internalPubkey, s.hash);
      if (a) return a.x;
    }
  }), Ce(s, "internalPubkey", () => {
    if (e.internalPubkey) return e.internalPubkey;
    const a = n();
    if (a && a.length > 1)
      return a[a.length - 1].slice(1, 33);
  }), Ce(s, "signature", () => {
    if (e.signature) return e.signature;
    const a = n();
    if (!(!a || a.length !== 1))
      return a[0];
  }), Ce(s, "witness", () => {
    if (e.witness) return e.witness;
    const a = o();
    if (a && e.redeem && e.redeem.output && e.internalPubkey) {
      const c = $s({
        output: e.redeem.output,
        version: s.redeemVersion
      }), u = B0(a, c);
      if (!u) return;
      const l = yp(e.internalPubkey, a.hash);
      if (!l) return;
      const f = fr(
        [
          Uint8Array.from([s.redeemVersion | l.parity]),
          e.internalPubkey
        ].concat(u)
      );
      return [e.redeem.output, f];
    }
    if (e.signature) return [e.signature];
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (i && i.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== F5)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      a = r().data;
    }
    if (e.pubkey) {
      if (a.length > 0 && fe(a, e.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = e.pubkey;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== j5.OP_1 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      if (a.length > 0 && fe(a, e.output.slice(2)) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = e.output.slice(2);
    }
    if (e.internalPubkey) {
      const l = yp(e.internalPubkey, s.hash);
      if (a.length > 0 && fe(a, l.x) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = l.x;
    }
    if (a && a.length && !ew().isXOnlyPoint(a))
      throw new TypeError("Invalid pubkey for p2tr");
    const c = o();
    if (e.hash && c && fe(e.hash, c.hash) !== 0)
      throw new TypeError("Hash mismatch");
    if (e.redeem && e.redeem.output && c) {
      const l = $s({
        output: e.redeem.output,
        version: s.redeemVersion
      });
      if (!B0(c, l))
        throw new TypeError("Redeem script not in tree");
    }
    const u = n();
    if (e.redeem && s.redeem) {
      if (e.redeem.redeemVersion && e.redeem.redeemVersion !== s.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (e.redeem.output) {
        if (ar(e.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (s.redeem.output && fe(e.redeem.output, s.redeem.output) !== 0)
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (e.redeem.witness && s.redeem.witness && !Bd(e.redeem.witness, s.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (u && u.length)
      if (u.length === 1) {
        if (e.signature && fe(e.signature, u[0]) !== 0)
          throw new TypeError("Signature mismatch");
      } else {
        const l = u[u.length - 1];
        if (l.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${l.length}, expected min 33.`
          );
        if ((l.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${l.length} is incorrect!`
          );
        const f = (l.length - 33) / 32;
        if (f > 128)
          throw new TypeError(
            `The script path is too long. Got ${f}, expected max 128.`
          );
        const d = l.slice(1, 33);
        if (e.internalPubkey && fe(e.internalPubkey, d) !== 0)
          throw new TypeError("Internal pubkey mismatch");
        if (!ew().isXOnlyPoint(d))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const m = l[0] & a0, y = u[u.length - 2], b = $s({ output: y, version: m }), w = tw(l, b), v = yp(d, w);
        if (!v)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (a.length && fe(a, v.x) !== 0)
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (v.parity !== (l[0] & 1))
          throw new Error("Incorrect parity");
      }
  }
  return Object.assign(s, e);
}
var n7 = 40;
var o7 = 2;
var i7 = 16;
var s7 = 2;
var a7 = 80;
var c7 = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function vU(e, t) {
  const r = e.slice(2);
  if (r.length < o7 || r.length > n7)
    throw new TypeError("Invalid program length for segwit address");
  const n = e[0] - a7;
  if (n < s7 || n > i7)
    throw new TypeError("Invalid version for segwit address");
  if (e[1] !== r.length)
    throw new TypeError("Invalid script for segwit address");
  return console.warn(c7), EU(r, n, t.bech32);
}
function u7(e) {
  const t = Dl.decode(e);
  if (t.length < 21) throw new TypeError(e + " is too short");
  if (t.length > 21) throw new TypeError(e + " is too long");
  const r = Ks(t, 0), n = t.slice(1);
  return { version: r, hash: n };
}
function dv(e) {
  let t, r;
  try {
    t = go.decode(e);
  } catch {
  }
  if (t) {
    if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
  } else if (t = Nd.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
  const n = go.fromWords(t.words.slice(1));
  return {
    version: r,
    prefix: t.prefix,
    data: Uint8Array.from(n)
  };
}
function EU(e, t, r) {
  const n = go.toWords(e);
  return n.unshift(t), t === 0 ? go.encode(r, n) : Nd.encode(r, n);
}
function Ih(e, t) {
  t = t || Ei;
  try {
    return Sh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return kf({ output: e, network: t }).address;
  } catch {
  }
  try {
    return _h({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Th({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Ph({ output: e, network: t }).address;
  } catch {
  }
  try {
    return vU(e, t);
  } catch {
  }
  throw new Error(kN(e) + " has no matching Address");
}
function hv(e, t) {
  t = t || Ei;
  let r, n;
  try {
    r = u7(e);
  } catch {
  }
  if (r) {
    if (r.version === t.pubKeyHash)
      return Sh({ hash: r.hash }).output;
    if (r.version === t.scriptHash)
      return kf({ hash: r.hash }).output;
  } else {
    try {
      n = dv(e);
    } catch {
    }
    if (n) {
      if (n.prefix !== t.bech32)
        throw new Error(e + " has an invalid prefix");
      if (n.version === 0) {
        if (n.data.length === 20)
          return _h({ hash: n.data }).output;
        if (n.data.length === 32)
          return Th({ hash: n.data }).output;
      } else if (n.version === 1) {
        if (n.data.length === 32)
          return Ph({ pubkey: n.data }).output;
      } else if (n.version >= s7 && n.version <= i7 && n.data.length >= o7 && n.data.length <= n7)
        return console.warn(c7), Vn([
          n.version + a7,
          n.data
        ]);
    }
  }
  throw new Error(e + " has no matching Script");
}
function Li(e) {
  const t = e.length;
  return jo(t) + t;
}
function xU(e) {
  const t = e.length;
  return jo(t) + e.reduce((r, n) => r + Li(n), 0);
}
var ec = new Uint8Array(0);
var D5 = [];
var wb = Js(
  "0000000000000000000000000000000000000000000000000000000000000000"
);
var K5 = Js(
  "0000000000000000000000000000000000000000000000000000000000000001"
);
var kU = Js("ffffffffffffffff");
var AU = {
  script: ec,
  valueBuffer: kU
};
function SU(e) {
  return e.value !== void 0;
}
var kt = class kt2 {
  constructor() {
    Pt(this, "version", 1);
    Pt(this, "locktime", 0);
    Pt(this, "ins", []);
    Pt(this, "outs", []);
  }
  static fromBuffer(t, r) {
    const n = new pU(t), o = new kt2();
    o.version = n.readInt32();
    const i = n.readUInt8(), s = n.readUInt8();
    let a = false;
    i === kt2.ADVANCED_TRANSACTION_MARKER && s === kt2.ADVANCED_TRANSACTION_FLAG ? a = true : n.offset -= 2;
    const c = n.readVarInt();
    for (let l = 0; l < c; ++l)
      o.ins.push({
        hash: n.readSlice(32),
        index: n.readUInt32(),
        script: n.readVarSlice(),
        sequence: n.readUInt32(),
        witness: D5
      });
    const u = n.readVarInt();
    for (let l = 0; l < u; ++l)
      o.outs.push({
        value: n.readInt64(),
        script: n.readVarSlice()
      });
    if (a) {
      for (let l = 0; l < c; ++l)
        o.ins[l].witness = n.readVector();
      if (!o.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (o.locktime = n.readUInt32(), r) return o;
    if (n.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return o;
  }
  static fromHex(t) {
    return kt2.fromBuffer(Js(t), false);
  }
  static isCoinbaseHash(t) {
    nr(_5, t);
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0) return false;
    return true;
  }
  isCoinbase() {
    return this.ins.length === 1 && kt2.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(t, r, n, o) {
    return nr(
      Fi([
        _5,
        _s,
        Qy(_0(_s)),
        Qy(_0(Ut))
      ]),
      [t, r, n, o]
    ), n == null && (n = kt2.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: o || ec,
      sequence: n,
      witness: D5
    }) - 1;
  }
  addOutput(t, r) {
    return nr(Fi([Ut, gb]), [
      t,
      r
    ]), this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(false), r = this.byteLength(true);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = true) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + jo(this.ins.length) + jo(this.outs.length) + this.ins.reduce((n, o) => n + 40 + Li(o.script), 0) + this.outs.reduce((n, o) => n + 8 + Li(o.script), 0) + (r ? this.ins.reduce((n, o) => n + xU(o.witness), 0) : 0);
  }
  clone() {
    const t = new kt2();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(t, r, n) {
    if (nr(Fi([_s, Ut, Kn()]), [
      t,
      r,
      n
    ]), t >= this.ins.length) return K5;
    const o = Vn(
      ar(r).filter((a) => a !== Rt.OP_CODESEPARATOR)
    ), i = this.clone();
    if ((n & 31) === kt2.SIGHASH_NONE)
      i.outs = [], i.ins.forEach((a, c) => {
        c !== t && (a.sequence = 0);
      });
    else if ((n & 31) === kt2.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return K5;
      i.outs.length = t + 1;
      for (let a = 0; a < t; a++)
        i.outs[a] = AU;
      i.ins.forEach((a, c) => {
        c !== t && (a.sequence = 0);
      });
    }
    n & kt2.SIGHASH_ANYONECANPAY ? (i.ins = [i.ins[t]], i.ins[0].script = o) : (i.ins.forEach((a) => {
      a.script = ec;
    }), i.ins[t].script = o);
    const s = new Uint8Array(i.byteLength(false) + 4);
    return Ix(s, s.length - 4, n, "LE"), i.__toBuffer(s, 0, false), Dc(s);
  }
  hashForWitnessV1(t, r, n, o, i, s) {
    if (nr(
      Fi([
        _s,
        qn(Ut),
        qn(gb),
        _s
      ]),
      [t, r, n, o]
    ), n.length !== this.ins.length || r.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const a = o === kt2.SIGHASH_DEFAULT ? kt2.SIGHASH_ALL : o & kt2.SIGHASH_OUTPUT_MASK, u = (o & kt2.SIGHASH_INPUT_MASK) === kt2.SIGHASH_ANYONECANPAY, l = a === kt2.SIGHASH_NONE, f = a === kt2.SIGHASH_SINGLE;
    let d = ec, m = ec, y = ec, b = ec, w = ec;
    if (!u) {
      let _ = gn.withCapacity(36 * this.ins.length);
      this.ins.forEach((I) => {
        _.writeSlice(I.hash), _.writeUInt32(I.index);
      }), d = Qr(_.end()), _ = gn.withCapacity(8 * this.ins.length), n.forEach((I) => _.writeInt64(I)), m = Qr(_.end()), _ = gn.withCapacity(
        r.map(Li).reduce((I, P) => I + P)
      ), r.forEach(
        (I) => _.writeVarSlice(I)
      ), y = Qr(_.end()), _ = gn.withCapacity(4 * this.ins.length), this.ins.forEach((I) => _.writeUInt32(I.sequence)), b = Qr(_.end());
    }
    if (l || f) {
      if (f && t < this.outs.length) {
        const _ = this.outs[t], I = gn.withCapacity(
          8 + Li(_.script)
        );
        I.writeInt64(_.value), I.writeVarSlice(_.script), w = Qr(I.end());
      }
    } else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const _ = this.outs.map((P) => 8 + Li(P.script)).reduce((P, $) => P + $), I = gn.withCapacity(_);
      this.outs.forEach((P) => {
        I.writeInt64(P.value), I.writeVarSlice(P.script);
      }), w = Qr(I.end());
    }
    const v = (i ? 2 : 0) + (s ? 1 : 0), k = 174 - (u ? 49 : 0) - (l ? 32 : 0) + (s ? 32 : 0) + (i ? 37 : 0), x = gn.withCapacity(k);
    if (x.writeUInt8(o), x.writeInt32(this.version), x.writeUInt32(this.locktime), x.writeSlice(d), x.writeSlice(m), x.writeSlice(y), x.writeSlice(b), l || f || x.writeSlice(w), x.writeUInt8(v), u) {
      const _ = this.ins[t];
      x.writeSlice(_.hash), x.writeUInt32(_.index), x.writeInt64(n[t]), x.writeVarSlice(r[t]), x.writeUInt32(_.sequence);
    } else
      x.writeUInt32(t);
    if (s) {
      const _ = gn.withCapacity(Li(s));
      _.writeVarSlice(s), x.writeSlice(Qr(_.end()));
    }
    return f && x.writeSlice(w), i && (x.writeSlice(i), x.writeUInt8(0), x.writeUInt32(4294967295)), a1(
      "TapSighash",
      fr([Uint8Array.from([0]), x.end()])
    );
  }
  hashForWitnessV0(t, r, n, o) {
    nr(
      Fi([
        _s,
        Ut,
        gb,
        _s
      ]),
      [t, r, n, o]
    );
    let i = Uint8Array.from([]), s, a = wb, c = wb, u = wb;
    if (o & kt2.SIGHASH_ANYONECANPAY || (i = new Uint8Array(36 * this.ins.length), s = new gn(i, 0), this.ins.forEach((f) => {
      s.writeSlice(f.hash), s.writeUInt32(f.index);
    }), c = Dc(i)), !(o & kt2.SIGHASH_ANYONECANPAY) && (o & 31) !== kt2.SIGHASH_SINGLE && (o & 31) !== kt2.SIGHASH_NONE && (i = new Uint8Array(4 * this.ins.length), s = new gn(i, 0), this.ins.forEach((f) => {
      s.writeUInt32(f.sequence);
    }), u = Dc(i)), (o & 31) !== kt2.SIGHASH_SINGLE && (o & 31) !== kt2.SIGHASH_NONE) {
      const f = this.outs.reduce((d, m) => d + 8 + Li(m.script), 0);
      i = new Uint8Array(f), s = new gn(i, 0), this.outs.forEach((d) => {
        s.writeInt64(d.value), s.writeVarSlice(d.script);
      }), a = Dc(i);
    } else if ((o & 31) === kt2.SIGHASH_SINGLE && t < this.outs.length) {
      const f = this.outs[t];
      i = new Uint8Array(8 + Li(f.script)), s = new gn(i, 0), s.writeInt64(f.value), s.writeVarSlice(f.script), a = Dc(i);
    }
    i = new Uint8Array(156 + Li(r)), s = new gn(i, 0);
    const l = this.ins[t];
    return s.writeInt32(this.version), s.writeSlice(c), s.writeSlice(u), s.writeSlice(l.hash), s.writeUInt32(l.index), s.writeVarSlice(r), s.writeInt64(n), s.writeUInt32(l.sequence), s.writeSlice(a), s.writeUInt32(this.locktime), s.writeUInt32(o), Dc(i);
  }
  getHash(t) {
    return t && this.isCoinbase() ? new Uint8Array(32) : Dc(this.__toBuffer(void 0, void 0, t));
  }
  getId() {
    return Fe(fv(this.getHash(false)));
  }
  toBuffer(t, r) {
    return this.__toBuffer(t, r, true);
  }
  toHex() {
    return Fe(this.toBuffer(void 0, void 0));
  }
  setInputScript(t, r) {
    nr(Fi([Kn(), Ut]), [t, r]), this.ins[t].script = r;
  }
  setWitness(t, r) {
    nr(Fi([Kn(), qn(Ut)]), [
      t,
      r
    ]), this.ins[t].witness = r;
  }
  __toBuffer(t, r, n = false) {
    t || (t = new Uint8Array(this.byteLength(n)));
    const o = new gn(t, r || 0);
    o.writeInt32(this.version);
    const i = n && this.hasWitnesses();
    return i && (o.writeUInt8(kt2.ADVANCED_TRANSACTION_MARKER), o.writeUInt8(kt2.ADVANCED_TRANSACTION_FLAG)), o.writeVarInt(this.ins.length), this.ins.forEach((s) => {
      o.writeSlice(s.hash), o.writeUInt32(s.index), o.writeVarSlice(s.script), o.writeUInt32(s.sequence);
    }), o.writeVarInt(this.outs.length), this.outs.forEach((s) => {
      SU(s) ? o.writeInt64(s.value) : o.writeSlice(s.valueBuffer), o.writeVarSlice(s.script);
    }), i && this.ins.forEach((s) => {
      o.writeVector(s.witness);
    }), o.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, o.offset) : t;
  }
};
Pt(kt, "DEFAULT_SEQUENCE", 4294967295), Pt(kt, "SIGHASH_DEFAULT", 0), Pt(kt, "SIGHASH_ALL", 1), Pt(kt, "SIGHASH_NONE", 2), Pt(kt, "SIGHASH_SINGLE", 3), Pt(kt, "SIGHASH_ANYONECANPAY", 128), Pt(kt, "SIGHASH_OUTPUT_MASK", 3), Pt(kt, "SIGHASH_INPUT_MASK", 128), Pt(kt, "ADVANCED_TRANSACTION_MARKER", 0), Pt(kt, "ADVANCED_TRANSACTION_FLAG", 1);
var or = kt;
var Zi;
(function(e) {
  e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(Zi || (Zi = {}));
var xe;
(function(e) {
  e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(xe || (xe = {}));
var xr;
(function(e) {
  e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(xr || (xr = {}));
var _U = (e) => [...Array(e).keys()];
function TU(e) {
  if (e.key[0] !== Zi.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + Fe(e.key)
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + Fe(e.key)
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), r = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const n of _U(e.value.length / 4 - 1)) {
    const o = Ef(e.value, n * 4 + 4, "LE"), i = !!(o & 2147483648), s = o & 2147483647;
    r.path += "/" + s.toString(10) + (i ? "'" : "");
  }
  return r;
}
function PU(e) {
  const t = new Uint8Array([Zi.GLOBAL_XPUB]), r = fr([t, e.extendedPubkey]), n = e.path.split("/"), o = new Uint8Array(n.length * 4);
  o.set(e.masterFingerprint, 0);
  let i = 4;
  return n.slice(1).forEach((s) => {
    const a = s.slice(-1) === "'";
    let c = 2147483647 & parseInt(a ? s.slice(0, -1) : s, 10);
    a && (c += 2147483648), Ah(o, i, c, "LE"), i += 4;
  }), {
    key: r,
    value: o
  };
}
var IU = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function OU(e) {
  const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
  return t instanceof Uint8Array && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function BU(e, t, r) {
  const n = Fe(t.extendedPubkey);
  return r.has(n) ? false : (r.add(n), e.filter((o) => fe(o.extendedPubkey, t.extendedPubkey)).length === 0);
}
var CU = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: BU,
  check: OU,
  decode: TU,
  encode: PU,
  expected: IU
}, Symbol.toStringTag, { value: "Module" }));
function NU(e) {
  return {
    key: new Uint8Array([Zi.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
var UU = Object.freeze(Object.defineProperty({
  __proto__: null,
  encode: NU
}, Symbol.toStringTag, { value: "Module" }));
function $U(e) {
  if (e.key[0] !== xe.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + Fe(e.key)
    );
  return e.value;
}
function RU(e) {
  return {
    key: new Uint8Array([xe.FINAL_SCRIPTSIG]),
    value: e
  };
}
var zU = "Uint8Array";
function HU(e) {
  return e instanceof Uint8Array;
}
function LU(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
var jU = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: LU,
  check: HU,
  decode: $U,
  encode: RU,
  expected: zU
}, Symbol.toStringTag, { value: "Module" }));
function FU(e) {
  if (e.key[0] !== xe.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + Fe(e.key)
    );
  return e.value;
}
function DU(e) {
  return {
    key: new Uint8Array([xe.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
var KU = "Uint8Array";
function MU(e) {
  return e instanceof Uint8Array;
}
function qU(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
var VU = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: qU,
  check: MU,
  decode: FU,
  encode: DU,
  expected: KU
}, Symbol.toStringTag, { value: "Module" }));
function GU(e) {
  if (e.key[0] !== xe.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + Fe(e.key)
    );
  return e.value;
}
function WU(e) {
  return {
    key: new Uint8Array([xe.NON_WITNESS_UTXO]),
    value: e
  };
}
var ZU = "Uint8Array";
function XU(e) {
  return e instanceof Uint8Array;
}
function YU(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
var JU = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: YU,
  check: XU,
  decode: GU,
  encode: WU,
  expected: ZU
}, Symbol.toStringTag, { value: "Module" }));
function QU(e) {
  if (e.key[0] !== xe.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + Fe(e.key)
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + Fe(e.key)
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
function e$(e) {
  const t = new Uint8Array([xe.PARTIAL_SIG]);
  return {
    key: fr([t, e.pubkey]),
    value: e.signature
  };
}
var t$ = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function r$(e) {
  return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && n$(e.signature);
}
function n$(e) {
  if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return false;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return false;
  const r = e[3 + t + 2];
  return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function o$(e, t, r) {
  const n = Fe(t.pubkey);
  return r.has(n) ? false : (r.add(n), e.filter((o) => fe(o.pubkey, t.pubkey) === 0).length === 0);
}
var i$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: o$,
  check: r$,
  decode: QU,
  encode: e$,
  expected: t$
}, Symbol.toStringTag, { value: "Module" }));
function s$(e) {
  if (e.key[0] !== xe.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + Fe(e.key)
    );
  return XC(e.value);
}
function a$(e) {
  return {
    key: new Uint8Array([xe.POR_COMMITMENT]),
    value: YC(e)
  };
}
var c$ = "string";
function u$(e) {
  return typeof e == "string";
}
function l$(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
var f$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: l$,
  check: u$,
  decode: s$,
  encode: a$,
  expected: c$
}, Symbol.toStringTag, { value: "Module" }));
function d$(e) {
  if (e.key[0] !== xe.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + Fe(e.key)
    );
  return Number(Ef(e.value, 0, "LE"));
}
function h$(e) {
  const t = Uint8Array.from([xe.SIGHASH_TYPE]), r = new Uint8Array(4);
  return Ah(r, 0, e, "LE"), {
    key: t,
    value: r
  };
}
var p$ = "number";
function g$(e) {
  return typeof e == "number";
}
function m$(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
var b$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: m$,
  check: g$,
  decode: d$,
  encode: h$,
  expected: p$
}, Symbol.toStringTag, { value: "Module" }));
function y$(e) {
  if (e.key[0] !== xe.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + Fe(e.key)
    );
  if (!l7(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
function w$(e) {
  return { key: Uint8Array.from([xe.TAP_KEY_SIG]), value: e };
}
var v$ = "Uint8Array";
function l7(e) {
  return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function E$(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
var x$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: E$,
  check: l7,
  decode: y$,
  encode: w$,
  expected: v$
}, Symbol.toStringTag, { value: "Module" }));
function k$(e) {
  if (e.key[0] !== xe.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + Fe(e.key)
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + Fe(e.key)
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + Fe(e.key)
    );
  const r = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: r, leafVersion: t };
}
function A$(e) {
  const t = Uint8Array.from([xe.TAP_LEAF_SCRIPT]), r = Uint8Array.from([e.leafVersion]);
  return {
    key: fr([t, e.controlBlock]),
    value: fr([e.script, r])
  };
}
var S$ = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function _$(e) {
  return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function T$(e, t, r) {
  const n = Fe(t.controlBlock);
  return r.has(n) ? false : (r.add(n), e.filter((o) => fe(o.controlBlock, t.controlBlock) === 0).length === 0);
}
var P$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: T$,
  check: _$,
  decode: k$,
  encode: A$,
  expected: S$
}, Symbol.toStringTag, { value: "Module" }));
function I$(e) {
  if (e.key[0] !== xe.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + Fe(e.key)
    );
  if (!f7(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
function O$(e) {
  return { key: Uint8Array.from([xe.TAP_MERKLE_ROOT]), value: e };
}
var B$ = "Uint8Array";
function f7(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function C$(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
var N$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: C$,
  check: f7,
  decode: I$,
  encode: O$,
  expected: B$
}, Symbol.toStringTag, { value: "Module" }));
function U$(e) {
  if (e.key[0] !== xe.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + Fe(e.key)
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + Fe(e.key)
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + Fe(e.key)
    );
  const t = e.key.slice(1, 33), r = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: r,
    signature: e.value
  };
}
function $$(e) {
  const t = Uint8Array.from([xe.TAP_SCRIPT_SIG]);
  return {
    key: fr([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
var R$ = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function z$(e) {
  return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function H$(e, t, r) {
  const n = Fe(t.pubkey) + Fe(t.leafHash);
  return r.has(n) ? false : (r.add(n), e.filter(
    (o) => fe(o.pubkey, t.pubkey) === 0 && fe(o.leafHash, t.leafHash) === 0
  ).length === 0);
}
var L$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: H$,
  check: z$,
  decode: U$,
  encode: $$,
  expected: R$
}, Symbol.toStringTag, { value: "Module" }));
function j$(e) {
  if (e.key[0] !== xe.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + Fe(e.key)
    );
  const t = Bx(e.value, 0, "LE");
  let r = 8;
  const { numberValue: n, bytes: o } = Af(
    e.value,
    r
  );
  r += o;
  const i = e.value.slice(r);
  if (i.length !== n)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: i,
    value: t
  };
}
function F$(e) {
  const { script: t, value: r } = e, n = jo(t.length), o = new Uint8Array(8 + n + t.length);
  return Ox(o, 0, BigInt(r), "LE"), yc(t.length, o, 8), o.set(t, 8 + n), {
    key: Uint8Array.from([xe.WITNESS_UTXO]),
    value: o
  };
}
var D$ = "{ script: Uint8Array; value: bigint; }";
function K$(e) {
  return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function M$(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
var q$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: M$,
  check: K$,
  decode: j$,
  encode: F$,
  expected: D$
}, Symbol.toStringTag, { value: "Module" }));
function V$(e) {
  if (e.key[0] !== xr.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + Fe(e.key)
    );
  let t = 0;
  const r = [];
  for (; t < e.value.length; ) {
    const n = e.value[t++], o = e.value[t++], { numberValue: i, bytes: s } = Af(
      e.value,
      t
    );
    t += s, r.push({
      depth: n,
      leafVersion: o,
      script: e.value.slice(t, t + i)
    }), t += i;
  }
  return { leaves: r };
}
function G$(e) {
  const t = Uint8Array.from([xr.TAP_TREE]), r = [].concat(
    ...e.leaves.map((n) => [
      Uint8Array.of(n.depth, n.leafVersion),
      yc(BigInt(n.script.length)).buffer,
      n.script
    ])
  );
  return {
    key: t,
    value: fr(r)
  };
}
var W$ = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function Z$(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array
  );
}
function X$(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
var Y$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: X$,
  check: Z$,
  decode: V$,
  encode: G$,
  expected: W$
}, Symbol.toStringTag, { value: "Module" }));
var J$ = (e) => [...Array(e).keys()];
var Q$ = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function pv(e, t = Q$) {
  function r(a) {
    if (a.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + Fe(a.key)
      );
    const c = a.key.slice(1);
    if (!t(c))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + Fe(a.key)
      );
    if (a.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const u = {
      masterFingerprint: a.value.slice(0, 4),
      pubkey: c,
      path: "m"
    };
    for (const l of J$(a.value.length / 4 - 1)) {
      const f = Ef(a.value, l * 4 + 4, "LE"), d = !!(f & 2147483648), m = f & 2147483647;
      u.path += "/" + m.toString(10) + (d ? "'" : "");
    }
    return u;
  }
  function n(a) {
    const c = Uint8Array.from([e]), u = fr([c, a.pubkey]), l = a.path.split("/"), f = new Uint8Array(l.length * 4);
    f.set(a.masterFingerprint, 0);
    let d = 4;
    return l.slice(1).forEach((m) => {
      const y = m.slice(-1) === "'";
      let b = 2147483647 & parseInt(y ? m.slice(0, -1) : m, 10);
      y && (b += 2147483648), Ah(f, d, b, "LE"), d += 4;
    }), {
      key: u,
      value: f
    };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function i(a) {
    return a.pubkey instanceof Uint8Array && a.masterFingerprint instanceof Uint8Array && typeof a.path == "string" && t(a.pubkey) && a.masterFingerprint.length === 4;
  }
  function s(a, c, u) {
    const l = Fe(c.pubkey);
    return u.has(l) ? false : (u.add(l), a.filter((f) => fe(f.pubkey, c.pubkey) === 0).length === 0);
  }
  return {
    decode: r,
    encode: n,
    check: i,
    expected: o,
    canAddToArray: s
  };
}
function gv(e) {
  return t;
  function t(r) {
    let n;
    if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![2, 3, 4].includes(n[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + Fe(r.key)
      );
    return n;
  }
}
function d7(e) {
  function t(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + Fe(s.key)
      );
    return s.value;
  }
  function r(s) {
    return {
      key: Uint8Array.from([e]),
      value: s
    };
  }
  const n = "Uint8Array";
  function o(s) {
    return s instanceof Uint8Array;
  }
  function i(s, a) {
    return !!s && !!a && s.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: i
  };
}
var eR = (e) => e.length === 32;
function h7(e) {
  const t = pv(e, eR);
  function r(s) {
    const { numberValue: a, bytes: c } = Af(
      s.value
    ), u = t.decode({
      key: s.key,
      value: s.value.slice(c + Number(a) * 32)
    }), l = new Array(Number(a));
    for (let f = 0, d = c; f < a; f++, d += 32)
      l[f] = s.value.slice(d, d + 32);
    return { ...u, leafHashes: l };
  }
  function n(s) {
    const a = t.encode(s), c = jo(s.leafHashes.length), u = new Uint8Array(c);
    yc(s.leafHashes.length, u);
    const l = fr([u, ...s.leafHashes, a.value]);
    return { ...a, value: l };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function i(s) {
    return Array.isArray(s.leafHashes) && s.leafHashes.every(
      (a) => a instanceof Uint8Array && a.length === 32
    ) && t.check(s);
  }
  return {
    decode: r,
    encode: n,
    check: i,
    expected: o,
    canAddToArray: t.canAddToArray
  };
}
function p7(e) {
  function t(s) {
    if (s.key[0] !== e || s.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + Fe(s.key)
      );
    if (s.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return s.value;
  }
  function r(s) {
    return { key: Uint8Array.from([e]), value: s };
  }
  const n = "Uint8Array";
  function o(s) {
    return s instanceof Uint8Array && s.length === 32;
  }
  function i(s, a) {
    return !!s && !!a && s.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: i
  };
}
function g7(e) {
  function t(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + Fe(s.key)
      );
    return s.value;
  }
  function r(s) {
    return {
      key: Uint8Array.from([e]),
      value: s
    };
  }
  const n = "Uint8Array";
  function o(s) {
    return s instanceof Uint8Array;
  }
  function i(s, a) {
    return !!s && !!a && s.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: i
  };
}
var mv = {
  unsignedTx: UU,
  globalXpub: CU,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: gv([])
};
var zr = {
  nonWitnessUtxo: JU,
  partialSig: i$,
  sighashType: b$,
  finalScriptSig: jU,
  finalScriptWitness: VU,
  porCommitment: f$,
  witnessUtxo: q$,
  bip32Derivation: pv(xe.BIP32_DERIVATION),
  redeemScript: d7(xe.REDEEM_SCRIPT),
  witnessScript: g7(xe.WITNESS_SCRIPT),
  checkPubkey: gv([
    xe.PARTIAL_SIG,
    xe.BIP32_DERIVATION
  ]),
  tapKeySig: x$,
  tapScriptSig: L$,
  tapLeafScript: P$,
  tapBip32Derivation: h7(
    xe.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: p7(xe.TAP_INTERNAL_KEY),
  tapMerkleRoot: N$
};
var Ts = {
  bip32Derivation: pv(xr.BIP32_DERIVATION),
  redeemScript: d7(xr.REDEEM_SCRIPT),
  witnessScript: g7(xr.WITNESS_SCRIPT),
  checkPubkey: gv([xr.BIP32_DERIVATION]),
  tapBip32Derivation: h7(
    xr.TAP_BIP32_DERIVATION
  ),
  tapTree: Y$,
  tapInternalKey: p7(xr.TAP_INTERNAL_KEY)
};
var tR = Object.freeze(Object.defineProperty({
  __proto__: null,
  globals: mv,
  inputs: zr,
  outputs: Ts
}, Symbol.toStringTag, { value: "Module" }));
var C0 = (e) => [...Array(e).keys()];
function M5(e) {
  const t = e.map(rR);
  return t.push(Uint8Array.from([0])), fr(t);
}
function rR(e) {
  const t = e.key.length, r = e.value.length, n = jo(t), o = jo(r), i = new Uint8Array(n + t + o + r);
  return yc(t, i, 0), i.set(e.key, n), yc(r, i, n + t), i.set(e.value, n + t + o), i;
}
function nR(e, t) {
  let r = 0;
  function n() {
    const { numberValue: w, bytes: v } = Af(e, r);
    r += v;
    const k = e.slice(r, r + Number(w));
    return r += Number(w), k;
  }
  function o() {
    const w = Ef(e, r, "BE");
    return r += 4, w;
  }
  function i() {
    const w = Ks(e, r);
    return r += 1, w;
  }
  function s() {
    const w = n(), v = n();
    return {
      key: w,
      value: v
    };
  }
  function a() {
    if (r >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const w = Ks(e, r) === 0;
    return w && r++, w;
  }
  if (o() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (i() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const c = [], u = {};
  for (; !a(); ) {
    const w = s(), v = Fe(w.key);
    if (u[v])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + v
      );
    u[v] = 1, c.push(w);
  }
  const l = c.filter(
    (w) => w.key[0] === Zi.UNSIGNED_TX
  );
  if (l.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const f = t(l[0].value), { inputCount: d, outputCount: m } = f.getInputOutputCounts(), y = [], b = [];
  for (const w of C0(d)) {
    const v = {}, k = [];
    for (; !a(); ) {
      const x = s(), _ = Fe(x.key);
      if (v[_])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + w + " key " + _
        );
      v[_] = 1, k.push(x);
    }
    y.push(k);
  }
  for (const w of C0(m)) {
    const v = {}, k = [];
    for (; !a(); ) {
      const x = s(), _ = Fe(x.key);
      if (v[_])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + w + " key " + _
        );
      v[_] = 1, k.push(x);
    }
    b.push(k);
  }
  return m7(f, {
    globalMapKeyVals: c,
    inputKeyVals: y,
    outputKeyVals: b
  });
}
function hn(e, t, r) {
  if (fe(t, Uint8Array.from([r])))
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${e} key: ${Fe(t)}`
    );
}
function m7(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
  const o = {
    unsignedTx: e
  };
  let i = 0;
  for (const l of t)
    switch (l.key[0]) {
      case Zi.UNSIGNED_TX:
        if (hn("global", l.key, Zi.UNSIGNED_TX), i > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        i++;
        break;
      case Zi.GLOBAL_XPUB:
        o.globalXpub === void 0 && (o.globalXpub = []), o.globalXpub.push(mv.globalXpub.decode(l));
        break;
      default:
        o.unknownKeyVals || (o.unknownKeyVals = []), o.unknownKeyVals.push(l);
    }
  const s = r.length, a = n.length, c = [], u = [];
  for (const l of C0(s)) {
    const f = {};
    for (const d of r[l])
      switch (zr.checkPubkey(d), d.key[0]) {
        case xe.NON_WITNESS_UTXO:
          if (hn("input", d.key, xe.NON_WITNESS_UTXO), f.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          f.nonWitnessUtxo = zr.nonWitnessUtxo.decode(d);
          break;
        case xe.WITNESS_UTXO:
          if (hn("input", d.key, xe.WITNESS_UTXO), f.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          f.witnessUtxo = zr.witnessUtxo.decode(d);
          break;
        case xe.PARTIAL_SIG:
          f.partialSig === void 0 && (f.partialSig = []), f.partialSig.push(zr.partialSig.decode(d));
          break;
        case xe.SIGHASH_TYPE:
          if (hn("input", d.key, xe.SIGHASH_TYPE), f.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          f.sighashType = zr.sighashType.decode(d);
          break;
        case xe.REDEEM_SCRIPT:
          if (hn("input", d.key, xe.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          f.redeemScript = zr.redeemScript.decode(d);
          break;
        case xe.WITNESS_SCRIPT:
          if (hn("input", d.key, xe.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          f.witnessScript = zr.witnessScript.decode(d);
          break;
        case xe.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            zr.bip32Derivation.decode(d)
          );
          break;
        case xe.FINAL_SCRIPTSIG:
          hn("input", d.key, xe.FINAL_SCRIPTSIG), f.finalScriptSig = zr.finalScriptSig.decode(d);
          break;
        case xe.FINAL_SCRIPTWITNESS:
          hn("input", d.key, xe.FINAL_SCRIPTWITNESS), f.finalScriptWitness = zr.finalScriptWitness.decode(
            d
          );
          break;
        case xe.POR_COMMITMENT:
          hn("input", d.key, xe.POR_COMMITMENT), f.porCommitment = zr.porCommitment.decode(d);
          break;
        case xe.TAP_KEY_SIG:
          hn("input", d.key, xe.TAP_KEY_SIG), f.tapKeySig = zr.tapKeySig.decode(d);
          break;
        case xe.TAP_SCRIPT_SIG:
          f.tapScriptSig === void 0 && (f.tapScriptSig = []), f.tapScriptSig.push(zr.tapScriptSig.decode(d));
          break;
        case xe.TAP_LEAF_SCRIPT:
          f.tapLeafScript === void 0 && (f.tapLeafScript = []), f.tapLeafScript.push(zr.tapLeafScript.decode(d));
          break;
        case xe.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            zr.tapBip32Derivation.decode(d)
          );
          break;
        case xe.TAP_INTERNAL_KEY:
          hn("input", d.key, xe.TAP_INTERNAL_KEY), f.tapInternalKey = zr.tapInternalKey.decode(d);
          break;
        case xe.TAP_MERKLE_ROOT:
          hn("input", d.key, xe.TAP_MERKLE_ROOT), f.tapMerkleRoot = zr.tapMerkleRoot.decode(d);
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(d);
      }
    c.push(f);
  }
  for (const l of C0(a)) {
    const f = {};
    for (const d of n[l])
      switch (Ts.checkPubkey(d), d.key[0]) {
        case xr.REDEEM_SCRIPT:
          if (hn("output", d.key, xr.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          f.redeemScript = Ts.redeemScript.decode(d);
          break;
        case xr.WITNESS_SCRIPT:
          if (hn("output", d.key, xr.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          f.witnessScript = Ts.witnessScript.decode(d);
          break;
        case xr.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            Ts.bip32Derivation.decode(d)
          );
          break;
        case xr.TAP_INTERNAL_KEY:
          hn("output", d.key, xr.TAP_INTERNAL_KEY), f.tapInternalKey = Ts.tapInternalKey.decode(d);
          break;
        case xr.TAP_TREE:
          hn("output", d.key, xr.TAP_TREE), f.tapTree = Ts.tapTree.decode(d);
          break;
        case xr.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            Ts.tapBip32Derivation.decode(d)
          );
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(d);
      }
    u.push(f);
  }
  return { globalMap: o, inputs: c, outputs: u };
}
function oR({ globalMap: e, inputs: t, outputs: r }) {
  const { globalKeyVals: n, inputKeyVals: o, outputKeyVals: i } = ow({
    globalMap: e,
    inputs: t,
    outputs: r
  }), s = M5(n), a = (f) => f.length === 0 ? [Uint8Array.from([0])] : f.map(M5), c = a(o), u = a(i), l = new Uint8Array(5);
  return l.set([112, 115, 98, 116, 255], 0), fr(
    [l, s].concat(c, u)
  );
}
var iR = (e, t) => fe(e.key, t.key);
function vb(e, t) {
  const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((i, [s, a]) => {
    if (s === "unknownKeyVals") return i;
    const c = t[s];
    if (c === void 0) return i;
    const u = (Array.isArray(a) ? a : [a]).map(
      c.encode
    );
    return u.map((f) => Fe(f.key)).forEach((f) => {
      if (r.has(f))
        throw new Error("Serialize Error: Duplicate key: " + f);
      r.add(f);
    }), i.concat(u);
  }, []), o = e.unknownKeyVals ? e.unknownKeyVals.filter((i) => !r.has(Fe(i.key))) : [];
  return n.concat(o).sort(iR);
}
function ow({ globalMap: e, inputs: t, outputs: r }) {
  return {
    globalKeyVals: vb(e, mv),
    inputKeyVals: t.map((n) => vb(n, zr)),
    outputKeyVals: r.map((n) => vb(n, Ts))
  };
}
function sR(e) {
  const t = e[0], r = ow(t), n = e.slice(1);
  if (n.length === 0) throw new Error("Combine: Nothing to combine");
  const o = q5(t);
  if (o === void 0)
    throw new Error("Combine: Self missing transaction");
  const i = ul(r.globalKeyVals), s = r.inputKeyVals.map(ul), a = r.outputKeyVals.map(ul);
  for (const c of n) {
    const u = q5(c);
    if (u === void 0 || fe(u.toBuffer(), o.toBuffer()) !== 0)
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const l = ow(c);
    ul(l.globalKeyVals).forEach(
      Eb(
        i,
        r.globalKeyVals,
        l.globalKeyVals
      )
    ), l.inputKeyVals.map(ul).forEach(
      (y, b) => y.forEach(
        Eb(
          s[b],
          r.inputKeyVals[b],
          l.inputKeyVals[b]
        )
      )
    ), l.outputKeyVals.map(ul).forEach(
      (y, b) => y.forEach(
        Eb(
          a[b],
          r.outputKeyVals[b],
          l.outputKeyVals[b]
        )
      )
    );
  }
  return m7(o, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
}
function Eb(e, t, r) {
  return (n) => {
    if (e.has(n)) return;
    const o = r.filter((i) => Fe(i.key) === n)[0];
    t.push(o), e.add(n);
  };
}
function q5(e) {
  return e.globalMap.unsignedTx;
}
function ul(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    const n = Fe(r.key);
    if (t.has(n))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(n);
  }), t;
}
function cn(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No input #${t}`);
  return r;
}
function Ud(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No output #${t}`);
  return r;
}
function xb(e, t, r) {
  if (e.key[0] < r)
    throw new Error(
      "Use the method for your specific key instead of addUnknownKeyVal*"
    );
  if (t && t.filter((n) => fe(n.key, e.key) === 0).length !== 0)
    throw new Error(`Duplicate Key: ${Fe(e.key)}`);
}
function kb(e) {
  let t = 0;
  return Object.keys(e).forEach((r) => {
    Number(isNaN(Number(r))) && t++;
  }), t;
}
function aR(e, t) {
  let r = false;
  if (t.nonWitnessUtxo || t.witnessUtxo) {
    const n = !!t.redeemScript, o = !!t.witnessScript, i = !n || !!t.finalScriptSig, s = !o || !!t.finalScriptWitness, a = !!t.finalScriptSig || !!t.finalScriptWitness;
    r = i && s && a;
  }
  if (r === false)
    throw new Error(
      `Input #${e} has too much or too little data to clean`
    );
}
function V5(e, t, r, n) {
  throw new Error(
    `Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`
  );
}
function bv(e) {
  return (t, r) => {
    for (const n of Object.keys(t)) {
      const o = t[n], { canAdd: i, canAddToArray: s, check: a, expected: c } = (
        // @ts-ignore
        tR[e + "s"][n] || {}
      ), u = !!s;
      if (a)
        if (u) {
          if (!Array.isArray(o) || // @ts-ignore
          r[n] && !Array.isArray(r[n]))
            throw new Error(`Key type ${n} must be an array`);
          o.every(a) || V5(e, n, c, o);
          const l = r[n] || [], f = /* @__PURE__ */ new Set();
          if (!o.every((d) => s(l, d, f)))
            throw new Error("Can not add duplicate data to array");
          r[n] = l.concat(o);
        } else {
          if (a(o) || V5(e, n, c, o), !i(r, o))
            throw new Error(`Can not add duplicate data to ${e}`);
          r[n] = o;
        }
    }
  };
}
var cR = bv("global");
var b7 = bv("input");
var y7 = bv("output");
function uR(e, t) {
  const r = e.length - 1, n = cn(e, r);
  b7(t, n);
}
function lR(e, t) {
  const r = e.length - 1, n = Ud(e, r);
  y7(t, n);
}
var G5 = class {
  constructor(t) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: t
    };
  }
  static fromBase64(t, r) {
    const n = Px(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r) {
    const n = Js(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r) {
    const n = nR(t, r), o = new this(n.globalMap.unsignedTx);
    return Object.assign(o, n), o;
  }
  toBase64() {
    const t = this.toBuffer();
    return eN(t);
  }
  toHex() {
    const t = this.toBuffer();
    return Fe(t);
  }
  toBuffer() {
    return oR(this);
  }
  updateGlobal(t) {
    return cR(t, this.globalMap), this;
  }
  updateInput(t, r) {
    const n = cn(this.inputs, t);
    return b7(r, n), this;
  }
  updateOutput(t, r) {
    const n = Ud(this.outputs, t);
    return y7(r, n), this;
  }
  addUnknownKeyValToGlobal(t) {
    return xb(
      t,
      this.globalMap.unknownKeyVals,
      kb(Zi)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    const n = cn(this.inputs, t);
    return xb(r, n.unknownKeyVals, kb(xe)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    const n = Ud(this.outputs, t);
    return xb(r, n.unknownKeyVals, kb(xr)), n.unknownKeyVals || (n.unknownKeyVals = []), n.unknownKeyVals.push(r), this;
  }
  addInput(t) {
    this.globalMap.unsignedTx.addInput(t), this.inputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], n = this.inputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (o) => this.addUnknownKeyValToInput(n, o)
    ), uR(this.inputs, t), this;
  }
  addOutput(t) {
    this.globalMap.unsignedTx.addOutput(t), this.outputs.push({
      unknownKeyVals: []
    });
    const r = t.unknownKeyVals || [], n = this.outputs.length - 1;
    if (!Array.isArray(r))
      throw new Error("unknownKeyVals must be an Array");
    return r.forEach(
      (o) => this.addUnknownKeyValToOutput(n, o)
    ), lR(this.outputs, t), this;
  }
  clearFinalizedInput(t) {
    const r = cn(this.inputs, t);
    aR(t, r);
    for (const n of Object.keys(r))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(n) || delete r[n];
    return this;
  }
  combine(...t) {
    const r = sR([this].concat(t));
    return Object.assign(this, r), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function qu(e) {
  return (t) => {
    try {
      return e({ output: t }), true;
    } catch {
      return false;
    }
  };
}
var fR = qu(i1);
var dR = qu(qx);
var hR = qu(Sh);
var c1 = qu(_h);
var W5 = qu(Th);
var w7 = qu(kf);
var v7 = qu(Ph);
function N0(e) {
  let t = new Uint8Array(0);
  function r(s) {
    t = fr([t, s]);
  }
  function n(s) {
    const a = t.length, c = jo(s);
    t = fr([t, new Uint8Array(c)]), yc(s, t, a);
  }
  function o(s) {
    n(s.length), r(s);
  }
  function i(s) {
    n(s.length), s.forEach(o);
  }
  return i(e), t;
}
function E7(e, t) {
  const r = zs(e), n = e.slice(1, 33), o = ar(t);
  if (o === null) throw new Error("Unknown script error");
  return o.findIndex((i) => typeof i == "number" ? false : fe(e, i) === 0 || fe(r, i) === 0 || fe(n, i) === 0);
}
function u1(e, t) {
  return E7(e, t) !== -1;
}
function pR(e, t) {
  return gR(e).some(
    (n) => x7(n, yd.decode, t)
  );
}
function x7(e, t, r) {
  const { hashType: n } = t(e), o = [];
  switch (n & or.SIGHASH_ANYONECANPAY && o.push("addInput"), n & 31) {
    case or.SIGHASH_ALL:
      break;
    case or.SIGHASH_SINGLE:
    case or.SIGHASH_NONE:
      o.push("addOutput"), o.push("setInputSequence");
      break;
  }
  return o.indexOf(r) === -1;
}
function gR(e) {
  let t = [];
  if ((e.partialSig || []).length === 0) {
    if (!e.finalScriptSig && !e.finalScriptWitness) return [];
    t = mR(e);
  } else
    t = e.partialSig;
  return t.map((r) => r.signature);
}
function mR(e) {
  const t = e.finalScriptSig ? ar(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? ar(e.finalScriptWitness) || [] : [];
  return t.concat(r).filter((n) => n instanceof Uint8Array && Ms(n)).map((n) => ({ signature: n }));
}
var vd = (e) => e.length === 32 ? e : e.slice(1, 33);
function Z5(e, t, r) {
  const n = OR(
    t,
    e,
    r
  );
  try {
    const i = PR(t, n).concat(n.script).concat(n.controlBlock);
    return { finalScriptWitness: N0(i) };
  } catch (o) {
    throw new Error(`Can not finalize taproot input #${e}: ${o}`);
  }
}
function wp(e, t) {
  const r = t ? Uint8Array.from([t]) : Uint8Array.from([]);
  return fr([e, r]);
}
function Yo(e) {
  return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && v7(e.witnessUtxo.script));
}
function Ab(e, t) {
  return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function X5(e, t, r) {
  SR(e, t, r), TR(e, t, r);
}
function Y5(e, t, r) {
  _R(e, t, r), bR(e, t);
}
function bR(e, t) {
  if (!t.tapTree && !t.tapInternalKey) return;
  const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
  if (r) {
    const { script: o } = e, i = yR(r, n);
    if (o && fe(i, o) !== 0)
      throw new Error("Error adding output. Script or address mismatch.");
  }
}
function yR(e, t) {
  const r = t && wR(t.leaves), { output: n } = Ph({
    internalPubkey: e,
    scriptTree: r
  });
  return n;
}
function wR(e = []) {
  return e.length === 1 && e[0].depth === 0 ? {
    output: e[0].script,
    version: e[0].leafVersion
  } : AR(e);
}
function vR(e, t) {
  return xR(e).some(
    (n) => x7(n, ER, t)
  );
}
function ER(e) {
  return {
    signature: e.slice(0, 64),
    hashType: e.slice(64)[0] || or.SIGHASH_DEFAULT
  };
}
function xR(e) {
  const t = [];
  if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r) => r.signature)), !t.length) {
    const r = kR(e.finalScriptWitness);
    r && t.push(r);
  }
  return t;
}
function kR(e) {
  if (!e) return;
  const t = e.slice(2);
  if (t.length === 64 || t.length === 65) return t;
}
function AR(e) {
  let t;
  for (const r of e)
    if (t = iw(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
  return t;
}
function iw(e, t, r = 0) {
  if (r > gU) throw new Error("Max taptree depth exceeded.");
  if (e.depth === r)
    return t ? void 0 : {
      output: e.script,
      version: e.leafVersion
    };
  if (rv(t)) return;
  const n = iw(e, t && t[0], r + 1);
  if (n) return [n, t && t[1]];
  const o = iw(e, t && t[1], r + 1);
  if (o) return [t && t[0], o];
}
function SR(e, t, r) {
  const n = Yo(e) && Nl(t), o = Nl(e) && Yo(t), i = e === t && Yo(t) && Nl(t);
  if (n || o || i)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function _R(e, t, r) {
  const n = Ab(e) && Nl(t), o = Nl(e) && Ab(t), i = e === t && Ab(t) && Nl(t);
  if (n || o || i)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function TR(e, t, r) {
  if (t.tapMerkleRoot) {
    const n = (t.tapLeafScript || []).every(
      (i) => Sb(i, t.tapMerkleRoot)
    ), o = (e.tapLeafScript || []).every(
      (i) => Sb(i, t.tapMerkleRoot)
    );
    if (!n || !o)
      throw new Error(
        `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
      );
  } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every(
    (o) => Sb(o, e.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
    );
}
function Sb(e, t) {
  if (!t) return true;
  const r = $s({
    output: e.script,
    version: e.leafVersion
  }), n = tw(e.controlBlock, r);
  return fe(n, t) === 0;
}
function PR(e, t) {
  const r = $s({
    output: t.script,
    version: t.leafVersion
  });
  return (e.tapScriptSig || []).filter((n) => fe(n.leafHash, r) === 0).map((n) => IR(t.script, n)).sort((n, o) => o.positionInScript - n.positionInScript).map((n) => n.signature);
}
function IR(e, t) {
  return Object.assign(
    {
      positionInScript: E7(t.pubkey, e)
    },
    t
  );
}
function OR(e, t, r) {
  if (!e.tapScriptSig || !e.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${t}. No tapleaf script signature provided.`
    );
  const n = (e.tapLeafScript || []).sort((o, i) => o.controlBlock.length - i.controlBlock.length).find(
    (o) => BR(o, e.tapScriptSig, r)
  );
  if (!n)
    throw new Error(
      `Can not finalize taproot input #${t}. Signature for tapleaf script not found.`
    );
  return n;
}
function BR(e, t, r) {
  const n = $s({
    output: e.script,
    version: e.leafVersion
  });
  return (!r || fe(n, r) === 0) && t.find((i) => fe(i.leafHash, n) === 0) !== void 0;
}
function Nl(e) {
  return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
var CR = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: Ei,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
var Zt = class _Zt {
  constructor(t = {}, r = new G5(new k7())) {
    Pt(this, "data");
    Pt(this, "__CACHE");
    Pt(this, "opts");
    this.data = r, this.opts = Object.assign({}, CR, t), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: false
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const n = (o, i, s, a) => Object.defineProperty(o, i, {
      enumerable: s,
      writable: a
    });
    n(this, "__CACHE", false, true), n(this, "opts", false, true);
  }
  static fromBase64(t, r = {}) {
    const n = Px(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r = {}) {
    const n = Js(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r = {}) {
    const n = G5.fromBuffer(t, NR), o = new _Zt(r, n);
    return HR(o.__CACHE.__TX, o.__CACHE), o;
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((t) => ({
      hash: L5(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((t) => {
      let r;
      try {
        r = Ih(t.script, this.opts.network);
      } catch {
      }
      return {
        script: L5(t.script),
        value: t.value,
        address: r
      };
    });
  }
  combine(...t) {
    return this.data.combine(...t.map((r) => r.data)), this;
  }
  clone() {
    const t = _Zt.fromBuffer(this.data.toBuffer());
    return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
  }
  setMaximumFeeRate(t) {
    vp(t), this.opts.maximumFeeRate = t;
  }
  setVersion(t) {
    vp(t), Yf(this.data.inputs, "setVersion");
    const r = this.__CACHE;
    return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(t) {
    vp(t), Yf(this.data.inputs, "setLocktime");
    const r = this.__CACHE;
    return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(t, r) {
    vp(r), Yf(this.data.inputs, "setInputSequence");
    const n = this.__CACHE;
    if (n.__TX.ins.length <= t)
      throw new Error("Input index too high");
    return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
  }
  addInputs(t) {
    return t.forEach((r) => this.addInput(r)), this;
  }
  addInput(t) {
    if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    X5(t, t, "addInput"), Yf(this.data.inputs, "addInput"), t.witnessScript && U0(t.witnessScript);
    const r = this.__CACHE;
    this.data.addInput(t);
    const n = r.__TX.ins[r.__TX.ins.length - 1];
    _7(r, n);
    const o = this.data.inputs.length - 1, i = this.data.inputs[o];
    return i.nonWitnessUtxo && aw(this.__CACHE, i, o), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(t) {
    return t.forEach((r) => this.addOutput(r)), this;
  }
  addOutput(t) {
    if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    Yf(this.data.inputs, "addOutput");
    const { address: r } = t;
    if (typeof r == "string") {
      const { network: o } = this.opts, i = hv(r, o);
      t = Object.assign({}, t, { script: i });
    }
    Y5(t, t, "addOutput");
    const n = this.__CACHE;
    return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(t) {
    if (!this.data.inputs.every(A7)) throw new Error("Not finalized");
    const r = this.__CACHE;
    if (t || $R(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
    const n = r.__TX.clone();
    return C7(this.data.inputs, n, r, true), n;
  }
  getFeeRate() {
    return r4(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return r4("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return cn(this.data.inputs, 0), Jf(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, r) {
    const n = cn(this.data.inputs, t);
    return Yo(n) ? this._finalizeTaprootInput(
      t,
      n,
      void 0,
      r
    ) : this._finalizeInput(t, n, r);
  }
  finalizeTaprootInput(t, r, n = Z5) {
    const o = cn(this.data.inputs, t);
    if (Yo(o))
      return this._finalizeTaprootInput(
        t,
        o,
        r,
        n
      );
    throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
  }
  _finalizeInput(t, r, n = LR) {
    const { script: o, isP2SH: i, isP2WSH: s, isSegwit: a } = KR(
      t,
      r,
      this.__CACHE
    );
    if (!o) throw new Error(`No script found for input #${t}`);
    RR(r);
    const { finalScriptSig: c, finalScriptWitness: u } = n(
      t,
      r,
      o,
      a,
      i,
      s
    );
    if (c && this.data.updateInput(t, { finalScriptSig: c }), u && this.data.updateInput(t, { finalScriptWitness: u }), !c && !u)
      throw new Error(`Unknown error finalizing input #${t}`);
    return this.data.clearFinalizedInput(t), this;
  }
  _finalizeTaprootInput(t, r, n, o = Z5) {
    if (!r.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${t}. Missing withness utxo.`
      );
    if (r.tapKeySig) {
      const i = Ph({
        output: r.witnessUtxo.script,
        signature: r.tapKeySig
      }), s = N0(i.witness);
      this.data.updateInput(t, { finalScriptWitness: s });
    } else {
      const { finalScriptWitness: i } = o(
        t,
        r,
        n
      );
      this.data.updateInput(t, { finalScriptWitness: i });
    }
    return this.data.clearFinalizedInput(t), this;
  }
  getInputType(t) {
    const r = cn(this.data.inputs, t), n = N7(t, r, this.__CACHE), o = f1(
      n,
      t,
      "input",
      r.redeemScript || WR(r.finalScriptSig),
      r.witnessScript || ZR(r.finalScriptWitness)
    ), i = o.type === "raw" ? "" : o.type + "-", s = $7(o.meaningfulScript);
    return i + s;
  }
  inputHasPubkey(t, r) {
    const n = cn(this.data.inputs, t);
    return VR(r, n, t, this.__CACHE);
  }
  inputHasHDKey(t, r) {
    const n = cn(this.data.inputs, t), o = Q5(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  outputHasPubkey(t, r) {
    const n = Ud(this.data.outputs, t);
    return GR(r, n, t, this.__CACHE);
  }
  outputHasHDKey(t, r) {
    const n = Ud(this.data.outputs, t), o = Q5(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  validateSignaturesOfAllInputs(t) {
    return cn(this.data.inputs, 0), Jf(this.data.inputs.length).map(
      (n) => this.validateSignaturesOfInput(n, t)
    ).reduce((n, o) => o === true && n, true);
  }
  validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t];
    return Yo(o) ? this.validateSignaturesOfTaprootInput(
      t,
      r,
      n
    ) : this._validateSignaturesOfInput(t, r, n);
  }
  _validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t], i = (o || {}).partialSig;
    if (!o || !i || i.length < 1)
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    const s = n ? i.filter((f) => fe(f.pubkey, n) === 0) : i;
    if (s.length < 1) throw new Error("No signatures for this pubkey");
    const a = [];
    let c, u, l;
    for (const f of s) {
      const d = yd.decode(f.signature), { hash: m, script: y } = l !== d.hashType ? P7(
        t,
        Object.assign({}, o, { sighashType: d.hashType }),
        this.__CACHE,
        true
      ) : { hash: c, script: u };
      l = d.hashType, c = m, u = y, S7(f.pubkey, y, "verify"), a.push(r(f.pubkey, m, d.signature));
    }
    return a.every((f) => f === true);
  }
  validateSignaturesOfTaprootInput(t, r, n) {
    const o = this.data.inputs[t], i = (o || {}).tapKeySig, s = (o || {}).tapScriptSig;
    if (!o && !i && !(s && !s.length))
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    n = n && vd(n);
    const a = n ? sw(
      t,
      o,
      this.data.inputs,
      n,
      this.__CACHE
    ) : FR(
      t,
      o,
      this.data.inputs,
      this.__CACHE
    );
    if (!a.length) throw new Error("No signatures for this pubkey");
    const c = a.find((l) => !l.leafHash);
    let u = 0;
    if (i && c) {
      if (!r(
        c.pubkey,
        c.hash,
        o4(i)
      )) return false;
      u++;
    }
    if (s)
      for (const l of s) {
        const f = a.find(
          (d) => fe(d.pubkey, l.pubkey) === 0
        );
        if (f) {
          if (!r(
            l.pubkey,
            f.hash,
            o4(l.signature)
          )) return false;
          u++;
        }
      }
    return u > 0;
  }
  signAllInputsHD(t, r = [or.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const n = [];
    for (const o of Jf(this.data.inputs.length))
      try {
        this.signInputHD(o, t, r), n.push(true);
      } catch {
        n.push(false);
      }
    if (n.every((o) => o === false))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(t, r = [or.SIGHASH_ALL]) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey || !t.fingerprint)
        return o(new Error("Need HDSigner to sign input"));
      const i = [], s = [];
      for (const a of Jf(this.data.inputs.length))
        s.push(
          this.signInputHDAsync(a, t, r).then(
            () => {
              i.push(true);
            },
            () => {
              i.push(false);
            }
          )
        );
      return Promise.all(s).then(() => {
        if (i.every((a) => a === false))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInputHD(t, r, n = [or.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return i4(t, this.data.inputs, r).forEach((i) => this.signInput(t, i, n)), this;
  }
  signInputHDAsync(t, r, n = [or.SIGHASH_ALL]) {
    return new Promise((o, i) => {
      if (!r || !r.publicKey || !r.fingerprint)
        return i(new Error("Need HDSigner to sign input"));
      const a = i4(t, this.data.inputs, r).map(
        (c) => this.signInputAsync(t, c, n)
      );
      return Promise.all(a).then(() => {
        o();
      }).catch(i);
    });
  }
  signAllInputs(t, r) {
    if (!t || !t.publicKey)
      throw new Error("Need Signer to sign input");
    const n = [];
    for (const o of Jf(this.data.inputs.length))
      try {
        this.signInput(o, t, r), n.push(true);
      } catch {
        n.push(false);
      }
    if (n.every((o) => o === false))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(t, r) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey)
        return o(new Error("Need Signer to sign input"));
      const i = [], s = [];
      for (const [a] of this.data.inputs.entries())
        s.push(
          this.signInputAsync(a, t, r).then(
            () => {
              i.push(true);
            },
            () => {
              i.push(false);
            }
          )
        );
      return Promise.all(s).then(() => {
        if (i.every((a) => a === false))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInput(t, r, n) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const o = cn(this.data.inputs, t);
    return Yo(o) ? this._signTaprootInput(
      t,
      o,
      r,
      void 0,
      n
    ) : this._signInput(t, r, n);
  }
  signTaprootInput(t, r, n, o) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const i = cn(this.data.inputs, t);
    if (Yo(i))
      return this._signTaprootInput(
        t,
        i,
        r,
        n,
        o
      );
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  _signInput(t, r, n = [or.SIGHASH_ALL]) {
    const { hash: o, sighashType: i } = n4(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    ), s = [
      {
        pubkey: r.publicKey,
        signature: yd.encode(r.sign(o), i)
      }
    ];
    return this.data.updateInput(t, { partialSig: s }), this;
  }
  _signTaprootInput(t, r, n, o, i = [or.SIGHASH_DEFAULT]) {
    const s = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      i
    ), a = s.filter((u) => !u.leafHash).map(
      (u) => wp(
        n.signSchnorr(u.hash),
        r.sighashType
      )
    )[0], c = s.filter((u) => !!u.leafHash).map((u) => ({
      pubkey: vd(n.publicKey),
      signature: wp(
        n.signSchnorr(u.hash),
        r.sighashType
      ),
      leafHash: u.leafHash
    }));
    return a && this.data.updateInput(t, { tapKeySig: a }), c.length && this.data.updateInput(t, { tapScriptSig: c }), this;
  }
  signInputAsync(t, r, n) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const o = cn(this.data.inputs, t);
      return Yo(o) ? this._signTaprootInputAsync(
        t,
        o,
        r,
        void 0,
        n
      ) : this._signInputAsync(t, r, n);
    });
  }
  signTaprootInputAsync(t, r, n, o) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const i = cn(this.data.inputs, t);
      if (Yo(i))
        return this._signTaprootInputAsync(
          t,
          i,
          r,
          n,
          o
        );
      throw new Error(`Input #${t} is not of type Taproot.`);
    });
  }
  _signInputAsync(t, r, n = [or.SIGHASH_ALL]) {
    const { hash: o, sighashType: i } = n4(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    );
    return Promise.resolve(r.sign(o)).then((s) => {
      const a = [
        {
          pubkey: r.publicKey,
          signature: yd.encode(s, i)
        }
      ];
      this.data.updateInput(t, { partialSig: a });
    });
  }
  async _signTaprootInputAsync(t, r, n, o, i = [or.SIGHASH_DEFAULT]) {
    const s = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      i
    ), a = [], c = s.filter((l) => !l.leafHash)[0];
    if (c) {
      const l = Promise.resolve(
        n.signSchnorr(c.hash)
      ).then((f) => ({ tapKeySig: wp(f, r.sighashType) }));
      a.push(l);
    }
    const u = s.filter((l) => !!l.leafHash);
    if (u.length) {
      const l = u.map((f) => Promise.resolve(n.signSchnorr(f.hash)).then(
        (d) => ({ tapScriptSig: [
          {
            pubkey: vd(n.publicKey),
            signature: wp(
              d,
              r.sighashType
            ),
            leafHash: f.leafHash
          }
        ] })
      ));
      a.push(...l);
    }
    return Promise.all(a).then((l) => {
      l.forEach((f) => this.data.updateInput(t, f));
    });
  }
  checkTaprootHashesForSig(t, r, n, o, i) {
    if (typeof n.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${t}.`
      );
    const s = sw(
      t,
      r,
      this.data.inputs,
      n.publicKey,
      this.__CACHE,
      o,
      i
    );
    if (!s || !s.length)
      throw new Error(
        `Can not sign for input #${t} with the key ${Fe(n.publicKey)}`
      );
    return s;
  }
  toBuffer() {
    return _b(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return _b(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return _b(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, r) {
    return r.witnessScript && U0(r.witnessScript), X5(
      this.data.inputs[t],
      r,
      "updateInput"
    ), this.data.updateInput(t, r), r.nonWitnessUtxo && aw(
      this.__CACHE,
      this.data.inputs[t],
      t
    ), this;
  }
  updateOutput(t, r) {
    const n = this.data.outputs[t];
    return Y5(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    return this.data.addUnknownKeyValToInput(t, r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    return this.data.addUnknownKeyValToOutput(t, r), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
};
var NR = (e) => new k7(e);
var k7 = class {
  constructor(t = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    Pt(this, "tx");
    this.tx = or.fromBuffer(t), zR(this.tx), Object.defineProperty(this, "tx", {
      enumerable: false,
      writable: true
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const r = typeof t.hash == "string" ? fv(Js(t.hash)) : t.hash;
    this.tx.addInput(r, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
};
function UR(e, t, r) {
  switch (r) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return J5(1, e.partialSig);
    case "multisig":
      const n = i1({ output: t });
      return J5(n.m, e.partialSig, n.pubkeys);
    default:
      return false;
  }
}
function _b(e) {
  if (e.__UNSAFE_SIGN_NONSEGWIT !== false)
    throw new Error("Not BIP174 compliant, can not export");
}
function J5(e, t, r) {
  if (!t) return false;
  let n;
  if (r ? n = r.map((o) => {
    const i = XR(o);
    return t.find(
      (s) => fe(s.pubkey, i) === 0
    );
  }).filter((o) => !!o) : n = t, n.length > e) throw new Error("Too many signatures");
  return n.length === e;
}
function A7(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function Q5(e) {
  return (t) => !(fe(e.fingerprint, t.masterFingerprint) || fe(e.derivePath(t.path).publicKey, t.pubkey));
}
function vp(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function $R(e, t, r) {
  const n = t.__FEE_RATE || e.getFeeRate(), o = t.__EXTRACTED_TX.virtualSize(), i = n * o;
  if (n >= r.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(i / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${o} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function Yf(e, t) {
  e.forEach((r) => {
    if (Yo(r) ? vR(r, t) : pR(r, t))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function RR(e) {
  if (!e.sighashType || !e.partialSig) return;
  const { partialSig: t, sighashType: r } = e;
  t.forEach((n) => {
    const { hashType: o } = yd.decode(n.signature);
    if (r !== o)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function S7(e, t, r) {
  if (!u1(e, t))
    throw new Error(
      `Can not ${r} for this input with the key ${Fe(e)}`
    );
}
function zR(e) {
  if (!e.ins.every(
    (r) => r.script && r.script.length === 0 && r.witness && r.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function HR(e, t) {
  e.ins.forEach((r) => {
    _7(t, r);
  });
}
function _7(e, t) {
  const r = Fe(fv(Uint8Array.from(t.hash))) + ":" + t.index;
  if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
  e.__TX_IN_CACHE[r] = 1;
}
function T7(e, t) {
  return (r, n, o, i) => {
    const s = e({
      redeem: { output: o }
    }).output;
    if (fe(n, s))
      throw new Error(
        `${t} for ${i} #${r} doesn't match the scriptPubKey in the prevout`
      );
  };
}
var e4 = T7(kf, "Redeem script");
var t4 = T7(
  Th,
  "Witness script"
);
function r4(e, t, r, n) {
  if (!r.every(A7))
    throw new Error(`PSBT must be finalized to calculate ${t}`);
  if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
  if (e === "__FEE" && n.__FEE) return n.__FEE;
  let o, i = true;
  if (n.__EXTRACTED_TX ? (o = n.__EXTRACTED_TX, i = false) : o = n.__TX.clone(), C7(r, o, n, i), e === "__FEE_RATE") return n.__FEE_RATE;
  if (e === "__FEE") return n.__FEE;
}
function LR(e, t, r, n, o, i) {
  const s = $7(r);
  if (!UR(t, r, s))
    throw new Error(`Can not finalize input #${e}`);
  return jR(
    r,
    s,
    t.partialSig,
    n,
    o,
    i
  );
}
function jR(e, t, r, n, o, i) {
  let s, a;
  const c = DR(e, t, r), u = i ? Th({ redeem: c }) : null, l = o ? kf({ redeem: u || c }) : null;
  return n ? (u ? a = N0(u.witness) : a = N0(c.witness), l && (s = l.input)) : l ? s = l.input : s = c.input, {
    finalScriptSig: s,
    finalScriptWitness: a
  };
}
function n4(e, t, r, n, o) {
  const i = cn(e, t), { hash: s, sighashType: a, script: c } = P7(
    t,
    i,
    n,
    false,
    o
  );
  return S7(r, c, "sign"), {
    hash: s,
    sighashType: a
  };
}
function P7(e, t, r, n, o) {
  const i = r.__TX, s = t.sighashType || or.SIGHASH_ALL;
  O7(s, o);
  let a, c;
  if (t.nonWitnessUtxo) {
    const f = l1(
      r,
      t,
      e
    ), d = i.ins[e].hash, m = f.getHash();
    if (fe(d, m) !== 0)
      throw new Error(
        `Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`
      );
    const y = i.ins[e].index;
    c = f.outs[y];
  } else if (t.witnessUtxo)
    c = t.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: u, type: l } = f1(
    c.script,
    e,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(l) >= 0)
    a = i.hashForWitnessV0(
      e,
      u,
      c.value,
      s
    );
  else if (c1(u)) {
    const f = Sh({
      hash: u.slice(2)
    }).output;
    a = i.hashForWitnessV0(
      e,
      f,
      c.value,
      s
    );
  } else {
    if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === false)
      throw new Error(
        `Input #${e} has witnessUtxo but non-segwit script: ${Fe(u)}`
      );
    !n && r.__UNSAFE_SIGN_NONSEGWIT !== false && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), a = i.hashForSignature(
      e,
      u,
      s
    );
  }
  return {
    script: u,
    sighashType: s,
    hash: a
  };
}
function FR(e, t, r, n) {
  const o = [];
  if (t.tapInternalKey) {
    const s = I7(e, t, n);
    s && o.push(s);
  }
  if (t.tapScriptSig) {
    const s = t.tapScriptSig.map((a) => a.pubkey);
    o.push(...s);
  }
  return o.map(
    (s) => sw(e, t, r, s, n)
  ).flat();
}
function I7(e, t, r) {
  const { script: n } = yv(e, t, r);
  return v7(n) ? n.subarray(2, 34) : null;
}
function o4(e) {
  return e.length === 64 ? e : e.subarray(0, 64);
}
function sw(e, t, r, n, o, i, s) {
  const a = o.__TX, c = t.sighashType || or.SIGHASH_DEFAULT;
  O7(c, s);
  const u = r.map(
    (y, b) => yv(b, y, o)
  ), l = u.map((y) => y.script), f = u.map((y) => y.value), d = [];
  if (t.tapInternalKey && !i) {
    const y = I7(e, t, o) || Uint8Array.from([]);
    if (fe(vd(n), y) === 0) {
      const b = a.hashForWitnessV1(
        e,
        l,
        f,
        c
      );
      d.push({ pubkey: n, hash: b });
    }
  }
  const m = (t.tapLeafScript || []).filter((y) => u1(n, y.script)).map((y) => {
    const b = $s({
      output: y.script,
      version: y.leafVersion
    });
    return Object.assign({ hash: b }, y);
  }).filter(
    (y) => !i || fe(i, y.hash) === 0
  ).map((y) => {
    const b = a.hashForWitnessV1(
      e,
      l,
      f,
      c,
      y.hash
    );
    return {
      pubkey: n,
      hash: b,
      leafHash: y.hash
    };
  });
  return d.concat(m);
}
function O7(e, t) {
  if (t && t.indexOf(e) < 0) {
    const r = qR(e);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`
    );
  }
}
function DR(e, t, r) {
  let n;
  switch (t) {
    case "multisig":
      const o = MR(e, r);
      n = i1({
        output: e,
        signatures: o
      });
      break;
    case "pubkey":
      n = qx({
        output: e,
        signature: r[0].signature
      });
      break;
    case "pubkeyhash":
      n = Sh({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
    case "witnesspubkeyhash":
      n = _h({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
  }
  return n;
}
function KR(e, t, r) {
  const n = r.__TX, o = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false
  };
  if (o.isP2SH = !!t.redeemScript, o.isP2WSH = !!t.witnessScript, t.witnessScript)
    o.script = t.witnessScript;
  else if (t.redeemScript)
    o.script = t.redeemScript;
  else if (t.nonWitnessUtxo) {
    const i = l1(
      r,
      t,
      e
    ), s = n.ins[e].index;
    o.script = i.outs[s].script;
  } else t.witnessUtxo && (o.script = t.witnessUtxo.script);
  return (t.witnessScript || c1(o.script)) && (o.isSegwit = true), o;
}
function i4(e, t, r) {
  const n = cn(t, e);
  if (!n.bip32Derivation || n.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const o = n.bip32Derivation.map((s) => {
    if (fe(s.masterFingerprint, r.fingerprint) === 0)
      return s;
  }).filter((s) => !!s);
  if (o.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return o.map((s) => {
    const a = r.derivePath(s.path);
    if (fe(s.pubkey, a.publicKey) !== 0)
      throw new Error("pubkey did not match bip32Derivation");
    return a;
  });
}
function MR(e, t) {
  return i1({ output: e }).pubkeys.map((n) => (t.filter((o) => fe(o.pubkey, n) === 0)[0] || {}).signature).filter((n) => !!n);
}
function B7(e) {
  let t = 0;
  function r(s) {
    return t += s, e.slice(t - s, t);
  }
  function n() {
    const s = Af(e, t);
    return t += jo(s.bigintValue), s.numberValue;
  }
  function o() {
    return r(n());
  }
  function i() {
    const s = n(), a = [];
    for (let c = 0; c < s; c++) a.push(o());
    return a;
  }
  return i();
}
function qR(e) {
  let t = e & or.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case or.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case or.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case or.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function aw(e, t, r) {
  e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
  const n = or.fromBuffer(t.nonWitnessUtxo);
  e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
  const o = e, i = r;
  delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
    enumerable: true,
    get() {
      const s = o.__NON_WITNESS_UTXO_BUF_CACHE[i], a = o.__NON_WITNESS_UTXO_TX_CACHE[i];
      if (s !== void 0)
        return s;
      {
        const c = a.toBuffer();
        return o.__NON_WITNESS_UTXO_BUF_CACHE[i] = c, c;
      }
    },
    set(s) {
      o.__NON_WITNESS_UTXO_BUF_CACHE[i] = s;
    }
  });
}
function C7(e, t, r, n) {
  let o = 0n;
  e.forEach((c, u) => {
    if (n && c.finalScriptSig && (t.ins[u].script = c.finalScriptSig), n && c.finalScriptWitness && (t.ins[u].witness = B7(
      c.finalScriptWitness
    )), c.witnessUtxo)
      o += c.witnessUtxo.value;
    else if (c.nonWitnessUtxo) {
      const l = l1(r, c, u), f = t.ins[u].index, d = l.outs[f];
      o += d.value;
    }
  });
  const i = t.outs.reduce((c, u) => c + u.value, 0n), s = o - i;
  if (s < 0)
    throw new Error("Outputs are spending more than Inputs");
  const a = t.virtualSize();
  r.__FEE = s, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(s / BigInt(a)));
}
function l1(e, t, r) {
  const n = e.__NON_WITNESS_UTXO_TX_CACHE;
  return n[r] || aw(e, t, r), n[r];
}
function N7(e, t, r) {
  const { script: n } = yv(e, t, r);
  return n;
}
function yv(e, t, r) {
  if (t.witnessUtxo !== void 0)
    return {
      script: t.witnessUtxo.script,
      value: t.witnessUtxo.value
    };
  if (t.nonWitnessUtxo !== void 0) {
    const o = l1(
      r,
      t,
      e
    ).outs[r.__TX.ins[e].index];
    return { script: o.script, value: o.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function VR(e, t, r, n) {
  const o = N7(r, t, n), { meaningfulScript: i } = f1(
    o,
    r,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  return u1(e, i);
}
function GR(e, t, r, n) {
  const o = n.__TX.outs[r].script, { meaningfulScript: i } = f1(
    o,
    r,
    "output",
    t.redeemScript,
    t.witnessScript
  );
  return u1(e, i);
}
function WR(e) {
  if (!e) return;
  const t = ar(e);
  if (!t) return;
  const r = t[t.length - 1];
  if (!(!(r instanceof Uint8Array) || U7(r) || YR(r) || !ar(r)))
    return r;
}
function ZR(e) {
  if (!e) return;
  const t = B7(e), r = t[t.length - 1];
  if (!(U7(r) || !ar(r)))
    return r;
}
function XR(e) {
  if (e.length === 65) {
    const t = e[64] & 1, r = e.slice(0, 33);
    return r[0] = 2 | t, r;
  }
  return e.slice();
}
function U7(e) {
  return e.length === 33 && SN(e);
}
function YR(e) {
  return Ms(e);
}
function f1(e, t, r, n, o) {
  const i = w7(e), s = i && n && W5(n), a = W5(e);
  if (i && n === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((a || s) && o === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let c;
  return s ? (c = o, e4(t, e, n, r), t4(t, n, o, r), U0(c)) : a ? (c = o, t4(t, e, o, r), U0(c)) : i ? (c = n, e4(t, e, n, r)) : c = e, {
    meaningfulScript: c,
    type: s ? "p2sh-p2wsh" : i ? "p2sh" : a ? "p2wsh" : "raw"
  };
}
function U0(e) {
  if (c1(e) || w7(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function $7(e) {
  return c1(e) ? "witnesspubkeyhash" : hR(e) ? "pubkeyhash" : fR(e) ? "multisig" : dR(e) ? "pubkey" : "nonstandard";
}
function Jf(e) {
  return [...Array(e).keys()];
}
var R7 = class extends Vx {
  constructor(t, r) {
    super(), this.finished = false, this.destroyed = false, TN(t);
    const n = iv(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, i = new Uint8Array(o);
    i.set(n.length > o ? t.create().update(n).digest() : n);
    for (let s = 0; s < i.length; s++)
      i[s] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let s = 0; s < i.length; s++)
      i[s] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return I0(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    I0(this), s1(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: i, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = o, t.destroyed = i, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var wv = (e, t, r) => new R7(e, t).update(r).digest();
wv.create = (e, t) => new R7(e, t);
var vv = BigInt(0);
var d1 = BigInt(1);
var JR = BigInt(2);
function _u(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function Oh(e) {
  if (!_u(e))
    throw new Error("Uint8Array expected");
}
function Kl(e, t) {
  if (typeof t != "boolean")
    throw new Error(`${e} must be valid boolean, got "${t}".`);
}
var QR = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ml(e) {
  Oh(e);
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += QR[e[r]];
  return t;
}
function _l(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Ev(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
var bs = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function s4(e) {
  if (e >= bs._0 && e <= bs._9)
    return e - bs._0;
  if (e >= bs._A && e <= bs._F)
    return e - (bs._A - 10);
  if (e >= bs._a && e <= bs._f)
    return e - (bs._a - 10);
}
function ql(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let o = 0, i = 0; o < r; o++, i += 2) {
    const s = s4(e.charCodeAt(i)), a = s4(e.charCodeAt(i + 1));
    if (s === void 0 || a === void 0) {
      const c = e[i] + e[i + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + i);
    }
    n[o] = s * 16 + a;
  }
  return n;
}
function mu(e) {
  return Ev(Ml(e));
}
function xv(e) {
  return Oh(e), Ev(Ml(Uint8Array.from(e).reverse()));
}
function Vl(e, t) {
  return ql(e.toString(16).padStart(t * 2, "0"));
}
function kv(e, t) {
  return Vl(e, t).reverse();
}
function ez(e) {
  return ql(_l(e));
}
function Zo(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = ql(t);
    } catch (i) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${i}`);
    }
  else if (_u(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function $d(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    Oh(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const i = e[n];
    r.set(i, o), o += i.length;
  }
  return r;
}
function tz(e, t) {
  if (e.length !== t.length)
    return false;
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r |= e[n] ^ t[n];
  return r === 0;
}
function rz(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
var Tb = (e) => typeof e == "bigint" && vv <= e;
function h1(e, t, r) {
  return Tb(e) && Tb(t) && Tb(r) && t <= e && e < r;
}
function bu(e, t, r, n) {
  if (!h1(t, r, n))
    throw new Error(`expected valid ${e}: ${r} <= n < ${n}, got ${typeof t} ${t}`);
}
function z7(e) {
  let t;
  for (t = 0; e > vv; e >>= d1, t += 1)
    ;
  return t;
}
function nz(e, t) {
  return e >> BigInt(t) & d1;
}
function oz(e, t, r) {
  return e | (r ? d1 : vv) << BigInt(t);
}
var Av = (e) => (JR << BigInt(e - 1)) - d1;
var Pb = (e) => new Uint8Array(e);
var a4 = (e) => Uint8Array.from(e);
function H7(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = Pb(e), o = Pb(e), i = 0;
  const s = () => {
    n.fill(1), o.fill(0), i = 0;
  }, a = (...f) => r(o, n, ...f), c = (f = Pb()) => {
    o = a(a4([0]), f), n = a(), f.length !== 0 && (o = a(a4([1]), f), n = a());
  }, u = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let f = 0;
    const d = [];
    for (; f < t; ) {
      n = a();
      const m = n.slice();
      d.push(m), f += n.length;
    }
    return $d(...d);
  };
  return (f, d) => {
    s(), c(f);
    let m;
    for (; !(m = d(u())); )
      c();
    return s(), m;
  };
}
var iz = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || _u(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Bh(e, t, r = {}) {
  const n = (o, i, s) => {
    const a = iz[i];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const c = e[o];
    if (!(s && c === void 0) && !a(c, e))
      throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${i}`);
  };
  for (const [o, i] of Object.entries(t))
    n(o, i, false);
  for (const [o, i] of Object.entries(r))
    n(o, i, true);
  return e;
}
var sz = () => {
  throw new Error("not implemented");
};
function cw(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const o = t.get(r);
    if (o !== void 0)
      return o;
    const i = e(r, ...n);
    return t.set(r, i), i;
  };
}
var az = Object.freeze(Object.defineProperty({
  __proto__: null,
  aInRange: bu,
  abool: Kl,
  abytes: Oh,
  bitGet: nz,
  bitLen: z7,
  bitMask: Av,
  bitSet: oz,
  bytesToHex: Ml,
  bytesToNumberBE: mu,
  bytesToNumberLE: xv,
  concatBytes: $d,
  createHmacDrbg: H7,
  ensureBytes: Zo,
  equalBytes: tz,
  hexToBytes: ql,
  hexToNumber: Ev,
  inRange: h1,
  isBytes: _u,
  memoized: cw,
  notImplemented: sz,
  numberToBytesBE: Vl,
  numberToBytesLE: kv,
  numberToHexUnpadded: _l,
  numberToVarBytesBE: ez,
  utf8ToBytes: rz,
  validateObject: Bh
}, Symbol.toStringTag, { value: "Module" }));
var tn = BigInt(0);
var Sr = BigInt(1);
var Qc = BigInt(2);
var cz = BigInt(3);
var uw = BigInt(4);
var c4 = BigInt(5);
var u4 = BigInt(8);
BigInt(9);
BigInt(16);
function Tn(e, t) {
  const r = e % t;
  return r >= tn ? r : t + r;
}
function uz(e, t, r) {
  if (r <= tn || t < tn)
    throw new Error("Expected power/modulo > 0");
  if (r === Sr)
    return tn;
  let n = Sr;
  for (; t > tn; )
    t & Sr && (n = n * e % r), e = e * e % r, t >>= Sr;
  return n;
}
function Po(e, t, r) {
  let n = e;
  for (; t-- > tn; )
    n *= n, n %= r;
  return n;
}
function lw(e, t) {
  if (e === tn || t <= tn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Tn(e, t), n = t, o = tn, i = Sr;
  for (; r !== tn; ) {
    const a = n / r, c = n % r, u = o - i * a;
    n = r, r = c, o = i, i = u;
  }
  if (n !== Sr)
    throw new Error("invert: does not exist");
  return Tn(o, t);
}
function lz(e) {
  const t = (e - Sr) / Qc;
  let r, n, o;
  for (r = e - Sr, n = 0; r % Qc === tn; r /= Qc, n++)
    ;
  for (o = Qc; o < e && uz(o, t, e) !== e - Sr; o++)
    ;
  if (n === 1) {
    const s = (e + Sr) / uw;
    return function(c, u) {
      const l = c.pow(u, s);
      if (!c.eql(c.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const i = (r + Sr) / Qc;
  return function(a, c) {
    if (a.pow(c, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, l = a.pow(a.mul(a.ONE, o), r), f = a.pow(c, i), d = a.pow(c, r);
    for (; !a.eql(d, a.ONE); ) {
      if (a.eql(d, a.ZERO))
        return a.ZERO;
      let m = 1;
      for (let b = a.sqr(d); m < u && !a.eql(b, a.ONE); m++)
        b = a.sqr(b);
      const y = a.pow(l, Sr << BigInt(u - m - 1));
      l = a.sqr(y), f = a.mul(f, y), d = a.mul(d, l), u = m;
    }
    return f;
  };
}
function fz(e) {
  if (e % uw === cz) {
    const t = (e + Sr) / uw;
    return function(n, o) {
      const i = n.pow(o, t);
      if (!n.eql(n.sqr(i), o))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (e % u4 === c4) {
    const t = (e - c4) / u4;
    return function(n, o) {
      const i = n.mul(o, Qc), s = n.pow(i, t), a = n.mul(o, s), c = n.mul(n.mul(a, Qc), s), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), o))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return lz(e);
}
var dz = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function hz(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = dz.reduce((n, o) => (n[o] = "function", n), t);
  return Bh(e, r);
}
function pz(e, t, r) {
  if (r < tn)
    throw new Error("Expected power > 0");
  if (r === tn)
    return e.ONE;
  if (r === Sr)
    return t;
  let n = e.ONE, o = t;
  for (; r > tn; )
    r & Sr && (n = e.mul(n, o)), o = e.sqr(o), r >>= Sr;
  return n;
}
function gz(e, t) {
  const r = new Array(t.length), n = t.reduce((i, s, a) => e.is0(s) ? i : (r[a] = i, e.mul(i, s)), e.ONE), o = e.inv(n);
  return t.reduceRight((i, s, a) => e.is0(s) ? i : (r[a] = e.mul(i, r[a]), e.mul(i, s)), o), r;
}
function L7(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function Sv(e, t, r = false, n = {}) {
  if (e <= tn)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: i } = L7(e, t);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = fz(e), a = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: i,
    MASK: Av(o),
    ZERO: tn,
    ONE: Sr,
    create: (c) => Tn(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return tn <= c && c < e;
    },
    is0: (c) => c === tn,
    isOdd: (c) => (c & Sr) === Sr,
    neg: (c) => Tn(-c, e),
    eql: (c, u) => c === u,
    sqr: (c) => Tn(c * c, e),
    add: (c, u) => Tn(c + u, e),
    sub: (c, u) => Tn(c - u, e),
    mul: (c, u) => Tn(c * u, e),
    pow: (c, u) => pz(a, c, u),
    div: (c, u) => Tn(c * lw(u, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => lw(c, e),
    sqrt: n.sqrt || ((c) => s(a, c)),
    invertBatch: (c) => gz(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => r ? kv(c, i) : Vl(c, i),
    fromBytes: (c) => {
      if (c.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${c.length}`);
      return r ? xv(c) : mu(c);
    }
  });
  return Object.freeze(a);
}
function j7(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function F7(e) {
  const t = j7(e);
  return t + Math.ceil(t / 2);
}
function mz(e, t, r = false) {
  const n = e.length, o = j7(t), i = F7(t);
  if (n < 16 || n < i || n > 1024)
    throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);
  const s = r ? mu(e) : xv(e), a = Tn(s, t - Sr) + Sr;
  return r ? kv(a, o) : Vl(a, o);
}
var bz = BigInt(0);
var Ib = BigInt(1);
var Ob = /* @__PURE__ */ new WeakMap();
var l4 = /* @__PURE__ */ new WeakMap();
function yz(e, t) {
  const r = (i, s) => {
    const a = s.negate();
    return i ? a : s;
  }, n = (i) => {
    if (!Number.isSafeInteger(i) || i <= 0 || i > t)
      throw new Error(`Wrong window size=${i}, should be [1..${t}]`);
  }, o = (i) => {
    n(i);
    const s = Math.ceil(t / i) + 1, a = 2 ** (i - 1);
    return { windows: s, windowSize: a };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(i, s) {
      let a = e.ZERO, c = i;
      for (; s > bz; )
        s & Ib && (a = a.add(c)), c = c.double(), s >>= Ib;
      return a;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, s) {
      const { windows: a, windowSize: c } = o(s), u = [];
      let l = i, f = l;
      for (let d = 0; d < a; d++) {
        f = l, u.push(f);
        for (let m = 1; m < c; m++)
          f = f.add(l), u.push(f);
        l = f.double();
      }
      return u;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, s, a) {
      const { windows: c, windowSize: u } = o(i);
      let l = e.ZERO, f = e.BASE;
      const d = BigInt(2 ** i - 1), m = 2 ** i, y = BigInt(i);
      for (let b = 0; b < c; b++) {
        const w = b * u;
        let v = Number(a & d);
        a >>= y, v > u && (v -= m, a += Ib);
        const k = w, x = w + Math.abs(v) - 1, _ = b % 2 !== 0, I = v < 0;
        v === 0 ? f = f.add(r(_, s[k])) : l = l.add(r(I, s[x]));
      }
      return { p: l, f };
    },
    wNAFCached(i, s, a) {
      const c = l4.get(i) || 1;
      let u = Ob.get(i);
      return u || (u = this.precomputeWindow(i, c), c !== 1 && Ob.set(i, a(u))), this.wNAF(c, u, s);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(i, s) {
      n(s), l4.set(i, s), Ob.delete(i);
    }
  };
}
function wz(e, t, r, n) {
  if (!Array.isArray(r) || !Array.isArray(n) || n.length !== r.length)
    throw new Error("arrays of points and scalars must have equal length");
  n.forEach((l, f) => {
    if (!t.isValid(l))
      throw new Error(`wrong scalar at index ${f}`);
  }), r.forEach((l, f) => {
    if (!(l instanceof e))
      throw new Error(`wrong point at index ${f}`);
  });
  const o = z7(BigInt(r.length)), i = o > 12 ? o - 3 : o > 4 ? o - 2 : o ? 2 : 1, s = (1 << i) - 1, a = new Array(s + 1).fill(e.ZERO), c = Math.floor((t.BITS - 1) / i) * i;
  let u = e.ZERO;
  for (let l = c; l >= 0; l -= i) {
    a.fill(e.ZERO);
    for (let d = 0; d < n.length; d++) {
      const m = n[d], y = Number(m >> BigInt(l) & BigInt(s));
      a[y] = a[y].add(r[d]);
    }
    let f = e.ZERO;
    for (let d = a.length - 1, m = e.ZERO; d > 0; d--)
      m = m.add(a[d]), f = f.add(m);
    if (u = u.add(f), l !== 0)
      for (let d = 0; d < i; d++)
        u = u.double();
  }
  return u;
}
function D7(e) {
  return hz(e.Fp), Bh(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...L7(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
function f4(e) {
  e.lowS !== void 0 && Kl("lowS", e.lowS), e.prehash !== void 0 && Kl("prehash", e.prehash);
}
function vz(e) {
  const t = D7(e);
  Bh(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
var { bytesToNumberBE: Ez, hexToBytes: xz } = az;
var Os = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = Os;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, o = _l(n);
      if (o.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const i = n > 127 ? _l(o.length / 2 | 128) : "";
      return `${_l(e)}${i}${o}${t}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = Os;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const o = t[n++], i = !!(o & 128);
      let s = 0;
      if (!i)
        s = o;
      else {
        const c = o & 127;
        if (!c)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const u = t.subarray(n, n + c);
        if (u.length !== c)
          throw new r("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          s = s << 8 | l;
        if (n += c, s < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const a = t.subarray(n, n + s);
      if (a.length !== s)
        throw new r("tlv.decode: wrong value length");
      return { v: a, l: t.subarray(n + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = Os;
      if (e < Ns)
        throw new t("integer: negative integers are not allowed");
      let r = _l(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected assertion");
      return r;
    },
    decode(e) {
      const { Err: t } = Os;
      if (e[0] & 128)
        throw new t("Invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return Ez(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = Os, o = typeof e == "string" ? xz(e) : e;
    Oh(o);
    const { v: i, l: s } = n.decode(48, o);
    if (s.length)
      throw new t("Invalid signature: left bytes after parsing");
    const { v: a, l: c } = n.decode(2, i), { v: u, l } = n.decode(2, c);
    if (l.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: r.decode(a), s: r.decode(u) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = Os, n = `${t.encode(2, r.encode(e.r))}${t.encode(2, r.encode(e.s))}`;
    return t.encode(48, n);
  }
};
var Ns = BigInt(0);
var Zr = BigInt(1);
BigInt(2);
var d4 = BigInt(3);
BigInt(4);
function kz(e) {
  const t = vz(e), { Fp: r } = t, n = Sv(t.n, t.nBitLength), o = t.toBytes || ((b, w, v) => {
    const k = w.toAffine();
    return $d(Uint8Array.from([4]), r.toBytes(k.x), r.toBytes(k.y));
  }), i = t.fromBytes || ((b) => {
    const w = b.subarray(1), v = r.fromBytes(w.subarray(0, r.BYTES)), k = r.fromBytes(w.subarray(r.BYTES, 2 * r.BYTES));
    return { x: v, y: k };
  });
  function s(b) {
    const { a: w, b: v } = t, k = r.sqr(b), x = r.mul(k, b);
    return r.add(r.add(x, r.mul(b, w)), v);
  }
  if (!r.eql(r.sqr(t.Gy), s(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(b) {
    return h1(b, Zr, t.n);
  }
  function c(b) {
    const { allowedPrivateKeyLengths: w, nByteLength: v, wrapPrivateKey: k, n: x } = t;
    if (w && typeof b != "bigint") {
      if (_u(b) && (b = Ml(b)), typeof b != "string" || !w.includes(b.length))
        throw new Error("Invalid key");
      b = b.padStart(v * 2, "0");
    }
    let _;
    try {
      _ = typeof b == "bigint" ? b : mu(Zo("private key", b, v));
    } catch {
      throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof b}`);
    }
    return k && (_ = Tn(_, x)), bu("private key", _, Zr, x), _;
  }
  function u(b) {
    if (!(b instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  const l = cw((b, w) => {
    const { px: v, py: k, pz: x } = b;
    if (r.eql(x, r.ONE))
      return { x: v, y: k };
    const _ = b.is0();
    w == null && (w = _ ? r.ONE : r.inv(x));
    const I = r.mul(v, w), P = r.mul(k, w), $ = r.mul(x, w);
    if (_)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql($, r.ONE))
      throw new Error("invZ was invalid");
    return { x: I, y: P };
  }), f = cw((b) => {
    if (b.is0()) {
      if (t.allowInfinityPoint && !r.is0(b.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: w, y: v } = b.toAffine();
    if (!r.isValid(w) || !r.isValid(v))
      throw new Error("bad point: x or y not FE");
    const k = r.sqr(v), x = s(w);
    if (!r.eql(k, x))
      throw new Error("bad point: equation left != right");
    if (!b.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class d {
    constructor(w, v, k) {
      if (this.px = w, this.py = v, this.pz = k, w == null || !r.isValid(w))
        throw new Error("x required");
      if (v == null || !r.isValid(v))
        throw new Error("y required");
      if (k == null || !r.isValid(k))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(w) {
      const { x: v, y: k } = w || {};
      if (!w || !r.isValid(v) || !r.isValid(k))
        throw new Error("invalid affine point");
      if (w instanceof d)
        throw new Error("projective point not allowed");
      const x = (_) => r.eql(_, r.ZERO);
      return x(v) && x(k) ? d.ZERO : new d(v, k, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(w) {
      const v = r.invertBatch(w.map((k) => k.pz));
      return w.map((k, x) => k.toAffine(v[x])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(w) {
      const v = d.fromAffine(i(Zo("pointHex", w)));
      return v.assertValidity(), v;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(w) {
      return d.BASE.multiply(c(w));
    }
    // Multiscalar Multiplication
    static msm(w, v) {
      return wz(d, n, w, v);
    }
    // "Private method", don't use it directly
    _setWindowSize(w) {
      y.setWindowSize(this, w);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      f(this);
    }
    hasEvenY() {
      const { y: w } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(w);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(w) {
      u(w);
      const { px: v, py: k, pz: x } = this, { px: _, py: I, pz: P } = w, $ = r.eql(r.mul(v, P), r.mul(_, x)), L = r.eql(r.mul(k, P), r.mul(I, x));
      return $ && L;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: w, b: v } = t, k = r.mul(v, d4), { px: x, py: _, pz: I } = this;
      let P = r.ZERO, $ = r.ZERO, L = r.ZERO, V = r.mul(x, x), ee = r.mul(_, _), G = r.mul(I, I), N = r.mul(x, _);
      return N = r.add(N, N), L = r.mul(x, I), L = r.add(L, L), P = r.mul(w, L), $ = r.mul(k, G), $ = r.add(P, $), P = r.sub(ee, $), $ = r.add(ee, $), $ = r.mul(P, $), P = r.mul(N, P), L = r.mul(k, L), G = r.mul(w, G), N = r.sub(V, G), N = r.mul(w, N), N = r.add(N, L), L = r.add(V, V), V = r.add(L, V), V = r.add(V, G), V = r.mul(V, N), $ = r.add($, V), G = r.mul(_, I), G = r.add(G, G), V = r.mul(G, N), P = r.sub(P, V), L = r.mul(G, ee), L = r.add(L, L), L = r.add(L, L), new d(P, $, L);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(w) {
      u(w);
      const { px: v, py: k, pz: x } = this, { px: _, py: I, pz: P } = w;
      let $ = r.ZERO, L = r.ZERO, V = r.ZERO;
      const ee = t.a, G = r.mul(t.b, d4);
      let N = r.mul(v, _), q = r.mul(k, I), j = r.mul(x, P), C = r.add(v, k), U = r.add(_, I);
      C = r.mul(C, U), U = r.add(N, q), C = r.sub(C, U), U = r.add(v, x);
      let M = r.add(_, P);
      return U = r.mul(U, M), M = r.add(N, j), U = r.sub(U, M), M = r.add(k, x), $ = r.add(I, P), M = r.mul(M, $), $ = r.add(q, j), M = r.sub(M, $), V = r.mul(ee, U), $ = r.mul(G, j), V = r.add($, V), $ = r.sub(q, V), V = r.add(q, V), L = r.mul($, V), q = r.add(N, N), q = r.add(q, N), j = r.mul(ee, j), U = r.mul(G, U), q = r.add(q, j), j = r.sub(N, j), j = r.mul(ee, j), U = r.add(U, j), N = r.mul(q, U), L = r.add(L, N), N = r.mul(M, U), $ = r.mul(C, $), $ = r.sub($, N), N = r.mul(C, q), V = r.mul(M, V), V = r.add(V, N), new d($, L, V);
    }
    subtract(w) {
      return this.add(w.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(w) {
      return y.wNAFCached(this, w, d.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(w) {
      bu("scalar", w, Ns, t.n);
      const v = d.ZERO;
      if (w === Ns)
        return v;
      if (w === Zr)
        return this;
      const { endo: k } = t;
      if (!k)
        return y.unsafeLadder(this, w);
      let { k1neg: x, k1: _, k2neg: I, k2: P } = k.splitScalar(w), $ = v, L = v, V = this;
      for (; _ > Ns || P > Ns; )
        _ & Zr && ($ = $.add(V)), P & Zr && (L = L.add(V)), V = V.double(), _ >>= Zr, P >>= Zr;
      return x && ($ = $.negate()), I && (L = L.negate()), L = new d(r.mul(L.px, k.beta), L.py, L.pz), $.add(L);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(w) {
      const { endo: v, n: k } = t;
      bu("scalar", w, Zr, k);
      let x, _;
      if (v) {
        const { k1neg: I, k1: P, k2neg: $, k2: L } = v.splitScalar(w);
        let { p: V, f: ee } = this.wNAF(P), { p: G, f: N } = this.wNAF(L);
        V = y.constTimeNegate(I, V), G = y.constTimeNegate($, G), G = new d(r.mul(G.px, v.beta), G.py, G.pz), x = V.add(G), _ = ee.add(N);
      } else {
        const { p: I, f: P } = this.wNAF(w);
        x = I, _ = P;
      }
      return d.normalizeZ([x, _])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(w, v, k) {
      const x = d.BASE, _ = (P, $) => $ === Ns || $ === Zr || !P.equals(x) ? P.multiplyUnsafe($) : P.multiply($), I = _(this, v).add(_(w, k));
      return I.is0() ? void 0 : I;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(w) {
      return l(this, w);
    }
    isTorsionFree() {
      const { h: w, isTorsionFree: v } = t;
      if (w === Zr)
        return true;
      if (v)
        return v(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: w, clearCofactor: v } = t;
      return w === Zr ? this : v ? v(d, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(w = true) {
      return Kl("isCompressed", w), this.assertValidity(), o(d, this, w);
    }
    toHex(w = true) {
      return Kl("isCompressed", w), Ml(this.toRawBytes(w));
    }
  }
  d.BASE = new d(t.Gx, t.Gy, r.ONE), d.ZERO = new d(r.ZERO, r.ONE, r.ZERO);
  const m = t.nBitLength, y = yz(d, t.endo ? Math.ceil(m / 2) : m);
  return {
    CURVE: t,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: a
  };
}
function Az(e) {
  const t = D7(e);
  return Bh(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: true, ...t });
}
function Sz(e) {
  const t = Az(e), { Fp: r, n } = t, o = r.BYTES + 1, i = 2 * r.BYTES + 1;
  function s(j) {
    return Tn(j, n);
  }
  function a(j) {
    return lw(j, n);
  }
  const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: l, isWithinCurveOrder: f } = kz({
    ...t,
    toBytes(j, C, U) {
      const M = C.toAffine(), re = r.toBytes(M.x), te = $d;
      return Kl("isCompressed", U), U ? te(Uint8Array.from([C.hasEvenY() ? 2 : 3]), re) : te(Uint8Array.from([4]), re, r.toBytes(M.y));
    },
    fromBytes(j) {
      const C = j.length, U = j[0], M = j.subarray(1);
      if (C === o && (U === 2 || U === 3)) {
        const re = mu(M);
        if (!h1(re, Zr, r.ORDER))
          throw new Error("Point is not on curve");
        const te = l(re);
        let ie;
        try {
          ie = r.sqrt(te);
        } catch (K) {
          const ve = K instanceof Error ? ": " + K.message : "";
          throw new Error("Point is not on curve" + ve);
        }
        const ne = (ie & Zr) === Zr;
        return (U & 1) === 1 !== ne && (ie = r.neg(ie)), { x: re, y: ie };
      } else if (C === i && U === 4) {
        const re = r.fromBytes(M.subarray(0, r.BYTES)), te = r.fromBytes(M.subarray(r.BYTES, 2 * r.BYTES));
        return { x: re, y: te };
      } else
        throw new Error(`Point of length ${C} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`);
    }
  }), d = (j) => Ml(Vl(j, t.nByteLength));
  function m(j) {
    const C = n >> Zr;
    return j > C;
  }
  function y(j) {
    return m(j) ? s(-j) : j;
  }
  const b = (j, C, U) => mu(j.slice(C, U));
  class w {
    constructor(C, U, M) {
      this.r = C, this.s = U, this.recovery = M, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(C) {
      const U = t.nByteLength;
      return C = Zo("compactSignature", C, U * 2), new w(b(C, 0, U), b(C, U, 2 * U));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(C) {
      const { r: U, s: M } = Os.toSig(Zo("DER", C));
      return new w(U, M);
    }
    assertValidity() {
      bu("r", this.r, Zr, n), bu("s", this.s, Zr, n);
    }
    addRecoveryBit(C) {
      return new w(this.r, this.s, C);
    }
    recoverPublicKey(C) {
      const { r: U, s: M, recovery: re } = this, te = P(Zo("msgHash", C));
      if (re == null || ![0, 1, 2, 3].includes(re))
        throw new Error("recovery id invalid");
      const ie = re === 2 || re === 3 ? U + t.n : U;
      if (ie >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const ne = re & 1 ? "03" : "02", le = c.fromHex(ne + d(ie)), K = a(ie), ve = s(-te * K), At = s(M * K), ze = c.BASE.multiplyAndAddUnsafe(le, ve, At);
      if (!ze)
        throw new Error("point at infinify");
      return ze.assertValidity(), ze;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return m(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new w(this.r, s(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return ql(this.toDERHex());
    }
    toDERHex() {
      return Os.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return ql(this.toCompactHex());
    }
    toCompactHex() {
      return d(this.r) + d(this.s);
    }
  }
  const v = {
    isValidPrivateKey(j) {
      try {
        return u(j), true;
      } catch {
        return false;
      }
    },
    normPrivateKeyToScalar: u,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const j = F7(t.n);
      return mz(t.randomBytes(j), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(j = 8, C = c.BASE) {
      return C._setWindowSize(j), C.multiply(BigInt(3)), C;
    }
  };
  function k(j, C = true) {
    return c.fromPrivateKey(j).toRawBytes(C);
  }
  function x(j) {
    const C = _u(j), U = typeof j == "string", M = (C || U) && j.length;
    return C ? M === o || M === i : U ? M === 2 * o || M === 2 * i : j instanceof c;
  }
  function _(j, C, U = true) {
    if (x(j))
      throw new Error("first arg must be private key");
    if (!x(C))
      throw new Error("second arg must be public key");
    return c.fromHex(C).multiply(u(j)).toRawBytes(U);
  }
  const I = t.bits2int || function(j) {
    const C = mu(j), U = j.length * 8 - t.nBitLength;
    return U > 0 ? C >> BigInt(U) : C;
  }, P = t.bits2int_modN || function(j) {
    return s(I(j));
  }, $ = Av(t.nBitLength);
  function L(j) {
    return bu(`num < 2^${t.nBitLength}`, j, Ns, $), Vl(j, t.nByteLength);
  }
  function V(j, C, U = ee) {
    if (["recovered", "canonical"].some((et) => et in U))
      throw new Error("sign() legacy options not supported");
    const { hash: M, randomBytes: re } = t;
    let { lowS: te, prehash: ie, extraEntropy: ne } = U;
    te == null && (te = true), j = Zo("msgHash", j), f4(U), ie && (j = Zo("prehashed msgHash", M(j)));
    const le = P(j), K = u(C), ve = [L(K), L(le)];
    if (ne != null && ne !== false) {
      const et = ne === true ? re(r.BYTES) : ne;
      ve.push(Zo("extraEntropy", et));
    }
    const At = $d(...ve), ze = le;
    function St(et) {
      const Ge = I(et);
      if (!f(Ge))
        return;
      const ut = a(Ge), ot = c.BASE.multiply(Ge).toAffine(), He = s(ot.x);
      if (He === Ns)
        return;
      const Ae = s(ut * s(ze + He * K));
      if (Ae === Ns)
        return;
      let bt = (ot.x === He ? 0 : 2) | Number(ot.y & Zr), wr = Ae;
      return te && m(Ae) && (wr = y(Ae), bt ^= 1), new w(He, wr, bt);
    }
    return { seed: At, k2sig: St };
  }
  const ee = { lowS: t.lowS, prehash: false }, G = { lowS: t.lowS, prehash: false };
  function N(j, C, U = ee) {
    const { seed: M, k2sig: re } = V(j, C, U), te = t;
    return H7(te.hash.outputLen, te.nByteLength, te.hmac)(M, re);
  }
  c.BASE._setWindowSize(8);
  function q(j, C, U, M = G) {
    var ot;
    const re = j;
    if (C = Zo("msgHash", C), U = Zo("publicKey", U), "strict" in M)
      throw new Error("options.strict was renamed to lowS");
    f4(M);
    const { lowS: te, prehash: ie } = M;
    let ne, le;
    try {
      if (typeof re == "string" || _u(re))
        try {
          ne = w.fromDER(re);
        } catch (He) {
          if (!(He instanceof Os.Err))
            throw He;
          ne = w.fromCompact(re);
        }
      else if (typeof re == "object" && typeof re.r == "bigint" && typeof re.s == "bigint") {
        const { r: He, s: Ae } = re;
        ne = new w(He, Ae);
      } else
        throw new Error("PARSE");
      le = c.fromHex(U);
    } catch (He) {
      if (He.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return false;
    }
    if (te && ne.hasHighS())
      return false;
    ie && (C = t.hash(C));
    const { r: K, s: ve } = ne, At = P(C), ze = a(ve), St = s(At * ze), et = s(K * ze), Ge = (ot = c.BASE.multiplyAndAddUnsafe(le, St, et)) == null ? void 0 : ot.toAffine();
    return Ge ? s(Ge.x) === K : false;
  }
  return {
    CURVE: t,
    getPublicKey: k,
    getSharedSecret: _,
    sign: N,
    verify: q,
    ProjectivePoint: c,
    Signature: w,
    utils: v
  };
}
function _z(e) {
  return {
    hash: e,
    hmac: (t, ...r) => wv(e, t, ON(...r)),
    randomBytes: BN
  };
}
function Tz(e, t) {
  const r = (n) => Sz({ ...e, ..._z(n) });
  return Object.freeze({ ...r(t), create: r });
}
var K7 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var h4 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Pz = BigInt(1);
var fw = BigInt(2);
var p4 = (e, t) => (e + t / fw) / t;
function Iz(e) {
  const t = K7, r = BigInt(3), n = BigInt(6), o = BigInt(11), i = BigInt(22), s = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, l = u * u * e % t, f = Po(l, r, t) * l % t, d = Po(f, r, t) * l % t, m = Po(d, fw, t) * u % t, y = Po(m, o, t) * m % t, b = Po(y, i, t) * y % t, w = Po(b, a, t) * b % t, v = Po(w, c, t) * w % t, k = Po(v, a, t) * b % t, x = Po(k, r, t) * l % t, _ = Po(x, s, t) * y % t, I = Po(_, n, t) * u % t, P = Po(I, fw, t);
  if (!dw.eql(dw.sqr(P), e))
    throw new Error("Cannot find square root");
  return P;
}
var dw = Sv(K7, void 0, void 0, { sqrt: Iz });
var Tu = Tz({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: dw,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: h4,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = h4, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -Pz * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = r, s = BigInt("0x100000000000000000000000000000000"), a = p4(i * e, t), c = p4(-n * e, t);
      let u = Tn(e - a * r - c * o, t), l = Tn(-a * n - c * i, t);
      const f = u > s, d = l > s;
      if (f && (u = t - u), d && (l = t - l), u > s || l > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: u, k2neg: d, k2: l };
    }
  }
}, Qr);
BigInt(0);
Tu.ProjectivePoint;
function Oz(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function g4(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Bz(e, t) {
  Oz(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var Cz = (e) => e instanceof Uint8Array;
var Bb = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Pi = (e, t) => e << 32 - t | e >>> t;
var Nz = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Nz)
  throw new Error("Non little-endian hardware is not supported");
function Uz(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function M7(e) {
  if (typeof e == "string" && (e = Uz(e)), !Cz(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
var $z = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function Rz(e) {
  const t = (n) => e().update(M7(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function zz(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var Hz = class extends $z {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = Bb(this.buffer);
  }
  update(t) {
    g4(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = M7(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = Bb(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    g4(this), Bz(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    zz(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Bb(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
var Lz = (e, t, r) => e & t ^ ~e & r;
var jz = (e, t, r) => e & t ^ e & r ^ t & r;
var Fz = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var fa = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var da = new Uint32Array(64);
var Dz = class extends Hz {
  constructor() {
    super(64, 32, 8, false), this.A = fa[0] | 0, this.B = fa[1] | 0, this.C = fa[2] | 0, this.D = fa[3] | 0, this.E = fa[4] | 0, this.F = fa[5] | 0, this.G = fa[6] | 0, this.H = fa[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      da[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = da[f - 15], m = da[f - 2], y = Pi(d, 7) ^ Pi(d, 18) ^ d >>> 3, b = Pi(m, 17) ^ Pi(m, 19) ^ m >>> 10;
      da[f] = b + da[f - 7] + y + da[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = Pi(a, 6) ^ Pi(a, 11) ^ Pi(a, 25), m = l + d + Lz(a, c, u) + Fz[f] + da[f] | 0, b = (Pi(n, 2) ^ Pi(n, 13) ^ Pi(n, 22)) + jz(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + b | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    da.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var hw = Rz(() => new Dz());
function Ch(...e) {
  const t = (o, i) => (s) => o(i(s)), r = Array.from(e).reverse().reduce((o, i) => o ? t(o, i.encode) : i.encode, void 0), n = e.reduce((o, i) => o ? t(o, i.decode) : i.decode, void 0);
  return { encode: r, decode: n };
}
function p1(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
function g1(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
function q7(e, t = "=") {
  if (typeof t != "string")
    throw new Error("padding chr should be string");
  return {
    encode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let n of r)
        if (typeof n != "string")
          throw new Error(`padding.encode: non-string input=${n}`);
      for (; r.length * e % 8; )
        r.push(t);
      return r;
    },
    decode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let o of r)
        if (typeof o != "string")
          throw new Error(`padding.decode: non-string input=${o}`);
      let n = r.length;
      if (n * e % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n > 0 && r[n - 1] === t; n--)
        if (!((n - 1) * e % 8))
          throw new Error("Invalid padding: string has too much padding");
      return r.slice(0, n);
    }
  };
}
function m4(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], i = Array.from(e);
  for (i.forEach((s) => {
    if (s < 0 || s >= t)
      throw new Error(`Wrong integer: ${s}`);
  }); ; ) {
    let s = 0, a = true;
    for (let c = n; c < i.length; c++) {
      const u = i[c], l = t * s + u;
      if (!Number.isSafeInteger(l) || t * s / t !== s || l - u !== t * s)
        throw new Error("convertRadix: carry overflow");
      s = l % r;
      const f = Math.floor(l / r);
      if (i[c] = f, !Number.isSafeInteger(f) || f * r + s !== l)
        throw new Error("convertRadix: carry overflow");
      if (a)
        f ? a = false : n = c;
      else continue;
    }
    if (o.push(s), a)
      break;
  }
  for (let s = 0; s < e.length - 1 && e[s] === 0; s++)
    o.push(0);
  return o.reverse();
}
var V7 = (e, t) => t ? V7(t, e % t) : e;
var $0 = (e, t) => e + (t - V7(e, t));
function pw(e, t, r, n) {
  if (!Array.isArray(e))
    throw new Error("convertRadix2: data should be array");
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong to=${r}`);
  if ($0(t, r) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${$0(t, r)}`);
  let o = 0, i = 0;
  const s = 2 ** r - 1, a = [];
  for (const c of e) {
    if (c >= 2 ** t)
      throw new Error(`convertRadix2: invalid data word=${c} from=${t}`);
    if (o = o << t | c, i + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${i} from=${t}`);
    for (i += t; i >= r; i -= r)
      a.push((o >> i - r & s) >>> 0);
    o &= 2 ** i - 1;
  }
  if (o = o << r - i & s, !n && i >= t)
    throw new Error("Excess padding");
  if (!n && o)
    throw new Error(`Non-zero padding: ${o}`);
  return n && i > 0 && a.push(o >>> 0), a;
}
function Kz(e) {
  return {
    encode: (t) => {
      if (!(t instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return m4(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(m4(t, e, 2 ** 8));
    }
  };
}
function _v(e, t = false) {
  if (e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if ($0(8, e) > 32 || $0(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (r) => {
      if (!(r instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return pw(Array.from(r), 8, e, !t);
    },
    decode: (r) => {
      if (!Array.isArray(r) || r.length && typeof r[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(pw(r, e, 8, t));
    }
  };
}
function b4(e) {
  if (typeof e != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
function Mz(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), i = r.slice(-e);
      for (let s = 0; s < e; s++)
        if (o[s] !== i[s])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
var y4 = Ch(_v(6), p1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), q7(6), g1(""));
var w4 = Ch(_v(6), p1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), q7(6), g1(""));
var qz = (e) => Ch(Kz(58), p1(e), g1(""));
var Vz = qz("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var v4 = (e) => Ch(Mz(4, (t) => e(e(t))), Vz);
var gw = Ch(p1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), g1(""));
var E4 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function Qf(e) {
  const t = e >> 25;
  let r = (e & 33554431) << 5;
  for (let n = 0; n < E4.length; n++)
    (t >> n & 1) === 1 && (r ^= E4[n]);
  return r;
}
function x4(e, t, r = 1) {
  const n = e.length;
  let o = 1;
  for (let i = 0; i < n; i++) {
    const s = e.charCodeAt(i);
    if (s < 33 || s > 126)
      throw new Error(`Invalid prefix (${e})`);
    o = Qf(o) ^ s >> 5;
  }
  o = Qf(o);
  for (let i = 0; i < n; i++)
    o = Qf(o) ^ e.charCodeAt(i) & 31;
  for (let i of t)
    o = Qf(o) ^ i;
  for (let i = 0; i < 6; i++)
    o = Qf(o);
  return o ^= r, gw.encode(pw([o % 2 ** 30], 30, 5, false));
}
function G7(e) {
  const t = e === "bech32" ? 1 : 734539939, r = _v(5), n = r.decode, o = r.encode, i = b4(n);
  function s(l, f, d = 90) {
    if (typeof l != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof l}`);
    if (!Array.isArray(f) || f.length && typeof f[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof f}`);
    const m = l.length + 7 + f.length;
    if (d !== false && m > d)
      throw new TypeError(`Length ${m} exceeds limit ${d}`);
    const y = l.toLowerCase(), b = x4(y, f, t);
    return `${y}1${gw.encode(f)}${b}`;
  }
  function a(l, f = 90) {
    if (typeof l != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof l}`);
    if (l.length < 8 || f !== false && l.length > f)
      throw new TypeError(`Wrong string length: ${l.length} (${l}). Expected (8..${f})`);
    const d = l.toLowerCase();
    if (l !== d && l !== l.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    l = d;
    const m = l.lastIndexOf("1");
    if (m === 0 || m === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const y = l.slice(0, m), b = l.slice(m + 1);
    if (b.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const w = gw.decode(b).slice(0, -6), v = x4(y, w, t);
    if (!b.endsWith(v))
      throw new Error(`Invalid checksum in ${l}: expected "${v}"`);
    return { prefix: y, words: w };
  }
  const c = b4(a);
  function u(l) {
    const { prefix: f, words: d } = a(l, false);
    return { prefix: f, words: d, bytes: n(d) };
  }
  return { encode: s, decode: a, decodeToBytes: u, decodeUnsafe: c, fromWords: n, fromWordsUnsafe: i, toWords: o };
}
var Ep = G7("bech32");
var xp = G7("bech32m");
var Ki = {
  b58chk: {
    encode: (e) => v4(hw).encode(e),
    decode: (e) => v4(hw).decode(e)
  },
  base64: {
    encode: (e) => y4.encode(e),
    decode: (e) => y4.decode(e)
  },
  b64url: {
    encode: (e) => w4.encode(e),
    decode: (e) => w4.decode(e)
  },
  bech32: {
    to_words: Ep.toWords,
    to_bytes: Ep.fromWords,
    encode: (e, t, r = false) => Ep.encode(e, t, r),
    decode: (e, t = false) => {
      const { prefix: r, words: n } = Ep.decode(e, t);
      return { prefix: r, words: n };
    }
  },
  bech32m: {
    to_words: xp.toWords,
    to_bytes: xp.fromWords,
    encode: (e, t, r = false) => xp.encode(e, t, r),
    decode: (e, t = false) => {
      const { prefix: r, words: n } = xp.decode(e, t);
      return { prefix: r, words: n };
    }
  }
};
function Gz(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Wz(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Zz(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
function W7(e, t) {
  if (e !== t)
    throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
var Xz = BigInt(0);
var Yz = BigInt(255);
var Z7 = BigInt(256);
function Jz(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Qz(e, t, r = "be") {
  t === void 0 && (t = Jz(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > Xz; ) {
    const a = e & Yz, c = Number(a);
    n ? i.setUint8(s++, c) : i.setUint8(s--, c), e = (e - a) / Z7;
  }
  return new Uint8Array(o);
}
function eH(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * Z7 + BigInt(e[r]);
  return BigInt(t);
}
function tH(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let i = 0;
    for (let s = 0; s < 8; s++)
      i |= t[n + s] << 7 - s;
    r[o] = i;
  }
  return r;
}
function rH(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function nH(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function oH(e, t, r = "be") {
  t === void 0 && (t = nH(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? i.setUint8(s++, e) : i.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(o);
}
function iH(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], Zz(t);
  return t;
}
var sH = new TextEncoder();
var aH = new TextDecoder();
function Tv(e) {
  return sH.encode(e);
}
function Cb(e) {
  return aH.decode(e);
}
function cH(e, t) {
  Wz(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function uH(e, t, r = "le") {
  t = cH(e, t);
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? i.setUint8(s++, u) : i.setUint8(s--, u);
  }
  return new Uint8Array(o);
}
function lH(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
var { getRandomValues: fH } = crypto ?? globalThis.crypto ?? window.crypto;
function dH(e = 32) {
  if (typeof fH == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function X7(e) {
  return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function hH(e) {
  return typeof e == "string" && X7(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? true : !!(Array.isArray(e) && e.every((t) => typeof t == "number"));
}
function pH(e, t, r = "be") {
  t === void 0 && (t = e.length), Gz(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function Y7(e) {
  let t, r = 0;
  const n = e.reduce((i, s) => i + s.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const i = e[t];
    o.set(i, r), r += i.length;
  }
  return o;
}
function gH(e, t) {
  return typeof t == "bigint" ? `${t}n` : t;
}
function mH(e, t) {
  return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function bH(e, t, r) {
  const n = e.length, o = r / t;
  if (r % t !== 0)
    throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
  if (n !== r)
    throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
  if (n % t !== 0)
    throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
  const i = new Array(o);
  for (let s = 0; s < o; s++) {
    const a = s * t;
    i[s] = e.subarray(a, a + t);
  }
  return i;
}
function Pv(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return pH(e, t, r);
  if (Array.isArray(e)) {
    const n = e.map((o) => Pv(o, t, r));
    return Y7(n);
  } else {
    if (typeof e == "string")
      return uH(e, t, r);
    if (typeof e == "bigint")
      return Qz(e, t, r);
    if (typeof e == "number")
      return oH(e, t, r);
    if (typeof e == "boolean")
      return Uint8Array.of(e ? 1 : 0);
  }
  throw new TypeError("Unsupported format:" + typeof e);
}
var Re;
var Lt = (Re = class extends Uint8Array {
  static random(t = 32) {
    const r = dH(t);
    return new Re(r, t);
  }
  static now(t = 4) {
    const r = Math.floor(Date.now() / 1e3);
    return new Re(r, t);
  }
  constructor(t, r, n) {
    if (t instanceof Re && r === void 0)
      return t;
    const o = Pv(t, r, n);
    super(o);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.to_num();
  }
  get big() {
    return this.to_big();
  }
  get str() {
    return this.to_str();
  }
  get hex() {
    return this.to_hex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.to_bin();
  }
  get b58chk() {
    return this.to_b58chk();
  }
  get base64() {
    return this.to_base64();
  }
  get b64url() {
    return this.to_b64url();
  }
  get digest() {
    return this.to_hash();
  }
  get id() {
    return this.to_hash().hex;
  }
  get stream() {
    return new BH(this);
  }
  to_num(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return iH(r);
  }
  to_big(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return eH(r);
  }
  to_bin() {
    return rH(this);
  }
  to_hash() {
    const t = hw(this);
    return new Re(t);
  }
  to_json(t) {
    t === void 0 && (t = mH);
    const r = Cb(this);
    return JSON.parse(r, t);
  }
  to_bech32(t, r) {
    const { encode: n, to_words: o } = Ki.bech32, i = o(this);
    return n(t, i, r);
  }
  to_bech32m(t, r) {
    const { encode: n, to_words: o } = Ki.bech32m, i = o(this);
    return n(t, i, r);
  }
  to_str() {
    return Cb(this);
  }
  to_hex() {
    return lH(this);
  }
  to_bytes() {
    return new Uint8Array(this);
  }
  to_b58chk() {
    return Ki.b58chk.encode(this);
  }
  to_base64() {
    return Ki.base64.encode(this);
  }
  to_b64url() {
    return Ki.b64url.encode(this);
  }
  append(t) {
    return Re.join([this, Re.bytes(t)]);
  }
  prepend(t) {
    return Re.join([Re.bytes(t), this]);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new Re(t);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new Re(n);
  }
  set(t, r) {
    this.set(t, r);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new Re(n);
  }
  write(t, r) {
    const n = Re.bytes(t);
    this.set(n, r);
  }
  add_varint(t) {
    const r = Re.calc_varint(this.length, t);
    return Re.join([r, this]);
  }
  static from(t) {
    return new Re(Uint8Array.from(t));
  }
  static of(...t) {
    return new Re(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((o) => Re.bytes(o)), n = Y7(r);
    return new Re(n);
  }
  static sort(t, r) {
    const n = t.map((o) => k4(o, r).hex);
    return n.sort(), n.map((o) => Re.hex(o, r));
  }
  static calc_varint(t, r) {
    if (t < 253)
      return Re.num(t, 1);
    if (t < 65536)
      return Re.of(253, ...Re.num(t, 2, r));
    if (t < 4294967296)
      return Re.of(254, ...Re.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return Re.of(255, ...Re.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
}, Re.num = yH, Re.big = vH, Re.bin = wH, Re.raw = EH, Re.str = xH, Re.hex = kH, Re.bytes = k4, Re.json = AH, Re.base64 = SH, Re.b64url = _H, Re.bech32 = TH, Re.bech32m = PH, Re.b58chk = IH, Re.encode = Tv, Re.decode = Cb, Re.parse = OH, Re.is_bytes = hH, Re.is_hex = X7, Re);
function yH(e, t, r) {
  return new Lt(e, t, r);
}
function wH(e, t, r) {
  return new Lt(tH(e), t, r);
}
function vH(e, t, r) {
  return new Lt(e, t, r);
}
function EH(e, t, r) {
  return new Lt(e, t, r);
}
function xH(e, t, r) {
  return new Lt(Tv(e), t, r);
}
function kH(e, t, r) {
  return new Lt(e, t, r);
}
function AH(e, t) {
  t === void 0 && (t = gH);
  const r = JSON.stringify(e, t);
  return new Lt(Tv(r));
}
function SH(e) {
  return new Lt(Ki.base64.decode(e));
}
function _H(e) {
  return new Lt(Ki.b64url.decode(e));
}
function TH(e, t, r) {
  const { decode: n, to_bytes: o } = Ki.bech32, { prefix: i, words: s } = n(e, t), a = o(s);
  return typeof r == "string" && W7(i, r), new Lt(a);
}
function PH(e, t, r) {
  const { decode: n, to_bytes: o } = Ki.bech32m, { prefix: i, words: s } = n(e, t), a = o(s);
  return typeof r == "string" && W7(i, r), new Lt(a);
}
function IH(e) {
  return new Lt(Ki.b58chk.decode(e));
}
function OH(e, t, r) {
  const n = Pv(e);
  return bH(n, t, r).map((i) => Lt.bytes(i));
}
var BH = class {
  constructor(t) {
    this.data = Lt.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new Lt(this.data.slice(0, t));
  }
  read(t) {
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  read_varint(t) {
    const r = this.read(1).num;
    switch (true) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).to_num(t);
      case r === 254:
        return this.read(4).to_num(t);
      case r === 255:
        return this.read(8).to_num(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
function k4(e, t, r) {
  return new Lt(e, t, r);
}
var R0 = Tu.CURVE;
var m1 = R0.n;
var CH = R0.p;
var A4 = { x: R0.Gx, y: R0.Gy };
var NH = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
var UH = (e) => Tn(e, m1);
function J7(e, t = false) {
  if (!t)
    return false;
  throw new Error(e);
}
function $H(e, t, r) {
  const n = Lt.bytes(e);
  return n.length !== t ? J7(`Invalid byte size: ${n.hex} !== ${t}`, r) : true;
}
function RH(e, t) {
  return typeof e == "bigint" && NH < e && e < m1 || J7("x value is not in the field!", t), true;
}
var zH = Sv(m1, 32, true);
var S4 = Tu.ProjectivePoint;
var ed = zH;
var Vt;
var Gl = (Vt = class extends Uint8Array {
  static add(t) {
    return t.map((r) => Vt.mod(r)).reduce((r, n) => r.add(n));
  }
  static mod(t) {
    return new Vt(t);
  }
  static mul(t) {
    return t.map((r) => Vt.mod(r)).reduce((r, n) => r.mul(n));
  }
  static is_valid(t, r) {
    const n = Lt.bytes(t, 32).big;
    return RH(n, r);
  }
  constructor(t) {
    const r = UH(HH(t));
    Vt.is_valid(r, true), super(Lt.big(r, 32), 32);
  }
  get buff() {
    return new Lt(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(t) {
    return new Vt(t).big > this.big;
  }
  lt(t) {
    return new Vt(t).big < this.big;
  }
  eq(t) {
    return new Vt(t).big === this.big;
  }
  ne(t) {
    return new Vt(t).big !== this.big;
  }
  add(t) {
    const r = Vt.mod(t), n = ed.add(this.big, r.big);
    return new Vt(n);
  }
  sub(t) {
    const r = Vt.mod(t), n = ed.sub(this.big, r.big);
    return new Vt(n);
  }
  mul(t) {
    const r = Vt.mod(t), n = ed.mul(this.big, r.big);
    return new Vt(n);
  }
  pow(t) {
    const r = Vt.mod(t), n = ed.pow(this.big, r.big);
    return new Vt(n);
  }
  div(t) {
    const r = Vt.mod(t), n = ed.div(this.big, r.big);
    return new Vt(n);
  }
  negate() {
    return new Vt(Vt.N - this.big);
  }
  generate() {
    const r = Tu.ProjectivePoint.BASE.multiply(this.big);
    return Iv.import(r);
  }
}, Vt.N = m1, Vt);
var Nt;
var Iv = (Nt = class {
  static from_x(t, r = false) {
    let n = LH(t);
    n.length === 32 ? n = n.prepend(2) : r && (n[0] = 2), $H(n, 33);
    const o = S4.fromHex(n.hex);
    return o.assertValidity(), new Nt(o.x, o.y);
  }
  static generate(t) {
    const r = Gl.mod(t), n = Nt.base.multiply(r.big);
    return Nt.import(n);
  }
  static import(t) {
    const r = t instanceof Nt ? { x: t.x.big, y: t.y.big } : { x: t.x, y: t.y };
    return new Nt(r.x, r.y);
  }
  constructor(t, r) {
    this._p = new S4(t, r, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return Lt.big(this.p.x, 32);
  }
  get y() {
    return Lt.big(this.p.y, 32);
  }
  get buff() {
    return Lt.raw(this.p.toRawBytes(true));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  eq(t) {
    const r = t instanceof Nt ? t : Nt.from_x(t);
    return this.x.big === r.x.big && this.y.big === r.y.big;
  }
  add(t) {
    return t instanceof Nt ? Nt.import(this.p.add(t.p)) : Nt.import(this.p.add(Nt.generate(t).p));
  }
  sub(t) {
    return t instanceof Nt ? Nt.import(this.p.subtract(t.p)) : Nt.import(this.p.subtract(Nt.generate(t).p));
  }
  mul(t) {
    return t instanceof Nt ? Nt.import(this.p.multiply(t.x.big)) : Nt.import(this.p.multiply(Gl.mod(t).big));
  }
  negate() {
    return Nt.import(this.p.negate());
  }
}, Nt.P = CH, Nt.G = new Nt(A4.x, A4.y), Nt.curve = Tu.CURVE, Nt.base = Tu.ProjectivePoint.BASE, Nt.mul = Nt.generate, Nt);
function HH(e) {
  if (e instanceof Gl)
    return e.big;
  if (e instanceof Iv)
    return e.x.big;
  if (e instanceof Uint8Array)
    return Lt.raw(e).big;
  if (typeof e == "string")
    return Lt.hex(e).big;
  if (typeof e == "number")
    return Lt.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function LH(e) {
  if (e instanceof Gl)
    return e.point.buff;
  if (e instanceof Iv)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return Lt.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return Lt.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
var kp = BigInt(2 ** 32 - 1);
var mw = BigInt(32);
function Q7(e, t = false) {
  return t ? { h: Number(e & kp), l: Number(e >> mw & kp) } : { h: Number(e >> mw & kp) | 0, l: Number(e & kp) | 0 };
}
function jH(e, t = false) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: i, l: s } = Q7(e[o], t);
    [r[o], n[o]] = [i, s];
  }
  return [r, n];
}
var FH = (e, t) => BigInt(e >>> 0) << mw | BigInt(t >>> 0);
var DH = (e, t, r) => e >>> r;
var KH = (e, t, r) => e << 32 - r | t >>> r;
var MH = (e, t, r) => e >>> r | t << 32 - r;
var qH = (e, t, r) => e << 32 - r | t >>> r;
var VH = (e, t, r) => e << 64 - r | t >>> r - 32;
var GH = (e, t, r) => e >>> r - 32 | t << 64 - r;
var WH = (e, t) => t;
var ZH = (e, t) => e;
var XH = (e, t, r) => e << r | t >>> 32 - r;
var YH = (e, t, r) => t << r | e >>> 32 - r;
var JH = (e, t, r) => t << r - 32 | e >>> 64 - r;
var QH = (e, t, r) => e << r - 32 | t >>> 64 - r;
function eL(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
var tL = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
var rL = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
var nL = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
var oL = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
var iL = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
var sL = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0;
var ft = {
  fromBig: Q7,
  split: jH,
  toBig: FH,
  shrSH: DH,
  shrSL: KH,
  rotrSH: MH,
  rotrSL: qH,
  rotrBH: VH,
  rotrBL: GH,
  rotr32H: WH,
  rotr32L: ZH,
  rotlSH: XH,
  rotlSL: YH,
  rotlBH: JH,
  rotlBL: QH,
  add: eL,
  add3L: tL,
  add3H: rL,
  add4L: nL,
  add4H: oL,
  add5H: sL,
  add5L: iL
};
var [aL, cL] = ft.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e)));
var ha = new Uint32Array(80);
var pa = new Uint32Array(80);
var uL = class extends av {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: i, Cl: s, Dh: a, Dl: c, Eh: u, El: l, Fh: f, Fl: d, Gh: m, Gl: y, Hh: b, Hl: w } = this;
    return [t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = i | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = f | 0, this.Fl = d | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = w | 0;
  }
  process(t, r) {
    for (let x = 0; x < 16; x++, r += 4)
      ha[x] = t.getUint32(r), pa[x] = t.getUint32(r += 4);
    for (let x = 16; x < 80; x++) {
      const _ = ha[x - 15] | 0, I = pa[x - 15] | 0, P = ft.rotrSH(_, I, 1) ^ ft.rotrSH(_, I, 8) ^ ft.shrSH(_, I, 7), $ = ft.rotrSL(_, I, 1) ^ ft.rotrSL(_, I, 8) ^ ft.shrSL(_, I, 7), L = ha[x - 2] | 0, V = pa[x - 2] | 0, ee = ft.rotrSH(L, V, 19) ^ ft.rotrBH(L, V, 61) ^ ft.shrSH(L, V, 6), G = ft.rotrSL(L, V, 19) ^ ft.rotrBL(L, V, 61) ^ ft.shrSL(L, V, 6), N = ft.add4L($, G, pa[x - 7], pa[x - 16]), q = ft.add4H(N, P, ee, ha[x - 7], ha[x - 16]);
      ha[x] = q | 0, pa[x] = N | 0;
    }
    let { Ah: n, Al: o, Bh: i, Bl: s, Ch: a, Cl: c, Dh: u, Dl: l, Eh: f, El: d, Fh: m, Fl: y, Gh: b, Gl: w, Hh: v, Hl: k } = this;
    for (let x = 0; x < 80; x++) {
      const _ = ft.rotrSH(f, d, 14) ^ ft.rotrSH(f, d, 18) ^ ft.rotrBH(f, d, 41), I = ft.rotrSL(f, d, 14) ^ ft.rotrSL(f, d, 18) ^ ft.rotrBL(f, d, 41), P = f & m ^ ~f & b, $ = d & y ^ ~d & w, L = ft.add5L(k, I, $, cL[x], pa[x]), V = ft.add5H(L, v, _, P, aL[x], ha[x]), ee = L | 0, G = ft.rotrSH(n, o, 28) ^ ft.rotrBH(n, o, 34) ^ ft.rotrBH(n, o, 39), N = ft.rotrSL(n, o, 28) ^ ft.rotrBL(n, o, 34) ^ ft.rotrBL(n, o, 39), q = n & i ^ n & a ^ i & a, j = o & s ^ o & c ^ s & c;
      v = b | 0, k = w | 0, b = m | 0, w = y | 0, m = f | 0, y = d | 0, { h: f, l: d } = ft.add(u | 0, l | 0, V | 0, ee | 0), u = a | 0, l = c | 0, a = i | 0, c = s | 0, i = n | 0, s = o | 0;
      const C = ft.add3L(ee, N, j);
      n = ft.add3H(C, V, G, q), o = C | 0;
    }
    ({ h: n, l: o } = ft.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: i, l: s } = ft.add(this.Bh | 0, this.Bl | 0, i | 0, s | 0), { h: a, l: c } = ft.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l } = ft.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: f, l: d } = ft.add(this.Eh | 0, this.El | 0, f | 0, d | 0), { h: m, l: y } = ft.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: b, l: w } = ft.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0), { h: v, l: k } = ft.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, i, s, a, c, u, l, f, d, m, y, b, w, v, k);
  }
  roundClean() {
    ha.fill(0), pa.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var lL = sv(() => new uL());
function fL(e, t = false) {
  const r = Gl.mod(e);
  return t ? r.negated.buff : r.buff;
}
function e9(e, t = false) {
  const r = Gl.mod(e).point;
  return t ? r.x : r.buff;
}
Tu.ProjectivePoint;
function bw(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function dL(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function t9(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function hL(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  bw(e.outputLen), bw(e.blockLen);
}
function pL(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function gL(e, t) {
  t9(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var mL = {
  number: bw,
  bool: dL,
  bytes: t9,
  hash: hL,
  exists: pL,
  output: gL
};
var Nb = mL;
var Ub = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Ii = (e, t) => e << 32 - t | e >>> t;
var bL = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!bL)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function yL(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function r9(e) {
  if (typeof e == "string" && (e = yL(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
var wL = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function n9(e) {
  const t = (n) => e().update(r9(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function vL(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var EL = class extends wL {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = Ub(this.buffer);
  }
  update(t) {
    Nb.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = r9(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = Ub(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Nb.exists(this), Nb.output(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    vL(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Ub(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
var xL = (e, t, r) => e & t ^ ~e & r;
var kL = (e, t, r) => e & t ^ e & r ^ t & r;
var AL = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var ga = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var ma = new Uint32Array(64);
var o9 = class extends EL {
  constructor() {
    super(64, 32, 8, false), this.A = ga[0] | 0, this.B = ga[1] | 0, this.C = ga[2] | 0, this.D = ga[3] | 0, this.E = ga[4] | 0, this.F = ga[5] | 0, this.G = ga[6] | 0, this.H = ga[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      ma[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = ma[f - 15], m = ma[f - 2], y = Ii(d, 7) ^ Ii(d, 18) ^ d >>> 3, b = Ii(m, 17) ^ Ii(m, 19) ^ m >>> 10;
      ma[f] = b + ma[f - 7] + y + ma[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = Ii(a, 6) ^ Ii(a, 11) ^ Ii(a, 25), m = l + d + xL(a, c, u) + AL[f] + ma[f] | 0, b = (Ii(n, 2) ^ Ii(n, 13) ^ Ii(n, 22)) + kL(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + b | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    ma.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var SL = class extends o9 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var yw = n9(() => new o9());
n9(() => new SL());
function _L(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function TL(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function PL(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
var { getRandomValues: IL } = crypto ?? globalThis.crypto ?? window.crypto;
function OL(e = 32) {
  if (typeof IL == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function BL(e, t, r = "be") {
  t === void 0 && (t = e.length), _L(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function i9(e) {
  let t, r = 0;
  const n = e.reduce((i, s) => i + s.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const i = e[t];
    o.set(i, r), r += i.length;
  }
  return o;
}
var CL = new TextEncoder();
var NL = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function s9(e) {
  for (const t of NL)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function UL(e, t, r = false) {
  typeof e == "string" && (e = CL.encode(e));
  const n = s9(t), o = n.length, i = [];
  let s = "", a, c = 0, u, l;
  for (a = 0; a < e.length; a++)
    for (c = 0, u = e[a], s += u > 0 || (s.length ^ a) > 0 ? "" : "1"; c in i || u > 0; )
      l = i[c], l = l > 0 ? l * 256 + u : u, u = l / o | 0, i[c] = l % o, c++;
  for (; c-- > 0; )
    s += n[i[c]];
  return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function $L(e, t) {
  const r = s9(t), n = r.length, o = [], i = [];
  e = e.replace("=", "");
  let s, a = 0, c, u;
  for (s = 0; s < e.length; s++) {
    if (a = 0, c = r.indexOf(e[s]), c < 0)
      throw new Error(`Character range out of bounds: ${c}`);
    for (c > 0 || (i.length ^ s) > 0 || i.push(0); a in o || c > 0; )
      u = o[a], u = u > 0 ? u * n + c : c, c = u >> 8, o[a] = u % 256, a++;
  }
  for (; a-- > 0; )
    i.push(o[a]);
  return new Uint8Array(i);
}
function a9(e) {
  return yw(yw(e));
}
function RL(e) {
  const t = a9(e);
  return i9([e, t.slice(0, 4)]);
}
function zL(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (a9(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
var _4 = {
  encode: UL,
  decode: $L
};
var c9 = {
  encode: (e) => {
    const t = RL(e);
    return _4.encode(t, "base58");
  },
  decode: (e) => {
    const t = _4.decode(e, "base58");
    return zL(t);
  }
};
var u9 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var HL = [996825010, 642813549, 513874426, 1027748829, 705979059];
var z0 = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function l9(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= HL[o]);
  }
  return t;
}
function f9(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function LL(e, t, r) {
  const n = f9(e).concat(t);
  return l9(n) === r.const;
}
function jL(e, t, r) {
  const n = f9(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = l9(n) ^ r.const, i = [];
  for (let s = 0; s < 6; ++s)
    i.push(o >> 5 * (5 - s) & 31);
  return i;
}
function d9(e, t, r, n = true) {
  const o = [];
  let i = 0, s = 0;
  const a = (1 << r) - 1, c = (1 << t + r - 1) - 1;
  for (const u of e) {
    if (u < 0 || u >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(u));
    for (i = (i << t | u) & c, s += t; s >= r; )
      s -= r, o.push(i >> s & a);
  }
  if (n)
    s > 0 && o.push(i << r - s & a);
  else if (s >= t || (i << r - s & a) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function FL(e, t, r) {
  const n = t.concat(jL(e, t, r));
  let o = e + "1";
  for (let i = 0; i < n.length; ++i)
    o += u9.charAt(n[i]);
  return o;
}
function h9(e) {
  if (!DL(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !KL(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let i = r + 1; i < e.length; ++i) {
    const s = u9.indexOf(e.charAt(i));
    if (s === -1)
      throw new Error("Character idx out of bounds: " + String(i));
    t.push(s);
  }
  const o = z0.find((i) => i.version === t[0]) ?? z0[0];
  if (!LL(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function DL(e) {
  let t, r, n = false, o = false;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return false;
    r >= 97 && r <= 122 && (n = true), r >= 65 && r <= 90 && (o = true);
  }
  return !(n && o);
}
function KL(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function ML(e, t = "bc", r = 0) {
  const n = [r, ...d9([...e], 8, 5)], o = z0.find((s) => s.version === r) ?? z0[0], i = FL(t, n, o);
  return p9(i), i;
}
function p9(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = h9(e), o = d9(n.slice(1), 5, 8, false), i = o.length;
  switch (true) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || i < 2 || i > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function qL(e) {
  e = e.toLowerCase();
  const [t, r] = h9(e);
  return r[0];
}
var g9 = {
  encode: ML,
  decode: p9,
  version: qL
};
var m9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var VL = new TextEncoder();
function y9(e, t = false, r = true) {
  typeof e == "string" && (e = VL.encode(e));
  const n = t ? b9 : m9;
  let o = "", i = 0, s = 0;
  for (let a = 0; a < e.length; a++)
    for (s = s << 8 | e[a], i += 8; i >= 6; )
      i -= 6, o += n[s >> i & 63];
  if (i > 0)
    for (s <<= 6 - i, o += n[s & 63]; i < 6; )
      o += r ? "=" : "", i += 2;
  return o;
}
function w9(e, t = false) {
  const r = t || e.includes("-") || e.includes("_") ? b9.split("") : m9.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, i = 0;
  const s = [];
  for (let a = 0; a < n.length; a++) {
    const c = n[a], u = r.indexOf(c);
    if (u === -1)
      throw new Error("Invalid character: " + c);
    o += 6, i <<= 6, i |= u, o >= 8 && (o -= 8, s.push(i >>> o & 255));
  }
  return new Uint8Array(s);
}
var v9 = {
  encode: y9,
  decode: w9
};
var E9 = {
  encode: (e) => y9(e, true, false),
  decode: (e) => w9(e, true)
};
var GL = BigInt(0);
var WL = BigInt(255);
var x9 = BigInt(256);
function ZL(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function XL(e, t, r = "be") {
  t === void 0 && (t = ZL(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > GL; ) {
    const a = e & WL, c = Number(a);
    n ? i.setUint8(s++, c) : i.setUint8(s--, c), e = (e - a) / x9;
  }
  return new Uint8Array(o);
}
function YL(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * x9 + BigInt(e[r]);
  return BigInt(t);
}
function JL(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let i = 0;
    for (let s = 0; s < 8; s++)
      i |= t[n + s] << 7 - s;
    r[o] = i;
  }
  return r;
}
function QL(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function ej(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function tj(e, t, r = "be") {
  t === void 0 && (t = ej(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? i.setUint8(s++, e) : i.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(o);
}
function rj(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], PL(t);
  return t;
}
var nj = new TextEncoder();
var oj = new TextDecoder();
function Ov(e) {
  return nj.encode(e);
}
function $b(e) {
  return oj.decode(e);
}
function ij(e, t) {
  TL(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function sj(e, t, r = "le") {
  t = ij(e, t);
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? i.setUint8(s++, u) : i.setUint8(s--, u);
  }
  return new Uint8Array(o);
}
function aj(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function cj(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return Ov(t);
}
function uj(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return BL(e, t, r);
  if (typeof e == "string")
    return sj(e, t, r);
  if (typeof e == "bigint")
    return XL(e, t, r);
  if (typeof e == "number")
    return tj(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
var tt;
var W = (tt = class extends Uint8Array {
  static random(t = 32) {
    const r = OL(t);
    return new tt(r, t);
  }
  constructor(t, r, n) {
    const o = uj(t, r, n);
    super(o);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new Sf(this);
  }
  toNum(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return rj(r);
  }
  toBin() {
    return QL(this);
  }
  toBig(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return YL(r);
  }
  toHash() {
    const t = yw(this);
    return new tt(t);
  }
  toJson() {
    const t = $b(this);
    return JSON.parse(t);
  }
  toBech32(t, r = 0) {
    return g9.encode(this, t, r);
  }
  toStr() {
    return $b(this);
  }
  toHex() {
    return aj(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return c9.encode(this);
  }
  toBase64() {
    return v9.encode(this);
  }
  toB64url() {
    return E9.encode(this);
  }
  prepend(t) {
    return tt.join([tt.bytes(t), this]);
  }
  append(t) {
    return tt.join([this, tt.bytes(t)]);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new tt(n);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new tt(n);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new tt(t);
  }
  write(t, r) {
    const n = tt.bytes(t);
    this.set(n, r);
  }
  prefixSize(t) {
    const r = tt.varInt(this.length, t);
    return tt.join([r, this]);
  }
  static from(t) {
    return new tt(Uint8Array.from(t));
  }
  static of(...t) {
    return new tt(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((o) => tt.bytes(o)), n = i9(r);
    return new tt(n);
  }
  static varInt(t, r) {
    if (t < 253)
      return tt.num(t, 1);
    if (t < 65536)
      return tt.of(253, ...tt.num(t, 2, r));
    if (t < 4294967296)
      return tt.of(254, ...tt.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return tt.of(255, ...tt.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
}, tt.num = lj, tt.big = dj, tt.bin = fj, tt.raw = hj, tt.str = pj, tt.hex = gj, tt.bytes = mj, tt.json = bj, tt.base64 = yj, tt.b64url = wj, tt.bech32 = vj, tt.b58chk = Ej, tt.encode = Ov, tt.decode = $b, tt);
function lj(e, t, r) {
  return new W(e, t, r);
}
function fj(e, t, r) {
  return new W(JL(e), t, r);
}
function dj(e, t, r) {
  return new W(e, t, r);
}
function hj(e, t, r) {
  return new W(e, t, r);
}
function pj(e, t, r) {
  return new W(Ov(e), t, r);
}
function gj(e, t, r) {
  return new W(e, t, r);
}
function mj(e, t, r) {
  return new W(e, t, r);
}
function bj(e) {
  return new W(cj(e));
}
function yj(e) {
  return new W(v9.decode(e));
}
function wj(e) {
  return new W(E9.decode(e));
}
function vj(e) {
  return new W(g9.decode(e));
}
function Ej(e) {
  return new W(c9.decode(e));
}
var Sf = class {
  constructor(t) {
    this.data = W.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new W(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (true) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
function rs(e, t) {
  const r = W.bytes(e);
  if (r.length !== t)
    throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function bn(e, t) {
  if (t)
    throw new Error(e);
  return false;
}
function c0(e, ...t) {
  const r = W.str(e).digest.raw, n = t.map((o) => W.bytes(o));
  return W.join([r, r, W.join(n)]).digest;
}
var k9 = {
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_SUCCESS80: 80,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_SUCCESS98: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_SUCCESS126: 126,
  OP_SUCCESS127: 127,
  OP_SUCCESS128: 128,
  OP_SUCCESS129: 129,
  OP_SIZE: 130,
  OP_SUCCESS131: 131,
  OP_SUCCESS132: 132,
  OP_SUCCESS133: 133,
  OP_SUCCESS134: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_SUCCESS137: 137,
  OP_SUCCESS138: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_SUCCESS141: 141,
  OP_SUCCESS142: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_SUCCESS149: 149,
  OP_SUCCESS150: 150,
  OP_SUCCESS151: 151,
  OP_SUCCESS152: 152,
  OP_SUCCESS153: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186
};
function xj(e) {
  if (e > 186 && e < 255)
    return "OP_SUCCESS" + String(e);
  for (const [t, r] of Object.entries(k9))
    if (r === e)
      return t;
  throw new Error("OPCODE not found:" + String(e));
}
function kj(e) {
  for (const [t, r] of Object.entries(k9))
    if (t === e)
      return Number(r);
  throw new Error("OPCODE not found:" + e);
}
function Aj(e) {
  switch (true) {
    case e === 0:
      return "opcode";
    case (e >= 1 && e <= 75):
      return "varint";
    case e === 76:
      return "pushdata1";
    case e === 77:
      return "pushdata2";
    case e === 78:
      return "pushdata4";
    case e <= 254:
      return "opcode";
    default:
      throw new Error(`Invalid word range: ${e}`);
  }
}
function Sj(e) {
  const n = [];
  switch (true) {
    case typeof e != "number":
      return false;
    case e === 0:
      return true;
    case n.includes(e):
      return false;
    case (75 < e && e < 254):
      return true;
    default:
      return false;
  }
}
function Qs(e) {
  return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function A9(e) {
  return Qs(e) || e instanceof Uint8Array;
}
var H0 = 520;
function Vu(e = [], t = true) {
  let r = W.num(0);
  return Array.isArray(e) && (r = W.raw(S9(e))), Qs(e) && (r = W.hex(e)), e instanceof Uint8Array && (r = W.raw(e)), t && (r = r.prefixSize("le")), r;
}
function S9(e) {
  const t = [];
  for (const r of e)
    t.push(_j(r));
  return t.length > 0 ? W.join(t) : new Uint8Array();
}
function _j(e) {
  let t = new Uint8Array();
  if (typeof e == "string") {
    if (e.startsWith("OP_"))
      return W.num(kj(e), 1);
    Qs(e) ? t = W.hex(e) : t = W.str(e);
  } else if (t = W.bytes(e), t.length === 1 && t[0] <= 16)
    return t[0] !== 0 && (t[0] += 80), t;
  if (t.length > H0) {
    const r = Pj(t);
    return S9(r);
  }
  return W.join([Tj(t.length), t]);
}
function Tj(e) {
  const t = W.num(76, 1), r = W.num(77, 1);
  switch (true) {
    case e <= 75:
      return W.num(e);
    case (e > 75 && e < 256):
      return W.join([t, W.num(e, 1, "le")]);
    case (e >= 256 && e <= H0):
      return W.join([r, W.num(e, 2, "le")]);
    default:
      throw new Error("Invalid word size:" + e.toString());
  }
}
function Pj(e) {
  const t = [], r = new Sf(e);
  for (; r.size > H0; )
    t.push(r.read(H0));
  return t.push(r.read(r.size)), t;
}
function Bv(e, t = false) {
  let r = W.bytes(e);
  if (t) {
    const o = r.stream.readSize("le");
    if (r = r.slice(1), r.length !== o)
      throw new Error(`Varint does not match stream size: ${o} !== ${r.length}`);
  }
  return Ij(r);
}
function Ij(e) {
  const t = new Sf(e), r = [], n = t.size;
  let o, i, s, a = 0;
  for (; a < n; )
    switch (o = t.read(1).num, i = Aj(o), a++, i) {
      case "varint":
        r.push(t.read(o).hex), a += o;
        break;
      case "pushdata1":
        s = t.read(1).reverse().num, r.push(t.read(s).hex), a += s + 1;
        break;
      case "pushdata2":
        s = t.read(2).reverse().num, r.push(t.read(s).hex), a += s + 2;
        break;
      case "pushdata4":
        s = t.read(4).reverse().num, r.push(t.read(s).hex), a += s + 4;
        break;
      case "opcode":
        if (!Sj(o))
          throw new Error(`Invalid OPCODE: ${o}`);
        r.push(xj(o));
        break;
      default:
        throw new Error(`Word type undefined: ${o}`);
    }
  return r;
}
function Oj(e, t) {
  if (Array.isArray(e) && (e = Vu(e, t)), e instanceof Uint8Array || Qs(e))
    return Bv(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function Bj(e, t) {
  if ((e instanceof Uint8Array || Qs(e)) && (e = Bv(e, t)), Array.isArray(e))
    return Vu(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function Cj(e) {
  if (!Array.isArray(e))
    return W.bytes(e);
  throw new Error("Invalid format: " + typeof e);
}
var Nj = {
  toAsm: Oj,
  toBytes: Bj,
  toParam: Cj
};
var Rn = {
  encode: Vu,
  decode: Bv,
  fmt: Nj
};
function ww(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Uj(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function _9(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function $j(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  ww(e.outputLen), ww(e.blockLen);
}
function Rj(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function zj(e, t) {
  _9(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var Hj = {
  number: ww,
  bool: Uj,
  bytes: _9,
  hash: $j,
  exists: Rj,
  output: zj
};
var ou = Hj;
var Rb = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var zb = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Oi = (e, t) => e << 32 - t | e >>> t;
var Lj = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Lj)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function jj(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Cv(e) {
  if (typeof e == "string" && (e = jj(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function Fj(...e) {
  if (!e.every((n) => n instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((n, o) => n + o.length, 0), r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const i = e[n];
    r.set(i, o), o += i.length;
  }
  return r;
}
var T9 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function P9(e) {
  const t = (n) => e().update(Cv(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function I9(e = 32) {
  if (Rb && typeof Rb.getRandomValues == "function")
    return Rb.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
function Dj(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var Kj = class extends T9 {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = zb(this.buffer);
  }
  update(t) {
    ou.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = Cv(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = zb(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    ou.exists(this), ou.output(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    Dj(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = zb(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
var Mj = (e, t, r) => e & t ^ ~e & r;
var qj = (e, t, r) => e & t ^ e & r ^ t & r;
var Vj = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var ba = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var ya = new Uint32Array(64);
var O9 = class extends Kj {
  constructor() {
    super(64, 32, 8, false), this.A = ba[0] | 0, this.B = ba[1] | 0, this.C = ba[2] | 0, this.D = ba[3] | 0, this.E = ba[4] | 0, this.F = ba[5] | 0, this.G = ba[6] | 0, this.H = ba[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      ya[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = ya[f - 15], m = ya[f - 2], y = Oi(d, 7) ^ Oi(d, 18) ^ d >>> 3, b = Oi(m, 17) ^ Oi(m, 19) ^ m >>> 10;
      ya[f] = b + ya[f - 7] + y + ya[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = Oi(a, 6) ^ Oi(a, 11) ^ Oi(a, 25), m = l + d + Mj(a, c, u) + Vj[f] + ya[f] | 0, b = (Oi(n, 2) ^ Oi(n, 13) ^ Oi(n, 22)) + qj(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + b | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    ya.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Gj = class extends O9 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var L0 = P9(() => new O9());
P9(() => new Gj());
var Wj = BigInt(0);
var Nv = BigInt(1);
var Zj = BigInt(2);
var b1 = (e) => e instanceof Uint8Array;
var Xj = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Wl(e) {
  if (!b1(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += Xj[e[r]];
  return t;
}
function B9(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Uv(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function Zl(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const n = r * 2, o = e.slice(n, n + 2), i = Number.parseInt(o, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("invalid byte sequence");
    t[r] = i;
  }
  return t;
}
function Cn(e) {
  return Uv(Wl(e));
}
function $v(e) {
  if (!b1(e))
    throw new Error("Uint8Array expected");
  return Uv(Wl(Uint8Array.from(e).reverse()));
}
var gc = (e, t) => Zl(e.toString(16).padStart(t * 2, "0"));
var C9 = (e, t) => gc(e, t).reverse();
var Yj = (e) => Zl(B9(e));
function ln(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = Zl(t);
    } catch (i) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${i}`);
    }
  else if (b1(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function lo(...e) {
  const t = new Uint8Array(e.reduce((n, o) => n + o.length, 0));
  let r = 0;
  return e.forEach((n) => {
    if (!b1(n))
      throw new Error("Uint8Array expected");
    t.set(n, r), r += n.length;
  }), t;
}
function Jj(e, t) {
  if (e.length !== t.length)
    return false;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return false;
  return true;
}
function y1(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Qj(e) {
  let t;
  for (t = 0; e > 0n; e >>= Nv, t += 1)
    ;
  return t;
}
var eF = (e, t) => e >> BigInt(t) & 1n;
var tF = (e, t, r) => e | (r ? Nv : Wj) << BigInt(t);
var Rv = (e) => (Zj << BigInt(e - 1)) - Nv;
var Hb = (e) => new Uint8Array(e);
var T4 = (e) => Uint8Array.from(e);
function N9(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = Hb(e), o = Hb(e), i = 0;
  const s = () => {
    n.fill(1), o.fill(0), i = 0;
  }, a = (...f) => r(o, n, ...f), c = (f = Hb()) => {
    o = a(T4([0]), f), n = a(), f.length !== 0 && (o = a(T4([1]), f), n = a());
  }, u = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let f = 0;
    const d = [];
    for (; f < t; ) {
      n = a();
      const m = n.slice();
      d.push(m), f += n.length;
    }
    return lo(...d);
  };
  return (f, d) => {
    s(), c(f);
    let m;
    for (; !(m = d(u())); )
      c();
    return s(), m;
  };
}
var rF = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function _f(e, t, r = {}) {
  const n = (o, i, s) => {
    const a = rF[i];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const c = e[o];
    if (!(s && c === void 0) && !a(c, e))
      throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${i}`);
  };
  for (const [o, i] of Object.entries(t))
    n(o, i, false);
  for (const [o, i] of Object.entries(r))
    n(o, i, true);
  return e;
}
var nF = Object.freeze({
  __proto__: null,
  bitGet: eF,
  bitLen: Qj,
  bitMask: Rv,
  bitSet: tF,
  bytesToHex: Wl,
  bytesToNumberBE: Cn,
  bytesToNumberLE: $v,
  concatBytes: lo,
  createHmacDrbg: N9,
  ensureBytes: ln,
  equalBytes: Jj,
  hexToBytes: Zl,
  hexToNumber: Uv,
  numberToBytesBE: gc,
  numberToBytesLE: C9,
  numberToHexUnpadded: B9,
  numberToVarBytesBE: Yj,
  utf8ToBytes: y1,
  validateObject: _f
});
var rn = BigInt(0);
var _r = BigInt(1);
var eu = BigInt(2);
var oF = BigInt(3);
var vw = BigInt(4);
var P4 = BigInt(5);
var I4 = BigInt(8);
BigInt(9);
BigInt(16);
function Dr(e, t) {
  const r = e % t;
  return r >= rn ? r : t + r;
}
function iF(e, t, r) {
  if (r <= rn || t < rn)
    throw new Error("Expected power/modulo > 0");
  if (r === _r)
    return rn;
  let n = _r;
  for (; t > rn; )
    t & _r && (n = n * e % r), e = e * e % r, t >>= _r;
  return n;
}
function Io(e, t, r) {
  let n = e;
  for (; t-- > rn; )
    n *= n, n %= r;
  return n;
}
function Ew(e, t) {
  if (e === rn || t <= rn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Dr(e, t), n = t, o = rn, i = _r;
  for (; r !== rn; ) {
    const a = n / r, c = n % r, u = o - i * a;
    n = r, r = c, o = i, i = u;
  }
  if (n !== _r)
    throw new Error("invert: does not exist");
  return Dr(o, t);
}
function sF(e) {
  const t = (e - _r) / eu;
  let r, n, o;
  for (r = e - _r, n = 0; r % eu === rn; r /= eu, n++)
    ;
  for (o = eu; o < e && iF(o, t, e) !== e - _r; o++)
    ;
  if (n === 1) {
    const s = (e + _r) / vw;
    return function(c, u) {
      const l = c.pow(u, s);
      if (!c.eql(c.sqr(l), u))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  const i = (r + _r) / eu;
  return function(a, c) {
    if (a.pow(c, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let u = n, l = a.pow(a.mul(a.ONE, o), r), f = a.pow(c, i), d = a.pow(c, r);
    for (; !a.eql(d, a.ONE); ) {
      if (a.eql(d, a.ZERO))
        return a.ZERO;
      let m = 1;
      for (let b = a.sqr(d); m < u && !a.eql(b, a.ONE); m++)
        b = a.sqr(b);
      const y = a.pow(l, _r << BigInt(u - m - 1));
      l = a.sqr(y), f = a.mul(f, y), d = a.mul(d, l), u = m;
    }
    return f;
  };
}
function aF(e) {
  if (e % vw === oF) {
    const t = (e + _r) / vw;
    return function(n, o) {
      const i = n.pow(o, t);
      if (!n.eql(n.sqr(i), o))
        throw new Error("Cannot find square root");
      return i;
    };
  }
  if (e % I4 === P4) {
    const t = (e - P4) / I4;
    return function(n, o) {
      const i = n.mul(o, eu), s = n.pow(i, t), a = n.mul(o, s), c = n.mul(n.mul(a, eu), s), u = n.mul(a, n.sub(c, n.ONE));
      if (!n.eql(n.sqr(u), o))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  return sF(e);
}
var cF = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function U9(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = cF.reduce((n, o) => (n[o] = "function", n), t);
  return _f(e, r);
}
function uF(e, t, r) {
  if (r < rn)
    throw new Error("Expected power > 0");
  if (r === rn)
    return e.ONE;
  if (r === _r)
    return t;
  let n = e.ONE, o = t;
  for (; r > rn; )
    r & _r && (n = e.mul(n, o)), o = e.sqr(o), r >>= _r;
  return n;
}
function lF(e, t) {
  const r = new Array(t.length), n = t.reduce((i, s, a) => e.is0(s) ? i : (r[a] = i, e.mul(i, s)), e.ONE), o = e.inv(n);
  return t.reduceRight((i, s, a) => e.is0(s) ? i : (r[a] = e.mul(i, r[a]), e.mul(i, s)), o), r;
}
function zv(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function $9(e, t, r = false, n = {}) {
  if (e <= rn)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: i } = zv(e, t);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = aF(e), a = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: i,
    MASK: Rv(o),
    ZERO: rn,
    ONE: _r,
    create: (c) => Dr(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return rn <= c && c < e;
    },
    is0: (c) => c === rn,
    isOdd: (c) => (c & _r) === _r,
    neg: (c) => Dr(-c, e),
    eql: (c, u) => c === u,
    sqr: (c) => Dr(c * c, e),
    add: (c, u) => Dr(c + u, e),
    sub: (c, u) => Dr(c - u, e),
    mul: (c, u) => Dr(c * u, e),
    pow: (c, u) => uF(a, c, u),
    div: (c, u) => Dr(c * Ew(u, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => Ew(c, e),
    sqrt: n.sqrt || ((c) => s(a, c)),
    invertBatch: (c) => lF(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => r ? C9(c, i) : gc(c, i),
    fromBytes: (c) => {
      if (c.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${c.length}`);
      return r ? $v(c) : Cn(c);
    }
  });
  return Object.freeze(a);
}
function fF(e, t, r = false) {
  e = ln("privateHash", e);
  const n = e.length, o = zv(t).nByteLength + 8;
  if (o < 24 || n < o || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${n}`);
  const i = r ? $v(e) : Cn(e);
  return Dr(i, t - _r) + _r;
}
var dF = BigInt(0);
var Lb = BigInt(1);
function hF(e, t) {
  const r = (o, i) => {
    const s = i.negate();
    return o ? s : i;
  }, n = (o) => {
    const i = Math.ceil(t / o) + 1, s = 2 ** (o - 1);
    return { windows: i, windowSize: s };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(o, i) {
      let s = e.ZERO, a = o;
      for (; i > dF; )
        i & Lb && (s = s.add(a)), a = a.double(), i >>= Lb;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(o, i) {
      const { windows: s, windowSize: a } = n(i), c = [];
      let u = o, l = u;
      for (let f = 0; f < s; f++) {
        l = u, c.push(l);
        for (let d = 1; d < a; d++)
          l = l.add(u), c.push(l);
        u = l.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(o, i, s) {
      const { windows: a, windowSize: c } = n(o);
      let u = e.ZERO, l = e.BASE;
      const f = BigInt(2 ** o - 1), d = 2 ** o, m = BigInt(o);
      for (let y = 0; y < a; y++) {
        const b = y * c;
        let w = Number(s & f);
        s >>= m, w > c && (w -= d, s += Lb);
        const v = b, k = b + Math.abs(w) - 1, x = y % 2 !== 0, _ = w < 0;
        w === 0 ? l = l.add(r(x, i[v])) : u = u.add(r(_, i[k]));
      }
      return { p: u, f: l };
    },
    wNAFCached(o, i, s, a) {
      const c = o._WINDOW_SIZE || 1;
      let u = i.get(o);
      return u || (u = this.precomputeWindow(o, c), c !== 1 && i.set(o, a(u))), this.wNAF(c, u, s);
    }
  };
}
function R9(e) {
  return U9(e.Fp), _f(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...zv(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
function pF(e) {
  const t = R9(e);
  _f(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
var { bytesToNumberBE: gF, hexToBytes: mF } = nF;
var iu = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  _parseInt(e) {
    const { Err: t } = iu;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const r = e[1], n = e.subarray(2, r + 2);
    if (!r || n.length !== r)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] === 0 && n[1] <= 127)
      throw new t("Invalid signature integer: trailing length");
    return { d: gF(n), l: e.subarray(r + 2) };
  },
  toSig(e) {
    const { Err: t } = iu, r = typeof e == "string" ? mF(e) : e;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = r.length;
    if (n < 2 || r[0] != 48)
      throw new t("Invalid signature tag");
    if (r[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: o, l: i } = iu._parseInt(r.subarray(2)), { d: s, l: a } = iu._parseInt(i);
    if (a.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: o, s };
  },
  hexFromSig(e) {
    const t = (u) => Number.parseInt(u[0], 16) >= 8 ? "00" + u : u, r = (u) => {
      const l = u.toString(16);
      return l.length & 1 ? `0${l}` : l;
    }, n = t(r(e.s)), o = t(r(e.r)), i = n.length / 2, s = o.length / 2, a = r(i), c = r(s);
    return `30${r(s + i + 4)}02${c}${o}02${a}${n}`;
  }
};
var Qo = BigInt(0);
var Lr = BigInt(1);
var ys = BigInt(2);
var j0 = BigInt(3);
var O4 = BigInt(4);
function bF(e) {
  const t = pF(e), { Fp: r } = t, n = t.toBytes || ((y, b, w) => {
    const v = b.toAffine();
    return lo(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));
  }), o = t.fromBytes || ((y) => {
    const b = y.subarray(1), w = r.fromBytes(b.subarray(0, r.BYTES)), v = r.fromBytes(b.subarray(r.BYTES, 2 * r.BYTES));
    return { x: w, y: v };
  });
  function i(y) {
    const { a: b, b: w } = t, v = r.sqr(y), k = r.mul(v, y);
    return r.add(r.add(k, r.mul(y, b)), w);
  }
  function s(y) {
    return typeof y == "bigint" && Qo < y && y < t.n;
  }
  function a(y) {
    if (!s(y))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(y) {
    const { allowedPrivateKeyLengths: b, nByteLength: w, wrapPrivateKey: v, n: k } = t;
    if (b && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = Wl(y)), typeof y != "string" || !b.includes(y.length))
        throw new Error("Invalid key");
      y = y.padStart(w * 2, "0");
    }
    let x;
    try {
      x = typeof y == "bigint" ? y : Cn(ln("private key", y, w));
    } catch {
      throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof y}`);
    }
    return v && (x = Dr(x, k)), a(x), x;
  }
  const u = /* @__PURE__ */ new Map();
  function l(y) {
    if (!(y instanceof f))
      throw new Error("ProjectivePoint expected");
  }
  class f {
    constructor(b, w, v) {
      if (this.px = b, this.py = w, this.pz = v, b == null || !r.isValid(b))
        throw new Error("x required");
      if (w == null || !r.isValid(w))
        throw new Error("y required");
      if (v == null || !r.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(b) {
      const { x: w, y: v } = b || {};
      if (!b || !r.isValid(w) || !r.isValid(v))
        throw new Error("invalid affine point");
      if (b instanceof f)
        throw new Error("projective point not allowed");
      const k = (x) => r.eql(x, r.ZERO);
      return k(w) && k(v) ? f.ZERO : new f(w, v, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(b) {
      const w = r.invertBatch(b.map((v) => v.pz));
      return b.map((v, k) => v.toAffine(w[k])).map(f.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(b) {
      const w = f.fromAffine(o(ln("pointHex", b)));
      return w.assertValidity(), w;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(b) {
      return f.BASE.multiply(c(b));
    }
    // "Private method", don't use it directly
    _setWindowSize(b) {
      this._WINDOW_SIZE = b, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: b, y: w } = this.toAffine();
      if (!r.isValid(b) || !r.isValid(w))
        throw new Error("bad point: x or y not FE");
      const v = r.sqr(w), k = i(b);
      if (!r.eql(v, k))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(b) {
      l(b);
      const { px: w, py: v, pz: k } = this, { px: x, py: _, pz: I } = b, P = r.eql(r.mul(w, I), r.mul(x, k)), $ = r.eql(r.mul(v, I), r.mul(_, k));
      return P && $;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new f(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: w } = t, v = r.mul(w, j0), { px: k, py: x, pz: _ } = this;
      let I = r.ZERO, P = r.ZERO, $ = r.ZERO, L = r.mul(k, k), V = r.mul(x, x), ee = r.mul(_, _), G = r.mul(k, x);
      return G = r.add(G, G), $ = r.mul(k, _), $ = r.add($, $), I = r.mul(b, $), P = r.mul(v, ee), P = r.add(I, P), I = r.sub(V, P), P = r.add(V, P), P = r.mul(I, P), I = r.mul(G, I), $ = r.mul(v, $), ee = r.mul(b, ee), G = r.sub(L, ee), G = r.mul(b, G), G = r.add(G, $), $ = r.add(L, L), L = r.add($, L), L = r.add(L, ee), L = r.mul(L, G), P = r.add(P, L), ee = r.mul(x, _), ee = r.add(ee, ee), L = r.mul(ee, G), I = r.sub(I, L), $ = r.mul(ee, V), $ = r.add($, $), $ = r.add($, $), new f(I, P, $);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      l(b);
      const { px: w, py: v, pz: k } = this, { px: x, py: _, pz: I } = b;
      let P = r.ZERO, $ = r.ZERO, L = r.ZERO;
      const V = t.a, ee = r.mul(t.b, j0);
      let G = r.mul(w, x), N = r.mul(v, _), q = r.mul(k, I), j = r.add(w, v), C = r.add(x, _);
      j = r.mul(j, C), C = r.add(G, N), j = r.sub(j, C), C = r.add(w, k);
      let U = r.add(x, I);
      return C = r.mul(C, U), U = r.add(G, q), C = r.sub(C, U), U = r.add(v, k), P = r.add(_, I), U = r.mul(U, P), P = r.add(N, q), U = r.sub(U, P), L = r.mul(V, C), P = r.mul(ee, q), L = r.add(P, L), P = r.sub(N, L), L = r.add(N, L), $ = r.mul(P, L), N = r.add(G, G), N = r.add(N, G), q = r.mul(V, q), C = r.mul(ee, C), N = r.add(N, q), q = r.sub(G, q), q = r.mul(V, q), C = r.add(C, q), G = r.mul(N, C), $ = r.add($, G), G = r.mul(U, C), P = r.mul(j, P), P = r.sub(P, G), G = r.mul(j, N), L = r.mul(U, L), L = r.add(L, G), new f(P, $, L);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(b) {
      return m.wNAFCached(this, u, b, (w) => {
        const v = r.invertBatch(w.map((k) => k.pz));
        return w.map((k, x) => k.toAffine(v[x])).map(f.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      const w = f.ZERO;
      if (b === Qo)
        return w;
      if (a(b), b === Lr)
        return this;
      const { endo: v } = t;
      if (!v)
        return m.unsafeLadder(this, b);
      let { k1neg: k, k1: x, k2neg: _, k2: I } = v.splitScalar(b), P = w, $ = w, L = this;
      for (; x > Qo || I > Qo; )
        x & Lr && (P = P.add(L)), I & Lr && ($ = $.add(L)), L = L.double(), x >>= Lr, I >>= Lr;
      return k && (P = P.negate()), _ && ($ = $.negate()), $ = new f(r.mul($.px, v.beta), $.py, $.pz), P.add($);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      a(b);
      let w = b, v, k;
      const { endo: x } = t;
      if (x) {
        const { k1neg: _, k1: I, k2neg: P, k2: $ } = x.splitScalar(w);
        let { p: L, f: V } = this.wNAF(I), { p: ee, f: G } = this.wNAF($);
        L = m.constTimeNegate(_, L), ee = m.constTimeNegate(P, ee), ee = new f(r.mul(ee.px, x.beta), ee.py, ee.pz), v = L.add(ee), k = V.add(G);
      } else {
        const { p: _, f: I } = this.wNAF(w);
        v = _, k = I;
      }
      return f.normalizeZ([v, k])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(b, w, v) {
      const k = f.BASE, x = (I, P) => P === Qo || P === Lr || !I.equals(k) ? I.multiplyUnsafe(P) : I.multiply(P), _ = x(this, w).add(x(b, v));
      return _.is0() ? void 0 : _;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(b) {
      const { px: w, py: v, pz: k } = this, x = this.is0();
      b == null && (b = x ? r.ONE : r.inv(k));
      const _ = r.mul(w, b), I = r.mul(v, b), P = r.mul(k, b);
      if (x)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(P, r.ONE))
        throw new Error("invZ was invalid");
      return { x: _, y: I };
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: w } = t;
      if (b === Lr)
        return true;
      if (w)
        return w(f, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: b, clearCofactor: w } = t;
      return b === Lr ? this : w ? w(f, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(b = true) {
      return this.assertValidity(), n(f, this, b);
    }
    toHex(b = true) {
      return Wl(this.toRawBytes(b));
    }
  }
  f.BASE = new f(t.Gx, t.Gy, r.ONE), f.ZERO = new f(r.ZERO, r.ONE, r.ZERO);
  const d = t.nBitLength, m = hF(f, t.endo ? Math.ceil(d / 2) : d);
  return {
    CURVE: t,
    ProjectivePoint: f,
    normPrivateKeyToScalar: c,
    weierstrassEquation: i,
    isWithinCurveOrder: s
  };
}
function yF(e) {
  const t = R9(e);
  return _f(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: true, ...t });
}
function wF(e) {
  const t = yF(e), { Fp: r, n } = t, o = r.BYTES + 1, i = 2 * r.BYTES + 1;
  function s(C) {
    return Qo < C && C < r.ORDER;
  }
  function a(C) {
    return Dr(C, n);
  }
  function c(C) {
    return Ew(C, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: f, isWithinCurveOrder: d } = bF({
    ...t,
    toBytes(C, U, M) {
      const re = U.toAffine(), te = r.toBytes(re.x), ie = lo;
      return M ? ie(Uint8Array.from([U.hasEvenY() ? 2 : 3]), te) : ie(Uint8Array.from([4]), te, r.toBytes(re.y));
    },
    fromBytes(C) {
      const U = C.length, M = C[0], re = C.subarray(1);
      if (U === o && (M === 2 || M === 3)) {
        const te = Cn(re);
        if (!s(te))
          throw new Error("Point is not on curve");
        const ie = f(te);
        let ne = r.sqrt(ie);
        const le = (ne & Lr) === Lr;
        return (M & 1) === 1 !== le && (ne = r.neg(ne)), { x: te, y: ne };
      } else if (U === i && M === 4) {
        const te = r.fromBytes(re.subarray(0, r.BYTES)), ie = r.fromBytes(re.subarray(r.BYTES, 2 * r.BYTES));
        return { x: te, y: ie };
      } else
        throw new Error(`Point of length ${U} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`);
    }
  }), m = (C) => Wl(gc(C, t.nByteLength));
  function y(C) {
    const U = n >> Lr;
    return C > U;
  }
  function b(C) {
    return y(C) ? a(-C) : C;
  }
  const w = (C, U, M) => Cn(C.slice(U, M));
  class v {
    constructor(U, M, re) {
      this.r = U, this.s = M, this.recovery = re, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(U) {
      const M = t.nByteLength;
      return U = ln("compactSignature", U, M * 2), new v(w(U, 0, M), w(U, M, 2 * M));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(U) {
      const { r: M, s: re } = iu.toSig(ln("DER", U));
      return new v(M, re);
    }
    assertValidity() {
      if (!d(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!d(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(U) {
      return new v(this.r, this.s, U);
    }
    recoverPublicKey(U) {
      const { r: M, s: re, recovery: te } = this, ie = $(ln("msgHash", U));
      if (te == null || ![0, 1, 2, 3].includes(te))
        throw new Error("recovery id invalid");
      const ne = te === 2 || te === 3 ? M + t.n : M;
      if (ne >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const le = te & 1 ? "03" : "02", K = u.fromHex(le + m(ne)), ve = c(ne), At = a(-ie * ve), ze = a(re * ve), St = u.BASE.multiplyAndAddUnsafe(K, At, ze);
      if (!St)
        throw new Error("point at infinify");
      return St.assertValidity(), St;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Zl(this.toDERHex());
    }
    toDERHex() {
      return iu.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Zl(this.toCompactHex());
    }
    toCompactHex() {
      return m(this.r) + m(this.s);
    }
  }
  const k = {
    isValidPrivateKey(C) {
      try {
        return l(C), true;
      } catch {
        return false;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const C = t.randomBytes(r.BYTES + 8), U = fF(C, n);
      return gc(U, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(C = 8, U = u.BASE) {
      return U._setWindowSize(C), U.multiply(BigInt(3)), U;
    }
  };
  function x(C, U = true) {
    return u.fromPrivateKey(C).toRawBytes(U);
  }
  function _(C) {
    const U = C instanceof Uint8Array, M = typeof C == "string", re = (U || M) && C.length;
    return U ? re === o || re === i : M ? re === 2 * o || re === 2 * i : C instanceof u;
  }
  function I(C, U, M = true) {
    if (_(C))
      throw new Error("first arg must be private key");
    if (!_(U))
      throw new Error("second arg must be public key");
    return u.fromHex(U).multiply(l(C)).toRawBytes(M);
  }
  const P = t.bits2int || function(C) {
    const U = Cn(C), M = C.length * 8 - t.nBitLength;
    return M > 0 ? U >> BigInt(M) : U;
  }, $ = t.bits2int_modN || function(C) {
    return a(P(C));
  }, L = Rv(t.nBitLength);
  function V(C) {
    if (typeof C != "bigint")
      throw new Error("bigint expected");
    if (!(Qo <= C && C < L))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return gc(C, t.nByteLength);
  }
  function ee(C, U, M = G) {
    if (["recovered", "canonical"].some((Ge) => Ge in M))
      throw new Error("sign() legacy options not supported");
    const { hash: re, randomBytes: te } = t;
    let { lowS: ie, prehash: ne, extraEntropy: le } = M;
    ie == null && (ie = true), C = ln("msgHash", C), ne && (C = ln("prehashed msgHash", re(C)));
    const K = $(C), ve = l(U), At = [V(ve), V(K)];
    if (le != null) {
      const Ge = le === true ? te(r.BYTES) : le;
      At.push(ln("extraEntropy", Ge, r.BYTES));
    }
    const ze = lo(...At), St = K;
    function et(Ge) {
      const ut = P(Ge);
      if (!d(ut))
        return;
      const ot = c(ut), He = u.BASE.multiply(ut).toAffine(), Ae = a(He.x);
      if (Ae === Qo)
        return;
      const bt = a(ot * a(St + Ae * ve));
      if (bt === Qo)
        return;
      let wr = (He.x === Ae ? 0 : 2) | Number(He.y & Lr), Gt = bt;
      return ie && y(bt) && (Gt = b(bt), wr ^= 1), new v(Ae, Gt, wr);
    }
    return { seed: ze, k2sig: et };
  }
  const G = { lowS: t.lowS, prehash: false }, N = { lowS: t.lowS, prehash: false };
  function q(C, U, M = G) {
    const { seed: re, k2sig: te } = ee(C, U, M);
    return N9(t.hash.outputLen, t.nByteLength, t.hmac)(re, te);
  }
  u.BASE._setWindowSize(8);
  function j(C, U, M, re = N) {
    var He;
    const te = C;
    if (U = ln("msgHash", U), M = ln("publicKey", M), "strict" in re)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: ie, prehash: ne } = re;
    let le, K;
    try {
      if (typeof te == "string" || te instanceof Uint8Array)
        try {
          le = v.fromDER(te);
        } catch (Ae) {
          if (!(Ae instanceof iu.Err))
            throw Ae;
          le = v.fromCompact(te);
        }
      else if (typeof te == "object" && typeof te.r == "bigint" && typeof te.s == "bigint") {
        const { r: Ae, s: bt } = te;
        le = new v(Ae, bt);
      } else
        throw new Error("PARSE");
      K = u.fromHex(M);
    } catch (Ae) {
      if (Ae.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return false;
    }
    if (ie && le.hasHighS())
      return false;
    ne && (U = t.hash(U));
    const { r: ve, s: At } = le, ze = $(U), St = c(At), et = a(ze * St), Ge = a(ve * St), ut = (He = u.BASE.multiplyAndAddUnsafe(K, et, Ge)) == null ? void 0 : He.toAffine();
    return ut ? a(ut.x) === ve : false;
  }
  return {
    CURVE: t,
    getPublicKey: x,
    getSharedSecret: I,
    sign: q,
    verify: j,
    ProjectivePoint: u,
    Signature: v,
    utils: k
  };
}
function vF(e, t) {
  const r = e.ORDER;
  let n = Qo;
  for (let d = r - Lr; d % ys === Qo; d /= ys)
    n += Lr;
  const o = n, i = (r - Lr) / ys ** o, s = (i - Lr) / ys, a = ys ** o - Lr, c = ys ** (o - Lr), u = e.pow(t, i), l = e.pow(t, (i + Lr) / ys);
  let f = (d, m) => {
    let y = u, b = e.pow(m, a), w = e.sqr(b);
    w = e.mul(w, m);
    let v = e.mul(d, w);
    v = e.pow(v, s), v = e.mul(v, b), b = e.mul(v, m), w = e.mul(v, d);
    let k = e.mul(w, b);
    v = e.pow(k, c);
    let x = e.eql(v, e.ONE);
    b = e.mul(w, l), v = e.mul(k, y), w = e.cmov(b, w, x), k = e.cmov(v, k, x);
    for (let _ = o; _ > 1; _--) {
      let I = ys ** (_ - ys), P = e.pow(k, I);
      const $ = e.eql(P, e.ONE);
      b = e.mul(w, y), y = e.mul(y, y), P = e.mul(k, y), w = e.cmov(b, w, $), k = e.cmov(P, k, $);
    }
    return { isValid: x, value: w };
  };
  if (e.ORDER % O4 === j0) {
    const d = (e.ORDER - j0) / O4, m = e.sqrt(e.neg(t));
    f = (y, b) => {
      let w = e.sqr(b);
      const v = e.mul(y, b);
      w = e.mul(w, v);
      let k = e.pow(w, d);
      k = e.mul(k, v);
      const x = e.mul(k, m), _ = e.mul(e.sqr(k), b), I = e.eql(_, y);
      let P = e.cmov(x, k, I);
      return { isValid: I, value: P };
    };
  }
  return f;
}
function EF(e, t) {
  if (U9(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const r = vF(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (n) => {
    let o, i, s, a, c, u, l, f;
    o = e.sqr(n), o = e.mul(o, t.Z), i = e.sqr(o), i = e.add(i, o), s = e.add(i, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(i), !e.eql(i, e.ZERO)), a = e.mul(a, t.A), i = e.sqr(s), u = e.sqr(a), c = e.mul(u, t.A), i = e.add(i, c), i = e.mul(i, s), u = e.mul(u, a), c = e.mul(u, t.B), i = e.add(i, c), l = e.mul(o, s);
    const { isValid: d, value: m } = r(i, u);
    f = e.mul(o, n), f = e.mul(f, m), l = e.cmov(l, s, d), f = e.cmov(f, m, d);
    const y = e.isOdd(n) === e.isOdd(f);
    return f = e.cmov(e.neg(f), f, y), l = e.div(l, a), { x: l, y: f };
  };
}
function xF(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return y1(e);
  throw new Error("DST must be Uint8Array or string");
}
var kF = Cn;
function ic(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let n = t - 1; n >= 0; n--)
    r[n] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function AF(e, t) {
  const r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e[n] ^ t[n];
  return r;
}
function Rd(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function Hv(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function SF(e, t, r, n) {
  Rd(e), Rd(t), Hv(r), t.length > 255 && (t = n(lo(y1("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: o, blockLen: i } = n, s = Math.ceil(r / o);
  if (s > 255)
    throw new Error("Invalid xmd length");
  const a = lo(t, ic(t.length, 1)), c = ic(0, i), u = ic(r, 2), l = new Array(s), f = n(lo(c, e, u, ic(0, 1), a));
  l[0] = n(lo(f, ic(1, 1), a));
  for (let m = 1; m <= s; m++) {
    const y = [AF(f, l[m - 1]), ic(m + 1, 1), a];
    l[m] = n(lo(...y));
  }
  return lo(...l).slice(0, r);
}
function _F(e, t, r, n, o) {
  if (Rd(e), Rd(t), Hv(r), t.length > 255) {
    const i = Math.ceil(2 * n / 8);
    t = o.create({ dkLen: i }).update(y1("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return o.create({ dkLen: r }).update(e).update(ic(r, 2)).update(t).update(ic(t.length, 1)).digest();
}
function B4(e, t, r) {
  _f(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: n, k: o, m: i, hash: s, expand: a, DST: c } = r;
  Rd(e), Hv(t);
  const u = xF(c), l = n.toString(2).length, f = Math.ceil((l + o) / 8), d = t * i * f;
  let m;
  if (a === "xmd")
    m = SF(e, u, d, s);
  else if (a === "xof")
    m = _F(e, u, d, o, s);
  else if (a === void 0)
    m = e;
  else
    throw new Error('expand must be "xmd", "xof" or undefined');
  const y = new Array(t);
  for (let b = 0; b < t; b++) {
    const w = new Array(i);
    for (let v = 0; v < i; v++) {
      const k = f * (v + b * i), x = m.subarray(k, k + f);
      w[v] = Dr(kF(x), n);
    }
    y[b] = w;
  }
  return y;
}
function TF(e, t) {
  const r = t.map((n) => Array.from(n).reverse());
  return (n, o) => {
    const [i, s, a, c] = r.map((u) => u.reduce((l, f) => e.add(e.mul(l, n), f)));
    return n = e.div(i, s), o = e.mul(o, e.div(a, c)), { x: n, y: o };
  };
}
function PF(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(n, o) {
      const i = B4(n, 2, { ...r, DST: r.DST, ...o }), s = e.fromAffine(t(i[0])), a = e.fromAffine(t(i[1])), c = s.add(a).clearCofactor();
      return c.assertValidity(), c;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(n, o) {
      const i = B4(n, 1, { ...r, DST: r.encodeDST, ...o }), s = e.fromAffine(t(i[0])).clearCofactor();
      return s.assertValidity(), s;
    }
  };
}
var z9 = class extends T9 {
  constructor(t, r) {
    super(), this.finished = false, this.destroyed = false, ou.hash(t);
    const n = Cv(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, i = new Uint8Array(o);
    i.set(n.length > o ? t.create().update(n).digest() : n);
    for (let s = 0; s < i.length; s++)
      i[s] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let s = 0; s < i.length; s++)
      i[s] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return ou.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    ou.exists(this), ou.bytes(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: i, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = o, t.destroyed = i, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var H9 = (e, t, r) => new z9(e, t).update(r).digest();
H9.create = (e, t) => new z9(e, t);
function IF(e) {
  return {
    hash: e,
    hmac: (t, ...r) => H9(e, t, Fj(...r)),
    randomBytes: I9
  };
}
function OF(e, t) {
  const r = (n) => wF({ ...e, ...IF(n) });
  return Object.freeze({ ...r(t), create: r });
}
var w1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var F0 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var L9 = BigInt(1);
var D0 = BigInt(2);
var C4 = (e, t) => (e + t / D0) / t;
function j9(e) {
  const t = w1, r = BigInt(3), n = BigInt(6), o = BigInt(11), i = BigInt(22), s = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, l = u * u * e % t, f = Io(l, r, t) * l % t, d = Io(f, r, t) * l % t, m = Io(d, D0, t) * u % t, y = Io(m, o, t) * m % t, b = Io(y, i, t) * y % t, w = Io(b, a, t) * b % t, v = Io(w, c, t) * w % t, k = Io(v, a, t) * b % t, x = Io(k, r, t) * l % t, _ = Io(x, s, t) * y % t, I = Io(_, n, t) * u % t, P = Io(I, D0, t);
  if (!wc.eql(wc.sqr(P), e))
    throw new Error("Cannot find square root");
  return P;
}
var wc = $9(w1, void 0, void 0, { sqrt: j9 });
var Yi = OF({
  a: BigInt(0),
  b: BigInt(7),
  Fp: wc,
  n: F0,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = F0, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -L9 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = r, s = BigInt("0x100000000000000000000000000000000"), a = C4(i * e, t), c = C4(-n * e, t);
      let u = Dr(e - a * r - c * o, t), l = Dr(-a * n - c * i, t);
      const f = u > s, d = l > s;
      if (f && (u = t - u), d && (l = t - l), u > s || l > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: u, k2neg: d, k2: l };
    }
  }
}, L0);
var v1 = BigInt(0);
var F9 = (e) => typeof e == "bigint" && v1 < e && e < w1;
var BF = (e) => typeof e == "bigint" && v1 < e && e < F0;
var N4 = {};
function K0(e, ...t) {
  let r = N4[e];
  if (r === void 0) {
    const n = L0(Uint8Array.from(e, (o) => o.charCodeAt(0)));
    r = lo(n, n), N4[e] = r;
  }
  return L0(lo(r, ...t));
}
var Lv = (e) => e.toRawBytes(true).slice(1);
var xw = (e) => gc(e, 32);
var jb = (e) => Dr(e, w1);
var zd = (e) => Dr(e, F0);
var jv = Yi.ProjectivePoint;
var CF = (e, t, r) => jv.BASE.multiplyAndAddUnsafe(e, t, r);
function kw(e) {
  let t = Yi.utils.normPrivateKeyToScalar(e), r = jv.fromPrivateKey(t);
  return { scalar: r.hasEvenY() ? t : zd(-t), bytes: Lv(r) };
}
function D9(e) {
  if (!F9(e))
    throw new Error("bad x: need 0 < x < p");
  const t = jb(e * e), r = jb(t * e + BigInt(7));
  let n = j9(r);
  n % D0 !== v1 && (n = jb(-n));
  const o = new jv(e, n, L9);
  return o.assertValidity(), o;
}
function K9(...e) {
  return zd(Cn(K0("BIP0340/challenge", ...e)));
}
function NF(e) {
  return kw(e).bytes;
}
function UF(e, t, r = I9(32)) {
  const n = ln("message", e), { bytes: o, scalar: i } = kw(t), s = ln("auxRand", r, 32), a = xw(i ^ Cn(K0("BIP0340/aux", s))), c = K0("BIP0340/nonce", a, o, n), u = zd(Cn(c));
  if (u === v1)
    throw new Error("sign failed: k is zero");
  const { bytes: l, scalar: f } = kw(u), d = K9(l, o, n), m = new Uint8Array(64);
  if (m.set(l, 0), m.set(xw(zd(f + d * i)), 32), !M9(m, n, o))
    throw new Error("sign: Invalid signature produced");
  return m;
}
function M9(e, t, r) {
  const n = ln("signature", e, 64), o = ln("message", t), i = ln("publicKey", r, 32);
  try {
    const s = D9(Cn(i)), a = Cn(n.subarray(0, 32));
    if (!F9(a))
      return false;
    const c = Cn(n.subarray(32, 64));
    if (!BF(c))
      return false;
    const u = K9(xw(a), Lv(s), o), l = CF(s, c, zd(-u));
    return !(!l || !l.hasEvenY() || l.toAffine().x !== a);
  } catch {
    return false;
  }
}
var $F = {
  getPublicKey: NF,
  sign: UF,
  verify: M9,
  utils: {
    randomPrivateKey: Yi.utils.randomPrivateKey,
    lift_x: D9,
    pointToBytes: Lv,
    numberToBytesBE: gc,
    bytesToNumberBE: Cn,
    taggedHash: K0,
    mod: Dr
  }
};
var RF = TF(wc, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((e) => e.map((t) => BigInt(t))));
var zF = EF(wc, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: wc.create(BigInt("-11"))
});
PF(Yi.ProjectivePoint, (e) => {
  const { x: t, y: r } = zF(wc.create(e[0]));
  return RF(t, r);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: wc.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: L0
});
function Aw(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function HF(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function q9(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function LF(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Aw(e.outputLen), Aw(e.blockLen);
}
function jF(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function FF(e, t) {
  q9(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var DF = {
  number: Aw,
  bool: HF,
  bytes: q9,
  hash: LF,
  exists: jF,
  output: FF
};
var Fb = DF;
var Db = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Bi = (e, t) => e << 32 - t | e >>> t;
var KF = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!KF)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function MF(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function V9(e) {
  if (typeof e == "string" && (e = MF(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
var qF = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function G9(e) {
  const t = (n) => e().update(V9(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function VF(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var GF = class extends qF {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = Db(this.buffer);
  }
  update(t) {
    Fb.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = V9(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = Db(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Fb.exists(this), Fb.output(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    VF(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Db(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
var WF = (e, t, r) => e & t ^ ~e & r;
var ZF = (e, t, r) => e & t ^ e & r ^ t & r;
var XF = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var wa = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var va = new Uint32Array(64);
var W9 = class extends GF {
  constructor() {
    super(64, 32, 8, false), this.A = wa[0] | 0, this.B = wa[1] | 0, this.C = wa[2] | 0, this.D = wa[3] | 0, this.E = wa[4] | 0, this.F = wa[5] | 0, this.G = wa[6] | 0, this.H = wa[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      va[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = va[f - 15], m = va[f - 2], y = Bi(d, 7) ^ Bi(d, 18) ^ d >>> 3, b = Bi(m, 17) ^ Bi(m, 19) ^ m >>> 10;
      va[f] = b + va[f - 7] + y + va[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = Bi(a, 6) ^ Bi(a, 11) ^ Bi(a, 25), m = l + d + WF(a, c, u) + XF[f] + va[f] | 0, b = (Bi(n, 2) ^ Bi(n, 13) ^ Bi(n, 22)) + ZF(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + b | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    va.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var YF = class extends W9 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var Sw = G9(() => new W9());
G9(() => new YF());
function JF(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function QF(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function eD(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
var { getRandomValues: tD } = crypto ?? globalThis.crypto ?? window.crypto;
function rD(e = 32) {
  if (typeof tD == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function nD(e, t, r = "be") {
  t === void 0 && (t = e.length), JF(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function Z9(e) {
  let t, r = 0;
  const n = e.reduce((i, s) => i + s.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const i = e[t];
    o.set(i, r), r += i.length;
  }
  return o;
}
var oD = new TextEncoder();
var iD = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function X9(e) {
  for (const t of iD)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function sD(e, t, r = false) {
  typeof e == "string" && (e = oD.encode(e));
  const n = X9(t), o = n.length, i = [];
  let s = "", a, c = 0, u, l;
  for (a = 0; a < e.length; a++)
    for (c = 0, u = e[a], s += u > 0 || (s.length ^ a) > 0 ? "" : "1"; c in i || u > 0; )
      l = i[c], l = l > 0 ? l * 256 + u : u, u = l / o | 0, i[c] = l % o, c++;
  for (; c-- > 0; )
    s += n[i[c]];
  return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function aD(e, t) {
  const r = X9(t), n = r.length, o = [], i = [];
  e = e.replace("=", "");
  let s, a = 0, c, u;
  for (s = 0; s < e.length; s++) {
    if (a = 0, c = r.indexOf(e[s]), c < 0)
      throw new Error(`Character range out of bounds: ${c}`);
    for (c > 0 || (i.length ^ s) > 0 || i.push(0); a in o || c > 0; )
      u = o[a], u = u > 0 ? u * n + c : c, c = u >> 8, o[a] = u % 256, a++;
  }
  for (; a-- > 0; )
    i.push(o[a]);
  return new Uint8Array(i);
}
function Y9(e) {
  return Sw(Sw(e));
}
function cD(e) {
  const t = Y9(e);
  return Z9([e, t.slice(0, 4)]);
}
function uD(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (Y9(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
var U4 = {
  encode: sD,
  decode: aD
};
var J9 = {
  encode: (e) => {
    const t = cD(e);
    return U4.encode(t, "base58");
  },
  decode: (e) => {
    const t = U4.decode(e, "base58");
    return uD(t);
  }
};
var Q9 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var lD = [996825010, 642813549, 513874426, 1027748829, 705979059];
var M0 = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function ek(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= lD[o]);
  }
  return t;
}
function tk(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function fD(e, t, r) {
  const n = tk(e).concat(t);
  return ek(n) === r.const;
}
function dD(e, t, r) {
  const n = tk(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = ek(n) ^ r.const, i = [];
  for (let s = 0; s < 6; ++s)
    i.push(o >> 5 * (5 - s) & 31);
  return i;
}
function rk(e, t, r, n = true) {
  const o = [];
  let i = 0, s = 0;
  const a = (1 << r) - 1, c = (1 << t + r - 1) - 1;
  for (const u of e) {
    if (u < 0 || u >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(u));
    for (i = (i << t | u) & c, s += t; s >= r; )
      s -= r, o.push(i >> s & a);
  }
  if (n)
    s > 0 && o.push(i << r - s & a);
  else if (s >= t || (i << r - s & a) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function hD(e, t, r) {
  const n = t.concat(dD(e, t, r));
  let o = e + "1";
  for (let i = 0; i < n.length; ++i)
    o += Q9.charAt(n[i]);
  return o;
}
function nk(e) {
  if (!pD(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !gD(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let i = r + 1; i < e.length; ++i) {
    const s = Q9.indexOf(e.charAt(i));
    if (s === -1)
      throw new Error("Character idx out of bounds: " + String(i));
    t.push(s);
  }
  const o = M0.find((i) => i.version === t[0]) ?? M0[0];
  if (!fD(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function pD(e) {
  let t, r, n = false, o = false;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return false;
    r >= 97 && r <= 122 && (n = true), r >= 65 && r <= 90 && (o = true);
  }
  return !(n && o);
}
function gD(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function mD(e, t = "bc", r = 0) {
  const n = [r, ...rk([...e], 8, 5)], o = M0.find((s) => s.version === r) ?? M0[0], i = hD(t, n, o);
  return ok(i), i;
}
function ok(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = nk(e), o = rk(n.slice(1), 5, 8, false), i = o.length;
  switch (true) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || i < 2 || i > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function bD(e) {
  e = e.toLowerCase();
  const [t, r] = nk(e);
  return r[0];
}
var ik = {
  encode: mD,
  decode: ok,
  version: bD
};
var sk = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var ak = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var yD = new TextEncoder();
function ck(e, t = false, r = true) {
  typeof e == "string" && (e = yD.encode(e));
  const n = t ? ak : sk;
  let o = "", i = 0, s = 0;
  for (let a = 0; a < e.length; a++)
    for (s = s << 8 | e[a], i += 8; i >= 6; )
      i -= 6, o += n[s >> i & 63];
  if (i > 0)
    for (s <<= 6 - i, o += n[s & 63]; i < 6; )
      o += r ? "=" : "", i += 2;
  return o;
}
function uk(e, t = false) {
  const r = t || e.includes("-") || e.includes("_") ? ak.split("") : sk.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, i = 0;
  const s = [];
  for (let a = 0; a < n.length; a++) {
    const c = n[a], u = r.indexOf(c);
    if (u === -1)
      throw new Error("Invalid character: " + c);
    o += 6, i <<= 6, i |= u, o >= 8 && (o -= 8, s.push(i >>> o & 255));
  }
  return new Uint8Array(s);
}
var lk = {
  encode: ck,
  decode: uk
};
var fk = {
  encode: (e) => ck(e, true, false),
  decode: (e) => uk(e, true)
};
var wD = BigInt(0);
var vD = BigInt(255);
var dk = BigInt(256);
function ED(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function xD(e, t, r = "be") {
  t === void 0 && (t = ED(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > wD; ) {
    const a = e & vD, c = Number(a);
    n ? i.setUint8(s++, c) : i.setUint8(s--, c), e = (e - a) / dk;
  }
  return new Uint8Array(o);
}
function kD(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * dk + BigInt(e[r]);
  return BigInt(t);
}
function AD(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let i = 0;
    for (let s = 0; s < 8; s++)
      i |= t[n + s] << 7 - s;
    r[o] = i;
  }
  return r;
}
function SD(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function _D(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function TD(e, t, r = "be") {
  t === void 0 && (t = _D(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? i.setUint8(s++, e) : i.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(o);
}
function PD(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], eD(t);
  return t;
}
var ID = new TextEncoder();
var OD = new TextDecoder();
function Fv(e) {
  return ID.encode(e);
}
function Kb(e) {
  return OD.decode(e);
}
function BD(e, t) {
  QF(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function CD(e, t, r = "le") {
  t = BD(e, t);
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? i.setUint8(s++, u) : i.setUint8(s--, u);
  }
  return new Uint8Array(o);
}
function ND(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function UD(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return Fv(t);
}
function $D(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return nD(e, t, r);
  if (typeof e == "string")
    return CD(e, t, r);
  if (typeof e == "bigint")
    return xD(e, t, r);
  if (typeof e == "number")
    return TD(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
var vt = class vt2 extends Uint8Array {
  static random(t = 32) {
    const r = rD(t);
    return new vt2(r, t);
  }
  constructor(t, r, n) {
    const o = $D(t, r, n);
    super(o);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new WD(this);
  }
  toNum(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return PD(r);
  }
  toBin() {
    return SD(this);
  }
  toBig(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return kD(r);
  }
  toHash() {
    const t = Sw(this);
    return new vt2(t);
  }
  toJson() {
    const t = Kb(this);
    return JSON.parse(t);
  }
  toBech32(t, r = 0) {
    return ik.encode(this, t, r);
  }
  toStr() {
    return Kb(this);
  }
  toHex() {
    return ND(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return J9.encode(this);
  }
  toBase64() {
    return lk.encode(this);
  }
  toB64url() {
    return fk.encode(this);
  }
  prepend(t) {
    return vt2.join([vt2.bytes(t), this]);
  }
  append(t) {
    return vt2.join([this, vt2.bytes(t)]);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new vt2(n);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new vt2(n);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new vt2(t);
  }
  write(t, r) {
    const n = vt2.bytes(t);
    this.set(n, r);
  }
  prefixSize(t) {
    const r = vt2.varInt(this.length, t);
    return vt2.join([r, this]);
  }
  static from(t) {
    return new vt2(Uint8Array.from(t));
  }
  static of(...t) {
    return new vt2(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((o) => vt2.bytes(o)), n = Z9(r);
    return new vt2(n);
  }
  static varInt(t, r) {
    if (t < 253)
      return vt2.num(t, 1);
    if (t < 65536)
      return vt2.of(253, ...vt2.num(t, 2, r));
    if (t < 4294967296)
      return vt2.of(254, ...vt2.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return vt2.of(255, ...vt2.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
};
vt.num = RD, vt.big = HD, vt.bin = zD, vt.raw = LD, vt.str = jD, vt.hex = FD, vt.bytes = DD, vt.json = KD, vt.base64 = MD, vt.b64url = qD, vt.bech32 = VD, vt.b58chk = GD, vt.encode = Fv, vt.decode = Kb;
var Ke = vt;
function RD(e, t, r) {
  return new Ke(e, t, r);
}
function zD(e, t, r) {
  return new Ke(AD(e), t, r);
}
function HD(e, t, r) {
  return new Ke(e, t, r);
}
function LD(e, t, r) {
  return new Ke(e, t, r);
}
function jD(e, t, r) {
  return new Ke(Fv(e), t, r);
}
function FD(e, t, r) {
  return new Ke(e, t, r);
}
function DD(e, t, r) {
  return new Ke(e, t, r);
}
function KD(e) {
  return new Ke(UD(e));
}
function MD(e) {
  return new Ke(lk.decode(e));
}
function qD(e) {
  return new Ke(fk.decode(e));
}
function VD(e) {
  return new Ke(ik.decode(e));
}
function GD(e) {
  return new Ke(J9.decode(e));
}
var WD = class {
  constructor(t) {
    this.data = Ke.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new Ke(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (true) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
var q0 = Yi.CURVE;
var Dv = q0.n;
var ZD = q0.p;
var XD = { x: q0.Gx, y: q0.Gy };
var YD = BigInt(0);
var JD = BigInt(1);
var QD = BigInt(2);
var eK = BigInt(3);
var tK = BigInt(4);
var _w = { N: Dv, P: ZD, G: XD, _0n: YD, _1n: JD, _2n: QD, _3n: eK, _4n: tK };
var td = $9(Dv, 32, true);
var hk = (e) => Dr(e, Dv);
function Kv(e, t = false) {
  if (t)
    throw new Error(e);
  return false;
}
function pk(e) {
  return Ke.random(e);
}
function rK(e) {
  const t = Ke.bytes(e).big;
  return Ke.big(hk(t), 32);
}
var nK = Object.freeze({
  __proto__: null,
  fail: Kv,
  mod_bytes: rK,
  random: pk
});
var { N: oK, P: wwe, _0n: iK } = _w;
function sK(e, t, r) {
  const n = Ke.bytes(e);
  return n.length !== t ? Kv(`Invalid byte size: ${n.hex} !== ${t}`, r) : true;
}
function aK(e, t) {
  return typeof e == "bigint" && iK < e && e < oK || Kv("x value is not in the field!", t), true;
}
var $4 = Yi.ProjectivePoint;
var Er = class Er2 extends Uint8Array {
  static mod(t) {
    return new Er2(t);
  }
  static is_valid(t, r) {
    const n = Ke.bytes(t, 32).big;
    return aK(n, r);
  }
  constructor(t) {
    let r = cK(t);
    r = hk(r), Er2.is_valid(r, true), super(Ke.big(r, 32), 32);
  }
  get buff() {
    return new Ke(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(t) {
    return new Er2(t).big > this.big;
  }
  lt(t) {
    return new Er2(t).big < this.big;
  }
  eq(t) {
    return new Er2(t).big === this.big;
  }
  ne(t) {
    return new Er2(t).big !== this.big;
  }
  add(t) {
    const r = Er2.mod(t), n = td.add(this.big, r.big);
    return new Er2(n);
  }
  sub(t) {
    const r = Er2.mod(t), n = td.sub(this.big, r.big);
    return new Er2(n);
  }
  mul(t) {
    const r = Er2.mod(t), n = td.mul(this.big, r.big);
    return new Er2(n);
  }
  pow(t) {
    const r = Er2.mod(t), n = td.pow(this.big, r.big);
    return new Er2(n);
  }
  div(t) {
    const r = Er2.mod(t), n = td.div(this.big, r.big);
    return new Er2(n);
  }
  negate() {
    return new Er2(Er2.N - this.big);
  }
  generate() {
    const r = Yi.ProjectivePoint.BASE.multiply(this.big);
    return qs.import(r);
  }
};
Er.N = Yi.CURVE.n;
var dn = Er;
var Jt = class Jt2 {
  static from_x(t) {
    let r = uK(t);
    r.length === 32 && (r = r.prepend(2)), sK(r, 33);
    const n = $4.fromHex(r.hex);
    return n.assertValidity(), new Jt2(n.x, n.y);
  }
  static generate(t) {
    const r = dn.mod(t), n = Jt2.base.multiply(r.big);
    return Jt2.import(n);
  }
  static import(t) {
    const r = t instanceof Jt2 ? { x: t.x.big, y: t.y.big } : { x: t.x, y: t.y };
    return new Jt2(r.x, r.y);
  }
  constructor(t, r) {
    this._p = new $4(t, r, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return Ke.big(this.p.x, 32);
  }
  get y() {
    return Ke.big(this.p.y, 32);
  }
  get buff() {
    return Ke.raw(this.p.toRawBytes(true));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  eq(t) {
    const r = t instanceof Jt2 ? t : Jt2.from_x(t);
    return this.x.big === r.x.big && this.y.big === r.y.big;
  }
  add(t) {
    return t instanceof Jt2 ? Jt2.import(this.p.add(t.p)) : Jt2.import(this.p.add(Jt2.generate(t).p));
  }
  sub(t) {
    return t instanceof Jt2 ? Jt2.import(this.p.subtract(t.p)) : Jt2.import(this.p.subtract(Jt2.generate(t).p));
  }
  mul(t) {
    return t instanceof Jt2 ? Jt2.import(this.p.multiply(t.x.big)) : Jt2.import(this.p.multiply(dn.mod(t).big));
  }
  negate() {
    return Jt2.import(this.p.negate());
  }
};
Jt.P = _w.P, Jt.G = _w.G, Jt.base = Yi.ProjectivePoint.BASE;
var qs = Jt;
function cK(e) {
  if (e instanceof dn)
    return e.big;
  if (e instanceof qs)
    return e.x.big;
  if (e instanceof Uint8Array)
    return Ke.raw(e).big;
  if (typeof e == "string")
    return Ke.hex(e).big;
  if (typeof e == "number")
    return Ke.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function uK(e) {
  if (e instanceof dn)
    return e.point.buff;
  if (e instanceof qs)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return Ke.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return Ke.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
function Tw(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function lK(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function gk(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function fK(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Tw(e.outputLen), Tw(e.blockLen);
}
function dK(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function hK(e, t) {
  gk(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var pK = {
  number: Tw,
  bool: lK,
  bytes: gk,
  hash: fK,
  exists: dK,
  output: hK
};
var su = pK;
var gK = (e) => e instanceof Uint8Array;
var Mb = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Ci = (e, t) => e << 32 - t | e >>> t;
var mK = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!mK)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function bK(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function Mv(e) {
  if (typeof e == "string" && (e = bK(e)), !gK(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
var mk = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function Gu(e) {
  const t = (n) => e().update(Mv(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function yK(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var qv = class extends mk {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = Mb(this.buffer);
  }
  update(t) {
    su.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = Mv(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = Mb(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    su.exists(this), su.output(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    yK(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Mb(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
var wK = (e, t, r) => e & t ^ ~e & r;
var vK = (e, t, r) => e & t ^ e & r ^ t & r;
var EK = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Ea = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var xa = new Uint32Array(64);
var bk = class extends qv {
  constructor() {
    super(64, 32, 8, false), this.A = Ea[0] | 0, this.B = Ea[1] | 0, this.C = Ea[2] | 0, this.D = Ea[3] | 0, this.E = Ea[4] | 0, this.F = Ea[5] | 0, this.G = Ea[6] | 0, this.H = Ea[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      xa[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = xa[f - 15], m = xa[f - 2], y = Ci(d, 7) ^ Ci(d, 18) ^ d >>> 3, b = Ci(m, 17) ^ Ci(m, 19) ^ m >>> 10;
      xa[f] = b + xa[f - 7] + y + xa[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = Ci(a, 6) ^ Ci(a, 11) ^ Ci(a, 25), m = l + d + wK(a, c, u) + EK[f] + xa[f] | 0, b = (Ci(n, 2) ^ Ci(n, 13) ^ Ci(n, 22)) + vK(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + b | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    xa.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var xK = class extends bk {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var V0 = Gu(() => new bk());
Gu(() => new xK());
var Ap = BigInt(2 ** 32 - 1);
var Pw = BigInt(32);
function yk(e, t = false) {
  return t ? { h: Number(e & Ap), l: Number(e >> Pw & Ap) } : { h: Number(e >> Pw & Ap) | 0, l: Number(e & Ap) | 0 };
}
function kK(e, t = false) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: i, l: s } = yk(e[o], t);
    [r[o], n[o]] = [i, s];
  }
  return [r, n];
}
var AK = (e, t) => BigInt(e >>> 0) << Pw | BigInt(t >>> 0);
var SK = (e, t, r) => e >>> r;
var _K = (e, t, r) => e << 32 - r | t >>> r;
var TK = (e, t, r) => e >>> r | t << 32 - r;
var PK = (e, t, r) => e << 32 - r | t >>> r;
var IK = (e, t, r) => e << 64 - r | t >>> r - 32;
var OK = (e, t, r) => e >>> r - 32 | t << 64 - r;
var BK = (e, t) => t;
var CK = (e, t) => e;
var NK = (e, t, r) => e << r | t >>> 32 - r;
var UK = (e, t, r) => t << r | e >>> 32 - r;
var $K = (e, t, r) => t << r - 32 | e >>> 64 - r;
var RK = (e, t, r) => e << r - 32 | t >>> 64 - r;
function zK(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
var HK = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
var LK = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
var jK = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
var FK = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
var DK = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
var KK = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0;
var MK = {
  fromBig: yk,
  split: kK,
  toBig: AK,
  shrSH: SK,
  shrSL: _K,
  rotrSH: TK,
  rotrSL: PK,
  rotrBH: IK,
  rotrBL: OK,
  rotr32H: BK,
  rotr32L: CK,
  rotlSH: NK,
  rotlSL: UK,
  rotlBH: $K,
  rotlBL: RK,
  add: zK,
  add3L: HK,
  add3H: LK,
  add4L: jK,
  add4H: FK,
  add5H: KK,
  add5L: DK
};
var dt = MK;
var [qK, VK] = dt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e)));
var ka = new Uint32Array(80);
var Aa = new Uint32Array(80);
var E1 = class extends qv {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: i, Cl: s, Dh: a, Dl: c, Eh: u, El: l, Fh: f, Fl: d, Gh: m, Gl: y, Hh: b, Hl: w } = this;
    return [t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = i | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = f | 0, this.Fl = d | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = w | 0;
  }
  process(t, r) {
    for (let x = 0; x < 16; x++, r += 4)
      ka[x] = t.getUint32(r), Aa[x] = t.getUint32(r += 4);
    for (let x = 16; x < 80; x++) {
      const _ = ka[x - 15] | 0, I = Aa[x - 15] | 0, P = dt.rotrSH(_, I, 1) ^ dt.rotrSH(_, I, 8) ^ dt.shrSH(_, I, 7), $ = dt.rotrSL(_, I, 1) ^ dt.rotrSL(_, I, 8) ^ dt.shrSL(_, I, 7), L = ka[x - 2] | 0, V = Aa[x - 2] | 0, ee = dt.rotrSH(L, V, 19) ^ dt.rotrBH(L, V, 61) ^ dt.shrSH(L, V, 6), G = dt.rotrSL(L, V, 19) ^ dt.rotrBL(L, V, 61) ^ dt.shrSL(L, V, 6), N = dt.add4L($, G, Aa[x - 7], Aa[x - 16]), q = dt.add4H(N, P, ee, ka[x - 7], ka[x - 16]);
      ka[x] = q | 0, Aa[x] = N | 0;
    }
    let { Ah: n, Al: o, Bh: i, Bl: s, Ch: a, Cl: c, Dh: u, Dl: l, Eh: f, El: d, Fh: m, Fl: y, Gh: b, Gl: w, Hh: v, Hl: k } = this;
    for (let x = 0; x < 80; x++) {
      const _ = dt.rotrSH(f, d, 14) ^ dt.rotrSH(f, d, 18) ^ dt.rotrBH(f, d, 41), I = dt.rotrSL(f, d, 14) ^ dt.rotrSL(f, d, 18) ^ dt.rotrBL(f, d, 41), P = f & m ^ ~f & b, $ = d & y ^ ~d & w, L = dt.add5L(k, I, $, VK[x], Aa[x]), V = dt.add5H(L, v, _, P, qK[x], ka[x]), ee = L | 0, G = dt.rotrSH(n, o, 28) ^ dt.rotrBH(n, o, 34) ^ dt.rotrBH(n, o, 39), N = dt.rotrSL(n, o, 28) ^ dt.rotrBL(n, o, 34) ^ dt.rotrBL(n, o, 39), q = n & i ^ n & a ^ i & a, j = o & s ^ o & c ^ s & c;
      v = b | 0, k = w | 0, b = m | 0, w = y | 0, m = f | 0, y = d | 0, { h: f, l: d } = dt.add(u | 0, l | 0, V | 0, ee | 0), u = a | 0, l = c | 0, a = i | 0, c = s | 0, i = n | 0, s = o | 0;
      const C = dt.add3L(ee, N, j);
      n = dt.add3H(C, V, G, q), o = C | 0;
    }
    ({ h: n, l: o } = dt.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: i, l: s } = dt.add(this.Bh | 0, this.Bl | 0, i | 0, s | 0), { h: a, l: c } = dt.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l } = dt.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: f, l: d } = dt.add(this.Eh | 0, this.El | 0, f | 0, d | 0), { h: m, l: y } = dt.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: b, l: w } = dt.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0), { h: v, l: k } = dt.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, i, s, a, c, u, l, f, d, m, y, b, w, v, k);
  }
  roundClean() {
    ka.fill(0), Aa.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var GK = class extends E1 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
var WK = class extends E1 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
var ZK = class extends E1 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
var XK = Gu(() => new E1());
Gu(() => new GK());
Gu(() => new WK());
Gu(() => new ZK());
var YK = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var wk = Uint8Array.from({ length: 16 }, (e, t) => t);
var JK = wk.map((e) => (9 * e + 5) % 16);
var Vv = [wk];
var Gv = [JK];
for (let e = 0; e < 4; e++)
  for (let t of [Vv, Gv])
    t.push(t[e].map((r) => YK[r]));
var vk = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e));
var QK = Vv.map((e, t) => e.map((r) => vk[t][r]));
var eM = Gv.map((e, t) => e.map((r) => vk[t][r]));
var tM = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var rM = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
var Sp = (e, t) => e << t | e >>> 32 - t;
function R4(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
var _p = new Uint32Array(16);
var nM = class extends qv {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: o, h4: i } = this;
    return [t, r, n, o, i];
  }
  set(t, r, n, o, i) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = o | 0, this.h4 = i | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4)
      _p[m] = t.getUint32(r, true);
    let n = this.h0 | 0, o = n, i = this.h1 | 0, s = i, a = this.h2 | 0, c = a, u = this.h3 | 0, l = u, f = this.h4 | 0, d = f;
    for (let m = 0; m < 5; m++) {
      const y = 4 - m, b = tM[m], w = rM[m], v = Vv[m], k = Gv[m], x = QK[m], _ = eM[m];
      for (let I = 0; I < 16; I++) {
        const P = Sp(n + R4(m, i, a, u) + _p[v[I]] + b, x[I]) + f | 0;
        n = f, f = u, u = Sp(a, 10) | 0, a = i, i = P;
      }
      for (let I = 0; I < 16; I++) {
        const P = Sp(o + R4(y, s, c, l) + _p[k[I]] + w, _[I]) + d | 0;
        o = d, d = l, l = Sp(c, 10) | 0, c = s, s = P;
      }
    }
    this.set(this.h1 + a + l | 0, this.h2 + u + d | 0, this.h3 + f + o | 0, this.h4 + n + s | 0, this.h0 + i + c | 0);
  }
  roundClean() {
    _p.fill(0);
  }
  destroy() {
    this.destroyed = true, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
var oM = Gu(() => new nM());
var Ek = class extends mk {
  constructor(t, r) {
    super(), this.finished = false, this.destroyed = false, su.hash(t);
    const n = Mv(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, i = new Uint8Array(o);
    i.set(n.length > o ? t.create().update(n).digest() : n);
    for (let s = 0; s < i.length; s++)
      i[s] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let s = 0; s < i.length; s++)
      i[s] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return su.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    su.exists(this), su.bytes(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: i, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = o, t.destroyed = i, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var xk = (e, t, r) => new Ek(e, t).update(r).digest();
xk.create = (e, t) => new Ek(e, t);
function iM(e) {
  const t = Ke.bytes(e);
  return Ke.raw(V0(t));
}
function Xl(e) {
  const t = Ke.bytes(e);
  return Ke.raw(V0(V0(t)));
}
function Wv(e) {
  const t = Ke.bytes(e);
  return Ke.raw(oM(V0(t)));
}
function sM(e, t) {
  const r = Ke.bytes(e), n = Ke.bytes(t);
  return Ke.raw(xk(XK, r, n));
}
function aM(e) {
  const t = Ke.str(e).digest;
  return Ke.join([t, t]);
}
function cM(e = 32) {
  return Zv(pk(e));
}
function Zv(e) {
  return dn.mod(e).buff;
}
function kk(e, t = false) {
  const r = dn.mod(e).point;
  return t ? r.x : r.buff;
}
function Ak(e, t) {
  const r = qs.from_x(t), n = dn.mod(e);
  return r.mul(n).buff;
}
function uM(e, t, r = "ecdh/code") {
  const n = aM(r), o = Zv(e), i = kk(o), s = Ke.bytes(t), a = Ak(o, s), c = [i.hex, s.hex];
  return c.sort(), sM(a, Ke.join([n, ...c]));
}
function lM(e) {
  const t = Ke.bytes(e);
  switch (true) {
    case t.length === 32:
      return true;
    case (t.length === 33 && t[0] === 2):
      return true;
    case (t.length === 33 && t[0] === 3):
      return false;
    default:
      throw new TypeError(`Invalid public key: ${t.hex}`);
  }
}
function fM(e) {
  const t = Ke.bytes(e);
  switch (t.length) {
    case 32:
      return t;
    case 33:
      return t.slice(1, 33);
    default:
      throw new Error(`Invalid key length: ${t.length}`);
  }
}
var dM = Object.freeze({
  __proto__: null,
  genSecretKey: cM,
  getPublicKey: kk,
  getSecretKey: Zv,
  getSharedCode: uM,
  getSharedKey: Ak,
  is_even_pub: lM,
  xonly_pub: fM
});
Ke.random(32);
var Sk = { secp: Yi, schnorr: $F };
var Iw = { ...dM, ...nK };
function x1(e) {
  const t = W.bytes(e);
  return rs(t, 33), Wv(t);
}
function _k(e) {
  const t = Rn.fmt.toBytes(e, false);
  return Wv(t);
}
function Tk(e) {
  const t = Rn.fmt.toBytes(e, false);
  return iM(t);
}
function Pk(e, t = "main") {
  const r = t === "main" ? ["1"] : ["m", "n"];
  for (const n of r)
    if (e.startsWith(n))
      return true;
  return false;
}
function Ik(e, t = "main") {
  const r = W.bytes(e), n = t === "main" ? W.num(0) : W.num(111);
  return rs(e, 20), r.prepend(n).tob58chk();
}
function hM(e, t = "main") {
  if (!Pk(e, t))
    throw new TypeError("Invalid p2pkh address!");
  return W.b58chk(e).slice(1);
}
function pM(e) {
  const t = W.bytes(e);
  return rs(t, 20), ["OP_DUP", "OP_HASH160", t.hex, "OP_EQUALVERIFY", "OP_CHECKSIG"];
}
function gM(e, t) {
  const r = x1(e);
  return Ik(r, t);
}
var Ok = { check: Pk, encode: Ik, decode: hM, hash: x1, scriptPubKey: pM, fromPubKey: gM };
function Bk(e, t = "main") {
  const r = t === "main" ? ["3"] : ["2"];
  for (const n of r)
    if (e.startsWith(n))
      return true;
  return false;
}
function Ck(e, t = "main") {
  const r = t === "main" ? W.num(5) : W.num(196), n = W.bytes(e);
  return rs(n, 20), n.prepend(r).tob58chk();
}
function mM(e, t = "main") {
  if (!Bk(e, t))
    throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
  return W.b58chk(e).slice(1);
}
function bM(e) {
  return ["OP_HASH160", W.bytes(e).hex, "OP_EQUAL"];
}
function yM(e, t) {
  const r = _k(e);
  return Ck(r, t);
}
var Nk = { check: Bk, encode: Ck, decode: mM, hash: _k, scriptPubKey: bM, fromScript: yM };
var Xv = {
  main: "bc",
  testnet: "tb",
  signet: "tb",
  regtest: "bcrt"
};
var wM = ["bc1q", "tb1q", "bcrt1q"];
function Uk(e) {
  for (const t of wM)
    if (e.startsWith(t))
      return true;
  return false;
}
function $k(e, t = "main") {
  const r = Xv[t], n = W.bytes(e);
  return rs(n, 20), n.toBech32(r, 0);
}
function vM(e) {
  if (!Uk(e))
    throw new TypeError("Invalid segwit address!");
  return W.bech32(e);
}
function EM(e) {
  const t = W.bytes(e);
  return rs(t, 20), ["OP_0", t.hex];
}
function xM(e, t) {
  const r = x1(e);
  return $k(r, t);
}
var Rk = { check: Uk, encode: $k, decode: vM, hash: x1, scriptPubKey: EM, fromPubKey: xM };
var kM = ["bc1q", "tb1q", "bcrt1q"];
function zk(e) {
  for (const t of kM)
    if (e.startsWith(t))
      return true;
  return false;
}
function Hk(e, t = "main") {
  const r = Xv[t], n = W.bytes(e);
  return rs(n, 32), n.toBech32(r, 0);
}
function AM(e) {
  if (!zk(e))
    throw new TypeError("Invalid segwit address!");
  return W.bech32(e);
}
function SM(e) {
  const t = W.bytes(e);
  return rs(t, 32), ["OP_0", t.hex];
}
function _M(e, t) {
  const r = Tk(e);
  return Hk(r, t);
}
var Lk = { check: zk, encode: Hk, decode: AM, hash: Tk, scriptPubKey: SM, fromScript: _M };
function Pu(e) {
  const t = W.bytes(e);
  return t.length > 32 ? t.slice(1, 33) : t;
}
var TM = ["bc1p", "tb1p", "bcrt1p"];
function jk(e) {
  for (const t of TM)
    if (e.startsWith(t))
      return true;
  return false;
}
function Fk(e, t = "main") {
  const r = Xv[t], n = W.bytes(e);
  return rs(n, 32), n.toBech32(r, 1);
}
function PM(e) {
  if (!jk(e))
    throw new TypeError("Invalid taproot address!");
  return W.bech32(e);
}
function IM(e) {
  const t = W.bytes(e);
  return rs(t, 32), ["OP_1", t.hex];
}
function OM(e, t) {
  const r = Pu(e);
  return Fk(r, t);
}
var Dk = { check: jk, encode: Fk, decode: PM, scriptPubKey: IM, fromPubKey: OM };
var BM = {
  version: 2,
  vin: [],
  vout: [],
  locktime: 0
};
var CM = {
  scriptSig: [],
  sequence: 4294967293,
  witness: []
};
var NM = {
  value: 0n,
  scriptPubKey: []
};
function Yv(e) {
  const t = { ...BM, ...e };
  return t.vin = t.vin.map((r) => ({ ...CM, ...r })), t.vout = t.vout.map((r) => ({ ...NM, ...r })), t;
}
function Yl(e, t) {
  const { version: r, vin: n, vout: o, locktime: i } = Yv(e), s = t !== true && UM(n), a = [Jv(r)];
  s && a.push(W.hex("0001")), a.push($M(n)), a.push(RM(o));
  for (const c of n)
    s && a.push(HM(c.witness));
  return a.push(Qv(i)), W.join(a);
}
function UM(e) {
  for (const t of e) {
    const { witness: r } = t;
    if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0)
      return true;
  }
  return false;
}
function Jv(e) {
  return W.num(e, 4).reverse();
}
function Nh(e) {
  return W.hex(e, 32).reverse();
}
function Uh(e) {
  return W.num(e, 4).reverse();
}
function $h(e) {
  if (typeof e == "string")
    return W.hex(e, 4).reverse();
  if (typeof e == "number")
    return W.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function $M(e) {
  const t = [W.varInt(e.length, "le")];
  for (const r of e) {
    const { txid: n, vout: o, scriptSig: i, sequence: s } = r;
    t.push(Nh(n)), t.push(Uh(o)), t.push(Vu(i, true)), t.push($h(s));
  }
  return W.join(t);
}
function vc(e) {
  if (typeof e == "number") {
    if (e % 1 !== 0)
      throw new Error("Value must be an integer:" + String(e));
    return W.num(e, 8).reverse();
  }
  return W.big(e, 8).reverse();
}
function RM(e) {
  const t = [W.varInt(e.length, "le")];
  for (const r of e)
    t.push(zM(r));
  return W.join(t);
}
function zM(e) {
  const { value: t, scriptPubKey: r } = e, n = [];
  return n.push(vc(t)), n.push(Vu(r, true)), W.join(n);
}
function HM(e = []) {
  const t = [];
  if (Array.isArray(e)) {
    const r = W.varInt(e.length);
    t.push(r);
    for (const n of e)
      t.push(LM(n));
    return W.join(t);
  } else
    return W.bytes(e);
}
function LM(e) {
  return jM(e) ? new W(0) : Vu(e, true);
}
function jM(e) {
  if (Array.isArray(e))
    return e.length === 0;
  if (typeof e == "string" && e === "")
    return true;
  const t = W.bytes(e);
  return t.length === 1 && t[0] === 0;
}
function Qv(e) {
  if (typeof e == "string")
    return W.hex(e, 4);
  if (typeof e == "number")
    return W.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function e3(e) {
  typeof e == "string" && (e = W.hex(e).raw);
  const t = new Sf(e), r = FM(t), n = DM(t), o = KM(t), i = qM(t);
  if (n)
    for (const a of o)
      a.witness = GM(t);
  const s = WM(t);
  return { version: r, vin: o, vout: i, locktime: s };
}
function FM(e) {
  return e.read(4).reverse().toNum();
}
function DM(e) {
  const [t, r] = [...e.peek(2)];
  if (t === 0) {
    if (e.read(2), r === 1)
      return true;
    throw new Error(`Invalid witness flag: ${r}`);
  }
  return false;
}
function KM(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(MM(e));
  return t;
}
function MM(e) {
  return {
    txid: e.read(32).reverse().toHex(),
    vout: e.read(4).reverse().toNum(),
    scriptSig: Mk(e),
    sequence: e.read(4).reverse().toHex(),
    witness: []
  };
}
function qM(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(VM(e));
  return t;
}
function VM(e) {
  return {
    value: e.read(8).reverse().big,
    scriptPubKey: Mk(e)
  };
}
function GM(e) {
  const t = [], r = e.readSize();
  for (let n = 0; n < r; n++) {
    const o = Kk(e);
    t.push(o ?? "");
  }
  return t;
}
function Kk(e, t) {
  const r = e.readSize("le");
  return r > 0 ? e.read(r).hex : null;
}
function Mk(e, t) {
  const r = Kk(e);
  return r !== null ? r : [];
}
function WM(e) {
  return e.read(4).reverse().toNum();
}
function ZM(e) {
  if (A9(e))
    return e3(e);
  if (typeof e == "object" && !(e instanceof Uint8Array))
    return Yl(e), Yv(e);
  throw new Error("Invalid format: " + typeof e);
}
function XM(e) {
  if (A9(e))
    return e3(e), W.bytes(e);
  if (typeof e == "object")
    return Yl(e);
  throw new Error("Invalid format: " + typeof e);
}
var t3 = {
  toBytes: XM,
  toJson: ZM
};
var YM = [
  ["p2pkh", /^76a914(?<hash>\w{40})88ac$/],
  ["p2sh", /^a914(?<hash>\w{40})87$/],
  ["p2w-pkh", /^0014(?<hash>\w{40})$/],
  ["p2w-sh", /^0020(?<hash>\w{64})$/],
  ["p2tr", /^5120(?<hash>\w{64})$/]
];
var JM = [
  192,
  194,
  196,
  198,
  200,
  202,
  204,
  206,
  208,
  210,
  212,
  214,
  216,
  218,
  220,
  222,
  224,
  226,
  228,
  230,
  232,
  234,
  236,
  238,
  240,
  242,
  244,
  246,
  248,
  250,
  252,
  254,
  102,
  126,
  128,
  132,
  150,
  152,
  186,
  188,
  190
];
function QM(e) {
  let t = e.at(-1);
  return Qs(t) && (t = W.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), W.raw(t)) : null;
}
function eq(e) {
  let t = e.at(-1);
  return Qs(t) && (t = W.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && JM.includes(t[0] & 254) ? (e.pop(), W.raw(t)) : null;
}
function tq(e) {
  if (e.length > 1) {
    const t = e.at(-1);
    try {
      const r = Rn.fmt.toBytes(t);
      return e.pop(), r;
    } catch {
      return null;
    }
  }
  return null;
}
function rq(e) {
  const t = [];
  for (const r of e)
    if (Qs(r) || r instanceof Uint8Array || typeof r == "number")
      t.push(W.bytes(r));
    else
      throw new Error("unrecognized value: " + String(r));
  return t;
}
function nq(e = []) {
  const t = [...e], r = QM(t), n = eq(t), o = tq(t), i = rq(t);
  return { annex: r, cblock: n, script: o, params: i };
}
function oq(e) {
  const t = Rn.fmt.toBytes(e, false).hex;
  for (const [r, n] of YM) {
    const o = r, { groups: i } = n.exec(t) ?? {}, { hash: s } = i ?? {};
    if (Qs(s))
      return { type: o, data: W.hex(s) };
  }
  return { type: "raw", data: W.hex(t) };
}
function iq(e) {
  const t = t3.toJson(e), r = Yl(t, true);
  return Xl(r).reverse().hex;
}
function sq(e) {
  const t = t3.toJson(e), r = Yl(t, true).length, n = Yl(t, false).length, o = r * 3 + n, i = o % 4 > 0 ? 1 : 0, s = Math.floor(o / 4) + i;
  return { size: n, bsize: r, vsize: s, weight: o };
}
var oi = {
  create: Yv,
  encode: Yl,
  decode: e3,
  fmt: t3,
  util: {
    getTxSize: sq,
    getTxid: iq,
    readScriptPubKey: oq,
    readWitness: nq
  }
};
var aq = [
  ["1", "p2pkh", "main", 20, "base58"],
  ["3", "p2sh", "main", 20, "base58"],
  ["m", "p2pkh", "testnet", 20, "base58"],
  ["n", "p2pkh", "testnet", 20, "base58"],
  ["2", "p2sh", "testnet", 20, "base58"],
  ["bc1q", "p2w-pkh", "main", 20, "bech32"],
  ["tb1q", "p2w-pkh", "testnet", 20, "bech32"],
  ["bcrt1q", "p2w-pkh", "regtest", 20, "bech32"],
  ["bc1q", "p2w-sh", "main", 32, "bech32"],
  ["tb1q", "p2w-sh", "testnet", 32, "bech32"],
  ["bcrt1q", "p2w-sh", "regtest", 32, "bech32"],
  ["bc1p", "p2tr", "main", 32, "bech32m"],
  ["tb1p", "p2tr", "testnet", 32, "bech32m"],
  ["bcrt1p", "p2tr", "regtest", 32, "bech32m"]
];
function cq(e, t) {
  switch (t) {
    case "base58":
      return W.b58chk(e).slice(1);
    case "bech32":
      return W.bech32(e);
    case "bech32m":
      return W.bech32(e);
    default:
      throw new Error("Invalid address format: " + t);
  }
}
function uq(e) {
  for (const t of aq) {
    const [r, n, o, i, s] = t;
    if (e.startsWith(r) && cq(e, s).length === i)
      return t;
  }
  throw new Error("Invalid address: " + e);
}
function qk(e) {
  switch (e) {
    case "p2pkh":
      return Ok;
    case "p2sh":
      return Nk;
    case "p2w-pkh":
      return Rk;
    case "p2w-sh":
      return Lk;
    case "p2tr":
      return Dk;
    default:
      throw new Error("Invalid address type: " + e);
  }
}
function Vk(e) {
  const [t, r, n] = uq(e), o = qk(r), i = o.decode(e, n), s = o.scriptPubKey(i);
  return { prefix: t, type: r, network: n, data: i, script: s };
}
function lq(e, t) {
  const { type: r, data: n } = oi.util.readScriptPubKey(e);
  return qk(r).encode(n, t);
}
function fq(e) {
  const { script: t } = Vk(e);
  return Rn.fmt.toAsm(t, false);
}
var Gk = {
  p2pkh: Ok,
  p2sh: Nk,
  p2wpkh: Rk,
  p2wsh: Lk,
  p2tr: Dk,
  decode: Vk,
  fromScriptPubKey: lq,
  toScriptPubKey: fq
};
var dq = [1, 2, 3];
function r3(e, t, r = {}) {
  const { sigflag: n = 1 } = r, o = (n & 128) === 128, i = n % 128;
  if (!dq.includes(i))
    throw new Error("Invalid hash type: " + String(n));
  const s = oi.fmt.toJson(e), { version: a, vin: c, vout: u, locktime: l } = s, { txid: f, vout: d, prevout: m, sequence: y } = c[t], { value: b } = m ?? {};
  if (b === void 0)
    throw new Error("Prevout value is empty!");
  let w = r.script;
  if (w === void 0 && r.pubkey !== void 0 && (w = `76a914${Wv(r.pubkey).hex}88ac`), w === void 0)
    throw new Error("No pubkey / script has been set!");
  if (Rn.fmt.toAsm(w).includes("OP_CODESEPARATOR"))
    throw new Error("This library does not currently support the use of OP_CODESEPARATOR in segwit scripts.");
  const v = [
    Jv(a),
    hq(c, o),
    pq(c, i, o),
    Nh(f),
    Uh(d),
    Rn.encode(w, true),
    vc(b),
    $h(y),
    gq(u, t, i),
    Qv(l),
    W.num(n, 4).reverse()
  ];
  return Xl(W.join(v));
}
function hq(e, t) {
  if (t === true)
    return W.num(0, 32);
  const r = [];
  for (const { txid: n, vout: o } of e)
    r.push(Nh(n)), r.push(Uh(o));
  return Xl(W.join(r));
}
function pq(e, t, r) {
  if (r || t !== 1)
    return W.num(0, 32);
  const n = [];
  for (const { sequence: o } of e)
    n.push($h(o));
  return Xl(W.join(n));
}
function gq(e, t, r) {
  const n = [];
  if (r === 1) {
    for (const { value: o, scriptPubKey: i } of e)
      n.push(vc(o)), n.push(Rn.encode(i, true));
    return Xl(W.join(n));
  }
  if (r === 3 && t < e.length) {
    const { value: o, scriptPubKey: i } = e[t];
    return n.push(vc(o)), n.push(Rn.encode(i, true)), Xl(W.join(n));
  }
  return W.num(0, 32);
}
function mq(e, t, r, n = {}) {
  const { sigflag: o = 1 } = n, i = r3(t, r, n), s = Sk.secp.sign(i, e).toDERRawBytes(true);
  return W.join([s, o]);
}
function bq(e, t, r = {}) {
  const n = oi.fmt.toJson(e), { throws: o = false } = r, { witness: i = [] } = n.vin[t], s = oi.util.readWitness(i), { script: a, params: c } = s;
  let u = null;
  if (c.length < 1)
    return bn("Invalid witness data: " + String(i), o);
  if (r.script === void 0 && a !== null && (r.script = a), r.pubkey !== void 0)
    u = W.bytes(r.pubkey);
  else if (c.length > 1 && c[1].length === 33)
    u = W.bytes(c[1]);
  else
    return bn("No pubkey provided!", o);
  const l = Rn.fmt.toParam(c[0]), f = l.slice(0, -1), d = l.slice(-1)[0], m = r3(n, t, { ...r, sigflag: d });
  return Sk.secp.verify(f, m, u) ? true : bn("Invalid signature!", o);
}
var yq = {
  hash: r3,
  sign: mq,
  verify: bq
};
var wq = [0, 1, 2, 3, 129, 130, 131];
function n3(e, t, r = {}) {
  const { extension: n, sigflag: o = 0, extflag: i = 0, key_version: s = 0, separator_pos: a = 4294967295 } = r, c = oi.fmt.toJson(e), { version: u, vin: l, vout: f, locktime: d } = c;
  if (t >= l.length)
    throw new Error("Index out of bounds: " + String(t));
  if (!wq.includes(o))
    throw new Error("Invalid hash type: " + String(o));
  if (i < 0 || i > 127)
    throw new Error("Extention flag out of range: " + String(i));
  const { txid: m, vout: y, sequence: b, witness: w = [] } = l[t], v = (o & 128) === 128, k = _q(w), x = k !== void 0 ? 1 : 0, I = (i + (n !== void 0 ? 1 : 0)) * 2 + x, P = W.str("TapSighash").digest, $ = [
    P,
    P,
    W.num(0, 1),
    W.num(o, 1),
    Jv(u),
    Qv(d)
  ];
  if (!v) {
    const L = l.map((V) => z4(V));
    $.push(vq(l), xq(L), kq(L), Eq(l));
  }
  if (((o & 3) < 2 || (o & 3) > 3) && $.push(Aq(f)), $.push(W.num(I, 1)), v) {
    const { value: L, scriptPubKey: V } = z4(l[t]);
    $.push(Nh(m), Uh(y), vc(L), Rn.encode(V, true), $h(b));
  } else
    $.push(W.num(t, 4).reverse());
  return k !== void 0 && $.push(k), (o & 3) === 3 && $.push(Sq(f[t])), n !== void 0 && $.push(W.bytes(n), W.num(s), W.num(a, 4)), W.join($).digest;
}
function vq(e) {
  const t = [];
  for (const { txid: r, vout: n } of e)
    t.push(Nh(r)), t.push(Uh(n));
  return W.join(t).digest;
}
function Eq(e) {
  const t = [];
  for (const { sequence: r } of e)
    t.push($h(r));
  return W.join(t).digest;
}
function xq(e) {
  const t = [];
  for (const { value: r } of e)
    t.push(vc(r));
  return W.join(t).digest;
}
function kq(e) {
  const t = [];
  for (const { scriptPubKey: r } of e)
    t.push(Vu(r, true));
  return W.join(t).digest;
}
function Aq(e) {
  const t = [];
  for (const { value: r, scriptPubKey: n } of e)
    t.push(vc(r)), t.push(Rn.encode(n, true));
  return W.join(t).digest;
}
function Sq(e) {
  return W.join([
    vc(e.value),
    Rn.encode(e.scriptPubKey, true)
  ]).digest;
}
function _q(e) {
  if (e === void 0 || e.length < 2)
    return;
  let t = e.at(-1);
  if (typeof t == "string" && (t = W.hex(t)), t instanceof Uint8Array && t[0] === 80)
    return W.raw(t).prefixSize("be").digest;
}
function z4(e) {
  if (e.prevout === void 0)
    throw new Error("Prevout data missing for input: " + String(e.txid));
  return e.prevout;
}
var Tq = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
var Pq = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function Iq(e, t, r, n = {}) {
  const { sigflag: o = 0 } = n, i = n3(t, r, n), s = Oq(e, i);
  return o === 0 ? W.raw(s) : W.join([s, o]);
}
function Oq(e, t, r = W.random(32)) {
  const n = W.bytes(t), o = new dn(e), i = o.point, s = i.hasEvenY ? o.big : o.negated.big, a = c0("BIP0340/aux", W.bytes(r)), c = s ^ a.big, u = c0("BIP0340/nonce", c, i.x.raw, n), l = new dn(u), f = l.point, d = f.hasEvenY ? l.big : l.negated.big, m = new dn(c0("BIP0340/challenge", f.x.raw, i.x.raw, n)), y = new dn(d + m.big * s);
  return W.join([f.x.raw, y.raw]);
}
function Bq(e, t, r, n = false) {
  const o = qs.from_x(Pu(r)), i = W.bytes(t), s = W.bytes(e).stream;
  s.size < 64 && bn("Signature length is too small: " + String(s.size), n);
  const a = s.read(32);
  a.big > Tq && bn("Signature r value greater than field size!", n);
  const c = s.read(32);
  c.big > Pq && bn("Signature s value greater than curve order!", n);
  const u = new dn(c0("BIP0340/challenge", a.raw, o.x.raw, i)), l = new dn(c).point, f = o.mul(u.big), d = l.sub(f);
  return d.hasOddY && bn("Signature R value has odd Y coordinate!", n), d.x.big === 0n && bn("Signature R value is infinite!", n), d.x.big === a.big;
}
var Cq = 192;
function k1(e) {
  const t = W.str(e).digest;
  return W.join([t, t]);
}
function o3(e, t = Cq) {
  return W.join([
    k1("TapLeaf"),
    $q(t),
    W.bytes(e)
  ]).digest.hex;
}
function Nq(e, t) {
  return o3(Rn.fmt.toBytes(e), t);
}
function i3(e, t) {
  return t < e && ([e, t] = [t, e]), W.join([
    k1("TapBranch"),
    W.hex(e).raw,
    W.hex(t).raw
  ]).digest.hex;
}
function Uq(e) {
  return W.hex(G0(e)[0]);
}
function G0(e, t, r = []) {
  const n = [], o = [];
  if (e.length < 1)
    throw new Error("Tree is empty!");
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (Array.isArray(s)) {
      const [a, c, u] = G0(s, t);
      t = c, n.push(a);
      for (const l of u)
        r.push(l);
    } else
      n.push(s);
  }
  if (n.length === 1)
    return [n[0], t, r];
  n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
  for (let i = 0; i < n.length - 1; i += 2) {
    const s = i3(n[i], n[i + 1]);
    o.push(s), typeof t == "string" && (t === n[i] ? (r.push(n[i + 1]), t = s) : t === n[i + 1] && (r.push(n[i]), t = s));
  }
  return G0(o, t, r);
}
function $q(e = 192) {
  return e & 254;
}
function Wk(e, t = new Uint8Array(), r = false) {
  const n = r ? new dn(e).point.x.raw : Pu(e);
  return W.join([k1("TapTweak"), n, W.bytes(t)]).digest;
}
function Ul(e, t, r = false) {
  t === void 0 && (t = new Uint8Array());
  const n = W.bytes(e), o = Wk(e, t, r);
  return r ? Zk(n, o) : Xk(n, o);
}
function Rq(e, t) {
  return Ul(e, t);
}
function zq(e, t) {
  return Ul(e, t, true);
}
function Zk(e, t) {
  let r = new dn(e);
  return r.point.hasOddY && (r = r.negate()), W.raw(r.add(t).raw);
}
function Xk(e, t) {
  e = Pu(e);
  const n = qs.from_x(e).add(t);
  return W.raw(n.raw);
}
function Hq() {
  const e = W.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
  return qs.from_x(e.digest).x;
}
var Lq = Hq();
var jq = 192;
function Fq(e, t = {}) {
  return Yk(e, { ...t, isPrivate: true });
}
function Dq(e, t = {}) {
  return Yk(e, { ...t, isPrivate: false });
}
function Yk(e, t = {}) {
  const { isPrivate: r = false, tree: n = [], version: o = jq } = t, i = r ? Iw.getPublicKey(e, true) : Pu(e);
  let { target: s } = t;
  s !== void 0 && (s = W.bytes(s).hex);
  let a, c = [];
  if (n.length > 0) {
    const [m, y, b] = G0(n, s);
    c = b, a = Ul(e, m, r);
  } else
    s !== void 0 ? a = Ul(e, s, r) : a = Ul(e, void 0, r);
  const u = r ? Iw.getPublicKey(a)[0] : a[0], f = [W.num(o + Qk(u)), i];
  c.length > 0 && c.forEach((m) => f.push(W.hex(m)));
  const d = W.join(f);
  if (s !== void 0 && !s3(a, s, d, t))
    throw new Error("Path checking failed! Unable to generate path.");
  return [Pu(a).hex, d.hex];
}
function s3(e, t, r, n = {}) {
  const { isPrivate: o = false, throws: i = false } = n, { parity: s, paths: a, intkey: c } = Jk(r), u = o ? Iw.getPublicKey(e, true) : Pu(e), l = W.join([s, u]);
  if (l.length !== 33)
    return bn("Invalid tapkey: " + l.hex, i);
  let f = W.bytes(t).hex;
  for (const m of a)
    f = i3(f, m);
  const d = Ul(c, f);
  return W.raw(d).hex === W.raw(l).hex;
}
function Jk(e) {
  const t = new Sf(W.bytes(e)), r = t.read(1).num, n = t.read(32), [o, i] = r % 2 === 0 ? [r, 2] : [r - 1, 3], s = [];
  for (; t.size >= 32; )
    s.push(t.read(32).hex);
  if (t.size !== 0)
    throw new Error("Non-empty buffer on control block: " + String(t));
  return { intkey: n, paths: s, parity: i, version: o };
}
function Qk(e = 2) {
  if (e === 0 || e === 1)
    return e;
  if (e === 2 || e === "02")
    return 0;
  if (e === 3 || e === "03")
    return 1;
  throw new Error("Invalid parity bit: " + String(e));
}
function Kq(e, t, r = {}) {
  const n = oi.fmt.toJson(e), { throws: o = false } = r, { prevout: i, witness: s = [] } = n.vin[t], a = oi.util.readWitness(s), { cblock: c, script: u, params: l } = a;
  let f;
  if (l.length < 1)
    return bn("Invalid witness data: " + String(s), o);
  const { scriptPubKey: d } = i ?? {};
  if (d === void 0)
    return bn("Prevout scriptPubKey is empty!", o);
  const { type: m, data: y } = oi.util.readScriptPubKey(d);
  if (m !== "p2tr")
    return bn("Prevout script is not a valid taproot output:" + y.hex, o);
  if (y.length !== 32)
    return bn("Invalid tapkey length: " + String(y.length), o);
  if (c !== null && u !== null) {
    const x = c[0] & 254, _ = o3(u, x);
    if (r.extension = _, !s3(y, _, c, { throws: o }))
      return bn("cblock verification failed!", o);
  }
  r.pubkey !== void 0 ? f = W.bytes(r.pubkey) : l.length > 1 && l[1].length === 32 ? f = W.bytes(l[1]) : f = W.bytes(y);
  const b = Rn.fmt.toParam(l[0]), w = new Sf(b), v = w.read(64).raw;
  if (w.size === 1 && (r.sigflag = w.read(1).num, r.sigflag === 0))
    return bn("0x00 is not a valid appended sigflag!", o);
  const k = n3(n, t, r);
  return Bq(v, k, f, o) ? true : bn("Invalid signature!", o);
}
var Mq = {
  hash: n3,
  sign: Iq,
  verify: Kq
};
var qq = {
  segwit: yq,
  taproot: Mq
};
var Vq = {
  getTag: k1,
  getLeaf: o3,
  getBranch: i3,
  getRoot: Uq
};
var Gq = {
  readCtrlBlock: Jk,
  readParityBit: Qk
};
var Wq = {
  getPubKey: Rq,
  getSecKey: zq,
  getTweak: Wk,
  tweakSecKey: Zk,
  tweakPubKey: Xk
};
var W0 = {
  getPubKey: Dq,
  getSecKey: Fq,
  encodeScript: Nq,
  checkPath: s3,
  tree: Vq,
  tweak: Wq,
  util: Gq,
  SCRIPT_PUBKEY: Lq
};
var Bt;
(function(e) {
  e.assertEqual = (o) => o;
  function t(o) {
  }
  e.assertIs = t;
  function r(o) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (o) => {
    const i = {};
    for (const s of o)
      i[s] = s;
    return i;
  }, e.getValidEnumValues = (o) => {
    const i = e.objectKeys(o).filter((a) => typeof o[o[a]] != "number"), s = {};
    for (const a of i)
      s[a] = o[a];
    return e.objectValues(s);
  }, e.objectValues = (o) => e.objectKeys(o).map(function(i) {
    return o[i];
  }), e.objectKeys = typeof Object.keys == "function" ? (o) => Object.keys(o) : (o) => {
    const i = [];
    for (const s in o)
      Object.prototype.hasOwnProperty.call(o, s) && i.push(s);
    return i;
  }, e.find = (o, i) => {
    for (const s of o)
      if (i(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (o) => Number.isInteger(o) : (o) => typeof o == "number" && isFinite(o) && Math.floor(o) === o;
  function n(o, i = " | ") {
    return o.map((s) => typeof s == "string" ? `'${s}'` : s).join(i);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (o, i) => typeof i == "bigint" ? i.toString() : i;
})(Bt || (Bt = {}));
var Ow;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(Ow || (Ow = {}));
var pe = Bt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var ac = (e) => {
  switch (typeof e) {
    case "undefined":
      return pe.undefined;
    case "string":
      return pe.string;
    case "number":
      return isNaN(e) ? pe.nan : pe.number;
    case "boolean":
      return pe.boolean;
    case "function":
      return pe.function;
    case "bigint":
      return pe.bigint;
    case "symbol":
      return pe.symbol;
    case "object":
      return Array.isArray(e) ? pe.array : e === null ? pe.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? pe.promise : typeof Map < "u" && e instanceof Map ? pe.map : typeof Set < "u" && e instanceof Set ? pe.set : typeof Date < "u" && e instanceof Date ? pe.date : pe.object;
    default:
      return pe.unknown;
  }
};
var ae = Bt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var Zq = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
var ii = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(i) {
      return i.message;
    }, n = { _errors: [] }, o = (i) => {
      for (const s of i.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(o);
        else if (s.code === "invalid_return_type")
          o(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          o(s.argumentsError);
        else if (s.path.length === 0)
          n._errors.push(r(s));
        else {
          let a = n, c = 0;
          for (; c < s.path.length; ) {
            const u = s.path[c];
            c === s.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(r(s))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return o(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Bt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const o of this.issues)
      o.path.length > 0 ? (r[o.path[0]] = r[o.path[0]] || [], r[o.path[0]].push(t(o))) : n.push(t(o));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
ii.create = (e) => new ii(e);
var Hd = (e, t) => {
  let r;
  switch (e.code) {
    case ae.invalid_type:
      e.received === pe.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ae.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Bt.jsonStringifyReplacer)}`;
      break;
    case ae.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Bt.joinValues(e.keys, ", ")}`;
      break;
    case ae.invalid_union:
      r = "Invalid input";
      break;
    case ae.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Bt.joinValues(e.options)}`;
      break;
    case ae.invalid_enum_value:
      r = `Invalid enum value. Expected ${Bt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ae.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case ae.invalid_return_type:
      r = "Invalid function return type";
      break;
    case ae.invalid_date:
      r = "Invalid date";
      break;
    case ae.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Bt.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case ae.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case ae.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case ae.custom:
      r = "Invalid input";
      break;
    case ae.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case ae.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ae.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, Bt.assertNever(e);
  }
  return { message: r };
};
var eA = Hd;
function Xq(e) {
  eA = e;
}
function Z0() {
  return eA;
}
var X0 = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: o } = e, i = [...r, ...o.path || []], s = {
    ...o,
    path: i
  };
  let a = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(s, { data: t, defaultError: a }).message;
  return {
    ...o,
    path: i,
    message: o.message || a
  };
};
var Yq = [];
function ye(e, t) {
  const r = X0({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Z0(),
      Hd
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(r);
}
var En = class _En {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const o of r) {
      if (o.status === "aborted")
        return Je;
      o.status === "dirty" && t.dirty(), n.push(o.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const o of r)
      n.push({
        key: await o.key,
        value: await o.value
      });
    return _En.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const o of r) {
      const { key: i, value: s } = o;
      if (i.status === "aborted" || s.status === "aborted")
        return Je;
      i.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), (typeof s.value < "u" || o.alwaysSet) && (n[i.value] = s.value);
    }
    return { status: t.value, value: n };
  }
};
var Je = Object.freeze({
  status: "aborted"
});
var tA = (e) => ({ status: "dirty", value: e });
var zn = (e) => ({ status: "valid", value: e });
var Bw = (e) => e.status === "aborted";
var Cw = (e) => e.status === "dirty";
var Y0 = (e) => e.status === "valid";
var J0 = (e) => typeof Promise < "u" && e instanceof Promise;
var Oe;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Oe || (Oe = {}));
var Ji = class {
  constructor(t, r, n, o) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = o;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var H4 = (e, t) => {
  if (Y0(t))
    return { success: true, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const r = new ii(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function at(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: o } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: o } : { errorMap: (s, a) => s.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: n ?? a.defaultError } : { message: r ?? a.defaultError }, description: o };
}
var Et = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ac(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: ac(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new En(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ac(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (J0(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const o = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : false,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ac(t)
    }, i = this._parseSync({ data: t, path: o.path, parent: o });
    return H4(o, i);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: true
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ac(t)
    }, o = this._parse({ data: t, path: n.path, parent: n }), i = await (J0(o) ? o : Promise.resolve(o));
    return H4(n, i);
  }
  refine(t, r) {
    const n = (o) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(o) : r;
    return this._refinement((o, i) => {
      const s = t(o), a = () => i.addIssue({
        code: ae.custom,
        ...n(o)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((c) => c ? true : (a(), false)) : s ? true : (a(), false);
    });
  }
  refinement(t, r) {
    return this._refinement((n, o) => t(n) ? true : (o.addIssue(typeof r == "function" ? r(n, o) : r), false));
  }
  _refinement(t) {
    return new pi({
      schema: this,
      typeName: Le.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Hs.create(this, this._def);
  }
  nullable() {
    return Bu.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return si.create(this, this._def);
  }
  promise() {
    return Ql.create(this, this._def);
  }
  or(t) {
    return Dd.create([this, t], this._def);
  }
  and(t) {
    return Kd.create(this, t, this._def);
  }
  transform(t) {
    return new pi({
      ...at(this._def),
      schema: this,
      typeName: Le.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new Wd({
      ...at(this._def),
      innerType: this,
      defaultValue: r,
      typeName: Le.ZodDefault
    });
  }
  brand() {
    return new nA({
      typeName: Le.ZodBranded,
      type: this,
      ...at(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new rg({
      ...at(this._def),
      innerType: this,
      catchValue: r,
      typeName: Le.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Rh.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var Jq = /^c[^\s-]{8,}$/i;
var Qq = /^[a-z][a-z0-9]*$/;
var eV = /[0-9A-HJKMNP-TV-Z]{26}/;
var tV = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var rV = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var nV = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
var oV = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var iV = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var sV = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function aV(e, t) {
  return !!((t === "v4" || !t) && oV.test(e) || (t === "v6" || !t) && iV.test(e));
}
var ti = class _ti extends Et {
  constructor() {
    super(...arguments), this._regex = (t, r, n) => this.refinement((o) => t.test(o), {
      validation: r,
      code: ae.invalid_string,
      ...Oe.errToObj(n)
    }), this.nonempty = (t) => this.min(1, Oe.errToObj(t)), this.trim = () => new _ti({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new _ti({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new _ti({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== pe.string) {
      const i = this._getOrReturnCtx(t);
      return ye(
        i,
        {
          code: ae.invalid_type,
          expected: pe.string,
          received: i.parsedType
        }
        //
      ), Je;
    }
    const n = new En();
    let o;
    for (const i of this._def.checks)
      if (i.kind === "min")
        t.data.length < i.value && (o = this._getOrReturnCtx(t, o), ye(o, {
          code: ae.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        t.data.length > i.value && (o = this._getOrReturnCtx(t, o), ye(o, {
          code: ae.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const s = t.data.length > i.value, a = t.data.length < i.value;
        (s || a) && (o = this._getOrReturnCtx(t, o), s ? ye(o, {
          code: ae.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }) : a && ye(o, {
          code: ae.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        rV.test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
          validation: "email",
          code: ae.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "emoji")
        nV.test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
          validation: "emoji",
          code: ae.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        tV.test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
          validation: "uuid",
          code: ae.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        Jq.test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
          validation: "cuid",
          code: ae.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        Qq.test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
          validation: "cuid2",
          code: ae.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "ulid")
        eV.test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
          validation: "ulid",
          code: ae.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(t.data);
        } catch {
          o = this._getOrReturnCtx(t, o), ye(o, {
            validation: "url",
            code: ae.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
        validation: "regex",
        code: ae.invalid_string,
        message: i.message
      }), n.dirty())) : i.kind === "trim" ? t.data = t.data.trim() : i.kind === "includes" ? t.data.includes(i.value, i.position) || (o = this._getOrReturnCtx(t, o), ye(o, {
        code: ae.invalid_string,
        validation: { includes: i.value, position: i.position },
        message: i.message
      }), n.dirty()) : i.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i.kind === "startsWith" ? t.data.startsWith(i.value) || (o = this._getOrReturnCtx(t, o), ye(o, {
        code: ae.invalid_string,
        validation: { startsWith: i.value },
        message: i.message
      }), n.dirty()) : i.kind === "endsWith" ? t.data.endsWith(i.value) || (o = this._getOrReturnCtx(t, o), ye(o, {
        code: ae.invalid_string,
        validation: { endsWith: i.value },
        message: i.message
      }), n.dirty()) : i.kind === "datetime" ? sV(i).test(t.data) || (o = this._getOrReturnCtx(t, o), ye(o, {
        code: ae.invalid_string,
        validation: "datetime",
        message: i.message
      }), n.dirty()) : i.kind === "ip" ? aV(t.data, i.version) || (o = this._getOrReturnCtx(t, o), ye(o, {
        validation: "ip",
        code: ae.invalid_string,
        message: i.message
      }), n.dirty()) : Bt.assertNever(i);
    return { status: n.value, value: t.data };
  }
  _addCheck(t) {
    return new _ti({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Oe.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Oe.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Oe.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Oe.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Oe.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Oe.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Oe.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Oe.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : false,
      ...Oe.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Oe.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...Oe.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Oe.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Oe.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Oe.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Oe.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Oe.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
};
ti.create = (e) => {
  var t;
  return new ti({
    checks: [],
    typeName: Le.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...at(e)
  });
};
function cV(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, o = r > n ? r : n, i = parseInt(e.toFixed(o).replace(".", "")), s = parseInt(t.toFixed(o).replace(".", ""));
  return i % s / Math.pow(10, o);
}
var Ec = class _Ec extends Et {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== pe.number) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: ae.invalid_type,
        expected: pe.number,
        received: i.parsedType
      }), Je;
    }
    let n;
    const o = new En();
    for (const i of this._def.checks)
      i.kind === "int" ? Bt.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), o.dirty()) : i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), o.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), o.dirty()) : i.kind === "multipleOf" ? cV(t.data, i.value) !== 0 && (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), o.dirty()) : i.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.not_finite,
        message: i.message
      }), o.dirty()) : Bt.assertNever(i);
    return { status: o.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, true, Oe.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, false, Oe.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, true, Oe.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, false, Oe.toString(r));
  }
  setLimit(t, r, n, o) {
    return new _Ec({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Oe.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new _Ec({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Oe.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: Oe.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: Oe.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: Oe.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: Oe.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Oe.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Oe.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: Oe.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: Oe.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Bt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
};
Ec.create = (e) => new Ec({
  checks: [],
  typeName: Le.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...at(e)
});
var xc = class _xc extends Et {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== pe.bigint) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: ae.invalid_type,
        expected: pe.bigint,
        received: i.parsedType
      }), Je;
    }
    let n;
    const o = new En();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), o.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), o.dirty()) : i.kind === "multipleOf" ? t.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), ye(n, {
        code: ae.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), o.dirty()) : Bt.assertNever(i);
    return { status: o.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, true, Oe.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, false, Oe.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, true, Oe.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, false, Oe.toString(r));
  }
  setLimit(t, r, n, o) {
    return new _xc({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Oe.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new _xc({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: Oe.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: Oe.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: Oe.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: Oe.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Oe.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
};
xc.create = (e) => {
  var t;
  return new xc({
    checks: [],
    typeName: Le.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...at(e)
  });
};
var Ld = class extends Et {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== pe.boolean) {
      const n = this._getOrReturnCtx(t);
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.boolean,
        received: n.parsedType
      }), Je;
    }
    return zn(t.data);
  }
};
Ld.create = (e) => new Ld({
  typeName: Le.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...at(e)
});
var Iu = class _Iu extends Et {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== pe.date) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: ae.invalid_type,
        expected: pe.date,
        received: i.parsedType
      }), Je;
    }
    if (isNaN(t.data.getTime())) {
      const i = this._getOrReturnCtx(t);
      return ye(i, {
        code: ae.invalid_date
      }), Je;
    }
    const n = new En();
    let o;
    for (const i of this._def.checks)
      i.kind === "min" ? t.data.getTime() < i.value && (o = this._getOrReturnCtx(t, o), ye(o, {
        code: ae.too_small,
        message: i.message,
        inclusive: true,
        exact: false,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? t.data.getTime() > i.value && (o = this._getOrReturnCtx(t, o), ye(o, {
        code: ae.too_big,
        message: i.message,
        inclusive: true,
        exact: false,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : Bt.assertNever(i);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new _Iu({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Oe.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Oe.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
};
Iu.create = (e) => new Iu({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || false,
  typeName: Le.ZodDate,
  ...at(e)
});
var Q0 = class extends Et {
  _parse(t) {
    if (this._getType(t) !== pe.symbol) {
      const n = this._getOrReturnCtx(t);
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.symbol,
        received: n.parsedType
      }), Je;
    }
    return zn(t.data);
  }
};
Q0.create = (e) => new Q0({
  typeName: Le.ZodSymbol,
  ...at(e)
});
var jd = class extends Et {
  _parse(t) {
    if (this._getType(t) !== pe.undefined) {
      const n = this._getOrReturnCtx(t);
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.undefined,
        received: n.parsedType
      }), Je;
    }
    return zn(t.data);
  }
};
jd.create = (e) => new jd({
  typeName: Le.ZodUndefined,
  ...at(e)
});
var Fd = class extends Et {
  _parse(t) {
    if (this._getType(t) !== pe.null) {
      const n = this._getOrReturnCtx(t);
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.null,
        received: n.parsedType
      }), Je;
    }
    return zn(t.data);
  }
};
Fd.create = (e) => new Fd({
  typeName: Le.ZodNull,
  ...at(e)
});
var Jl = class extends Et {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(t) {
    return zn(t.data);
  }
};
Jl.create = (e) => new Jl({
  typeName: Le.ZodAny,
  ...at(e)
});
var yu = class extends Et {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(t) {
    return zn(t.data);
  }
};
yu.create = (e) => new yu({
  typeName: Le.ZodUnknown,
  ...at(e)
});
var Vs = class extends Et {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return ye(r, {
      code: ae.invalid_type,
      expected: pe.never,
      received: r.parsedType
    }), Je;
  }
};
Vs.create = (e) => new Vs({
  typeName: Le.ZodNever,
  ...at(e)
});
var eg = class extends Et {
  _parse(t) {
    if (this._getType(t) !== pe.undefined) {
      const n = this._getOrReturnCtx(t);
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.void,
        received: n.parsedType
      }), Je;
    }
    return zn(t.data);
  }
};
eg.create = (e) => new eg({
  typeName: Le.ZodVoid,
  ...at(e)
});
var si = class _si extends Et {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), o = this._def;
    if (r.parsedType !== pe.array)
      return ye(r, {
        code: ae.invalid_type,
        expected: pe.array,
        received: r.parsedType
      }), Je;
    if (o.exactLength !== null) {
      const s = r.data.length > o.exactLength.value, a = r.data.length < o.exactLength.value;
      (s || a) && (ye(r, {
        code: s ? ae.too_big : ae.too_small,
        minimum: a ? o.exactLength.value : void 0,
        maximum: s ? o.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: o.exactLength.message
      }), n.dirty());
    }
    if (o.minLength !== null && r.data.length < o.minLength.value && (ye(r, {
      code: ae.too_small,
      minimum: o.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: o.minLength.message
    }), n.dirty()), o.maxLength !== null && r.data.length > o.maxLength.value && (ye(r, {
      code: ae.too_big,
      maximum: o.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: o.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((s, a) => o.type._parseAsync(new Ji(r, s, r.path, a)))).then((s) => En.mergeArray(n, s));
    const i = [...r.data].map((s, a) => o.type._parseSync(new Ji(r, s, r.path, a)));
    return En.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new _si({
      ...this._def,
      minLength: { value: t, message: Oe.toString(r) }
    });
  }
  max(t, r) {
    return new _si({
      ...this._def,
      maxLength: { value: t, message: Oe.toString(r) }
    });
  }
  length(t, r) {
    return new _si({
      ...this._def,
      exactLength: { value: t, message: Oe.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
si.create = (e, t) => new si({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Le.ZodArray,
  ...at(t)
});
function yl(e) {
  if (e instanceof tr) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = Hs.create(yl(n));
    }
    return new tr({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof si ? new si({
    ...e._def,
    type: yl(e.element)
  }) : e instanceof Hs ? Hs.create(yl(e.unwrap())) : e instanceof Bu ? Bu.create(yl(e.unwrap())) : e instanceof Qi ? Qi.create(e.items.map((t) => yl(t))) : e;
}
var tr = class _tr extends Et {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = Bt.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== pe.object) {
      const u = this._getOrReturnCtx(t);
      return ye(u, {
        code: ae.invalid_type,
        expected: pe.object,
        received: u.parsedType
      }), Je;
    }
    const { status: n, ctx: o } = this._processInputParams(t), { shape: i, keys: s } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof Vs && this._def.unknownKeys === "strip"))
      for (const u in o.data)
        s.includes(u) || a.push(u);
    const c = [];
    for (const u of s) {
      const l = i[u], f = o.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new Ji(o, f, o.path, u)),
        alwaysSet: u in o.data
      });
    }
    if (this._def.catchall instanceof Vs) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of a)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: o.data[l] }
          });
      else if (u === "strict")
        a.length > 0 && (ye(o, {
          code: ae.unrecognized_keys,
          keys: a
        }), n.dirty());
      else if (u !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of a) {
        const f = o.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new Ji(o, f, o.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in o.data
        });
      }
    }
    return o.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const f = await l.key;
        u.push({
          key: f,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => En.mergeObjectSync(n, u)) : En.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return new _tr({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var o, i, s, a;
          const c = (s = (i = (o = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(o, r, n).message) !== null && s !== void 0 ? s : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (a = Oe.errToObj(t).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _tr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _tr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new _tr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new _tr({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Le.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new _tr({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return Bt.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new _tr({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return Bt.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new _tr({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return yl(this);
  }
  partial(t) {
    const r = {};
    return Bt.objectKeys(this.shape).forEach((n) => {
      const o = this.shape[n];
      t && !t[n] ? r[n] = o : r[n] = o.optional();
    }), new _tr({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return Bt.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof Hs; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new _tr({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return rA(Bt.objectKeys(this.shape));
  }
};
tr.create = (e, t) => new tr({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Vs.create(),
  typeName: Le.ZodObject,
  ...at(t)
});
tr.strictCreate = (e, t) => new tr({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Vs.create(),
  typeName: Le.ZodObject,
  ...at(t)
});
tr.lazycreate = (e, t) => new tr({
  shape: e,
  unknownKeys: "strip",
  catchall: Vs.create(),
  typeName: Le.ZodObject,
  ...at(t)
});
var Dd = class extends Et {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function o(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return r.common.issues.push(...a.ctx.common.issues), a.result;
      const s = i.map((a) => new ii(a.ctx.common.issues));
      return ye(r, {
        code: ae.invalid_union,
        unionErrors: s
      }), Je;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const s = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: s
          }),
          ctx: s
        };
      })).then(o);
    {
      let i;
      const s = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && s.push(u.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const a = s.map((c) => new ii(c));
      return ye(r, {
        code: ae.invalid_union,
        unionErrors: a
      }), Je;
    }
  }
  get options() {
    return this._def.options;
  }
};
Dd.create = (e, t) => new Dd({
  options: e,
  typeName: Le.ZodUnion,
  ...at(t)
});
var u0 = (e) => e instanceof qd ? u0(e.schema) : e instanceof pi ? u0(e.innerType()) : e instanceof Vd ? [e.value] : e instanceof kc ? e.options : e instanceof Gd ? Object.keys(e.enum) : e instanceof Wd ? u0(e._def.innerType) : e instanceof jd ? [void 0] : e instanceof Fd ? [null] : null;
var A1 = class _A1 extends Et {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== pe.object)
      return ye(r, {
        code: ae.invalid_type,
        expected: pe.object,
        received: r.parsedType
      }), Je;
    const n = this.discriminator, o = r.data[n], i = this.optionsMap.get(o);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (ye(r, {
      code: ae.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), Je);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const o = /* @__PURE__ */ new Map();
    for (const i of r) {
      const s = u0(i.shape[t]);
      if (!s)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const a of s) {
        if (o.has(a))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
        o.set(a, i);
      }
    }
    return new _A1({
      typeName: Le.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: o,
      ...at(n)
    });
  }
};
function Nw(e, t) {
  const r = ac(e), n = ac(t);
  if (e === t)
    return { valid: true, data: e };
  if (r === pe.object && n === pe.object) {
    const o = Bt.objectKeys(t), i = Bt.objectKeys(e).filter((a) => o.indexOf(a) !== -1), s = { ...e, ...t };
    for (const a of i) {
      const c = Nw(e[a], t[a]);
      if (!c.valid)
        return { valid: false };
      s[a] = c.data;
    }
    return { valid: true, data: s };
  } else if (r === pe.array && n === pe.array) {
    if (e.length !== t.length)
      return { valid: false };
    const o = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i], a = t[i], c = Nw(s, a);
      if (!c.valid)
        return { valid: false };
      o.push(c.data);
    }
    return { valid: true, data: o };
  } else return r === pe.date && n === pe.date && +e == +t ? { valid: true, data: e } : { valid: false };
}
var Kd = class extends Et {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = (i, s) => {
      if (Bw(i) || Bw(s))
        return Je;
      const a = Nw(i.value, s.value);
      return a.valid ? ((Cw(i) || Cw(s)) && r.dirty(), { status: r.value, value: a.data }) : (ye(n, {
        code: ae.invalid_intersection_types
      }), Je);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, s]) => o(i, s)) : o(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
Kd.create = (e, t, r) => new Kd({
  left: e,
  right: t,
  typeName: Le.ZodIntersection,
  ...at(r)
});
var Qi = class _Qi extends Et {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== pe.array)
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.array,
        received: n.parsedType
      }), Je;
    if (n.data.length < this._def.items.length)
      return ye(n, {
        code: ae.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), Je;
    !this._def.rest && n.data.length > this._def.items.length && (ye(n, {
      code: ae.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((s, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new Ji(n, s, n.path, a)) : null;
    }).filter((s) => !!s);
    return n.common.async ? Promise.all(i).then((s) => En.mergeArray(r, s)) : En.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new _Qi({
      ...this._def,
      rest: t
    });
  }
};
Qi.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Qi({
    items: e,
    typeName: Le.ZodTuple,
    rest: null,
    ...at(t)
  });
};
var Md = class _Md extends Et {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== pe.object)
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.object,
        received: n.parsedType
      }), Je;
    const o = [], i = this._def.keyType, s = this._def.valueType;
    for (const a in n.data)
      o.push({
        key: i._parse(new Ji(n, a, n.path, a)),
        value: s._parse(new Ji(n, n.data[a], n.path, a))
      });
    return n.common.async ? En.mergeObjectAsync(r, o) : En.mergeObjectSync(r, o);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof Et ? new _Md({
      keyType: t,
      valueType: r,
      typeName: Le.ZodRecord,
      ...at(n)
    }) : new _Md({
      keyType: ti.create(),
      valueType: t,
      typeName: Le.ZodRecord,
      ...at(r)
    });
  }
};
var tg = class extends Et {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== pe.map)
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.map,
        received: n.parsedType
      }), Je;
    const o = this._def.keyType, i = this._def.valueType, s = [...n.data.entries()].map(([a, c], u) => ({
      key: o._parse(new Ji(n, a, n.path, [u, "key"])),
      value: i._parse(new Ji(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of s) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return Je;
          (u.status === "dirty" || l.status === "dirty") && r.dirty(), a.set(u.value, l.value);
        }
        return { status: r.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of s) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return Je;
        (u.status === "dirty" || l.status === "dirty") && r.dirty(), a.set(u.value, l.value);
      }
      return { status: r.value, value: a };
    }
  }
};
tg.create = (e, t, r) => new tg({
  valueType: t,
  keyType: e,
  typeName: Le.ZodMap,
  ...at(r)
});
var Ou = class _Ou extends Et {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== pe.set)
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.set,
        received: n.parsedType
      }), Je;
    const o = this._def;
    o.minSize !== null && n.data.size < o.minSize.value && (ye(n, {
      code: ae.too_small,
      minimum: o.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: o.minSize.message
    }), r.dirty()), o.maxSize !== null && n.data.size > o.maxSize.value && (ye(n, {
      code: ae.too_big,
      maximum: o.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: o.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function s(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return Je;
        l.status === "dirty" && r.dirty(), u.add(l.value);
      }
      return { status: r.value, value: u };
    }
    const a = [...n.data.values()].map((c, u) => i._parse(new Ji(n, c, n.path, u)));
    return n.common.async ? Promise.all(a).then((c) => s(c)) : s(a);
  }
  min(t, r) {
    return new _Ou({
      ...this._def,
      minSize: { value: t, message: Oe.toString(r) }
    });
  }
  max(t, r) {
    return new _Ou({
      ...this._def,
      maxSize: { value: t, message: Oe.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
Ou.create = (e, t) => new Ou({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Le.ZodSet,
  ...at(t)
});
var $l = class _$l extends Et {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== pe.function)
      return ye(r, {
        code: ae.invalid_type,
        expected: pe.function,
        received: r.parsedType
      }), Je;
    function n(a, c) {
      return X0({
        data: a,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Z0(),
          Hd
        ].filter((u) => !!u),
        issueData: {
          code: ae.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function o(a, c) {
      return X0({
        data: a,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Z0(),
          Hd
        ].filter((u) => !!u),
        issueData: {
          code: ae.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, s = r.data;
    return this._def.returns instanceof Ql ? zn(async (...a) => {
      const c = new ii([]), u = await this._def.args.parseAsync(a, i).catch((d) => {
        throw c.addIssue(n(a, d)), c;
      }), l = await s(...u);
      return await this._def.returns._def.type.parseAsync(l, i).catch((d) => {
        throw c.addIssue(o(l, d)), c;
      });
    }) : zn((...a) => {
      const c = this._def.args.safeParse(a, i);
      if (!c.success)
        throw new ii([n(a, c.error)]);
      const u = s(...c.data), l = this._def.returns.safeParse(u, i);
      if (!l.success)
        throw new ii([o(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new _$l({
      ...this._def,
      args: Qi.create(t).rest(yu.create())
    });
  }
  returns(t) {
    return new _$l({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new _$l({
      args: t || Qi.create([]).rest(yu.create()),
      returns: r || yu.create(),
      typeName: Le.ZodFunction,
      ...at(n)
    });
  }
};
var qd = class extends Et {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
qd.create = (e, t) => new qd({
  getter: e,
  typeName: Le.ZodLazy,
  ...at(t)
});
var Vd = class extends Et {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return ye(r, {
        received: r.data,
        code: ae.invalid_literal,
        expected: this._def.value
      }), Je;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
Vd.create = (e, t) => new Vd({
  value: e,
  typeName: Le.ZodLiteral,
  ...at(t)
});
function rA(e, t) {
  return new kc({
    values: e,
    typeName: Le.ZodEnum,
    ...at(t)
  });
}
var kc = class _kc extends Et {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return ye(r, {
        expected: Bt.joinValues(n),
        received: r.parsedType,
        code: ae.invalid_type
      }), Je;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return ye(r, {
        received: r.data,
        code: ae.invalid_enum_value,
        options: n
      }), Je;
    }
    return zn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return _kc.create(t);
  }
  exclude(t) {
    return _kc.create(this.options.filter((r) => !t.includes(r)));
  }
};
kc.create = rA;
var Gd = class extends Et {
  _parse(t) {
    const r = Bt.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== pe.string && n.parsedType !== pe.number) {
      const o = Bt.objectValues(r);
      return ye(n, {
        expected: Bt.joinValues(o),
        received: n.parsedType,
        code: ae.invalid_type
      }), Je;
    }
    if (r.indexOf(t.data) === -1) {
      const o = Bt.objectValues(r);
      return ye(n, {
        received: n.data,
        code: ae.invalid_enum_value,
        options: o
      }), Je;
    }
    return zn(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
Gd.create = (e, t) => new Gd({
  values: e,
  typeName: Le.ZodNativeEnum,
  ...at(t)
});
var Ql = class extends Et {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== pe.promise && r.common.async === false)
      return ye(r, {
        code: ae.invalid_type,
        expected: pe.promise,
        received: r.parsedType
      }), Je;
    const n = r.parsedType === pe.promise ? r.data : Promise.resolve(r.data);
    return zn(n.then((o) => this._def.type.parseAsync(o, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
Ql.create = (e, t) => new Ql({
  type: e,
  typeName: Le.ZodPromise,
  ...at(t)
});
var pi = class extends Et {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Le.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = this._def.effect || null;
    if (o.type === "preprocess") {
      const s = o.transform(n.data);
      return n.common.async ? Promise.resolve(s).then((a) => this._def.schema._parseAsync({
        data: a,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: s,
        path: n.path,
        parent: n
      });
    }
    const i = {
      addIssue: (s) => {
        ye(n, s), s.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), o.type === "refinement") {
      const s = (a) => {
        const c = o.refinement(a, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (n.common.async === false) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? Je : (a.status === "dirty" && r.dirty(), s(a.value), { status: r.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => a.status === "aborted" ? Je : (a.status === "dirty" && r.dirty(), s(a.value).then(() => ({ status: r.value, value: a.value }))));
    }
    if (o.type === "transform")
      if (n.common.async === false) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Y0(s))
          return s;
        const a = o.transform(s.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => Y0(s) ? Promise.resolve(o.transform(s.value, i)).then((a) => ({ status: r.value, value: a })) : s);
    Bt.assertNever(o);
  }
};
pi.create = (e, t, r) => new pi({
  schema: e,
  typeName: Le.ZodEffects,
  effect: t,
  ...at(r)
});
pi.createWithPreprocess = (e, t, r) => new pi({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Le.ZodEffects,
  ...at(r)
});
var Hs = class extends Et {
  _parse(t) {
    return this._getType(t) === pe.undefined ? zn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Hs.create = (e, t) => new Hs({
  innerType: e,
  typeName: Le.ZodOptional,
  ...at(t)
});
var Bu = class extends Et {
  _parse(t) {
    return this._getType(t) === pe.null ? zn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Bu.create = (e, t) => new Bu({
  innerType: e,
  typeName: Le.ZodNullable,
  ...at(t)
});
var Wd = class extends Et {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === pe.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Wd.create = (e, t) => new Wd({
  innerType: e,
  typeName: Le.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...at(t)
});
var rg = class extends Et {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, o = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return J0(o) ? o.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new ii(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new ii(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
rg.create = (e, t) => new rg({
  innerType: e,
  typeName: Le.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...at(t)
});
var ng = class extends Et {
  _parse(t) {
    if (this._getType(t) !== pe.nan) {
      const n = this._getOrReturnCtx(t);
      return ye(n, {
        code: ae.invalid_type,
        expected: pe.nan,
        received: n.parsedType
      }), Je;
    }
    return { status: "valid", value: t.data };
  }
};
ng.create = (e) => new ng({
  typeName: Le.ZodNaN,
  ...at(e)
});
var uV = Symbol("zod_brand");
var nA = class extends Et {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Rh = class _Rh extends Et {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? Je : i.status === "dirty" ? (r.dirty(), tA(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const o = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return o.status === "aborted" ? Je : o.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: o.value
      }) : this._def.out._parseSync({
        data: o.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new _Rh({
      in: t,
      out: r,
      typeName: Le.ZodPipeline
    });
  }
};
var oA = (e, t = {}, r) => e ? Jl.create().superRefine((n, o) => {
  var i, s;
  if (!e(n)) {
    const a = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, c = (s = (i = a.fatal) !== null && i !== void 0 ? i : r) !== null && s !== void 0 ? s : true, u = typeof a == "string" ? { message: a } : a;
    o.addIssue({ code: "custom", ...u, fatal: c });
  }
}) : Jl.create();
var lV = {
  object: tr.lazycreate
};
var Le;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(Le || (Le = {}));
var fV = (e, t = {
  message: `Input not instance of ${e.name}`
}) => oA((r) => r instanceof e, t);
var iA = ti.create;
var sA = Ec.create;
var dV = ng.create;
var hV = xc.create;
var aA = Ld.create;
var pV = Iu.create;
var gV = Q0.create;
var mV = jd.create;
var bV = Fd.create;
var yV = Jl.create;
var wV = yu.create;
var vV = Vs.create;
var EV = eg.create;
var xV = si.create;
var kV = tr.create;
var AV = tr.strictCreate;
var SV = Dd.create;
var _V = A1.create;
var TV = Kd.create;
var PV = Qi.create;
var IV = Md.create;
var OV = tg.create;
var BV = Ou.create;
var CV = $l.create;
var NV = qd.create;
var UV = Vd.create;
var $V = kc.create;
var RV = Gd.create;
var zV = Ql.create;
var L4 = pi.create;
var HV = Hs.create;
var LV = Bu.create;
var jV = pi.createWithPreprocess;
var FV = Rh.create;
var DV = () => iA().optional();
var KV = () => sA().optional();
var MV = () => aA().optional();
var qV = {
  string: (e) => ti.create({ ...e, coerce: true }),
  number: (e) => Ec.create({ ...e, coerce: true }),
  boolean: (e) => Ld.create({
    ...e,
    coerce: true
  }),
  bigint: (e) => xc.create({ ...e, coerce: true }),
  date: (e) => Iu.create({ ...e, coerce: true })
};
var VV = Je;
var Nn = Object.freeze({
  __proto__: null,
  defaultErrorMap: Hd,
  setErrorMap: Xq,
  getErrorMap: Z0,
  makeIssue: X0,
  EMPTY_PATH: Yq,
  addIssueToContext: ye,
  ParseStatus: En,
  INVALID: Je,
  DIRTY: tA,
  OK: zn,
  isAborted: Bw,
  isDirty: Cw,
  isValid: Y0,
  isAsync: J0,
  get util() {
    return Bt;
  },
  get objectUtil() {
    return Ow;
  },
  ZodParsedType: pe,
  getParsedType: ac,
  ZodType: Et,
  ZodString: ti,
  ZodNumber: Ec,
  ZodBigInt: xc,
  ZodBoolean: Ld,
  ZodDate: Iu,
  ZodSymbol: Q0,
  ZodUndefined: jd,
  ZodNull: Fd,
  ZodAny: Jl,
  ZodUnknown: yu,
  ZodNever: Vs,
  ZodVoid: eg,
  ZodArray: si,
  ZodObject: tr,
  ZodUnion: Dd,
  ZodDiscriminatedUnion: A1,
  ZodIntersection: Kd,
  ZodTuple: Qi,
  ZodRecord: Md,
  ZodMap: tg,
  ZodSet: Ou,
  ZodFunction: $l,
  ZodLazy: qd,
  ZodLiteral: Vd,
  ZodEnum: kc,
  ZodNativeEnum: Gd,
  ZodPromise: Ql,
  ZodEffects: pi,
  ZodTransformer: pi,
  ZodOptional: Hs,
  ZodNullable: Bu,
  ZodDefault: Wd,
  ZodCatch: rg,
  ZodNaN: ng,
  BRAND: uV,
  ZodBranded: nA,
  ZodPipeline: Rh,
  custom: oA,
  Schema: Et,
  ZodSchema: Et,
  late: lV,
  get ZodFirstPartyTypeKind() {
    return Le;
  },
  coerce: qV,
  any: yV,
  array: xV,
  bigint: hV,
  boolean: aA,
  date: pV,
  discriminatedUnion: _V,
  effect: L4,
  enum: $V,
  function: CV,
  instanceof: fV,
  intersection: TV,
  lazy: NV,
  literal: UV,
  map: OV,
  nan: dV,
  nativeEnum: RV,
  never: vV,
  null: bV,
  nullable: LV,
  number: sA,
  object: kV,
  oboolean: MV,
  onumber: KV,
  optional: HV,
  ostring: DV,
  pipeline: FV,
  preprocess: jV,
  promise: zV,
  record: IV,
  set: BV,
  strictObject: AV,
  string: iA,
  symbol: gV,
  transformer: L4,
  tuple: PV,
  undefined: mV,
  union: SV,
  unknown: wV,
  void: EV,
  NEVER: VV,
  ZodIssueCode: ae,
  quotelessJson: Zq,
  ZodError: ii
});
var cA = Nn.string().regex(/^[a-fA-F0-9]$/);
var GV = Nn.string().regex(/^[a-fA-F0-9]{64}$/);
var ef = Nn.number().min(0).max(4294967295);
var WV = Nn.bigint();
var uA = Nn.instanceof(Uint8Array);
var ZV = Nn.union([cA, ef, Nn.string(), uA]).array();
var a3 = Nn.union([ZV, cA, uA]);
var XV = Nn.array(a3);
var lA = Nn.object({
  value: Nn.union([ef, WV]),
  scriptPubKey: a3
});
var YV = Nn.object({
  txid: GV,
  vout: ef,
  scriptSig: a3,
  sequence: ef,
  prevout: lA.optional(),
  witness: XV
});
Nn.object({
  version: ef,
  vin: Nn.array(YV),
  vout: Nn.array(lA),
  locktime: ef
});
var dr = {};
var c3 = {};
var JV = {};
var QV = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: JV
}, Symbol.toStringTag, { value: "Module" }));
var fA = XN(QV);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.Signature = e.Point = e.CURVE = void 0;
  const t = fA, r = BigInt(0), n = BigInt(1), o = BigInt(2), i = BigInt(3), s = BigInt(8), a = Object.freeze({
    a: r,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  e.CURVE = a;
  const c = (T, E) => (T + E / o) / E, u = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(T) {
      const { n: E } = a, S = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), B = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), z = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), D = S, X = BigInt("0x100000000000000000000000000000000"), Y = c(D * T, E), se = c(-B * T, E);
      let oe = K(T - Y * S - se * z, E), ue = K(-Y * B - se * D, E);
      const he = oe > X, be = ue > X;
      if (he && (oe = E - oe), be && (ue = E - ue), oe > X || ue > X)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + T);
      return { k1neg: he, k1: oe, k2neg: be, k2: ue };
    }
  }, l = 32, f = 32, d = 32, m = l + 1, y = 2 * l + 1;
  function b(T) {
    const { a: E, b: S } = a, B = K(T * T), z = K(B * T);
    return K(z + E * T + S);
  }
  const w = a.a === r;
  class v extends Error {
    constructor(E) {
      super(E);
    }
  }
  function k(T) {
    if (!(T instanceof x))
      throw new TypeError("JacobianPoint expected");
  }
  class x {
    constructor(E, S, B) {
      this.x = E, this.y = S, this.z = B;
    }
    static fromAffine(E) {
      if (!(E instanceof P))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return E.equals(P.ZERO) ? x.ZERO : new x(E.x, E.y, n);
    }
    static toAffineBatch(E) {
      const S = St(E.map((B) => B.z));
      return E.map((B, z) => B.toAffine(S[z]));
    }
    static normalizeZ(E) {
      return x.toAffineBatch(E).map(x.fromAffine);
    }
    equals(E) {
      k(E);
      const { x: S, y: B, z } = this, { x: D, y: X, z: Y } = E, se = K(z * z), oe = K(Y * Y), ue = K(S * oe), he = K(D * se), be = K(K(B * Y) * oe), yt = K(K(X * z) * se);
      return ue === he && be === yt;
    }
    negate() {
      return new x(this.x, K(-this.y), this.z);
    }
    double() {
      const { x: E, y: S, z: B } = this, z = K(E * E), D = K(S * S), X = K(D * D), Y = E + D, se = K(o * (K(Y * Y) - z - X)), oe = K(i * z), ue = K(oe * oe), he = K(ue - o * se), be = K(oe * (se - he) - s * X), yt = K(o * S * B);
      return new x(he, be, yt);
    }
    add(E) {
      k(E);
      const { x: S, y: B, z } = this, { x: D, y: X, z: Y } = E;
      if (D === r || X === r)
        return this;
      if (S === r || B === r)
        return E;
      const se = K(z * z), oe = K(Y * Y), ue = K(S * oe), he = K(D * se), be = K(K(B * Y) * oe), yt = K(K(X * z) * se), lt = K(he - ue), vr = K(yt - be);
      if (lt === r)
        return vr === r ? this.double() : x.ZERO;
      const ao = K(lt * lt), co = K(lt * ao), uo = K(ue * ao), hs = K(vr * vr - co - o * uo), Fc = K(vr * (uo - hs) - be * co), Mo = K(z * Y * lt);
      return new x(hs, Fc, Mo);
    }
    subtract(E) {
      return this.add(E.negate());
    }
    multiplyUnsafe(E) {
      const S = x.ZERO;
      if (typeof E == "bigint" && E === r)
        return S;
      let B = le(E);
      if (B === n)
        return this;
      if (!w) {
        let he = S, be = this;
        for (; B > r; )
          B & n && (he = he.add(be)), be = be.double(), B >>= n;
        return he;
      }
      let { k1neg: z, k1: D, k2neg: X, k2: Y } = u.splitScalar(B), se = S, oe = S, ue = this;
      for (; D > r || Y > r; )
        D & n && (se = se.add(ue)), Y & n && (oe = oe.add(ue)), ue = ue.double(), D >>= n, Y >>= n;
      return z && (se = se.negate()), X && (oe = oe.negate()), oe = new x(K(oe.x * u.beta), oe.y, oe.z), se.add(oe);
    }
    precomputeWindow(E) {
      const S = w ? 128 / E + 1 : 256 / E + 1, B = [];
      let z = this, D = z;
      for (let X = 0; X < S; X++) {
        D = z, B.push(D);
        for (let Y = 1; Y < 2 ** (E - 1); Y++)
          D = D.add(z), B.push(D);
        z = D.double();
      }
      return B;
    }
    wNAF(E, S) {
      !S && this.equals(x.BASE) && (S = P.BASE);
      const B = S && S._WINDOW_SIZE || 1;
      if (256 % B)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let z = S && I.get(S);
      z || (z = this.precomputeWindow(B), S && B !== 1 && (z = x.normalizeZ(z), I.set(S, z)));
      let D = x.ZERO, X = x.BASE;
      const Y = 1 + (w ? 128 / B : 256 / B), se = 2 ** (B - 1), oe = BigInt(2 ** B - 1), ue = 2 ** B, he = BigInt(B);
      for (let be = 0; be < Y; be++) {
        const yt = be * se;
        let lt = Number(E & oe);
        E >>= he, lt > se && (lt -= ue, E += n);
        const vr = yt, ao = yt + Math.abs(lt) - 1, co = be % 2 !== 0, uo = lt < 0;
        lt === 0 ? X = X.add(_(co, z[vr])) : D = D.add(_(uo, z[ao]));
      }
      return { p: D, f: X };
    }
    multiply(E, S) {
      let B = le(E), z, D;
      if (w) {
        const { k1neg: X, k1: Y, k2neg: se, k2: oe } = u.splitScalar(B);
        let { p: ue, f: he } = this.wNAF(Y, S), { p: be, f: yt } = this.wNAF(oe, S);
        ue = _(X, ue), be = _(se, be), be = new x(K(be.x * u.beta), be.y, be.z), z = ue.add(be), D = he.add(yt);
      } else {
        const { p: X, f: Y } = this.wNAF(B, S);
        z = X, D = Y;
      }
      return x.normalizeZ([z, D])[0];
    }
    toAffine(E) {
      const { x: S, y: B, z } = this, D = this.equals(x.ZERO);
      E == null && (E = D ? s : ze(z));
      const X = E, Y = K(X * X), se = K(Y * X), oe = K(S * Y), ue = K(B * se), he = K(z * X);
      if (D)
        return P.ZERO;
      if (he !== n)
        throw new Error("invZ was invalid");
      return new P(oe, ue);
    }
  }
  x.BASE = new x(a.Gx, a.Gy, n), x.ZERO = new x(r, n, r);
  function _(T, E) {
    const S = E.negate();
    return T ? S : E;
  }
  const I = /* @__PURE__ */ new WeakMap();
  class P {
    constructor(E, S) {
      this.x = E, this.y = S;
    }
    _setWindowSize(E) {
      this._WINDOW_SIZE = E, I.delete(this);
    }
    hasEvenY() {
      return this.y % o === r;
    }
    static fromCompressedHex(E) {
      const S = E.length === 32, B = ie(S ? E : E.subarray(1));
      if (!bt(B))
        throw new Error("Point is not on curve");
      const z = b(B);
      let D = At(z);
      const X = (D & n) === n;
      S ? X && (D = K(-D)) : (E[0] & 1) === 1 !== X && (D = K(-D));
      const Y = new P(B, D);
      return Y.assertValidity(), Y;
    }
    static fromUncompressedHex(E) {
      const S = ie(E.subarray(1, l + 1)), B = ie(E.subarray(l + 1, l * 2 + 1)), z = new P(S, B);
      return z.assertValidity(), z;
    }
    static fromHex(E) {
      const S = ne(E), B = S.length, z = S[0];
      if (B === l)
        return this.fromCompressedHex(S);
      if (B === m && (z === 2 || z === 3))
        return this.fromCompressedHex(S);
      if (B === y && z === 4)
        return this.fromUncompressedHex(S);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${m} compressed bytes or ${y} uncompressed bytes, not ${B}`);
    }
    static fromPrivateKey(E) {
      return P.BASE.multiply(Gt(E));
    }
    static fromSignature(E, S, B) {
      const { r: z, s: D } = us(S);
      if (![0, 1, 2, 3].includes(B))
        throw new Error("Cannot recover: invalid recovery bit");
      const X = Ge(ne(E)), { n: Y } = a, se = B === 2 || B === 3 ? z + Y : z, oe = ze(se, Y), ue = K(-X * oe, Y), he = K(D * oe, Y), be = B & 1 ? "03" : "02", yt = P.fromHex(be + C(se)), lt = P.BASE.multiplyAndAddUnsafe(yt, ue, he);
      if (!lt)
        throw new Error("Cannot recover signature: point at infinify");
      return lt.assertValidity(), lt;
    }
    toRawBytes(E = false) {
      return te(this.toHex(E));
    }
    toHex(E = false) {
      const S = C(this.x);
      return E ? `${this.hasEvenY() ? "02" : "03"}${S}` : `04${S}${C(this.y)}`;
    }
    toHexX() {
      return this.toHex(true).slice(2);
    }
    toRawX() {
      return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
      const E = "Point is not on elliptic curve", { x: S, y: B } = this;
      if (!bt(S) || !bt(B))
        throw new Error(E);
      const z = K(B * B), D = b(S);
      if (K(z - D) !== r)
        throw new Error(E);
    }
    equals(E) {
      return this.x === E.x && this.y === E.y;
    }
    negate() {
      return new P(this.x, K(-this.y));
    }
    double() {
      return x.fromAffine(this).double().toAffine();
    }
    add(E) {
      return x.fromAffine(this).add(x.fromAffine(E)).toAffine();
    }
    subtract(E) {
      return this.add(E.negate());
    }
    multiply(E) {
      return x.fromAffine(this).multiply(E, this).toAffine();
    }
    multiplyAndAddUnsafe(E, S, B) {
      const z = x.fromAffine(this), D = S === r || S === n || this !== P.BASE ? z.multiplyUnsafe(S) : z.multiply(S), X = x.fromAffine(E).multiplyUnsafe(B), Y = D.add(X);
      return Y.equals(x.ZERO) ? void 0 : Y.toAffine();
    }
  }
  e.Point = P, P.BASE = new P(a.Gx, a.Gy), P.ZERO = new P(r, r);
  function $(T) {
    return Number.parseInt(T[0], 16) >= 8 ? "00" + T : T;
  }
  function L(T) {
    if (T.length < 2 || T[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${q(T)}`);
    const E = T[1], S = T.subarray(2, E + 2);
    if (!E || S.length !== E)
      throw new Error("Invalid signature integer: wrong length");
    if (S[0] === 0 && S[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ie(S), left: T.subarray(E + 2) };
  }
  function V(T) {
    if (T.length < 2 || T[0] != 48)
      throw new Error(`Invalid signature tag: ${q(T)}`);
    if (T[1] !== T.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: E, left: S } = L(T.subarray(2)), { data: B, left: z } = L(S);
    if (z.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${q(z)}`);
    return { r: E, s: B };
  }
  class ee {
    constructor(E, S) {
      this.r = E, this.s = S, this.assertValidity();
    }
    static fromCompact(E) {
      const S = E instanceof Uint8Array, B = "Signature.fromCompact";
      if (typeof E != "string" && !S)
        throw new TypeError(`${B}: Expected string or Uint8Array`);
      const z = S ? q(E) : E;
      if (z.length !== 128)
        throw new Error(`${B}: Expected 64-byte hex`);
      return new ee(re(z.slice(0, 64)), re(z.slice(64, 128)));
    }
    static fromDER(E) {
      const S = E instanceof Uint8Array;
      if (typeof E != "string" && !S)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: B, s: z } = V(S ? E : te(E));
      return new ee(B, z);
    }
    static fromHex(E) {
      return this.fromDER(E);
    }
    assertValidity() {
      const { r: E, s: S } = this;
      if (!Ae(E))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Ae(S))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const E = a.n >> n;
      return this.s > E;
    }
    normalizeS() {
      return this.hasHighS() ? new ee(this.r, K(-this.s, a.n)) : this;
    }
    toDERRawBytes() {
      return te(this.toDERHex());
    }
    toDERHex() {
      const E = $(M(this.s)), S = $(M(this.r)), B = E.length / 2, z = S.length / 2, D = M(B), X = M(z);
      return `30${M(z + B + 4)}02${X}${S}02${D}${E}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return te(this.toCompactHex());
    }
    toCompactHex() {
      return C(this.r) + C(this.s);
    }
  }
  e.Signature = ee;
  function G(...T) {
    if (!T.every((B) => B instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (T.length === 1)
      return T[0];
    const E = T.reduce((B, z) => B + z.length, 0), S = new Uint8Array(E);
    for (let B = 0, z = 0; B < T.length; B++) {
      const D = T[B];
      S.set(D, z), z += D.length;
    }
    return S;
  }
  const N = Array.from({ length: 256 }, (T, E) => E.toString(16).padStart(2, "0"));
  function q(T) {
    if (!(T instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let E = "";
    for (let S = 0; S < T.length; S++)
      E += N[T[S]];
    return E;
  }
  const j = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function C(T) {
    if (typeof T != "bigint")
      throw new Error("Expected bigint");
    if (!(r <= T && T < j))
      throw new Error("Expected number 0 <= n < 2^256");
    return T.toString(16).padStart(64, "0");
  }
  function U(T) {
    const E = te(C(T));
    if (E.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return E;
  }
  function M(T) {
    const E = T.toString(16);
    return E.length & 1 ? `0${E}` : E;
  }
  function re(T) {
    if (typeof T != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof T);
    return BigInt(`0x${T}`);
  }
  function te(T) {
    if (typeof T != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof T);
    if (T.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + T.length);
    const E = new Uint8Array(T.length / 2);
    for (let S = 0; S < E.length; S++) {
      const B = S * 2, z = T.slice(B, B + 2), D = Number.parseInt(z, 16);
      if (Number.isNaN(D) || D < 0)
        throw new Error("Invalid byte sequence");
      E[S] = D;
    }
    return E;
  }
  function ie(T) {
    return re(q(T));
  }
  function ne(T) {
    return T instanceof Uint8Array ? Uint8Array.from(T) : te(T);
  }
  function le(T) {
    if (typeof T == "number" && Number.isSafeInteger(T) && T > 0)
      return BigInt(T);
    if (typeof T == "bigint" && Ae(T))
      return T;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function K(T, E = a.P) {
    const S = T % E;
    return S >= r ? S : E + S;
  }
  function ve(T, E) {
    const { P: S } = a;
    let B = T;
    for (; E-- > r; )
      B *= B, B %= S;
    return B;
  }
  function At(T) {
    const { P: E } = a, S = BigInt(6), B = BigInt(11), z = BigInt(22), D = BigInt(23), X = BigInt(44), Y = BigInt(88), se = T * T * T % E, oe = se * se * T % E, ue = ve(oe, i) * oe % E, he = ve(ue, i) * oe % E, be = ve(he, o) * se % E, yt = ve(be, B) * be % E, lt = ve(yt, z) * yt % E, vr = ve(lt, X) * lt % E, ao = ve(vr, Y) * vr % E, co = ve(ao, X) * lt % E, uo = ve(co, i) * oe % E, hs = ve(uo, D) * yt % E, Fc = ve(hs, S) * se % E, Mo = ve(Fc, o);
    if (Mo * Mo % E !== T)
      throw new Error("Cannot find square root");
    return Mo;
  }
  function ze(T, E = a.P) {
    if (T === r || E <= r)
      throw new Error(`invert: expected positive integers, got n=${T} mod=${E}`);
    let S = K(T, E), B = E, z = r, D = n;
    for (; S !== r; ) {
      const Y = B / S, se = B % S, oe = z - D * Y;
      B = S, S = se, z = D, D = oe;
    }
    if (B !== n)
      throw new Error("invert: does not exist");
    return K(z, E);
  }
  function St(T, E = a.P) {
    const S = new Array(T.length), B = T.reduce((D, X, Y) => X === r ? D : (S[Y] = D, K(D * X, E)), n), z = ze(B, E);
    return T.reduceRight((D, X, Y) => X === r ? D : (S[Y] = K(D * S[Y], E), K(D * X, E)), z), S;
  }
  function et(T) {
    const E = T.length * 8 - f * 8, S = ie(T);
    return E > 0 ? S >> BigInt(E) : S;
  }
  function Ge(T, E = false) {
    const S = et(T);
    if (E)
      return S;
    const { n: B } = a;
    return S >= B ? S - B : S;
  }
  let ut, ot;
  class He {
    constructor(E, S) {
      if (this.hashLen = E, this.qByteLen = S, typeof E != "number" || E < 2)
        throw new Error("hashLen must be a number");
      if (typeof S != "number" || S < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(E).fill(1), this.k = new Uint8Array(E).fill(0), this.counter = 0;
    }
    hmac(...E) {
      return e.utils.hmacSha256(this.k, ...E);
    }
    hmacSync(...E) {
      return ot(this.k, ...E);
    }
    checkSync() {
      if (typeof ot != "function")
        throw new v("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(E = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), E), this.v = await this.hmac(this.v), E.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), E), this.v = await this.hmac(this.v));
    }
    reseedSync(E = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), E), this.v = this.hmacSync(this.v), E.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), E), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let E = 0;
      const S = [];
      for (; E < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const B = this.v.slice();
        S.push(B), E += this.v.length;
      }
      return G(...S);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let E = 0;
      const S = [];
      for (; E < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const B = this.v.slice();
        S.push(B), E += this.v.length;
      }
      return G(...S);
    }
  }
  function Ae(T) {
    return r < T && T < a.n;
  }
  function bt(T) {
    return r < T && T < a.P;
  }
  function wr(T, E, S, B = true) {
    const { n: z } = a, D = Ge(T, true);
    if (!Ae(D))
      return;
    const X = ze(D, z), Y = P.BASE.multiply(D), se = K(Y.x, z);
    if (se === r)
      return;
    const oe = K(X * K(E + S * se, z), z);
    if (oe === r)
      return;
    let ue = new ee(se, oe), he = (Y.x === ue.r ? 0 : 2) | Number(Y.y & n);
    return B && ue.hasHighS() && (ue = ue.normalizeS(), he ^= 1), { sig: ue, recovery: he };
  }
  function Gt(T) {
    let E;
    if (typeof T == "bigint")
      E = T;
    else if (typeof T == "number" && Number.isSafeInteger(T) && T > 0)
      E = BigInt(T);
    else if (typeof T == "string") {
      if (T.length !== 2 * f)
        throw new Error("Expected 32 bytes of private key");
      E = re(T);
    } else if (T instanceof Uint8Array) {
      if (T.length !== f)
        throw new Error("Expected 32 bytes of private key");
      E = ie(T);
    } else
      throw new TypeError("Expected valid private key");
    if (!Ae(E))
      throw new Error("Expected private key: 0 < key < n");
    return E;
  }
  function An(T) {
    return T instanceof P ? (T.assertValidity(), T) : P.fromHex(T);
  }
  function us(T) {
    if (T instanceof ee)
      return T.assertValidity(), T;
    try {
      return ee.fromDER(T);
    } catch {
      return ee.fromCompact(T);
    }
  }
  function Lc(T, E = false) {
    return P.fromPrivateKey(T).toRawBytes(E);
  }
  e.getPublicKey = Lc;
  function ls(T, E, S, B = false) {
    return P.fromSignature(T, E, S).toRawBytes(B);
  }
  e.recoverPublicKey = ls;
  function Sn(T) {
    const E = T instanceof Uint8Array, S = typeof T == "string", B = (E || S) && T.length;
    return E ? B === m || B === y : S ? B === m * 2 || B === y * 2 : T instanceof P;
  }
  function Wt(T, E, S = false) {
    if (Sn(T))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Sn(E))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const B = An(E);
    return B.assertValidity(), B.multiply(Gt(T)).toRawBytes(S);
  }
  e.getSharedSecret = Wt;
  function so(T) {
    const E = T.length > l ? T.slice(0, l) : T;
    return ie(E);
  }
  function jc(T) {
    const E = so(T), S = K(E, a.n);
    return Qt(S < r ? E : S);
  }
  function Qt(T) {
    return U(T);
  }
  function fs(T, E, S) {
    if (T == null)
      throw new Error(`sign: expected valid message hash, not "${T}"`);
    const B = ne(T), z = Gt(E), D = [Qt(z), jc(B)];
    if (S != null) {
      S === true && (S = e.utils.randomBytes(l));
      const se = ne(S);
      if (se.length !== l)
        throw new Error(`sign: Expected ${l} bytes of extra data`);
      D.push(se);
    }
    const X = G(...D), Y = so(B);
    return { seed: X, m: Y, d: z };
  }
  function p(T, E) {
    const { sig: S, recovery: B } = T, { der: z, recovered: D } = Object.assign({ canonical: true, der: true }, E), X = z ? S.toDERRawBytes() : S.toCompactRawBytes();
    return D ? [X, B] : X;
  }
  async function h(T, E, S = {}) {
    const { seed: B, m: z, d: D } = fs(T, E, S.extraEntropy), X = new He(d, f);
    await X.reseed(B);
    let Y;
    for (; !(Y = wr(await X.generate(), z, D, S.canonical)); )
      await X.reseed();
    return p(Y, S);
  }
  e.sign = h;
  function g(T, E, S = {}) {
    const { seed: B, m: z, d: D } = fs(T, E, S.extraEntropy), X = new He(d, f);
    X.reseedSync(B);
    let Y;
    for (; !(Y = wr(X.generateSync(), z, D, S.canonical)); )
      X.reseedSync();
    return p(Y, S);
  }
  e.signSync = g;
  const A = { strict: true };
  function O(T, E, S, B = A) {
    let z;
    try {
      z = us(T), E = ne(E);
    } catch {
      return false;
    }
    const { r: D, s: X } = z;
    if (B.strict && z.hasHighS())
      return false;
    const Y = Ge(E);
    let se;
    try {
      se = An(S);
    } catch {
      return false;
    }
    const { n: oe } = a, ue = ze(X, oe), he = K(Y * ue, oe), be = K(D * ue, oe), yt = P.BASE.multiplyAndAddUnsafe(se, he, be);
    return yt ? K(yt.x, oe) === D : false;
  }
  e.verify = O;
  function R(T) {
    return K(ie(T), a.n);
  }
  class F {
    constructor(E, S) {
      this.r = E, this.s = S, this.assertValidity();
    }
    static fromHex(E) {
      const S = ne(E);
      if (S.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${S.length}`);
      const B = ie(S.subarray(0, 32)), z = ie(S.subarray(32, 64));
      return new F(B, z);
    }
    assertValidity() {
      const { r: E, s: S } = this;
      if (!bt(E) || !Ae(S))
        throw new Error("Invalid signature");
    }
    toHex() {
      return C(this.r) + C(this.s);
    }
    toRawBytes() {
      return te(this.toHex());
    }
  }
  function me(T) {
    return P.fromPrivateKey(T).toRawX();
  }
  class Me {
    constructor(E, S, B = e.utils.randomBytes()) {
      if (E == null)
        throw new TypeError(`sign: Expected valid message, not "${E}"`);
      this.m = ne(E);
      const { x: z, scalar: D } = this.getScalar(Gt(S));
      if (this.px = z, this.d = D, this.rand = ne(B), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(E) {
      const S = P.fromPrivateKey(E), B = S.hasEvenY() ? E : a.n - E;
      return { point: S, scalar: B, x: S.toRawX() };
    }
    initNonce(E, S) {
      return U(E ^ ie(S));
    }
    finalizeNonce(E) {
      const S = K(ie(E), a.n);
      if (S === r)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: B, x: z, scalar: D } = this.getScalar(S);
      return { R: B, rx: z, k: D };
    }
    finalizeSig(E, S, B, z) {
      return new F(E.x, K(S + B * z, a.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: E, d: S, px: B, rand: z } = this, D = e.utils.taggedHash, X = this.initNonce(S, await D(an.aux, z)), { R: Y, rx: se, k: oe } = this.finalizeNonce(await D(an.nonce, X, B, E)), ue = R(await D(an.challenge, se, B, E)), he = this.finalizeSig(Y, oe, ue, S);
      return await Wf(he, E, B) || this.error(), he;
    }
    calcSync() {
      const { m: E, d: S, px: B, rand: z } = this, D = e.utils.taggedHashSync, X = this.initNonce(S, D(an.aux, z)), { R: Y, rx: se, k: oe } = this.finalizeNonce(D(an.nonce, X, B, E)), ue = R(D(an.challenge, se, B, E)), he = this.finalizeSig(Y, oe, ue, S);
      return Zf(he, E, B) || this.error(), he;
    }
  }
  async function Pe(T, E, S) {
    return new Me(T, E, S).calc();
  }
  function Ie(T, E, S) {
    return new Me(T, E, S).calcSync();
  }
  function Se(T, E, S) {
    const B = T instanceof F, z = B ? T : F.fromHex(T);
    return B && z.assertValidity(), {
      ...z,
      m: ne(E),
      P: An(S)
    };
  }
  function Gf(T, E, S, B) {
    const z = P.BASE.multiplyAndAddUnsafe(E, Gt(S), K(-B, a.n));
    return !(!z || !z.hasEvenY() || z.x !== T);
  }
  async function Wf(T, E, S) {
    try {
      const { r: B, s: z, m: D, P: X } = Se(T, E, S), Y = R(await e.utils.taggedHash(an.challenge, U(B), X.toRawX(), D));
      return Gf(B, X, z, Y);
    } catch {
      return false;
    }
  }
  function Zf(T, E, S) {
    try {
      const { r: B, s: z, m: D, P: X } = Se(T, E, S), Y = R(e.utils.taggedHashSync(an.challenge, U(B), X.toRawX(), D));
      return Gf(B, X, z, Y);
    } catch (B) {
      if (B instanceof v)
        throw B;
      return false;
    }
  }
  e.schnorr = {
    Signature: F,
    getPublicKey: me,
    sign: Pe,
    verify: Wf,
    signSync: Ie,
    verifySync: Zf
  }, P.BASE._setWindowSize(8);
  const Dt = {
    node: t,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, an = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, ds = {};
  e.utils = {
    bytesToHex: q,
    hexToBytes: te,
    concatBytes: G,
    mod: K,
    invert: ze,
    isValidPrivateKey(T) {
      try {
        return Gt(T), true;
      } catch {
        return false;
      }
    },
    _bigintTo32Bytes: U,
    _normalizePrivateKey: Gt,
    hashToPrivateKey: (T) => {
      T = ne(T);
      const E = f + 8;
      if (T.length < E || T.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const S = K(ie(T), a.n - n) + n;
      return U(S);
    },
    randomBytes: (T = 32) => {
      if (Dt.web)
        return Dt.web.getRandomValues(new Uint8Array(T));
      if (Dt.node) {
        const { randomBytes: E } = Dt.node;
        return Uint8Array.from(E(T));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => e.utils.hashToPrivateKey(e.utils.randomBytes(f + 8)),
    precompute(T = 8, E = P.BASE) {
      const S = E === P.BASE ? E : new P(E.x, E.y);
      return S._setWindowSize(T), S.multiply(i), S;
    },
    sha256: async (...T) => {
      if (Dt.web) {
        const E = await Dt.web.subtle.digest("SHA-256", G(...T));
        return new Uint8Array(E);
      } else if (Dt.node) {
        const { createHash: E } = Dt.node, S = E("sha256");
        return T.forEach((B) => S.update(B)), Uint8Array.from(S.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (T, ...E) => {
      if (Dt.web) {
        const S = await Dt.web.subtle.importKey("raw", T, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), B = G(...E), z = await Dt.web.subtle.sign("HMAC", S, B);
        return new Uint8Array(z);
      } else if (Dt.node) {
        const { createHmac: S } = Dt.node, B = S("sha256", T);
        return E.forEach((z) => B.update(z)), Uint8Array.from(B.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (T, ...E) => {
      let S = ds[T];
      if (S === void 0) {
        const B = await e.utils.sha256(Uint8Array.from(T, (z) => z.charCodeAt(0)));
        S = G(B, B), ds[T] = S;
      }
      return e.utils.sha256(S, ...E);
    },
    taggedHashSync: (T, ...E) => {
      if (typeof ut != "function")
        throw new v("sha256Sync is undefined, you need to set it");
      let S = ds[T];
      if (S === void 0) {
        const B = ut(Uint8Array.from(T, (z) => z.charCodeAt(0)));
        S = G(B, B), ds[T] = S;
      }
      return ut(S, ...E);
    },
    _JacobianPoint: x
  }, Object.defineProperties(e.utils, {
    sha256Sync: {
      configurable: false,
      get() {
        return ut;
      },
      set(T) {
        ut || (ut = T);
      }
    },
    hmacSha256Sync: {
      configurable: false,
      get() {
        return ot;
      },
      set(T) {
        ot || (ot = T);
      }
    }
  });
})(c3);
var S1 = {};
var xo = {};
Object.defineProperty(xo, "__esModule", { value: true });
xo.isBytes = hA;
xo.number = og;
xo.bool = dA;
xo.bytes = u3;
xo.hash = pA;
xo.exists = gA;
xo.output = mA;
function og(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function dA(e) {
  if (typeof e != "boolean")
    throw new Error(`boolean expected, not ${e}`);
}
function hA(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function u3(e, ...t) {
  if (!hA(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function pA(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  og(e.outputLen), og(e.blockLen);
}
function gA(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function mA(e, t) {
  u3(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var eG = { number: og, bool: dA, bytes: u3, hash: pA, exists: gA, output: mA };
xo.default = eG;
var Nc = {};
var _1 = {};
Object.defineProperty(_1, "__esModule", { value: true });
_1.crypto = void 0;
_1.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.Hash = e.nextTick = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = void 0, e.isBytes = n, e.byteSwap32 = l, e.bytesToHex = d, e.hexToBytes = b, e.asyncLoop = v, e.utf8ToBytes = k, e.toBytes = x, e.concatBytes = _, e.checkOpts = $, e.wrapConstructor = L, e.wrapConstructorWithOpts = V, e.wrapXOFConstructorWithOpts = ee, e.randomBytes = G;
  const t = _1, r = xo;
  function n(N) {
    return N instanceof Uint8Array || N != null && typeof N == "object" && N.constructor.name === "Uint8Array";
  }
  const o = (N) => new Uint8Array(N.buffer, N.byteOffset, N.byteLength);
  e.u8 = o;
  const i = (N) => new Uint32Array(N.buffer, N.byteOffset, Math.floor(N.byteLength / 4));
  e.u32 = i;
  const s = (N) => new DataView(N.buffer, N.byteOffset, N.byteLength);
  e.createView = s;
  const a = (N, q) => N << 32 - q | N >>> q;
  e.rotr = a;
  const c = (N, q) => N << q | N >>> 32 - q >>> 0;
  e.rotl = c, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const u = (N) => N << 24 & 4278190080 | N << 8 & 16711680 | N >>> 8 & 65280 | N >>> 24 & 255;
  e.byteSwap = u, e.byteSwapIfBE = e.isLE ? (N) => N : (N) => (0, e.byteSwap)(N);
  function l(N) {
    for (let q = 0; q < N.length; q++)
      N[q] = (0, e.byteSwap)(N[q]);
  }
  const f = Array.from({ length: 256 }, (N, q) => q.toString(16).padStart(2, "0"));
  function d(N) {
    (0, r.bytes)(N);
    let q = "";
    for (let j = 0; j < N.length; j++)
      q += f[N[j]];
    return q;
  }
  const m = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function y(N) {
    if (N >= m._0 && N <= m._9)
      return N - m._0;
    if (N >= m._A && N <= m._F)
      return N - (m._A - 10);
    if (N >= m._a && N <= m._f)
      return N - (m._a - 10);
  }
  function b(N) {
    if (typeof N != "string")
      throw new Error("hex string expected, got " + typeof N);
    const q = N.length, j = q / 2;
    if (q % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + q);
    const C = new Uint8Array(j);
    for (let U = 0, M = 0; U < j; U++, M += 2) {
      const re = y(N.charCodeAt(M)), te = y(N.charCodeAt(M + 1));
      if (re === void 0 || te === void 0) {
        const ie = N[M] + N[M + 1];
        throw new Error('hex string expected, got non-hex character "' + ie + '" at index ' + M);
      }
      C[U] = re * 16 + te;
    }
    return C;
  }
  const w = async () => {
  };
  e.nextTick = w;
  async function v(N, q, j) {
    let C = Date.now();
    for (let U = 0; U < N; U++) {
      j(U);
      const M = Date.now() - C;
      M >= 0 && M < q || (await (0, e.nextTick)(), C += M);
    }
  }
  function k(N) {
    if (typeof N != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof N}`);
    return new Uint8Array(new TextEncoder().encode(N));
  }
  function x(N) {
    return typeof N == "string" && (N = k(N)), (0, r.bytes)(N), N;
  }
  function _(...N) {
    let q = 0;
    for (let C = 0; C < N.length; C++) {
      const U = N[C];
      (0, r.bytes)(U), q += U.length;
    }
    const j = new Uint8Array(q);
    for (let C = 0, U = 0; C < N.length; C++) {
      const M = N[C];
      j.set(M, U), U += M.length;
    }
    return j;
  }
  class I {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = I;
  const P = {}.toString;
  function $(N, q) {
    if (q !== void 0 && P.call(q) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(N, q);
  }
  function L(N) {
    const q = (C) => N().update(x(C)).digest(), j = N();
    return q.outputLen = j.outputLen, q.blockLen = j.blockLen, q.create = () => N(), q;
  }
  function V(N) {
    const q = (C, U) => N(U).update(x(C)).digest(), j = N({});
    return q.outputLen = j.outputLen, q.blockLen = j.blockLen, q.create = (C) => N(C), q;
  }
  function ee(N) {
    const q = (C, U) => N(U).update(x(C)).digest(), j = N({});
    return q.outputLen = j.outputLen, q.blockLen = j.blockLen, q.create = (C) => N(C), q;
  }
  function G(N = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(N));
    if (t.crypto && typeof t.crypto.randomBytes == "function")
      return t.crypto.randomBytes(N);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(Nc);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.hmac = e.HMAC = void 0;
  const t = xo, r = Nc;
  class n extends r.Hash {
    constructor(s, a) {
      super(), this.finished = false, this.destroyed = false, (0, t.hash)(s);
      const c = (0, r.toBytes)(a);
      if (this.iHash = s.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const u = this.blockLen, l = new Uint8Array(u);
      l.set(c.length > u ? s.create().update(c).digest() : c);
      for (let f = 0; f < l.length; f++)
        l[f] ^= 54;
      this.iHash.update(l), this.oHash = s.create();
      for (let f = 0; f < l.length; f++)
        l[f] ^= 106;
      this.oHash.update(l), l.fill(0);
    }
    update(s) {
      return (0, t.exists)(this), this.iHash.update(s), this;
    }
    digestInto(s) {
      (0, t.exists)(this), (0, t.bytes)(s, this.outputLen), this.finished = true, this.iHash.digestInto(s), this.oHash.update(s), this.oHash.digestInto(s), this.destroy();
    }
    digest() {
      const s = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(s), s;
    }
    _cloneInto(s) {
      s || (s = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: a, iHash: c, finished: u, destroyed: l, blockLen: f, outputLen: d } = this;
      return s = s, s.finished = u, s.destroyed = l, s.blockLen = f, s.outputLen = d, s.oHash = a._cloneInto(s.oHash), s.iHash = c._cloneInto(s.iHash), s;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = n;
  const o = (i, s, a) => new n(i, s).update(a).digest();
  e.hmac = o, e.hmac.create = (i, s) => new n(i, s);
})(S1);
var ai = {};
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: true });
Ls.HashMD = Ls.Maj = Ls.Chi = void 0;
var qb = xo;
var rd = Nc;
function tG(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var rG = (e, t, r) => e & t ^ ~e & r;
Ls.Chi = rG;
var nG = (e, t, r) => e & t ^ e & r ^ t & r;
Ls.Maj = nG;
var oG = class extends rd.Hash {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = (0, rd.createView)(this.buffer);
  }
  update(t) {
    (0, qb.exists)(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = (0, rd.toBytes)(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = (0, rd.createView)(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    (0, qb.exists)(this), (0, qb.output)(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    tG(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = (0, rd.createView)(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
Ls.HashMD = oG;
Object.defineProperty(ai, "__esModule", { value: true });
ai.sha224 = ai.sha256 = ai.SHA256 = void 0;
var Vb = Ls;
var Uo = Nc;
var iG = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Sa = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var _a = new Uint32Array(64);
var l3 = class extends Vb.HashMD {
  constructor() {
    super(64, 32, 8, false), this.A = Sa[0] | 0, this.B = Sa[1] | 0, this.C = Sa[2] | 0, this.D = Sa[3] | 0, this.E = Sa[4] | 0, this.F = Sa[5] | 0, this.G = Sa[6] | 0, this.H = Sa[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      _a[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = _a[f - 15], m = _a[f - 2], y = (0, Uo.rotr)(d, 7) ^ (0, Uo.rotr)(d, 18) ^ d >>> 3, b = (0, Uo.rotr)(m, 17) ^ (0, Uo.rotr)(m, 19) ^ m >>> 10;
      _a[f] = b + _a[f - 7] + y + _a[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = (0, Uo.rotr)(a, 6) ^ (0, Uo.rotr)(a, 11) ^ (0, Uo.rotr)(a, 25), m = l + d + (0, Vb.Chi)(a, c, u) + iG[f] + _a[f] | 0, b = ((0, Uo.rotr)(n, 2) ^ (0, Uo.rotr)(n, 13) ^ (0, Uo.rotr)(n, 22)) + (0, Vb.Maj)(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + b | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    _a.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
ai.SHA256 = l3;
var sG = class extends l3 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
ai.sha256 = (0, Uo.wrapConstructor)(() => new l3());
ai.sha224 = (0, Uo.wrapConstructor)(() => new sG());
var aG = c3;
var cG = S1;
var bA = ai;
function uG(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(r) {
    if (r !== "default") {
      var n = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(t, r, n.get ? n : {
        enumerable: true,
        get: function() {
          return e[r];
        }
      });
    }
  }), t.default = e, Object.freeze(t);
}
var It = uG(aG);
var Uc = "Expected Private";
var $c = "Expected Point";
var zh = "Expected Tweak";
var lG = "Expected Hash";
var ig = "Expected Signature";
var f3 = "Expected Extra Data (32 bytes)";
var Hh = "Expected Scalar";
var fG = "Bad Recovery Id";
It.utils.hmacSha256Sync = (e, ...t) => cG.hmac(bA.sha256, e, It.utils.concatBytes(...t));
It.utils.sha256Sync = (...e) => bA.sha256(It.utils.concatBytes(...e));
var d3 = It.utils._normalizePrivateKey;
var dG = 32;
var hG = 32;
var Uw = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]);
var pG = 32;
var gG = new Uint8Array(32);
var mG = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function bG(e) {
  return e instanceof Uint8Array;
}
function Zd(e, t) {
  for (let r = 0; r < 32; ++r)
    if (e[r] !== t[r])
      return e[r] < t[r] ? -1 : 1;
  return 0;
}
function j4(e) {
  return Zd(e, gG) === 0;
}
function Lh(e) {
  return !(!(e instanceof Uint8Array) || e.length !== hG || Zd(e, Uw) >= 0);
}
function h3(e) {
  return e instanceof Uint8Array && e.length === 64 && Zd(e.subarray(0, 32), Uw) < 0 && Zd(e.subarray(32, 64), Uw) < 0;
}
function yG(e) {
  return bG(e) && e.length === 64 && Zd(e.subarray(0, 32), mG) < 0;
}
function wG(e) {
  return !(j4(e.subarray(0, 32)) || j4(e.subarray(32, 64)));
}
function Tf(e) {
  return e instanceof Uint8Array && e.length === dG;
}
function p3(e) {
  return e === void 0 || e instanceof Uint8Array && e.length === pG;
}
function yA(e) {
  if (typeof e != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof e);
  return BigInt(`0x${e}`);
}
function vG(e) {
  return yA(It.utils.bytesToHex(e));
}
function g3(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0)
    t = BigInt(e);
  else if (typeof e == "string") {
    if (e.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    t = yA(e);
  } else if (e instanceof Uint8Array) {
    if (e.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    t = vG(e);
  } else
    throw new TypeError("Expected valid private scalar");
  if (t < 0) throw new Error("Expected private scalar >= 0");
  return t;
}
var EG = (e, t) => {
  const r = d3(e), n = g3(t), o = It.utils._bigintTo32Bytes(It.utils.mod(r + n, It.CURVE.n));
  return It.utils.isValidPrivateKey(o) ? o : null;
};
var xG = (e, t) => {
  const r = d3(e), n = g3(t), o = It.utils._bigintTo32Bytes(It.utils.mod(r - n, It.CURVE.n));
  return It.utils.isValidPrivateKey(o) ? o : null;
};
var kG = (e) => {
  const t = d3(e), r = It.utils._bigintTo32Bytes(It.CURVE.n - t);
  return It.utils.isValidPrivateKey(r) ? r : null;
};
var wA = (e, t, r) => {
  const n = It.Point.fromHex(e), o = g3(t), i = It.Point.BASE.multiplyAndAddUnsafe(n, o, BigInt(1));
  if (!i) throw new Error("Tweaked point at infinity");
  return i.toRawBytes(r);
};
var AG = (e, t, r) => {
  const n = It.Point.fromHex(e), o = typeof t == "string" ? t : It.utils.bytesToHex(t), i = BigInt(`0x${o}`);
  return n.multiply(i).toRawBytes(r);
};
function Pf(e, t) {
  return e === void 0 ? t !== void 0 ? vA(t) : true : !!e;
}
function Wu(e) {
  try {
    return e();
  } catch {
    return null;
  }
}
function m3(e, t) {
  if (e.length === 32 !== t) return false;
  try {
    return !!It.Point.fromHex(e);
  } catch {
    return false;
  }
}
function Ac(e) {
  return m3(e, false);
}
function vA(e) {
  return m3(e, false) && e.length === 33;
}
function ea(e) {
  return It.utils.isValidPrivateKey(e);
}
function T1(e) {
  return m3(e, true);
}
function SG(e, t) {
  if (!T1(e))
    throw new Error($c);
  if (!Lh(t))
    throw new Error(zh);
  return Wu(() => {
    const r = wA(e, t, true);
    return { parity: r[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: r.slice(1) };
  });
}
function EA(e) {
  if (!Ac(e))
    throw new Error($c);
  return e.slice(1, 33);
}
function xA(e, t) {
  if (!ea(e))
    throw new Error(Uc);
  return Wu(
    () => It.getPublicKey(e, Pf(t))
  );
}
function _G(e) {
  if (!ea(e))
    throw new Error(Uc);
  return EA(xA(e));
}
function TG(e, t) {
  if (!Ac(e))
    throw new Error($c);
  return It.Point.fromHex(e).toRawBytes(Pf(t, e));
}
function PG(e, t, r) {
  if (!Ac(e))
    throw new Error($c);
  if (!Lh(t))
    throw new Error(zh);
  return Wu(
    () => AG(e, t, Pf(r, e))
  );
}
function IG(e, t, r) {
  if (!Ac(e) || !Ac(t))
    throw new Error($c);
  return Wu(() => {
    const n = It.Point.fromHex(e), o = It.Point.fromHex(t);
    return n.equals(o.negate()) ? null : n.add(o).toRawBytes(Pf(r, e));
  });
}
function OG(e, t, r) {
  if (!Ac(e))
    throw new Error($c);
  if (!Lh(t))
    throw new Error(zh);
  return Wu(
    () => wA(e, t, Pf(r, e))
  );
}
function BG(e, t) {
  if (ea(e) === false)
    throw new Error(Uc);
  if (Lh(t) === false)
    throw new Error(zh);
  return Wu(() => EG(e, t));
}
function CG(e, t) {
  if (ea(e) === false)
    throw new Error(Uc);
  if (Lh(t) === false)
    throw new Error(zh);
  return Wu(() => xG(e, t));
}
function NG(e) {
  if (ea(e) === false)
    throw new Error(Uc);
  return kG(e);
}
function UG(e, t, r) {
  if (!ea(t))
    throw new Error(Uc);
  if (!Tf(e))
    throw new Error(Hh);
  if (!p3(r))
    throw new Error(f3);
  return It.signSync(e, t, { der: false, extraEntropy: r });
}
function $G(e, t, r) {
  if (!ea(t))
    throw new Error(Uc);
  if (!Tf(e))
    throw new Error(Hh);
  if (!p3(r))
    throw new Error(f3);
  const [n, o] = It.signSync(e, t, { der: false, extraEntropy: r, recovered: true });
  return { signature: n, recoveryId: o };
}
function RG(e, t, r = Buffer.alloc(32, 0)) {
  if (!ea(t))
    throw new Error(Uc);
  if (!Tf(e))
    throw new Error(Hh);
  if (!p3(r))
    throw new Error(f3);
  return It.schnorr.signSync(e, t, r);
}
function zG(e, t, r, n) {
  if (!Tf(e))
    throw new Error(lG);
  if (!h3(t) || !wG(t))
    throw new Error(ig);
  if (r & 2 && !yG(t))
    throw new Error(fG);
  if (!T1(t.subarray(0, 32)))
    throw new Error(ig);
  return It.recoverPublicKey(e, t, r, Pf(n));
}
function HG(e, t, r, n) {
  if (!Ac(t))
    throw new Error($c);
  if (!h3(r))
    throw new Error(ig);
  if (!Tf(e))
    throw new Error(Hh);
  return It.verify(r, e, t, { strict: n });
}
function LG(e, t, r) {
  if (!T1(t))
    throw new Error($c);
  if (!h3(r))
    throw new Error(ig);
  if (!Tf(e))
    throw new Error(Hh);
  return It.schnorr.verifySync(r, e, t);
}
var jG = dr.isPoint = Ac;
var FG = dr.isPointCompressed = vA;
var DG = dr.isPrivate = ea;
var KG = dr.isXOnlyPoint = T1;
var MG = dr.pointAdd = IG;
var qG = dr.pointAddScalar = OG;
var VG = dr.pointCompress = TG;
var GG = dr.pointFromScalar = xA;
var WG = dr.pointMultiply = PG;
var ZG = dr.privateAdd = BG;
var XG = dr.privateNegate = NG;
var YG = dr.privateSub = CG;
var JG = dr.recover = zG;
var QG = dr.sign = UG;
var eW = dr.signRecoverable = $G;
var tW = dr.signSchnorr = RG;
var rW = dr.verify = HG;
var nW = dr.verifySchnorr = LG;
var oW = dr.xOnlyPointAddTweak = SG;
var iW = dr.xOnlyPointFromPoint = EA;
var sW = dr.xOnlyPointFromScalar = _G;
var b3 = zC({
  __proto__: null,
  default: dr,
  isPoint: jG,
  isPointCompressed: FG,
  isPrivate: DG,
  isXOnlyPoint: KG,
  pointAdd: MG,
  pointAddScalar: qG,
  pointCompress: VG,
  pointFromScalar: GG,
  pointMultiply: WG,
  privateAdd: ZG,
  privateNegate: XG,
  privateSub: YG,
  recover: JG,
  sign: QG,
  signRecoverable: eW,
  signSchnorr: tW,
  verify: rW,
  verifySchnorr: nW,
  xOnlyPointAddTweak: oW,
  xOnlyPointFromPoint: iW,
  xOnlyPointFromScalar: sW
}, [dr]);
var kA = {};
var If = {};
If.byteLength = uW;
If.toByteArray = fW;
If.fromByteArray = pW;
var Mi = [];
var Ro = [];
var aW = typeof Uint8Array < "u" ? Uint8Array : Array;
var Gb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (ll = 0, cW = Gb.length; ll < cW; ++ll)
  Mi[ll] = Gb[ll], Ro[Gb.charCodeAt(ll)] = ll;
var ll;
var cW;
Ro[45] = 62;
Ro[95] = 63;
function AA(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function uW(e) {
  var t = AA(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function lW(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function fW(e) {
  var t, r = AA(e), n = r[0], o = r[1], i = new aW(lW(e, n, o)), s = 0, a = o > 0 ? n - 4 : n, c;
  for (c = 0; c < a; c += 4)
    t = Ro[e.charCodeAt(c)] << 18 | Ro[e.charCodeAt(c + 1)] << 12 | Ro[e.charCodeAt(c + 2)] << 6 | Ro[e.charCodeAt(c + 3)], i[s++] = t >> 16 & 255, i[s++] = t >> 8 & 255, i[s++] = t & 255;
  return o === 2 && (t = Ro[e.charCodeAt(c)] << 2 | Ro[e.charCodeAt(c + 1)] >> 4, i[s++] = t & 255), o === 1 && (t = Ro[e.charCodeAt(c)] << 10 | Ro[e.charCodeAt(c + 1)] << 4 | Ro[e.charCodeAt(c + 2)] >> 2, i[s++] = t >> 8 & 255, i[s++] = t & 255), i;
}
function dW(e) {
  return Mi[e >> 18 & 63] + Mi[e >> 12 & 63] + Mi[e >> 6 & 63] + Mi[e & 63];
}
function hW(e, t, r) {
  for (var n, o = [], i = t; i < r; i += 3)
    n = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255), o.push(dW(n));
  return o.join("");
}
function pW(e) {
  for (var t, r = e.length, n = r % 3, o = [], i = 16383, s = 0, a = r - n; s < a; s += i)
    o.push(hW(e, s, s + i > a ? a : s + i));
  return n === 1 ? (t = e[r - 1], o.push(
    Mi[t >> 2] + Mi[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    Mi[t >> 10] + Mi[t >> 4 & 63] + Mi[t << 2 & 63] + "="
  )), o.join("");
}
var y3 = {};
y3.read = function(e, t, r, n, o) {
  var i, s, a = o * 8 - n - 1, c = (1 << a) - 1, u = c >> 1, l = -7, f = r ? o - 1 : 0, d = r ? -1 : 1, m = e[t + f];
  for (f += d, i = m & (1 << -l) - 1, m >>= -l, l += a; l > 0; i = i * 256 + e[t + f], f += d, l -= 8)
    ;
  for (s = i & (1 << -l) - 1, i >>= -l, l += n; l > 0; s = s * 256 + e[t + f], f += d, l -= 8)
    ;
  if (i === 0)
    i = 1 - u;
  else {
    if (i === c)
      return s ? NaN : (m ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, n), i = i - u;
  }
  return (m ? -1 : 1) * s * Math.pow(2, i - n);
};
y3.write = function(e, t, r, n, o, i) {
  var s, a, c, u = i * 8 - o - 1, l = (1 << u) - 1, f = l >> 1, d = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = n ? 0 : i - 1, y = n ? 1 : -1, b = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), s + f >= 1 ? t += d / c : t += d * Math.pow(2, 1 - f), t * c >= 2 && (s++, c /= 2), s + f >= l ? (a = 0, s = l) : s + f >= 1 ? (a = (t * c - 1) * Math.pow(2, o), s = s + f) : (a = t * Math.pow(2, f - 1) * Math.pow(2, o), s = 0)); o >= 8; e[r + m] = a & 255, m += y, a /= 256, o -= 8)
    ;
  for (s = s << o | a, u += o; u > 0; e[r + m] = s & 255, m += y, s /= 256, u -= 8)
    ;
  e[r + m - y] |= b * 128;
};
(function(e) {
  const t = If, r = y3, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = a, e.SlowBuffer = k, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, a.TYPED_ARRAY_SUPPORT = i(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function i() {
    try {
      const p = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(p, h), p.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s(p) {
    if (p > o)
      throw new RangeError('The value "' + p + '" is invalid for option "size"');
    const h = new Uint8Array(p);
    return Object.setPrototypeOf(h, a.prototype), h;
  }
  function a(p, h, g) {
    if (typeof p == "number") {
      if (typeof h == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return f(p);
    }
    return c(p, h, g);
  }
  a.poolSize = 8192;
  function c(p, h, g) {
    if (typeof p == "string")
      return d(p, h);
    if (ArrayBuffer.isView(p))
      return y(p);
    if (p == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p
      );
    if (Wt(p, ArrayBuffer) || p && Wt(p.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Wt(p, SharedArrayBuffer) || p && Wt(p.buffer, SharedArrayBuffer)))
      return b(p, h, g);
    if (typeof p == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const A = p.valueOf && p.valueOf();
    if (A != null && A !== p)
      return a.from(A, h, g);
    const O = w(p);
    if (O) return O;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof p[Symbol.toPrimitive] == "function")
      return a.from(p[Symbol.toPrimitive]("string"), h, g);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p
    );
  }
  a.from = function(p, h, g) {
    return c(p, h, g);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function u(p) {
    if (typeof p != "number")
      throw new TypeError('"size" argument must be of type number');
    if (p < 0)
      throw new RangeError('The value "' + p + '" is invalid for option "size"');
  }
  function l(p, h, g) {
    return u(p), p <= 0 ? s(p) : h !== void 0 ? typeof g == "string" ? s(p).fill(h, g) : s(p).fill(h) : s(p);
  }
  a.alloc = function(p, h, g) {
    return l(p, h, g);
  };
  function f(p) {
    return u(p), s(p < 0 ? 0 : v(p) | 0);
  }
  a.allocUnsafe = function(p) {
    return f(p);
  }, a.allocUnsafeSlow = function(p) {
    return f(p);
  };
  function d(p, h) {
    if ((typeof h != "string" || h === "") && (h = "utf8"), !a.isEncoding(h))
      throw new TypeError("Unknown encoding: " + h);
    const g = x(p, h) | 0;
    let A = s(g);
    const O = A.write(p, h);
    return O !== g && (A = A.slice(0, O)), A;
  }
  function m(p) {
    const h = p.length < 0 ? 0 : v(p.length) | 0, g = s(h);
    for (let A = 0; A < h; A += 1)
      g[A] = p[A] & 255;
    return g;
  }
  function y(p) {
    if (Wt(p, Uint8Array)) {
      const h = new Uint8Array(p);
      return b(h.buffer, h.byteOffset, h.byteLength);
    }
    return m(p);
  }
  function b(p, h, g) {
    if (h < 0 || p.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (p.byteLength < h + (g || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return h === void 0 && g === void 0 ? A = new Uint8Array(p) : g === void 0 ? A = new Uint8Array(p, h) : A = new Uint8Array(p, h, g), Object.setPrototypeOf(A, a.prototype), A;
  }
  function w(p) {
    if (a.isBuffer(p)) {
      const h = v(p.length) | 0, g = s(h);
      return g.length === 0 || p.copy(g, 0, 0, h), g;
    }
    if (p.length !== void 0)
      return typeof p.length != "number" || so(p.length) ? s(0) : m(p);
    if (p.type === "Buffer" && Array.isArray(p.data))
      return m(p.data);
  }
  function v(p) {
    if (p >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return p | 0;
  }
  function k(p) {
    return +p != p && (p = 0), a.alloc(+p);
  }
  a.isBuffer = function(h) {
    return h != null && h._isBuffer === true && h !== a.prototype;
  }, a.compare = function(h, g) {
    if (Wt(h, Uint8Array) && (h = a.from(h, h.offset, h.byteLength)), Wt(g, Uint8Array) && (g = a.from(g, g.offset, g.byteLength)), !a.isBuffer(h) || !a.isBuffer(g))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (h === g) return 0;
    let A = h.length, O = g.length;
    for (let R = 0, F = Math.min(A, O); R < F; ++R)
      if (h[R] !== g[R]) {
        A = h[R], O = g[R];
        break;
      }
    return A < O ? -1 : O < A ? 1 : 0;
  }, a.isEncoding = function(h) {
    switch (String(h).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, a.concat = function(h, g) {
    if (!Array.isArray(h))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (h.length === 0)
      return a.alloc(0);
    let A;
    if (g === void 0)
      for (g = 0, A = 0; A < h.length; ++A)
        g += h[A].length;
    const O = a.allocUnsafe(g);
    let R = 0;
    for (A = 0; A < h.length; ++A) {
      let F = h[A];
      if (Wt(F, Uint8Array))
        R + F.length > O.length ? (a.isBuffer(F) || (F = a.from(F)), F.copy(O, R)) : Uint8Array.prototype.set.call(
          O,
          F,
          R
        );
      else if (a.isBuffer(F))
        F.copy(O, R);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      R += F.length;
    }
    return O;
  };
  function x(p, h) {
    if (a.isBuffer(p))
      return p.length;
    if (ArrayBuffer.isView(p) || Wt(p, ArrayBuffer))
      return p.byteLength;
    if (typeof p != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof p
      );
    const g = p.length, A = arguments.length > 2 && arguments[2] === true;
    if (!A && g === 0) return 0;
    let O = false;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return g;
        case "utf8":
        case "utf-8":
          return An(p).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return g * 2;
        case "hex":
          return g >>> 1;
        case "base64":
          return ls(p).length;
        default:
          if (O)
            return A ? -1 : An(p).length;
          h = ("" + h).toLowerCase(), O = true;
      }
  }
  a.byteLength = x;
  function _(p, h, g) {
    let A = false;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((g === void 0 || g > this.length) && (g = this.length), g <= 0) || (g >>>= 0, h >>>= 0, g <= h))
      return "";
    for (p || (p = "utf8"); ; )
      switch (p) {
        case "hex":
          return te(this, h, g);
        case "utf8":
        case "utf-8":
          return j(this, h, g);
        case "ascii":
          return M(this, h, g);
        case "latin1":
        case "binary":
          return re(this, h, g);
        case "base64":
          return q(this, h, g);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, h, g);
        default:
          if (A) throw new TypeError("Unknown encoding: " + p);
          p = (p + "").toLowerCase(), A = true;
      }
  }
  a.prototype._isBuffer = true;
  function I(p, h, g) {
    const A = p[h];
    p[h] = p[g], p[g] = A;
  }
  a.prototype.swap16 = function() {
    const h = this.length;
    if (h % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let g = 0; g < h; g += 2)
      I(this, g, g + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const h = this.length;
    if (h % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let g = 0; g < h; g += 4)
      I(this, g, g + 3), I(this, g + 1, g + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const h = this.length;
    if (h % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let g = 0; g < h; g += 8)
      I(this, g, g + 7), I(this, g + 1, g + 6), I(this, g + 2, g + 5), I(this, g + 3, g + 4);
    return this;
  }, a.prototype.toString = function() {
    const h = this.length;
    return h === 0 ? "" : arguments.length === 0 ? j(this, 0, h) : _.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(h) {
    if (!a.isBuffer(h)) throw new TypeError("Argument must be a Buffer");
    return this === h ? true : a.compare(this, h) === 0;
  }, a.prototype.inspect = function() {
    let h = "";
    const g = e.INSPECT_MAX_BYTES;
    return h = this.toString("hex", 0, g).replace(/(.{2})/g, "$1 ").trim(), this.length > g && (h += " ... "), "<Buffer " + h + ">";
  }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(h, g, A, O, R) {
    if (Wt(h, Uint8Array) && (h = a.from(h, h.offset, h.byteLength)), !a.isBuffer(h))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof h
      );
    if (g === void 0 && (g = 0), A === void 0 && (A = h ? h.length : 0), O === void 0 && (O = 0), R === void 0 && (R = this.length), g < 0 || A > h.length || O < 0 || R > this.length)
      throw new RangeError("out of range index");
    if (O >= R && g >= A)
      return 0;
    if (O >= R)
      return -1;
    if (g >= A)
      return 1;
    if (g >>>= 0, A >>>= 0, O >>>= 0, R >>>= 0, this === h) return 0;
    let F = R - O, me = A - g;
    const Me = Math.min(F, me), Pe = this.slice(O, R), Ie = h.slice(g, A);
    for (let Se = 0; Se < Me; ++Se)
      if (Pe[Se] !== Ie[Se]) {
        F = Pe[Se], me = Ie[Se];
        break;
      }
    return F < me ? -1 : me < F ? 1 : 0;
  };
  function P(p, h, g, A, O) {
    if (p.length === 0) return -1;
    if (typeof g == "string" ? (A = g, g = 0) : g > 2147483647 ? g = 2147483647 : g < -2147483648 && (g = -2147483648), g = +g, so(g) && (g = O ? 0 : p.length - 1), g < 0 && (g = p.length + g), g >= p.length) {
      if (O) return -1;
      g = p.length - 1;
    } else if (g < 0)
      if (O) g = 0;
      else return -1;
    if (typeof h == "string" && (h = a.from(h, A)), a.isBuffer(h))
      return h.length === 0 ? -1 : $(p, h, g, A, O);
    if (typeof h == "number")
      return h = h & 255, typeof Uint8Array.prototype.indexOf == "function" ? O ? Uint8Array.prototype.indexOf.call(p, h, g) : Uint8Array.prototype.lastIndexOf.call(p, h, g) : $(p, [h], g, A, O);
    throw new TypeError("val must be string, number or Buffer");
  }
  function $(p, h, g, A, O) {
    let R = 1, F = p.length, me = h.length;
    if (A !== void 0 && (A = String(A).toLowerCase(), A === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (p.length < 2 || h.length < 2)
        return -1;
      R = 2, F /= 2, me /= 2, g /= 2;
    }
    function Me(Ie, Se) {
      return R === 1 ? Ie[Se] : Ie.readUInt16BE(Se * R);
    }
    let Pe;
    if (O) {
      let Ie = -1;
      for (Pe = g; Pe < F; Pe++)
        if (Me(p, Pe) === Me(h, Ie === -1 ? 0 : Pe - Ie)) {
          if (Ie === -1 && (Ie = Pe), Pe - Ie + 1 === me) return Ie * R;
        } else
          Ie !== -1 && (Pe -= Pe - Ie), Ie = -1;
    } else
      for (g + me > F && (g = F - me), Pe = g; Pe >= 0; Pe--) {
        let Ie = true;
        for (let Se = 0; Se < me; Se++)
          if (Me(p, Pe + Se) !== Me(h, Se)) {
            Ie = false;
            break;
          }
        if (Ie) return Pe;
      }
    return -1;
  }
  a.prototype.includes = function(h, g, A) {
    return this.indexOf(h, g, A) !== -1;
  }, a.prototype.indexOf = function(h, g, A) {
    return P(this, h, g, A, true);
  }, a.prototype.lastIndexOf = function(h, g, A) {
    return P(this, h, g, A, false);
  };
  function L(p, h, g, A) {
    g = Number(g) || 0;
    const O = p.length - g;
    A ? (A = Number(A), A > O && (A = O)) : A = O;
    const R = h.length;
    A > R / 2 && (A = R / 2);
    let F;
    for (F = 0; F < A; ++F) {
      const me = parseInt(h.substr(F * 2, 2), 16);
      if (so(me)) return F;
      p[g + F] = me;
    }
    return F;
  }
  function V(p, h, g, A) {
    return Sn(An(h, p.length - g), p, g, A);
  }
  function ee(p, h, g, A) {
    return Sn(us(h), p, g, A);
  }
  function G(p, h, g, A) {
    return Sn(ls(h), p, g, A);
  }
  function N(p, h, g, A) {
    return Sn(Lc(h, p.length - g), p, g, A);
  }
  a.prototype.write = function(h, g, A, O) {
    if (g === void 0)
      O = "utf8", A = this.length, g = 0;
    else if (A === void 0 && typeof g == "string")
      O = g, A = this.length, g = 0;
    else if (isFinite(g))
      g = g >>> 0, isFinite(A) ? (A = A >>> 0, O === void 0 && (O = "utf8")) : (O = A, A = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const R = this.length - g;
    if ((A === void 0 || A > R) && (A = R), h.length > 0 && (A < 0 || g < 0) || g > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    O || (O = "utf8");
    let F = false;
    for (; ; )
      switch (O) {
        case "hex":
          return L(this, h, g, A);
        case "utf8":
        case "utf-8":
          return V(this, h, g, A);
        case "ascii":
        case "latin1":
        case "binary":
          return ee(this, h, g, A);
        case "base64":
          return G(this, h, g, A);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N(this, h, g, A);
        default:
          if (F) throw new TypeError("Unknown encoding: " + O);
          O = ("" + O).toLowerCase(), F = true;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function q(p, h, g) {
    return h === 0 && g === p.length ? t.fromByteArray(p) : t.fromByteArray(p.slice(h, g));
  }
  function j(p, h, g) {
    g = Math.min(p.length, g);
    const A = [];
    let O = h;
    for (; O < g; ) {
      const R = p[O];
      let F = null, me = R > 239 ? 4 : R > 223 ? 3 : R > 191 ? 2 : 1;
      if (O + me <= g) {
        let Me, Pe, Ie, Se;
        switch (me) {
          case 1:
            R < 128 && (F = R);
            break;
          case 2:
            Me = p[O + 1], (Me & 192) === 128 && (Se = (R & 31) << 6 | Me & 63, Se > 127 && (F = Se));
            break;
          case 3:
            Me = p[O + 1], Pe = p[O + 2], (Me & 192) === 128 && (Pe & 192) === 128 && (Se = (R & 15) << 12 | (Me & 63) << 6 | Pe & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (F = Se));
            break;
          case 4:
            Me = p[O + 1], Pe = p[O + 2], Ie = p[O + 3], (Me & 192) === 128 && (Pe & 192) === 128 && (Ie & 192) === 128 && (Se = (R & 15) << 18 | (Me & 63) << 12 | (Pe & 63) << 6 | Ie & 63, Se > 65535 && Se < 1114112 && (F = Se));
        }
      }
      F === null ? (F = 65533, me = 1) : F > 65535 && (F -= 65536, A.push(F >>> 10 & 1023 | 55296), F = 56320 | F & 1023), A.push(F), O += me;
    }
    return U(A);
  }
  const C = 4096;
  function U(p) {
    const h = p.length;
    if (h <= C)
      return String.fromCharCode.apply(String, p);
    let g = "", A = 0;
    for (; A < h; )
      g += String.fromCharCode.apply(
        String,
        p.slice(A, A += C)
      );
    return g;
  }
  function M(p, h, g) {
    let A = "";
    g = Math.min(p.length, g);
    for (let O = h; O < g; ++O)
      A += String.fromCharCode(p[O] & 127);
    return A;
  }
  function re(p, h, g) {
    let A = "";
    g = Math.min(p.length, g);
    for (let O = h; O < g; ++O)
      A += String.fromCharCode(p[O]);
    return A;
  }
  function te(p, h, g) {
    const A = p.length;
    (!h || h < 0) && (h = 0), (!g || g < 0 || g > A) && (g = A);
    let O = "";
    for (let R = h; R < g; ++R)
      O += jc[p[R]];
    return O;
  }
  function ie(p, h, g) {
    const A = p.slice(h, g);
    let O = "";
    for (let R = 0; R < A.length - 1; R += 2)
      O += String.fromCharCode(A[R] + A[R + 1] * 256);
    return O;
  }
  a.prototype.slice = function(h, g) {
    const A = this.length;
    h = ~~h, g = g === void 0 ? A : ~~g, h < 0 ? (h += A, h < 0 && (h = 0)) : h > A && (h = A), g < 0 ? (g += A, g < 0 && (g = 0)) : g > A && (g = A), g < h && (g = h);
    const O = this.subarray(h, g);
    return Object.setPrototypeOf(O, a.prototype), O;
  };
  function ne(p, h, g) {
    if (p % 1 !== 0 || p < 0) throw new RangeError("offset is not uint");
    if (p + h > g) throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(h, g, A) {
    h = h >>> 0, g = g >>> 0, A || ne(h, g, this.length);
    let O = this[h], R = 1, F = 0;
    for (; ++F < g && (R *= 256); )
      O += this[h + F] * R;
    return O;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(h, g, A) {
    h = h >>> 0, g = g >>> 0, A || ne(h, g, this.length);
    let O = this[h + --g], R = 1;
    for (; g > 0 && (R *= 256); )
      O += this[h + --g] * R;
    return O;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(h, g) {
    return h = h >>> 0, g || ne(h, 1, this.length), this[h];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(h, g) {
    return h = h >>> 0, g || ne(h, 2, this.length), this[h] | this[h + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(h, g) {
    return h = h >>> 0, g || ne(h, 2, this.length), this[h] << 8 | this[h + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(h, g) {
    return h = h >>> 0, g || ne(h, 4, this.length), (this[h] | this[h + 1] << 8 | this[h + 2] << 16) + this[h + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(h, g) {
    return h = h >>> 0, g || ne(h, 4, this.length), this[h] * 16777216 + (this[h + 1] << 16 | this[h + 2] << 8 | this[h + 3]);
  }, a.prototype.readBigUInt64LE = Qt(function(h) {
    h = h >>> 0, Ae(h, "offset");
    const g = this[h], A = this[h + 7];
    (g === void 0 || A === void 0) && bt(h, this.length - 8);
    const O = g + this[++h] * 2 ** 8 + this[++h] * 2 ** 16 + this[++h] * 2 ** 24, R = this[++h] + this[++h] * 2 ** 8 + this[++h] * 2 ** 16 + A * 2 ** 24;
    return BigInt(O) + (BigInt(R) << BigInt(32));
  }), a.prototype.readBigUInt64BE = Qt(function(h) {
    h = h >>> 0, Ae(h, "offset");
    const g = this[h], A = this[h + 7];
    (g === void 0 || A === void 0) && bt(h, this.length - 8);
    const O = g * 2 ** 24 + this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + this[++h], R = this[++h] * 2 ** 24 + this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + A;
    return (BigInt(O) << BigInt(32)) + BigInt(R);
  }), a.prototype.readIntLE = function(h, g, A) {
    h = h >>> 0, g = g >>> 0, A || ne(h, g, this.length);
    let O = this[h], R = 1, F = 0;
    for (; ++F < g && (R *= 256); )
      O += this[h + F] * R;
    return R *= 128, O >= R && (O -= Math.pow(2, 8 * g)), O;
  }, a.prototype.readIntBE = function(h, g, A) {
    h = h >>> 0, g = g >>> 0, A || ne(h, g, this.length);
    let O = g, R = 1, F = this[h + --O];
    for (; O > 0 && (R *= 256); )
      F += this[h + --O] * R;
    return R *= 128, F >= R && (F -= Math.pow(2, 8 * g)), F;
  }, a.prototype.readInt8 = function(h, g) {
    return h = h >>> 0, g || ne(h, 1, this.length), this[h] & 128 ? (255 - this[h] + 1) * -1 : this[h];
  }, a.prototype.readInt16LE = function(h, g) {
    h = h >>> 0, g || ne(h, 2, this.length);
    const A = this[h] | this[h + 1] << 8;
    return A & 32768 ? A | 4294901760 : A;
  }, a.prototype.readInt16BE = function(h, g) {
    h = h >>> 0, g || ne(h, 2, this.length);
    const A = this[h + 1] | this[h] << 8;
    return A & 32768 ? A | 4294901760 : A;
  }, a.prototype.readInt32LE = function(h, g) {
    return h = h >>> 0, g || ne(h, 4, this.length), this[h] | this[h + 1] << 8 | this[h + 2] << 16 | this[h + 3] << 24;
  }, a.prototype.readInt32BE = function(h, g) {
    return h = h >>> 0, g || ne(h, 4, this.length), this[h] << 24 | this[h + 1] << 16 | this[h + 2] << 8 | this[h + 3];
  }, a.prototype.readBigInt64LE = Qt(function(h) {
    h = h >>> 0, Ae(h, "offset");
    const g = this[h], A = this[h + 7];
    (g === void 0 || A === void 0) && bt(h, this.length - 8);
    const O = this[h + 4] + this[h + 5] * 2 ** 8 + this[h + 6] * 2 ** 16 + (A << 24);
    return (BigInt(O) << BigInt(32)) + BigInt(g + this[++h] * 2 ** 8 + this[++h] * 2 ** 16 + this[++h] * 2 ** 24);
  }), a.prototype.readBigInt64BE = Qt(function(h) {
    h = h >>> 0, Ae(h, "offset");
    const g = this[h], A = this[h + 7];
    (g === void 0 || A === void 0) && bt(h, this.length - 8);
    const O = (g << 24) + // Overflow
    this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + this[++h];
    return (BigInt(O) << BigInt(32)) + BigInt(this[++h] * 2 ** 24 + this[++h] * 2 ** 16 + this[++h] * 2 ** 8 + A);
  }), a.prototype.readFloatLE = function(h, g) {
    return h = h >>> 0, g || ne(h, 4, this.length), r.read(this, h, true, 23, 4);
  }, a.prototype.readFloatBE = function(h, g) {
    return h = h >>> 0, g || ne(h, 4, this.length), r.read(this, h, false, 23, 4);
  }, a.prototype.readDoubleLE = function(h, g) {
    return h = h >>> 0, g || ne(h, 8, this.length), r.read(this, h, true, 52, 8);
  }, a.prototype.readDoubleBE = function(h, g) {
    return h = h >>> 0, g || ne(h, 8, this.length), r.read(this, h, false, 52, 8);
  };
  function le(p, h, g, A, O, R) {
    if (!a.isBuffer(p)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > O || h < R) throw new RangeError('"value" argument is out of bounds');
    if (g + A > p.length) throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(h, g, A, O) {
    if (h = +h, g = g >>> 0, A = A >>> 0, !O) {
      const me = Math.pow(2, 8 * A) - 1;
      le(this, h, g, A, me, 0);
    }
    let R = 1, F = 0;
    for (this[g] = h & 255; ++F < A && (R *= 256); )
      this[g + F] = h / R & 255;
    return g + A;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(h, g, A, O) {
    if (h = +h, g = g >>> 0, A = A >>> 0, !O) {
      const me = Math.pow(2, 8 * A) - 1;
      le(this, h, g, A, me, 0);
    }
    let R = A - 1, F = 1;
    for (this[g + R] = h & 255; --R >= 0 && (F *= 256); )
      this[g + R] = h / F & 255;
    return g + A;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 1, 255, 0), this[g] = h & 255, g + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 2, 65535, 0), this[g] = h & 255, this[g + 1] = h >>> 8, g + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 2, 65535, 0), this[g] = h >>> 8, this[g + 1] = h & 255, g + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 4, 4294967295, 0), this[g + 3] = h >>> 24, this[g + 2] = h >>> 16, this[g + 1] = h >>> 8, this[g] = h & 255, g + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 4, 4294967295, 0), this[g] = h >>> 24, this[g + 1] = h >>> 16, this[g + 2] = h >>> 8, this[g + 3] = h & 255, g + 4;
  };
  function K(p, h, g, A, O) {
    He(h, A, O, p, g, 7);
    let R = Number(h & BigInt(4294967295));
    p[g++] = R, R = R >> 8, p[g++] = R, R = R >> 8, p[g++] = R, R = R >> 8, p[g++] = R;
    let F = Number(h >> BigInt(32) & BigInt(4294967295));
    return p[g++] = F, F = F >> 8, p[g++] = F, F = F >> 8, p[g++] = F, F = F >> 8, p[g++] = F, g;
  }
  function ve(p, h, g, A, O) {
    He(h, A, O, p, g, 7);
    let R = Number(h & BigInt(4294967295));
    p[g + 7] = R, R = R >> 8, p[g + 6] = R, R = R >> 8, p[g + 5] = R, R = R >> 8, p[g + 4] = R;
    let F = Number(h >> BigInt(32) & BigInt(4294967295));
    return p[g + 3] = F, F = F >> 8, p[g + 2] = F, F = F >> 8, p[g + 1] = F, F = F >> 8, p[g] = F, g + 8;
  }
  a.prototype.writeBigUInt64LE = Qt(function(h, g = 0) {
    return K(this, h, g, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = Qt(function(h, g = 0) {
    return ve(this, h, g, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(h, g, A, O) {
    if (h = +h, g = g >>> 0, !O) {
      const Me = Math.pow(2, 8 * A - 1);
      le(this, h, g, A, Me - 1, -Me);
    }
    let R = 0, F = 1, me = 0;
    for (this[g] = h & 255; ++R < A && (F *= 256); )
      h < 0 && me === 0 && this[g + R - 1] !== 0 && (me = 1), this[g + R] = (h / F >> 0) - me & 255;
    return g + A;
  }, a.prototype.writeIntBE = function(h, g, A, O) {
    if (h = +h, g = g >>> 0, !O) {
      const Me = Math.pow(2, 8 * A - 1);
      le(this, h, g, A, Me - 1, -Me);
    }
    let R = A - 1, F = 1, me = 0;
    for (this[g + R] = h & 255; --R >= 0 && (F *= 256); )
      h < 0 && me === 0 && this[g + R + 1] !== 0 && (me = 1), this[g + R] = (h / F >> 0) - me & 255;
    return g + A;
  }, a.prototype.writeInt8 = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 1, 127, -128), h < 0 && (h = 255 + h + 1), this[g] = h & 255, g + 1;
  }, a.prototype.writeInt16LE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 2, 32767, -32768), this[g] = h & 255, this[g + 1] = h >>> 8, g + 2;
  }, a.prototype.writeInt16BE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 2, 32767, -32768), this[g] = h >>> 8, this[g + 1] = h & 255, g + 2;
  }, a.prototype.writeInt32LE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 4, 2147483647, -2147483648), this[g] = h & 255, this[g + 1] = h >>> 8, this[g + 2] = h >>> 16, this[g + 3] = h >>> 24, g + 4;
  }, a.prototype.writeInt32BE = function(h, g, A) {
    return h = +h, g = g >>> 0, A || le(this, h, g, 4, 2147483647, -2147483648), h < 0 && (h = 4294967295 + h + 1), this[g] = h >>> 24, this[g + 1] = h >>> 16, this[g + 2] = h >>> 8, this[g + 3] = h & 255, g + 4;
  }, a.prototype.writeBigInt64LE = Qt(function(h, g = 0) {
    return K(this, h, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = Qt(function(h, g = 0) {
    return ve(this, h, g, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function At(p, h, g, A, O, R) {
    if (g + A > p.length) throw new RangeError("Index out of range");
    if (g < 0) throw new RangeError("Index out of range");
  }
  function ze(p, h, g, A, O) {
    return h = +h, g = g >>> 0, O || At(p, h, g, 4), r.write(p, h, g, A, 23, 4), g + 4;
  }
  a.prototype.writeFloatLE = function(h, g, A) {
    return ze(this, h, g, true, A);
  }, a.prototype.writeFloatBE = function(h, g, A) {
    return ze(this, h, g, false, A);
  };
  function St(p, h, g, A, O) {
    return h = +h, g = g >>> 0, O || At(p, h, g, 8), r.write(p, h, g, A, 52, 8), g + 8;
  }
  a.prototype.writeDoubleLE = function(h, g, A) {
    return St(this, h, g, true, A);
  }, a.prototype.writeDoubleBE = function(h, g, A) {
    return St(this, h, g, false, A);
  }, a.prototype.copy = function(h, g, A, O) {
    if (!a.isBuffer(h)) throw new TypeError("argument should be a Buffer");
    if (A || (A = 0), !O && O !== 0 && (O = this.length), g >= h.length && (g = h.length), g || (g = 0), O > 0 && O < A && (O = A), O === A || h.length === 0 || this.length === 0) return 0;
    if (g < 0)
      throw new RangeError("targetStart out of bounds");
    if (A < 0 || A >= this.length) throw new RangeError("Index out of range");
    if (O < 0) throw new RangeError("sourceEnd out of bounds");
    O > this.length && (O = this.length), h.length - g < O - A && (O = h.length - g + A);
    const R = O - A;
    return this === h && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(g, A, O) : Uint8Array.prototype.set.call(
      h,
      this.subarray(A, O),
      g
    ), R;
  }, a.prototype.fill = function(h, g, A, O) {
    if (typeof h == "string") {
      if (typeof g == "string" ? (O = g, g = 0, A = this.length) : typeof A == "string" && (O = A, A = this.length), O !== void 0 && typeof O != "string")
        throw new TypeError("encoding must be a string");
      if (typeof O == "string" && !a.isEncoding(O))
        throw new TypeError("Unknown encoding: " + O);
      if (h.length === 1) {
        const F = h.charCodeAt(0);
        (O === "utf8" && F < 128 || O === "latin1") && (h = F);
      }
    } else typeof h == "number" ? h = h & 255 : typeof h == "boolean" && (h = Number(h));
    if (g < 0 || this.length < g || this.length < A)
      throw new RangeError("Out of range index");
    if (A <= g)
      return this;
    g = g >>> 0, A = A === void 0 ? this.length : A >>> 0, h || (h = 0);
    let R;
    if (typeof h == "number")
      for (R = g; R < A; ++R)
        this[R] = h;
    else {
      const F = a.isBuffer(h) ? h : a.from(h, O), me = F.length;
      if (me === 0)
        throw new TypeError('The value "' + h + '" is invalid for argument "value"');
      for (R = 0; R < A - g; ++R)
        this[R + g] = F[R % me];
    }
    return this;
  };
  const et = {};
  function Ge(p, h, g) {
    et[p] = class extends g {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: h.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${p}]`, this.stack, delete this.name;
      }
      get code() {
        return p;
      }
      set code(O) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: O,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${p}]: ${this.message}`;
      }
    };
  }
  Ge(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(p) {
      return p ? `${p} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Ge(
    "ERR_INVALID_ARG_TYPE",
    function(p, h) {
      return `The "${p}" argument must be of type number. Received type ${typeof h}`;
    },
    TypeError
  ), Ge(
    "ERR_OUT_OF_RANGE",
    function(p, h, g) {
      let A = `The value of "${p}" is out of range.`, O = g;
      return Number.isInteger(g) && Math.abs(g) > 2 ** 32 ? O = ut(String(g)) : typeof g == "bigint" && (O = String(g), (g > BigInt(2) ** BigInt(32) || g < -(BigInt(2) ** BigInt(32))) && (O = ut(O)), O += "n"), A += ` It must be ${h}. Received ${O}`, A;
    },
    RangeError
  );
  function ut(p) {
    let h = "", g = p.length;
    const A = p[0] === "-" ? 1 : 0;
    for (; g >= A + 4; g -= 3)
      h = `_${p.slice(g - 3, g)}${h}`;
    return `${p.slice(0, g)}${h}`;
  }
  function ot(p, h, g) {
    Ae(h, "offset"), (p[h] === void 0 || p[h + g] === void 0) && bt(h, p.length - (g + 1));
  }
  function He(p, h, g, A, O, R) {
    if (p > g || p < h) {
      const F = typeof h == "bigint" ? "n" : "";
      let me;
      throw h === 0 || h === BigInt(0) ? me = `>= 0${F} and < 2${F} ** ${(R + 1) * 8}${F}` : me = `>= -(2${F} ** ${(R + 1) * 8 - 1}${F}) and < 2 ** ${(R + 1) * 8 - 1}${F}`, new et.ERR_OUT_OF_RANGE("value", me, p);
    }
    ot(A, O, R);
  }
  function Ae(p, h) {
    if (typeof p != "number")
      throw new et.ERR_INVALID_ARG_TYPE(h, "number", p);
  }
  function bt(p, h, g) {
    throw Math.floor(p) !== p ? (Ae(p, g), new et.ERR_OUT_OF_RANGE("offset", "an integer", p)) : h < 0 ? new et.ERR_BUFFER_OUT_OF_BOUNDS() : new et.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${h}`,
      p
    );
  }
  const wr = /[^+/0-9A-Za-z-_]/g;
  function Gt(p) {
    if (p = p.split("=")[0], p = p.trim().replace(wr, ""), p.length < 2) return "";
    for (; p.length % 4 !== 0; )
      p = p + "=";
    return p;
  }
  function An(p, h) {
    h = h || 1 / 0;
    let g;
    const A = p.length;
    let O = null;
    const R = [];
    for (let F = 0; F < A; ++F) {
      if (g = p.charCodeAt(F), g > 55295 && g < 57344) {
        if (!O) {
          if (g > 56319) {
            (h -= 3) > -1 && R.push(239, 191, 189);
            continue;
          } else if (F + 1 === A) {
            (h -= 3) > -1 && R.push(239, 191, 189);
            continue;
          }
          O = g;
          continue;
        }
        if (g < 56320) {
          (h -= 3) > -1 && R.push(239, 191, 189), O = g;
          continue;
        }
        g = (O - 55296 << 10 | g - 56320) + 65536;
      } else O && (h -= 3) > -1 && R.push(239, 191, 189);
      if (O = null, g < 128) {
        if ((h -= 1) < 0) break;
        R.push(g);
      } else if (g < 2048) {
        if ((h -= 2) < 0) break;
        R.push(
          g >> 6 | 192,
          g & 63 | 128
        );
      } else if (g < 65536) {
        if ((h -= 3) < 0) break;
        R.push(
          g >> 12 | 224,
          g >> 6 & 63 | 128,
          g & 63 | 128
        );
      } else if (g < 1114112) {
        if ((h -= 4) < 0) break;
        R.push(
          g >> 18 | 240,
          g >> 12 & 63 | 128,
          g >> 6 & 63 | 128,
          g & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return R;
  }
  function us(p) {
    const h = [];
    for (let g = 0; g < p.length; ++g)
      h.push(p.charCodeAt(g) & 255);
    return h;
  }
  function Lc(p, h) {
    let g, A, O;
    const R = [];
    for (let F = 0; F < p.length && !((h -= 2) < 0); ++F)
      g = p.charCodeAt(F), A = g >> 8, O = g % 256, R.push(O), R.push(A);
    return R;
  }
  function ls(p) {
    return t.toByteArray(Gt(p));
  }
  function Sn(p, h, g, A) {
    let O;
    for (O = 0; O < A && !(O + g >= h.length || O >= p.length); ++O)
      h[O + g] = p[O];
    return O;
  }
  function Wt(p, h) {
    return p instanceof h || p != null && p.constructor != null && p.constructor.name != null && p.constructor.name === h.name;
  }
  function so(p) {
    return p !== p;
  }
  const jc = function() {
    const p = "0123456789abcdef", h = new Array(256);
    for (let g = 0; g < 16; ++g) {
      const A = g * 16;
      for (let O = 0; O < 16; ++O)
        h[A + O] = p[g] + p[O];
    }
    return h;
  }();
  function Qt(p) {
    return typeof BigInt > "u" ? fs : p;
  }
  function fs() {
    throw new Error("BigInt not supported");
  }
})(kA);
var Twe = "Mainnet";
var tf = "BITCOIN_MAINNET";
var P1 = "BITCOIN_TESTNET";
var I1 = "BITCOIN_TESTNET4";
var O1 = "BITCOIN_SIGNET";
var B1 = "FRACTAL_BITCOIN_MAINNET";
var C1 = "FRACTAL_BITCOIN_TESTNET";
var SA = "GLITTR_DEVNET";
var Pwe = "livenet";
var Iwe = "testnet";
var pd = "Mainnet";
var $w = "Testnet";
var gW = "Signet";
var mW = "livenet";
var bW = "testnet";
var Ed = "livenet";
var Rw = "testnet";
var _A = "testnet4";
var TA = "signet";
var Tp = "Mainnet";
var Wb = "Testnet";
var zw = "mainnet";
var PA = "testnet";
var Pp = "main";
var F4 = "testnet";
var yW = "signet";
var Tt = "mainnet";
var Vr = "signet";
var Mt = "testnet";
var Br = "testnet4";
var no = "fractal mainnet";
var Cr = "fractal testnet";
var IA = "glittr devnet";
var Owe = "regtest";
var l0 = (e) => e === Tt ? pd : e === Mt || e === Br ? $w : e === Vr ? gW : pd;
var Bwe = (e) => e === Tt ? zw : e === Mt ? PA : zw;
var OA = (e) => e === Tt ? tf : e === Mt ? P1 : e === Br ? I1 : e === Vr ? O1 : e === no ? B1 : e === Cr ? C1 : tf;
var wW = (e) => e === Tt ? tf : e === Mt ? P1 : e === Br ? I1 : e === Vr ? O1 : e === no ? B1 : e === Cr ? C1 : e === IA ? SA : tf;
var Cwe = (e) => e === Tt ? Ed : e === Mt ? Rw : e === Br ? _A : e === Vr ? TA : e === Cr ? Rw : Ed;
var Zb = (e) => e === Tt ? Tp : e === Mt || e === Br || e === Vr ? Wb : Tp;
var vW = (e) => e === Tt ? Pp : e === Br || e === Mt ? F4 : e === Vr ? yW : Pp;
var sg = (e) => e === tf ? Tt : e === P1 ? Mt : e === I1 ? Br : e === O1 ? Vr : e === B1 ? no : e === C1 ? Cr : Tt;
var D4 = (e) => e === tf ? Tt : e === P1 ? Mt : e === I1 ? Br : e === O1 ? Vr : e === B1 ? no : e === C1 ? Cr : e === SA ? IA : Tt;
var Nwe = (e) => e === pd ? Tt : e === $w ? Mt : Tt;
var Uwe = (e) => e === zw ? Tt : e === PA ? Mt : Tt;
var EW = (e) => e === mW ? Tt : e === bW ? Mt : Tt;
var K4 = (e) => e === Ed ? Tt : e === Rw ? Mt : e === _A ? Br : e === TA ? Vr : e === Cr ? Mt : Tt;
function BA(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
var { toString: xW } = Object.prototype;
var { getPrototypeOf: w3 } = Object;
var N1 = /* @__PURE__ */ ((e) => (t) => {
  const r = xW.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var xi = (e) => (e = e.toLowerCase(), (t) => N1(t) === e);
var U1 = (e) => (t) => typeof t === e;
var { isArray: Of } = Array;
var Xd = U1("undefined");
function kW(e) {
  return e !== null && !Xd(e) && e.constructor !== null && !Xd(e.constructor) && bo(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
var CA = xi("ArrayBuffer");
function AW(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && CA(e.buffer), t;
}
var SW = U1("string");
var bo = U1("function");
var NA = U1("number");
var $1 = (e) => e !== null && typeof e == "object";
var _W = (e) => e === true || e === false;
var f0 = (e) => {
  if (N1(e) !== "object")
    return false;
  const t = w3(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
};
var TW = xi("Date");
var PW = xi("File");
var IW = xi("Blob");
var OW = xi("FileList");
var BW = (e) => $1(e) && bo(e.pipe);
var CW = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || bo(e.append) && ((t = N1(e)) === "formdata" || // detect form-data instance
  t === "object" && bo(e.toString) && e.toString() === "[object FormData]"));
};
var NW = xi("URLSearchParams");
var [UW, $W, RW, zW] = ["ReadableStream", "Request", "Response", "Headers"].map(xi);
var HW = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function jh(e, t, { allOwnKeys: r = false } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, o;
  if (typeof e != "object" && (e = [e]), Of(e))
    for (n = 0, o = e.length; n < o; n++)
      t.call(null, e[n], n, e);
  else {
    const i = r ? Object.getOwnPropertyNames(e) : Object.keys(e), s = i.length;
    let a;
    for (n = 0; n < s; n++)
      a = i[n], t.call(null, e[a], a, e);
  }
}
function UA(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, o;
  for (; n-- > 0; )
    if (o = r[n], t === o.toLowerCase())
      return o;
  return null;
}
var au = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global;
var $A = (e) => !Xd(e) && e !== au;
function Hw() {
  const { caseless: e } = $A(this) && this || {}, t = {}, r = (n, o) => {
    const i = e && UA(t, o) || o;
    f0(t[i]) && f0(n) ? t[i] = Hw(t[i], n) : f0(n) ? t[i] = Hw({}, n) : Of(n) ? t[i] = n.slice() : t[i] = n;
  };
  for (let n = 0, o = arguments.length; n < o; n++)
    arguments[n] && jh(arguments[n], r);
  return t;
}
var LW = (e, t, r, { allOwnKeys: n } = {}) => (jh(t, (o, i) => {
  r && bo(o) ? e[i] = BA(o, r) : e[i] = o;
}, { allOwnKeys: n }), e);
var jW = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e);
var FW = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
};
var DW = (e, t, r, n) => {
  let o, i, s;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), i = o.length; i-- > 0; )
      s = o[i], (!n || n(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = true);
    e = r !== false && w3(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
};
var KW = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
};
var MW = (e) => {
  if (!e) return null;
  if (Of(e)) return e;
  let t = e.length;
  if (!NA(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
};
var qW = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && w3(Uint8Array));
var VW = (e, t) => {
  const n = (e && e[Symbol.iterator]).call(e);
  let o;
  for (; (o = n.next()) && !o.done; ) {
    const i = o.value;
    t.call(e, i[0], i[1]);
  }
};
var GW = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
};
var WW = xi("HTMLFormElement");
var ZW = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, o) {
    return n.toUpperCase() + o;
  }
);
var M4 = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype);
var XW = xi("RegExp");
var RA = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  jh(r, (o, i) => {
    let s;
    (s = t(o, i, e)) !== false && (n[i] = s || o);
  }), Object.defineProperties(e, n);
};
var YW = (e) => {
  RA(e, (t, r) => {
    if (bo(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return false;
    const n = e[r];
    if (bo(n)) {
      if (t.enumerable = false, "writable" in t) {
        t.writable = false;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
};
var JW = (e, t) => {
  const r = {}, n = (o) => {
    o.forEach((i) => {
      r[i] = true;
    });
  };
  return Of(e) ? n(e) : n(String(e).split(t)), r;
};
var QW = () => {
};
var eZ = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
var Xb = "abcdefghijklmnopqrstuvwxyz";
var q4 = "0123456789";
var zA = {
  DIGIT: q4,
  ALPHA: Xb,
  ALPHA_DIGIT: Xb + Xb.toUpperCase() + q4
};
var tZ = (e = 16, t = zA.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function rZ(e) {
  return !!(e && bo(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
var nZ = (e) => {
  const t = new Array(10), r = (n, o) => {
    if ($1(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[o] = n;
        const i = Of(n) ? [] : {};
        return jh(n, (s, a) => {
          const c = r(s, o + 1);
          !Xd(c) && (i[a] = c);
        }), t[o] = void 0, i;
      }
    }
    return n;
  };
  return r(e, 0);
};
var oZ = xi("AsyncFunction");
var iZ = (e) => e && ($1(e) || bo(e)) && bo(e.then) && bo(e.catch);
var HA = ((e, t) => e ? setImmediate : t ? ((r, n) => (au.addEventListener("message", ({ source: o, data: i }) => {
  o === au && i === r && n.length && n.shift()();
}, false), (o) => {
  n.push(o), au.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  bo(au.postMessage)
);
var sZ = typeof queueMicrotask < "u" ? queueMicrotask.bind(au) : typeof process < "u" && process.nextTick || HA;
var J = {
  isArray: Of,
  isArrayBuffer: CA,
  isBuffer: kW,
  isFormData: CW,
  isArrayBufferView: AW,
  isString: SW,
  isNumber: NA,
  isBoolean: _W,
  isObject: $1,
  isPlainObject: f0,
  isReadableStream: UW,
  isRequest: $W,
  isResponse: RW,
  isHeaders: zW,
  isUndefined: Xd,
  isDate: TW,
  isFile: PW,
  isBlob: IW,
  isRegExp: XW,
  isFunction: bo,
  isStream: BW,
  isURLSearchParams: NW,
  isTypedArray: qW,
  isFileList: OW,
  forEach: jh,
  merge: Hw,
  extend: LW,
  trim: HW,
  stripBOM: jW,
  inherits: FW,
  toFlatObject: DW,
  kindOf: N1,
  kindOfTest: xi,
  endsWith: KW,
  toArray: MW,
  forEachEntry: VW,
  matchAll: GW,
  isHTMLForm: WW,
  hasOwnProperty: M4,
  hasOwnProp: M4,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: RA,
  freezeMethods: YW,
  toObjectSet: JW,
  toCamelCase: ZW,
  noop: QW,
  toFiniteNumber: eZ,
  findKey: UA,
  global: au,
  isContextDefined: $A,
  ALPHABET: zA,
  generateString: tZ,
  isSpecCompliantForm: rZ,
  toJSONObject: nZ,
  isAsyncFn: oZ,
  isThenable: iZ,
  setImmediate: HA,
  asap: sZ
};
function rt(e, t, r, n, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), o && (this.response = o, this.status = o.status ? o.status : null);
}
J.inherits(rt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: J.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var LA = rt.prototype;
var jA = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  jA[e] = { value: e };
});
Object.defineProperties(rt, jA);
Object.defineProperty(LA, "isAxiosError", { value: true });
rt.from = (e, t, r, n, o, i) => {
  const s = Object.create(LA);
  return J.toFlatObject(e, s, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), rt.call(s, e.message, t, r, n, o), s.cause = e, s.name = e.name, i && Object.assign(s, i), s;
};
var aZ = null;
function Lw(e) {
  return J.isPlainObject(e) || J.isArray(e);
}
function FA(e) {
  return J.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function V4(e, t, r) {
  return e ? e.concat(t).map(function(o, i) {
    return o = FA(o), !r && i ? "[" + o + "]" : o;
  }).join(r ? "." : "") : t;
}
function cZ(e) {
  return J.isArray(e) && !e.some(Lw);
}
var uZ = J.toFlatObject(J, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function R1(e, t, r) {
  if (!J.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = J.toFlatObject(r, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function(b, w) {
    return !J.isUndefined(w[b]);
  });
  const n = r.metaTokens, o = r.visitor || l, i = r.dots, s = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && J.isSpecCompliantForm(t);
  if (!J.isFunction(o))
    throw new TypeError("visitor must be a function");
  function u(y) {
    if (y === null) return "";
    if (J.isDate(y))
      return y.toISOString();
    if (!c && J.isBlob(y))
      throw new rt("Blob is not supported. Use a Buffer instead.");
    return J.isArrayBuffer(y) || J.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
  }
  function l(y, b, w) {
    let v = y;
    if (y && !w && typeof y == "object") {
      if (J.endsWith(b, "{}"))
        b = n ? b : b.slice(0, -2), y = JSON.stringify(y);
      else if (J.isArray(y) && cZ(y) || (J.isFileList(y) || J.endsWith(b, "[]")) && (v = J.toArray(y)))
        return b = FA(b), v.forEach(function(x, _) {
          !(J.isUndefined(x) || x === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === true ? V4([b], _, i) : s === null ? b : b + "[]",
            u(x)
          );
        }), false;
    }
    return Lw(y) ? true : (t.append(V4(w, b, i), u(y)), false);
  }
  const f = [], d = Object.assign(uZ, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: Lw
  });
  function m(y, b) {
    if (!J.isUndefined(y)) {
      if (f.indexOf(y) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      f.push(y), J.forEach(y, function(v, k) {
        (!(J.isUndefined(v) || v === null) && o.call(
          t,
          v,
          J.isString(k) ? k.trim() : k,
          b,
          d
        )) === true && m(v, b ? b.concat(k) : [k]);
      }), f.pop();
    }
  }
  if (!J.isObject(e))
    throw new TypeError("data must be an object");
  return m(e), t;
}
function G4(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function v3(e, t) {
  this._pairs = [], e && R1(e, this, t);
}
var DA = v3.prototype;
DA.append = function(t, r) {
  this._pairs.push([t, r]);
};
DA.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, G4);
  } : G4;
  return this._pairs.map(function(o) {
    return r(o[0]) + "=" + r(o[1]);
  }, "").join("&");
};
function lZ(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function KA(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || lZ, o = r && r.serialize;
  let i;
  if (o ? i = o(t, r) : i = J.isURLSearchParams(t) ? t.toString() : new v3(t, r).toString(n), i) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
}
var W4 = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : false,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    J.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
};
var MA = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var fZ = typeof URLSearchParams < "u" ? URLSearchParams : v3;
var dZ = typeof FormData < "u" ? FormData : null;
var hZ = typeof Blob < "u" ? Blob : null;
var pZ = {
  isBrowser: true,
  classes: {
    URLSearchParams: fZ,
    FormData: dZ,
    Blob: hZ
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
var E3 = typeof window < "u" && typeof document < "u";
var jw = typeof navigator == "object" && navigator || void 0;
var gZ = E3 && (!jw || ["ReactNative", "NativeScript", "NS"].indexOf(jw.product) < 0);
var mZ = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function";
var bZ = E3 && window.location.href || "http://localhost";
var yZ = Object.freeze(Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: E3,
  hasStandardBrowserEnv: gZ,
  hasStandardBrowserWebWorkerEnv: mZ,
  navigator: jw,
  origin: bZ
}, Symbol.toStringTag, { value: "Module" }));
var Gn = {
  ...yZ,
  ...pZ
};
function wZ(e, t) {
  return R1(e, new Gn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, o, i) {
      return Gn.isNode && J.isBuffer(r) ? (this.append(n, r.toString("base64")), false) : i.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function vZ(e) {
  return J.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function EZ(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const o = r.length;
  let i;
  for (n = 0; n < o; n++)
    i = r[n], t[i] = e[i];
  return t;
}
function qA(e) {
  function t(r, n, o, i) {
    let s = r[i++];
    if (s === "__proto__") return true;
    const a = Number.isFinite(+s), c = i >= r.length;
    return s = !s && J.isArray(o) ? o.length : s, c ? (J.hasOwnProp(o, s) ? o[s] = [o[s], n] : o[s] = n, !a) : ((!o[s] || !J.isObject(o[s])) && (o[s] = []), t(r, n, o[s], i) && J.isArray(o[s]) && (o[s] = EZ(o[s])), !a);
  }
  if (J.isFormData(e) && J.isFunction(e.entries)) {
    const r = {};
    return J.forEachEntry(e, (n, o) => {
      t(vZ(n), o, r, 0);
    }), r;
  }
  return null;
}
function xZ(e, t, r) {
  if (J.isString(e))
    try {
      return (t || JSON.parse)(e), J.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (0, JSON.stringify)(e);
}
var Fh = {
  transitional: MA,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", o = n.indexOf("application/json") > -1, i = J.isObject(t);
    if (i && J.isHTMLForm(t) && (t = new FormData(t)), J.isFormData(t))
      return o ? JSON.stringify(qA(t)) : t;
    if (J.isArrayBuffer(t) || J.isBuffer(t) || J.isStream(t) || J.isFile(t) || J.isBlob(t) || J.isReadableStream(t))
      return t;
    if (J.isArrayBufferView(t))
      return t.buffer;
    if (J.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), t.toString();
    let a;
    if (i) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return wZ(t, this.formSerializer).toString();
      if ((a = J.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return R1(
          a ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return i || o ? (r.setContentType("application/json", false), xZ(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || Fh.transitional, n = r && r.forcedJSONParsing, o = this.responseType === "json";
    if (J.isResponse(t) || J.isReadableStream(t))
      return t;
    if (t && J.isString(t) && (n && !this.responseType || o)) {
      const s = !(r && r.silentJSONParsing) && o;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (s)
          throw a.name === "SyntaxError" ? rt.from(a, rt.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Gn.classes.FormData,
    Blob: Gn.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
J.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Fh.headers[e] = {};
});
var kZ = J.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var AZ = (e) => {
  const t = {};
  let r, n, o;
  return e && e.split(`
`).forEach(function(s) {
    o = s.indexOf(":"), r = s.substring(0, o).trim().toLowerCase(), n = s.substring(o + 1).trim(), !(!r || t[r] && kZ[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
};
var Z4 = Symbol("internals");
function nd(e) {
  return e && String(e).trim().toLowerCase();
}
function d0(e) {
  return e === false || e == null ? e : J.isArray(e) ? e.map(d0) : String(e);
}
function SZ(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
var _Z = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Yb(e, t, r, n, o) {
  if (J.isFunction(n))
    return n.call(this, t, r);
  if (o && (t = r), !!J.isString(t)) {
    if (J.isString(n))
      return t.indexOf(n) !== -1;
    if (J.isRegExp(n))
      return n.test(t);
  }
}
function TZ(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function PZ(e, t) {
  const r = J.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(o, i, s) {
        return this[n].call(this, t, o, i, s);
      },
      configurable: true
    });
  });
}
var Wn = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const o = this;
    function i(a, c, u) {
      const l = nd(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const f = J.findKey(o, l);
      (!f || o[f] === void 0 || u === true || u === void 0 && o[f] !== false) && (o[f || c] = d0(a));
    }
    const s = (a, c) => J.forEach(a, (u, l) => i(u, l, c));
    if (J.isPlainObject(t) || t instanceof this.constructor)
      s(t, r);
    else if (J.isString(t) && (t = t.trim()) && !_Z(t))
      s(AZ(t), r);
    else if (J.isHeaders(t))
      for (const [a, c] of t.entries())
        i(c, a, n);
    else
      t != null && i(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = nd(t), t) {
      const n = J.findKey(this, t);
      if (n) {
        const o = this[n];
        if (!r)
          return o;
        if (r === true)
          return SZ(o);
        if (J.isFunction(r))
          return r.call(this, o, n);
        if (J.isRegExp(r))
          return r.exec(o);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = nd(t), t) {
      const n = J.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || Yb(this, this[n], n, r)));
    }
    return false;
  }
  delete(t, r) {
    const n = this;
    let o = false;
    function i(s) {
      if (s = nd(s), s) {
        const a = J.findKey(n, s);
        a && (!r || Yb(n, n[a], a, r)) && (delete n[a], o = true);
      }
    }
    return J.isArray(t) ? t.forEach(i) : i(t), o;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, o = false;
    for (; n--; ) {
      const i = r[n];
      (!t || Yb(this, this[i], i, t, true)) && (delete this[i], o = true);
    }
    return o;
  }
  normalize(t) {
    const r = this, n = {};
    return J.forEach(this, (o, i) => {
      const s = J.findKey(n, i);
      if (s) {
        r[s] = d0(o), delete r[i];
        return;
      }
      const a = t ? TZ(i) : String(i).trim();
      a !== i && delete r[i], r[a] = d0(o), n[a] = true;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return J.forEach(this, (n, o) => {
      n != null && n !== false && (r[o] = t && J.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((o) => n.set(o)), n;
  }
  static accessor(t) {
    const n = (this[Z4] = this[Z4] = {
      accessors: {}
    }).accessors, o = this.prototype;
    function i(s) {
      const a = nd(s);
      n[a] || (PZ(o, s), n[a] = true);
    }
    return J.isArray(t) ? t.forEach(i) : i(t), this;
  }
};
Wn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
J.reduceDescriptors(Wn.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
J.freezeMethods(Wn);
function Jb(e, t) {
  const r = this || Fh, n = t || r, o = Wn.from(n.headers);
  let i = n.data;
  return J.forEach(e, function(a) {
    i = a.call(r, i, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), i;
}
function VA(e) {
  return !!(e && e.__CANCEL__);
}
function Bf(e, t, r) {
  rt.call(this, e ?? "canceled", rt.ERR_CANCELED, t, r), this.name = "CanceledError";
}
J.inherits(Bf, rt, {
  __CANCEL__: true
});
function GA(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new rt(
    "Request failed with status code " + r.status,
    [rt.ERR_BAD_REQUEST, rt.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function IZ(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function OZ(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let o = 0, i = 0, s;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const u = Date.now(), l = n[i];
    s || (s = u), r[o] = c, n[o] = u;
    let f = i, d = 0;
    for (; f !== o; )
      d += r[f++], f = f % e;
    if (o = (o + 1) % e, o === i && (i = (i + 1) % e), u - s < t)
      return;
    const m = l && u - l;
    return m ? Math.round(d * 1e3 / m) : void 0;
  };
}
function BZ(e, t) {
  let r = 0, n = 1e3 / t, o, i;
  const s = (u, l = Date.now()) => {
    r = l, o = null, i && (clearTimeout(i), i = null), e.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), f = l - r;
    f >= n ? s(u, l) : (o = u, i || (i = setTimeout(() => {
      i = null, s(o);
    }, n - f)));
  }, () => o && s(o)];
}
var ag = (e, t, r = 3) => {
  let n = 0;
  const o = OZ(50, 250);
  return BZ((i) => {
    const s = i.loaded, a = i.lengthComputable ? i.total : void 0, c = s - n, u = o(c), l = s <= a;
    n = s;
    const f = {
      loaded: s,
      total: a,
      progress: a ? s / a : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && a && l ? (a - s) / u : void 0,
      event: i,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: true
    };
    e(f);
  }, r);
};
var X4 = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
};
var Y4 = (e) => (...t) => J.asap(() => e(...t));
var CZ = Gn.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = Gn.navigator && /(msie|trident)/i.test(Gn.navigator.userAgent), r = document.createElement("a");
    let n;
    function o(i) {
      let s = i;
      return t && (r.setAttribute("href", s), s = r.href), r.setAttribute("href", s), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return n = o(window.location.href), function(s) {
      const a = J.isString(s) ? o(s) : s;
      return a.protocol === n.protocol && a.host === n.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return true;
    };
  }()
);
var NZ = Gn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, o, i) {
      const s = [e + "=" + encodeURIComponent(t)];
      J.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), J.isString(n) && s.push("path=" + n), J.isString(o) && s.push("domain=" + o), i === true && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function UZ(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function $Z(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function WA(e, t) {
  return e && !UZ(t) ? $Z(e, t) : t;
}
var J4 = (e) => e instanceof Wn ? { ...e } : e;
function Cu(e, t) {
  t = t || {};
  const r = {};
  function n(u, l, f) {
    return J.isPlainObject(u) && J.isPlainObject(l) ? J.merge.call({ caseless: f }, u, l) : J.isPlainObject(l) ? J.merge({}, l) : J.isArray(l) ? l.slice() : l;
  }
  function o(u, l, f) {
    if (J.isUndefined(l)) {
      if (!J.isUndefined(u))
        return n(void 0, u, f);
    } else return n(u, l, f);
  }
  function i(u, l) {
    if (!J.isUndefined(l))
      return n(void 0, l);
  }
  function s(u, l) {
    if (J.isUndefined(l)) {
      if (!J.isUndefined(u))
        return n(void 0, u);
    } else return n(void 0, l);
  }
  function a(u, l, f) {
    if (f in t)
      return n(u, l);
    if (f in e)
      return n(void 0, u);
  }
  const c = {
    url: i,
    method: i,
    data: i,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: a,
    headers: (u, l) => o(J4(u), J4(l), true)
  };
  return J.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const f = c[l] || o, d = f(e[l], t[l], l);
    J.isUndefined(d) && f !== a || (r[l] = d);
  }), r;
}
var ZA = (e) => {
  const t = Cu({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: o, xsrfCookieName: i, headers: s, auth: a } = t;
  t.headers = s = Wn.from(s), t.url = KA(WA(t.baseURL, t.url), e.params, e.paramsSerializer), a && s.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (J.isFormData(r)) {
    if (Gn.hasStandardBrowserEnv || Gn.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((c = s.getContentType()) !== false) {
      const [u, ...l] = c ? c.split(";").map((f) => f.trim()).filter(Boolean) : [];
      s.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (Gn.hasStandardBrowserEnv && (n && J.isFunction(n) && (n = n(t)), n || n !== false && CZ(t.url))) {
    const u = o && i && NZ.read(i);
    u && s.set(o, u);
  }
  return t;
};
var RZ = typeof XMLHttpRequest < "u";
var zZ = RZ && function(e) {
  return new Promise(function(r, n) {
    const o = ZA(e);
    let i = o.data;
    const s = Wn.from(o.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: u } = o, l, f, d, m, y;
    function b() {
      m && m(), y && y(), o.cancelToken && o.cancelToken.unsubscribe(l), o.signal && o.signal.removeEventListener("abort", l);
    }
    let w = new XMLHttpRequest();
    w.open(o.method.toUpperCase(), o.url, true), w.timeout = o.timeout;
    function v() {
      if (!w)
        return;
      const x = Wn.from(
        "getAllResponseHeaders" in w && w.getAllResponseHeaders()
      ), I = {
        data: !a || a === "text" || a === "json" ? w.responseText : w.response,
        status: w.status,
        statusText: w.statusText,
        headers: x,
        config: e,
        request: w
      };
      GA(function($) {
        r($), b();
      }, function($) {
        n($), b();
      }, I), w = null;
    }
    "onloadend" in w ? w.onloadend = v : w.onreadystatechange = function() {
      !w || w.readyState !== 4 || w.status === 0 && !(w.responseURL && w.responseURL.indexOf("file:") === 0) || setTimeout(v);
    }, w.onabort = function() {
      w && (n(new rt("Request aborted", rt.ECONNABORTED, e, w)), w = null);
    }, w.onerror = function() {
      n(new rt("Network Error", rt.ERR_NETWORK, e, w)), w = null;
    }, w.ontimeout = function() {
      let _ = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
      const I = o.transitional || MA;
      o.timeoutErrorMessage && (_ = o.timeoutErrorMessage), n(new rt(
        _,
        I.clarifyTimeoutError ? rt.ETIMEDOUT : rt.ECONNABORTED,
        e,
        w
      )), w = null;
    }, i === void 0 && s.setContentType(null), "setRequestHeader" in w && J.forEach(s.toJSON(), function(_, I) {
      w.setRequestHeader(I, _);
    }), J.isUndefined(o.withCredentials) || (w.withCredentials = !!o.withCredentials), a && a !== "json" && (w.responseType = o.responseType), u && ([d, y] = ag(u, true), w.addEventListener("progress", d)), c && w.upload && ([f, m] = ag(c), w.upload.addEventListener("progress", f), w.upload.addEventListener("loadend", m)), (o.cancelToken || o.signal) && (l = (x) => {
      w && (n(!x || x.type ? new Bf(null, e, w) : x), w.abort(), w = null);
    }, o.cancelToken && o.cancelToken.subscribe(l), o.signal && (o.signal.aborted ? l() : o.signal.addEventListener("abort", l)));
    const k = IZ(o.url);
    if (k && Gn.protocols.indexOf(k) === -1) {
      n(new rt("Unsupported protocol " + k + ":", rt.ERR_BAD_REQUEST, e));
      return;
    }
    w.send(i || null);
  });
};
var HZ = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), o;
    const i = function(u) {
      if (!o) {
        o = true, a();
        const l = u instanceof Error ? u : this.reason;
        n.abort(l instanceof rt ? l : new Bf(l instanceof Error ? l.message : l));
      }
    };
    let s = t && setTimeout(() => {
      s = null, i(new rt(`timeout ${t} of ms exceeded`, rt.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(i) : u.removeEventListener("abort", i);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", i));
    const { signal: c } = n;
    return c.unsubscribe = () => J.asap(a), c;
  }
};
var LZ = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let n = 0, o;
  for (; n < r; )
    o = n + t, yield e.slice(n, o), n = o;
};
var jZ = async function* (e, t) {
  for await (const r of FZ(e))
    yield* LZ(r, t);
};
var FZ = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
};
var Q4 = (e, t, r, n) => {
  const o = jZ(e, t);
  let i = 0, s, a = (c) => {
    s || (s = true, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await o.next();
        if (u) {
          a(), c.close();
          return;
        }
        let f = l.byteLength;
        if (r) {
          let d = i += f;
          r(d);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw a(u), u;
      }
    },
    cancel(c) {
      return a(c), o.return();
    }
  }, {
    highWaterMark: 2
  });
};
var z1 = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function";
var XA = z1 && typeof ReadableStream == "function";
var DZ = z1 && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer()));
var YA = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return false;
  }
};
var KZ = XA && YA(() => {
  let e = false;
  const t = new Request(Gn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = true, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
});
var e6 = 64 * 1024;
var Fw = XA && YA(() => J.isReadableStream(new Response("").body));
var cg = {
  stream: Fw && ((e) => e.body)
};
z1 && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !cg[t] && (cg[t] = J.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new rt(`Response type '${t}' is not supported`, rt.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
var MZ = async (e) => {
  if (e == null)
    return 0;
  if (J.isBlob(e))
    return e.size;
  if (J.isSpecCompliantForm(e))
    return (await new Request(Gn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (J.isArrayBufferView(e) || J.isArrayBuffer(e))
    return e.byteLength;
  if (J.isURLSearchParams(e) && (e = e + ""), J.isString(e))
    return (await DZ(e)).byteLength;
};
var qZ = async (e, t) => {
  const r = J.toFiniteNumber(e.getContentLength());
  return r ?? MZ(t);
};
var VZ = z1 && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: o,
    cancelToken: i,
    timeout: s,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: f = "same-origin",
    fetchOptions: d
  } = ZA(e);
  u = u ? (u + "").toLowerCase() : "text";
  let m = HZ([o, i && i.toAbortSignal()], s), y;
  const b = m && m.unsubscribe && (() => {
    m.unsubscribe();
  });
  let w;
  try {
    if (c && KZ && r !== "get" && r !== "head" && (w = await qZ(l, n)) !== 0) {
      let I = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), P;
      if (J.isFormData(n) && (P = I.headers.get("content-type")) && l.setContentType(P), I.body) {
        const [$, L] = X4(
          w,
          ag(Y4(c))
        );
        n = Q4(I.body, e6, $, L);
      }
    }
    J.isString(f) || (f = f ? "include" : "omit");
    const v = "credentials" in Request.prototype;
    y = new Request(t, {
      ...d,
      signal: m,
      method: r.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: v ? f : void 0
    });
    let k = await fetch(y);
    const x = Fw && (u === "stream" || u === "response");
    if (Fw && (a || x && b)) {
      const I = {};
      ["status", "statusText", "headers"].forEach((V) => {
        I[V] = k[V];
      });
      const P = J.toFiniteNumber(k.headers.get("content-length")), [$, L] = a && X4(
        P,
        ag(Y4(a), true)
      ) || [];
      k = new Response(
        Q4(k.body, e6, $, () => {
          L && L(), b && b();
        }),
        I
      );
    }
    u = u || "text";
    let _ = await cg[J.findKey(cg, u) || "text"](k, e);
    return !x && b && b(), await new Promise((I, P) => {
      GA(I, P, {
        data: _,
        headers: Wn.from(k.headers),
        status: k.status,
        statusText: k.statusText,
        config: e,
        request: y
      });
    });
  } catch (v) {
    throw b && b(), v && v.name === "TypeError" && /fetch/i.test(v.message) ? Object.assign(
      new rt("Network Error", rt.ERR_NETWORK, e, y),
      {
        cause: v.cause || v
      }
    ) : rt.from(v, v && v.code, e, y);
  }
});
var Dw = {
  http: aZ,
  xhr: zZ,
  fetch: VZ
};
J.forEach(Dw, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
var t6 = (e) => `- ${e}`;
var GZ = (e) => J.isFunction(e) || e === null || e === false;
var JA = {
  getAdapter: (e) => {
    e = J.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const o = {};
    for (let i = 0; i < t; i++) {
      r = e[i];
      let s;
      if (n = r, !GZ(r) && (n = Dw[(s = String(r)).toLowerCase()], n === void 0))
        throw new rt(`Unknown adapter '${s}'`);
      if (n)
        break;
      o[s || "#" + i] = n;
    }
    if (!n) {
      const i = Object.entries(o).map(
        ([a, c]) => `adapter ${a} ` + (c === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? i.length > 1 ? `since :
` + i.map(t6).join(`
`) : " " + t6(i[0]) : "as no adapter specified";
      throw new rt(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: Dw
};
function Qb(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Bf(null, e);
}
function r6(e) {
  return Qb(e), e.headers = Wn.from(e.headers), e.data = Jb.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", false), JA.getAdapter(e.adapter || Fh.adapter)(e).then(function(n) {
    return Qb(e), n.data = Jb.call(
      e,
      e.transformResponse,
      n
    ), n.headers = Wn.from(n.headers), n;
  }, function(n) {
    return VA(n) || (Qb(e), n && n.response && (n.response.data = Jb.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = Wn.from(n.response.headers))), Promise.reject(n);
  });
}
var QA = "1.7.7";
var x3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  x3[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
var n6 = {};
x3.transitional = function(t, r, n) {
  function o(i, s) {
    return "[Axios v" + QA + "] Transitional option '" + i + "'" + s + (n ? ". " + n : "");
  }
  return (i, s, a) => {
    if (t === false)
      throw new rt(
        o(s, " has been removed" + (r ? " in " + r : "")),
        rt.ERR_DEPRECATED
      );
    return r && !n6[s] && (n6[s] = true, console.warn(
      o(
        s,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(i, s, a) : true;
  };
};
function WZ(e, t, r) {
  if (typeof e != "object")
    throw new rt("options must be an object", rt.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let o = n.length;
  for (; o-- > 0; ) {
    const i = n[o], s = t[i];
    if (s) {
      const a = e[i], c = a === void 0 || s(a, i, e);
      if (c !== true)
        throw new rt("option " + i + " must be " + c, rt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== true)
      throw new rt("Unknown option " + i, rt.ERR_BAD_OPTION);
  }
}
var Kw = {
  assertOptions: WZ,
  validators: x3
};
var Ta = Kw.validators;
var wu = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new W4(),
      response: new W4()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let o;
        Error.captureStackTrace ? Error.captureStackTrace(o = {}) : o = new Error();
        const i = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? i && !String(n.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + i) : n.stack = i;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = Cu(this.defaults, r);
    const { transitional: n, paramsSerializer: o, headers: i } = r;
    n !== void 0 && Kw.assertOptions(n, {
      silentJSONParsing: Ta.transitional(Ta.boolean),
      forcedJSONParsing: Ta.transitional(Ta.boolean),
      clarifyTimeoutError: Ta.transitional(Ta.boolean)
    }, false), o != null && (J.isFunction(o) ? r.paramsSerializer = {
      serialize: o
    } : Kw.assertOptions(o, {
      encode: Ta.function,
      serialize: Ta.function
    }, true)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let s = i && J.merge(
      i.common,
      i[r.method]
    );
    i && J.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete i[y];
      }
    ), r.headers = Wn.concat(s, i);
    const a = [];
    let c = true;
    this.interceptors.request.forEach(function(b) {
      typeof b.runWhen == "function" && b.runWhen(r) === false || (c = c && b.synchronous, a.unshift(b.fulfilled, b.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(b) {
      u.push(b.fulfilled, b.rejected);
    });
    let l, f = 0, d;
    if (!c) {
      const y = [r6.bind(this), void 0];
      for (y.unshift.apply(y, a), y.push.apply(y, u), d = y.length, l = Promise.resolve(r); f < d; )
        l = l.then(y[f++], y[f++]);
      return l;
    }
    d = a.length;
    let m = r;
    for (f = 0; f < d; ) {
      const y = a[f++], b = a[f++];
      try {
        m = y(m);
      } catch (w) {
        b.call(this, w);
        break;
      }
    }
    try {
      l = r6.call(this, m);
    } catch (y) {
      return Promise.reject(y);
    }
    for (f = 0, d = u.length; f < d; )
      l = l.then(u[f++], u[f++]);
    return l;
  }
  getUri(t) {
    t = Cu(this.defaults, t);
    const r = WA(t.baseURL, t.url);
    return KA(r, t.params, t.paramsSerializer);
  }
};
J.forEach(["delete", "get", "head", "options"], function(t) {
  wu.prototype[t] = function(r, n) {
    return this.request(Cu(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
J.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(i, s, a) {
      return this.request(Cu(a || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: i,
        data: s
      }));
    };
  }
  wu.prototype[t] = r(), wu.prototype[t + "Form"] = r(true);
});
var k3 = class _k3 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(i) {
      r = i;
    });
    const n = this;
    this.promise.then((o) => {
      if (!n._listeners) return;
      let i = n._listeners.length;
      for (; i-- > 0; )
        n._listeners[i](o);
      n._listeners = null;
    }), this.promise.then = (o) => {
      let i;
      const s = new Promise((a) => {
        n.subscribe(a), i = a;
      }).then(o);
      return s.cancel = function() {
        n.unsubscribe(i);
      }, s;
    }, t(function(i, s, a) {
      n.reason || (n.reason = new Bf(i, s, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new _k3(function(o) {
        t = o;
      }),
      cancel: t
    };
  }
};
function ZZ(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function XZ(e) {
  return J.isObject(e) && e.isAxiosError === true;
}
var Mw = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Mw).forEach(([e, t]) => {
  Mw[t] = e;
});
function eS(e) {
  const t = new wu(e), r = BA(wu.prototype.request, t);
  return J.extend(r, wu.prototype, t, { allOwnKeys: true }), J.extend(r, t, null, { allOwnKeys: true }), r.create = function(o) {
    return eS(Cu(e, o));
  }, r;
}
var hr = eS(Fh);
hr.Axios = wu;
hr.CanceledError = Bf;
hr.CancelToken = k3;
hr.isCancel = VA;
hr.VERSION = QA;
hr.toFormData = R1;
hr.AxiosError = rt;
hr.Cancel = hr.CanceledError;
hr.all = function(t) {
  return Promise.all(t);
};
hr.spread = ZZ;
hr.isAxiosError = XZ;
hr.mergeConfig = Cu;
hr.AxiosHeaders = Wn;
hr.formToJSON = (e) => qA(J.isHTMLForm(e) ? new FormData(e) : e);
hr.getAdapter = JA.getAdapter;
hr.HttpStatusCode = Mw;
hr.default = hr;
var YZ = "https://mempool.space";
var JZ = "https://mempool.space/testnet";
var QZ = "https://mempool.space/testnet4";
var eX = "https://mempool.space/signet";
var tX = "https://mempool.fractalbitcoin.io";
var rX = "https://mempool-testnet.fractalbitcoin.io";
var H1 = (e) => e === Mt ? JZ : e === Br ? QZ : e === Vr ? eX : e === no ? tX : e === Cr ? rX : YZ;
var $we = "text/html";
var Rwe = "text/css";
var nX = "text/plain";
var zwe = "text/javascript";
var Hwe = "text/markdown";
var Lwe = "application/json";
var jwe = "application/javascript";
var Fwe = "application/xml";
var Dwe = "application/pdf";
var Kwe = "application/zip";
var Mwe = "application/gzip";
var qwe = "application/xhtml+xml";
var Vwe = "application/rss+xml";
var Gwe = "application/atom+xml";
var Wwe = "application/x-www-form-urlencoded";
var Zwe = "application/octet-stream";
var Xwe = "image/jpeg";
var Ywe = "image/png";
var Jwe = "image/gif";
var Qwe = "image/svg+xml";
var e2e = "image/webp";
var t2e = "image/x-icon";
var r2e = "video/mp4";
var n2e = "video/webm";
var o2e = "video/ogg";
var i2e = "audio/mpeg";
var s2e = "audio/wav";
var a2e = "audio/ogg";
var c2e = "multipart/form-data";
Jx(b3);
var Gr = (e) => e === Mt || e === Br || e === Vr ? VC : Ei;
var A3 = (e) => e.find(({ purpose: t }) => t === "ordinals");
var S3 = (e) => e.find(({ purpose: t }) => t === "payment");
var Cf = async (e, t) => {
  try {
    const r = await _3(e, t);
    return r ? r.reduce((n, o) => n + BigInt(o.value), 0n) : 0n;
  } catch (r) {
    throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
  }
};
function oX(e, t, r) {
  const a = e * 57 + t * 41, c = r * 34;
  return 10 + a + c;
}
async function _3(e, t) {
  if (e.startsWith("t")) {
    if (t === Tt)
      return [];
    if (t === no)
      return [];
    if (t === Cr)
      return [];
  }
  return await hr.get(`${H1(t)}/api/address/${e}/utxo`).then((r) => r.data);
}
async function T3(e, t, r, n, o, i, s = 7) {
  const a = e === t, c = await _3(t, i);
  if (!c)
    throw new Error("No UTXOs found");
  const u = c.sort((b, w) => w.value - b.value), l = new Zt({ network: Gr(i) }), f = oX(1, 0, 2), d = Math.floor(f * s) + n;
  let m = 0, y = 0;
  for await (let b of u) {
    const { txid: w, vout: v, value: k } = b, x = hv(t, Gr(i));
    if (l.addInput({
      hash: w,
      index: v,
      witnessUtxo: {
        script: x,
        value: BigInt(k)
      }
    }), !a) {
      const _ = tS(o, i);
      l.updateInput(y, { redeemScript: _ });
    }
    if (m += k, m >= d)
      break;
  }
  if (m < d)
    throw new Error("Insufficient funds");
  return l.addOutput({
    address: r,
    value: BigInt(n)
  }), m > d && l.addOutput({
    address: t,
    value: BigInt(m - d)
  }), {
    psbtBase64: l.toBase64(),
    psbtHex: l.toHex()
  };
}
function tS(e, t) {
  var o;
  const r = _h({
    pubkey: kA.Buffer.from(e, "hex"),
    network: Gr(t)
  }), n = kf({
    redeem: r,
    network: Gr(t)
  });
  return (o = n == null ? void 0 : n.redeem) == null ? void 0 : o.output;
}
function iX(e) {
  return e == null ? void 0 : e.reduce((t, r) => t + r.value, 0);
}
async function P3(e, t) {
  return (await hr.post(`${H1(t)}/api/tx`, e, {
    headers: {
      "Content-Type": "text/plain"
    }
  })).data;
}
var sX = (e, t) => {
  try {
    const r = Gr(t), n = u7(e);
    if (n.version === r.pubKeyHash)
      return KC;
    if (n.version === r.scriptHash) {
      const o = ar(n.hash);
      return o && o.length === 2 && o[0] === Rt.OP_0 ? MC : Ax;
    }
  } catch {
    try {
      const n = dv(e);
      if (n.version === 0 && n.data.length === 20)
        return Jy;
      if (n.version === 0 && n.data.length === 32)
        return qC;
      if (n.version === 1 && n.data.length === 32)
        return bd;
    } catch {
      return "unknown";
    }
  }
  return "unknown";
};
var I3 = (e) => e === Mt || e === Br || e === Vr;
var O3 = (e) => e === Tt || e === no || e === Cr;
var ns = {};
var Yr = {};
var We = {};
Object.defineProperty(We, "__esModule", { value: true });
We.add5L = We.add5H = We.add4H = We.add4L = We.add3H = We.add3L = We.rotlBL = We.rotlBH = We.rotlSL = We.rotlSH = We.rotr32L = We.rotr32H = We.rotrBL = We.rotrBH = We.rotrSL = We.rotrSH = We.shrSL = We.shrSH = We.toBig = void 0;
We.fromBig = B3;
We.split = rS;
We.add = mS;
var Ip = BigInt(2 ** 32 - 1);
var qw = BigInt(32);
function B3(e, t = false) {
  return t ? { h: Number(e & Ip), l: Number(e >> qw & Ip) } : { h: Number(e >> qw & Ip) | 0, l: Number(e & Ip) | 0 };
}
function rS(e, t = false) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: i, l: s } = B3(e[o], t);
    [r[o], n[o]] = [i, s];
  }
  return [r, n];
}
var nS = (e, t) => BigInt(e >>> 0) << qw | BigInt(t >>> 0);
We.toBig = nS;
var oS = (e, t, r) => e >>> r;
We.shrSH = oS;
var iS = (e, t, r) => e << 32 - r | t >>> r;
We.shrSL = iS;
var sS = (e, t, r) => e >>> r | t << 32 - r;
We.rotrSH = sS;
var aS = (e, t, r) => e << 32 - r | t >>> r;
We.rotrSL = aS;
var cS = (e, t, r) => e << 64 - r | t >>> r - 32;
We.rotrBH = cS;
var uS = (e, t, r) => e >>> r - 32 | t << 64 - r;
We.rotrBL = uS;
var lS = (e, t) => t;
We.rotr32H = lS;
var fS = (e, t) => e;
We.rotr32L = fS;
var dS = (e, t, r) => e << r | t >>> 32 - r;
We.rotlSH = dS;
var hS = (e, t, r) => t << r | e >>> 32 - r;
We.rotlSL = hS;
var pS = (e, t, r) => t << r - 32 | e >>> 64 - r;
We.rotlBH = pS;
var gS = (e, t, r) => e << r - 32 | t >>> 64 - r;
We.rotlBL = gS;
function mS(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
var bS = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
We.add3L = bS;
var yS = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
We.add3H = yS;
var wS = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
We.add4L = wS;
var vS = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
We.add4H = vS;
var ES = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
We.add5L = ES;
var xS = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0;
We.add5H = xS;
var aX = {
  fromBig: B3,
  split: rS,
  toBig: nS,
  shrSH: oS,
  shrSL: iS,
  rotrSH: sS,
  rotrSL: aS,
  rotrBH: cS,
  rotrBL: uS,
  rotr32H: lS,
  rotr32L: fS,
  rotlSH: dS,
  rotlSL: hS,
  rotlBH: pS,
  rotlBL: gS,
  add: mS,
  add3L: bS,
  add3H: yS,
  add4L: wS,
  add4H: vS,
  add5H: xS,
  add5L: ES
};
We.default = aX;
Object.defineProperty(Yr, "__esModule", { value: true });
Yr.sha384 = Yr.sha512_256 = Yr.sha512_224 = Yr.sha512 = Yr.SHA384 = Yr.SHA512_256 = Yr.SHA512_224 = Yr.SHA512 = void 0;
var cX = Ls;
var ht = We;
var L1 = Nc;
var [uX, lX] = ht.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e)));
var Pa = new Uint32Array(80);
var Ia = new Uint32Array(80);
var Dh = class extends cX.HashMD {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: i, Cl: s, Dh: a, Dl: c, Eh: u, El: l, Fh: f, Fl: d, Gh: m, Gl: y, Hh: b, Hl: w } = this;
    return [t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = i | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = f | 0, this.Fl = d | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = w | 0;
  }
  process(t, r) {
    for (let x = 0; x < 16; x++, r += 4)
      Pa[x] = t.getUint32(r), Ia[x] = t.getUint32(r += 4);
    for (let x = 16; x < 80; x++) {
      const _ = Pa[x - 15] | 0, I = Ia[x - 15] | 0, P = ht.default.rotrSH(_, I, 1) ^ ht.default.rotrSH(_, I, 8) ^ ht.default.shrSH(_, I, 7), $ = ht.default.rotrSL(_, I, 1) ^ ht.default.rotrSL(_, I, 8) ^ ht.default.shrSL(_, I, 7), L = Pa[x - 2] | 0, V = Ia[x - 2] | 0, ee = ht.default.rotrSH(L, V, 19) ^ ht.default.rotrBH(L, V, 61) ^ ht.default.shrSH(L, V, 6), G = ht.default.rotrSL(L, V, 19) ^ ht.default.rotrBL(L, V, 61) ^ ht.default.shrSL(L, V, 6), N = ht.default.add4L($, G, Ia[x - 7], Ia[x - 16]), q = ht.default.add4H(N, P, ee, Pa[x - 7], Pa[x - 16]);
      Pa[x] = q | 0, Ia[x] = N | 0;
    }
    let { Ah: n, Al: o, Bh: i, Bl: s, Ch: a, Cl: c, Dh: u, Dl: l, Eh: f, El: d, Fh: m, Fl: y, Gh: b, Gl: w, Hh: v, Hl: k } = this;
    for (let x = 0; x < 80; x++) {
      const _ = ht.default.rotrSH(f, d, 14) ^ ht.default.rotrSH(f, d, 18) ^ ht.default.rotrBH(f, d, 41), I = ht.default.rotrSL(f, d, 14) ^ ht.default.rotrSL(f, d, 18) ^ ht.default.rotrBL(f, d, 41), P = f & m ^ ~f & b, $ = d & y ^ ~d & w, L = ht.default.add5L(k, I, $, lX[x], Ia[x]), V = ht.default.add5H(L, v, _, P, uX[x], Pa[x]), ee = L | 0, G = ht.default.rotrSH(n, o, 28) ^ ht.default.rotrBH(n, o, 34) ^ ht.default.rotrBH(n, o, 39), N = ht.default.rotrSL(n, o, 28) ^ ht.default.rotrBL(n, o, 34) ^ ht.default.rotrBL(n, o, 39), q = n & i ^ n & a ^ i & a, j = o & s ^ o & c ^ s & c;
      v = b | 0, k = w | 0, b = m | 0, w = y | 0, m = f | 0, y = d | 0, { h: f, l: d } = ht.default.add(u | 0, l | 0, V | 0, ee | 0), u = a | 0, l = c | 0, a = i | 0, c = s | 0, i = n | 0, s = o | 0;
      const C = ht.default.add3L(ee, N, j);
      n = ht.default.add3H(C, V, G, q), o = C | 0;
    }
    ({ h: n, l: o } = ht.default.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: i, l: s } = ht.default.add(this.Bh | 0, this.Bl | 0, i | 0, s | 0), { h: a, l: c } = ht.default.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l } = ht.default.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: f, l: d } = ht.default.add(this.Eh | 0, this.El | 0, f | 0, d | 0), { h: m, l: y } = ht.default.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: b, l: w } = ht.default.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0), { h: v, l: k } = ht.default.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, i, s, a, c, u, l, f, d, m, y, b, w, v, k);
  }
  roundClean() {
    Pa.fill(0), Ia.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Yr.SHA512 = Dh;
var kS = class extends Dh {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Yr.SHA512_224 = kS;
var AS = class extends Dh {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Yr.SHA512_256 = AS;
var SS = class extends Dh {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Yr.SHA384 = SS;
Yr.sha512 = (0, L1.wrapConstructor)(() => new Dh());
Yr.sha512_224 = (0, L1.wrapConstructor)(() => new kS());
Yr.sha512_256 = (0, L1.wrapConstructor)(() => new AS());
Yr.sha384 = (0, L1.wrapConstructor)(() => new SS());
var j1 = {};
Object.defineProperty(j1, "__esModule", { value: true });
j1.pbkdf2 = dX;
j1.pbkdf2Async = hX;
var Op = xo;
var fX = S1;
var Rl = Nc;
function _S(e, t, r, n) {
  (0, Op.hash)(e);
  const o = (0, Rl.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: i, dkLen: s, asyncTick: a } = o;
  if ((0, Op.number)(i), (0, Op.number)(s), (0, Op.number)(a), i < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const c = (0, Rl.toBytes)(t), u = (0, Rl.toBytes)(r), l = new Uint8Array(s), f = fX.hmac.create(e, c), d = f._cloneInto().update(u);
  return { c: i, dkLen: s, asyncTick: a, DK: l, PRF: f, PRFSalt: d };
}
function TS(e, t, r, n, o) {
  return e.destroy(), t.destroy(), n && n.destroy(), o.fill(0), r;
}
function dX(e, t, r, n) {
  const { c: o, dkLen: i, DK: s, PRF: a, PRFSalt: c } = _S(e, t, r, n);
  let u;
  const l = new Uint8Array(4), f = (0, Rl.createView)(l), d = new Uint8Array(a.outputLen);
  for (let m = 1, y = 0; y < i; m++, y += a.outputLen) {
    const b = s.subarray(y, y + a.outputLen);
    f.setInt32(0, m, false), (u = c._cloneInto(u)).update(l).digestInto(d), b.set(d.subarray(0, b.length));
    for (let w = 1; w < o; w++) {
      a._cloneInto(u).update(d).digestInto(d);
      for (let v = 0; v < b.length; v++)
        b[v] ^= d[v];
    }
  }
  return TS(a, c, s, u, d);
}
async function hX(e, t, r, n) {
  const { c: o, dkLen: i, asyncTick: s, DK: a, PRF: c, PRFSalt: u } = _S(e, t, r, n);
  let l;
  const f = new Uint8Array(4), d = (0, Rl.createView)(f), m = new Uint8Array(c.outputLen);
  for (let y = 1, b = 0; b < i; y++, b += c.outputLen) {
    const w = a.subarray(b, b + c.outputLen);
    d.setInt32(0, y, false), (l = u._cloneInto(l)).update(f).digestInto(m), w.set(m.subarray(0, w.length)), await (0, Rl.asyncLoop)(o - 1, s, () => {
      c._cloneInto(l).update(m).digestInto(m);
      for (let v = 0; v < w.length; v++)
        w[v] ^= m[v];
    });
  }
  return TS(c, u, a, l, m);
}
var jn = {};
var pX = [
  "abdikace",
  "abeceda",
  "adresa",
  "agrese",
  "akce",
  "aktovka",
  "alej",
  "alkohol",
  "amputace",
  "ananas",
  "andulka",
  "anekdota",
  "anketa",
  "antika",
  "anulovat",
  "archa",
  "arogance",
  "asfalt",
  "asistent",
  "aspirace",
  "astma",
  "astronom",
  "atlas",
  "atletika",
  "atol",
  "autobus",
  "azyl",
  "babka",
  "bachor",
  "bacil",
  "baculka",
  "badatel",
  "bageta",
  "bagr",
  "bahno",
  "bakterie",
  "balada",
  "baletka",
  "balkon",
  "balonek",
  "balvan",
  "balza",
  "bambus",
  "bankomat",
  "barbar",
  "baret",
  "barman",
  "baroko",
  "barva",
  "baterka",
  "batoh",
  "bavlna",
  "bazalka",
  "bazilika",
  "bazuka",
  "bedna",
  "beran",
  "beseda",
  "bestie",
  "beton",
  "bezinka",
  "bezmoc",
  "beztak",
  "bicykl",
  "bidlo",
  "biftek",
  "bikiny",
  "bilance",
  "biograf",
  "biolog",
  "bitva",
  "bizon",
  "blahobyt",
  "blatouch",
  "blecha",
  "bledule",
  "blesk",
  "blikat",
  "blizna",
  "blokovat",
  "bloudit",
  "blud",
  "bobek",
  "bobr",
  "bodlina",
  "bodnout",
  "bohatost",
  "bojkot",
  "bojovat",
  "bokorys",
  "bolest",
  "borec",
  "borovice",
  "bota",
  "boubel",
  "bouchat",
  "bouda",
  "boule",
  "bourat",
  "boxer",
  "bradavka",
  "brambora",
  "branka",
  "bratr",
  "brepta",
  "briketa",
  "brko",
  "brloh",
  "bronz",
  "broskev",
  "brunetka",
  "brusinka",
  "brzda",
  "brzy",
  "bublina",
  "bubnovat",
  "buchta",
  "buditel",
  "budka",
  "budova",
  "bufet",
  "bujarost",
  "bukvice",
  "buldok",
  "bulva",
  "bunda",
  "bunkr",
  "burza",
  "butik",
  "buvol",
  "buzola",
  "bydlet",
  "bylina",
  "bytovka",
  "bzukot",
  "capart",
  "carevna",
  "cedr",
  "cedule",
  "cejch",
  "cejn",
  "cela",
  "celer",
  "celkem",
  "celnice",
  "cenina",
  "cennost",
  "cenovka",
  "centrum",
  "cenzor",
  "cestopis",
  "cetka",
  "chalupa",
  "chapadlo",
  "charita",
  "chata",
  "chechtat",
  "chemie",
  "chichot",
  "chirurg",
  "chlad",
  "chleba",
  "chlubit",
  "chmel",
  "chmura",
  "chobot",
  "chochol",
  "chodba",
  "cholera",
  "chomout",
  "chopit",
  "choroba",
  "chov",
  "chrapot",
  "chrlit",
  "chrt",
  "chrup",
  "chtivost",
  "chudina",
  "chutnat",
  "chvat",
  "chvilka",
  "chvost",
  "chyba",
  "chystat",
  "chytit",
  "cibule",
  "cigareta",
  "cihelna",
  "cihla",
  "cinkot",
  "cirkus",
  "cisterna",
  "citace",
  "citrus",
  "cizinec",
  "cizost",
  "clona",
  "cokoliv",
  "couvat",
  "ctitel",
  "ctnost",
  "cudnost",
  "cuketa",
  "cukr",
  "cupot",
  "cvaknout",
  "cval",
  "cvik",
  "cvrkot",
  "cyklista",
  "daleko",
  "dareba",
  "datel",
  "datum",
  "dcera",
  "debata",
  "dechovka",
  "decibel",
  "deficit",
  "deflace",
  "dekl",
  "dekret",
  "demokrat",
  "deprese",
  "derby",
  "deska",
  "detektiv",
  "dikobraz",
  "diktovat",
  "dioda",
  "diplom",
  "disk",
  "displej",
  "divadlo",
  "divoch",
  "dlaha",
  "dlouho",
  "dluhopis",
  "dnes",
  "dobro",
  "dobytek",
  "docent",
  "dochutit",
  "dodnes",
  "dohled",
  "dohoda",
  "dohra",
  "dojem",
  "dojnice",
  "doklad",
  "dokola",
  "doktor",
  "dokument",
  "dolar",
  "doleva",
  "dolina",
  "doma",
  "dominant",
  "domluvit",
  "domov",
  "donutit",
  "dopad",
  "dopis",
  "doplnit",
  "doposud",
  "doprovod",
  "dopustit",
  "dorazit",
  "dorost",
  "dort",
  "dosah",
  "doslov",
  "dostatek",
  "dosud",
  "dosyta",
  "dotaz",
  "dotek",
  "dotknout",
  "doufat",
  "doutnat",
  "dovozce",
  "dozadu",
  "doznat",
  "dozorce",
  "drahota",
  "drak",
  "dramatik",
  "dravec",
  "draze",
  "drdol",
  "drobnost",
  "drogerie",
  "drozd",
  "drsnost",
  "drtit",
  "drzost",
  "duben",
  "duchovno",
  "dudek",
  "duha",
  "duhovka",
  "dusit",
  "dusno",
  "dutost",
  "dvojice",
  "dvorec",
  "dynamit",
  "ekolog",
  "ekonomie",
  "elektron",
  "elipsa",
  "email",
  "emise",
  "emoce",
  "empatie",
  "epizoda",
  "epocha",
  "epopej",
  "epos",
  "esej",
  "esence",
  "eskorta",
  "eskymo",
  "etiketa",
  "euforie",
  "evoluce",
  "exekuce",
  "exkurze",
  "expedice",
  "exploze",
  "export",
  "extrakt",
  "facka",
  "fajfka",
  "fakulta",
  "fanatik",
  "fantazie",
  "farmacie",
  "favorit",
  "fazole",
  "federace",
  "fejeton",
  "fenka",
  "fialka",
  "figurant",
  "filozof",
  "filtr",
  "finance",
  "finta",
  "fixace",
  "fjord",
  "flanel",
  "flirt",
  "flotila",
  "fond",
  "fosfor",
  "fotbal",
  "fotka",
  "foton",
  "frakce",
  "freska",
  "fronta",
  "fukar",
  "funkce",
  "fyzika",
  "galeje",
  "garant",
  "genetika",
  "geolog",
  "gilotina",
  "glazura",
  "glejt",
  "golem",
  "golfista",
  "gotika",
  "graf",
  "gramofon",
  "granule",
  "grep",
  "gril",
  "grog",
  "groteska",
  "guma",
  "hadice",
  "hadr",
  "hala",
  "halenka",
  "hanba",
  "hanopis",
  "harfa",
  "harpuna",
  "havran",
  "hebkost",
  "hejkal",
  "hejno",
  "hejtman",
  "hektar",
  "helma",
  "hematom",
  "herec",
  "herna",
  "heslo",
  "hezky",
  "historik",
  "hladovka",
  "hlasivky",
  "hlava",
  "hledat",
  "hlen",
  "hlodavec",
  "hloh",
  "hloupost",
  "hltat",
  "hlubina",
  "hluchota",
  "hmat",
  "hmota",
  "hmyz",
  "hnis",
  "hnojivo",
  "hnout",
  "hoblina",
  "hoboj",
  "hoch",
  "hodiny",
  "hodlat",
  "hodnota",
  "hodovat",
  "hojnost",
  "hokej",
  "holinka",
  "holka",
  "holub",
  "homole",
  "honitba",
  "honorace",
  "horal",
  "horda",
  "horizont",
  "horko",
  "horlivec",
  "hormon",
  "hornina",
  "horoskop",
  "horstvo",
  "hospoda",
  "hostina",
  "hotovost",
  "houba",
  "houf",
  "houpat",
  "houska",
  "hovor",
  "hradba",
  "hranice",
  "hravost",
  "hrazda",
  "hrbolek",
  "hrdina",
  "hrdlo",
  "hrdost",
  "hrnek",
  "hrobka",
  "hromada",
  "hrot",
  "hrouda",
  "hrozen",
  "hrstka",
  "hrubost",
  "hryzat",
  "hubenost",
  "hubnout",
  "hudba",
  "hukot",
  "humr",
  "husita",
  "hustota",
  "hvozd",
  "hybnost",
  "hydrant",
  "hygiena",
  "hymna",
  "hysterik",
  "idylka",
  "ihned",
  "ikona",
  "iluze",
  "imunita",
  "infekce",
  "inflace",
  "inkaso",
  "inovace",
  "inspekce",
  "internet",
  "invalida",
  "investor",
  "inzerce",
  "ironie",
  "jablko",
  "jachta",
  "jahoda",
  "jakmile",
  "jakost",
  "jalovec",
  "jantar",
  "jarmark",
  "jaro",
  "jasan",
  "jasno",
  "jatka",
  "javor",
  "jazyk",
  "jedinec",
  "jedle",
  "jednatel",
  "jehlan",
  "jekot",
  "jelen",
  "jelito",
  "jemnost",
  "jenom",
  "jepice",
  "jeseter",
  "jevit",
  "jezdec",
  "jezero",
  "jinak",
  "jindy",
  "jinoch",
  "jiskra",
  "jistota",
  "jitrnice",
  "jizva",
  "jmenovat",
  "jogurt",
  "jurta",
  "kabaret",
  "kabel",
  "kabinet",
  "kachna",
  "kadet",
  "kadidlo",
  "kahan",
  "kajak",
  "kajuta",
  "kakao",
  "kaktus",
  "kalamita",
  "kalhoty",
  "kalibr",
  "kalnost",
  "kamera",
  "kamkoliv",
  "kamna",
  "kanibal",
  "kanoe",
  "kantor",
  "kapalina",
  "kapela",
  "kapitola",
  "kapka",
  "kaple",
  "kapota",
  "kapr",
  "kapusta",
  "kapybara",
  "karamel",
  "karotka",
  "karton",
  "kasa",
  "katalog",
  "katedra",
  "kauce",
  "kauza",
  "kavalec",
  "kazajka",
  "kazeta",
  "kazivost",
  "kdekoliv",
  "kdesi",
  "kedluben",
  "kemp",
  "keramika",
  "kino",
  "klacek",
  "kladivo",
  "klam",
  "klapot",
  "klasika",
  "klaun",
  "klec",
  "klenba",
  "klepat",
  "klesnout",
  "klid",
  "klima",
  "klisna",
  "klobouk",
  "klokan",
  "klopa",
  "kloub",
  "klubovna",
  "klusat",
  "kluzkost",
  "kmen",
  "kmitat",
  "kmotr",
  "kniha",
  "knot",
  "koalice",
  "koberec",
  "kobka",
  "kobliha",
  "kobyla",
  "kocour",
  "kohout",
  "kojenec",
  "kokos",
  "koktejl",
  "kolaps",
  "koleda",
  "kolize",
  "kolo",
  "komando",
  "kometa",
  "komik",
  "komnata",
  "komora",
  "kompas",
  "komunita",
  "konat",
  "koncept",
  "kondice",
  "konec",
  "konfese",
  "kongres",
  "konina",
  "konkurs",
  "kontakt",
  "konzerva",
  "kopanec",
  "kopie",
  "kopnout",
  "koprovka",
  "korbel",
  "korektor",
  "kormidlo",
  "koroptev",
  "korpus",
  "koruna",
  "koryto",
  "korzet",
  "kosatec",
  "kostka",
  "kotel",
  "kotleta",
  "kotoul",
  "koukat",
  "koupelna",
  "kousek",
  "kouzlo",
  "kovboj",
  "koza",
  "kozoroh",
  "krabice",
  "krach",
  "krajina",
  "kralovat",
  "krasopis",
  "kravata",
  "kredit",
  "krejcar",
  "kresba",
  "kreveta",
  "kriket",
  "kritik",
  "krize",
  "krkavec",
  "krmelec",
  "krmivo",
  "krocan",
  "krok",
  "kronika",
  "kropit",
  "kroupa",
  "krovka",
  "krtek",
  "kruhadlo",
  "krupice",
  "krutost",
  "krvinka",
  "krychle",
  "krypta",
  "krystal",
  "kryt",
  "kudlanka",
  "kufr",
  "kujnost",
  "kukla",
  "kulajda",
  "kulich",
  "kulka",
  "kulomet",
  "kultura",
  "kuna",
  "kupodivu",
  "kurt",
  "kurzor",
  "kutil",
  "kvalita",
  "kvasinka",
  "kvestor",
  "kynolog",
  "kyselina",
  "kytara",
  "kytice",
  "kytka",
  "kytovec",
  "kyvadlo",
  "labrador",
  "lachtan",
  "ladnost",
  "laik",
  "lakomec",
  "lamela",
  "lampa",
  "lanovka",
  "lasice",
  "laso",
  "lastura",
  "latinka",
  "lavina",
  "lebka",
  "leckdy",
  "leden",
  "lednice",
  "ledovka",
  "ledvina",
  "legenda",
  "legie",
  "legrace",
  "lehce",
  "lehkost",
  "lehnout",
  "lektvar",
  "lenochod",
  "lentilka",
  "lepenka",
  "lepidlo",
  "letadlo",
  "letec",
  "letmo",
  "letokruh",
  "levhart",
  "levitace",
  "levobok",
  "libra",
  "lichotka",
  "lidojed",
  "lidskost",
  "lihovina",
  "lijavec",
  "lilek",
  "limetka",
  "linie",
  "linka",
  "linoleum",
  "listopad",
  "litina",
  "litovat",
  "lobista",
  "lodivod",
  "logika",
  "logoped",
  "lokalita",
  "loket",
  "lomcovat",
  "lopata",
  "lopuch",
  "lord",
  "losos",
  "lotr",
  "loudal",
  "louh",
  "louka",
  "louskat",
  "lovec",
  "lstivost",
  "lucerna",
  "lucifer",
  "lump",
  "lusk",
  "lustrace",
  "lvice",
  "lyra",
  "lyrika",
  "lysina",
  "madam",
  "madlo",
  "magistr",
  "mahagon",
  "majetek",
  "majitel",
  "majorita",
  "makak",
  "makovice",
  "makrela",
  "malba",
  "malina",
  "malovat",
  "malvice",
  "maminka",
  "mandle",
  "manko",
  "marnost",
  "masakr",
  "maskot",
  "masopust",
  "matice",
  "matrika",
  "maturita",
  "mazanec",
  "mazivo",
  "mazlit",
  "mazurka",
  "mdloba",
  "mechanik",
  "meditace",
  "medovina",
  "melasa",
  "meloun",
  "mentolka",
  "metla",
  "metoda",
  "metr",
  "mezera",
  "migrace",
  "mihnout",
  "mihule",
  "mikina",
  "mikrofon",
  "milenec",
  "milimetr",
  "milost",
  "mimika",
  "mincovna",
  "minibar",
  "minomet",
  "minulost",
  "miska",
  "mistr",
  "mixovat",
  "mladost",
  "mlha",
  "mlhovina",
  "mlok",
  "mlsat",
  "mluvit",
  "mnich",
  "mnohem",
  "mobil",
  "mocnost",
  "modelka",
  "modlitba",
  "mohyla",
  "mokro",
  "molekula",
  "momentka",
  "monarcha",
  "monokl",
  "monstrum",
  "montovat",
  "monzun",
  "mosaz",
  "moskyt",
  "most",
  "motivace",
  "motorka",
  "motyka",
  "moucha",
  "moudrost",
  "mozaika",
  "mozek",
  "mozol",
  "mramor",
  "mravenec",
  "mrkev",
  "mrtvola",
  "mrzet",
  "mrzutost",
  "mstitel",
  "mudrc",
  "muflon",
  "mulat",
  "mumie",
  "munice",
  "muset",
  "mutace",
  "muzeum",
  "muzikant",
  "myslivec",
  "mzda",
  "nabourat",
  "nachytat",
  "nadace",
  "nadbytek",
  "nadhoz",
  "nadobro",
  "nadpis",
  "nahlas",
  "nahnat",
  "nahodile",
  "nahradit",
  "naivita",
  "najednou",
  "najisto",
  "najmout",
  "naklonit",
  "nakonec",
  "nakrmit",
  "nalevo",
  "namazat",
  "namluvit",
  "nanometr",
  "naoko",
  "naopak",
  "naostro",
  "napadat",
  "napevno",
  "naplnit",
  "napnout",
  "naposled",
  "naprosto",
  "narodit",
  "naruby",
  "narychlo",
  "nasadit",
  "nasekat",
  "naslepo",
  "nastat",
  "natolik",
  "navenek",
  "navrch",
  "navzdory",
  "nazvat",
  "nebe",
  "nechat",
  "necky",
  "nedaleko",
  "nedbat",
  "neduh",
  "negace",
  "nehet",
  "nehoda",
  "nejen",
  "nejprve",
  "neklid",
  "nelibost",
  "nemilost",
  "nemoc",
  "neochota",
  "neonka",
  "nepokoj",
  "nerost",
  "nerv",
  "nesmysl",
  "nesoulad",
  "netvor",
  "neuron",
  "nevina",
  "nezvykle",
  "nicota",
  "nijak",
  "nikam",
  "nikdy",
  "nikl",
  "nikterak",
  "nitro",
  "nocleh",
  "nohavice",
  "nominace",
  "nora",
  "norek",
  "nositel",
  "nosnost",
  "nouze",
  "noviny",
  "novota",
  "nozdra",
  "nuda",
  "nudle",
  "nuget",
  "nutit",
  "nutnost",
  "nutrie",
  "nymfa",
  "obal",
  "obarvit",
  "obava",
  "obdiv",
  "obec",
  "obehnat",
  "obejmout",
  "obezita",
  "obhajoba",
  "obilnice",
  "objasnit",
  "objekt",
  "obklopit",
  "oblast",
  "oblek",
  "obliba",
  "obloha",
  "obluda",
  "obnos",
  "obohatit",
  "obojek",
  "obout",
  "obrazec",
  "obrna",
  "obruba",
  "obrys",
  "obsah",
  "obsluha",
  "obstarat",
  "obuv",
  "obvaz",
  "obvinit",
  "obvod",
  "obvykle",
  "obyvatel",
  "obzor",
  "ocas",
  "ocel",
  "ocenit",
  "ochladit",
  "ochota",
  "ochrana",
  "ocitnout",
  "odboj",
  "odbyt",
  "odchod",
  "odcizit",
  "odebrat",
  "odeslat",
  "odevzdat",
  "odezva",
  "odhadce",
  "odhodit",
  "odjet",
  "odjinud",
  "odkaz",
  "odkoupit",
  "odliv",
  "odluka",
  "odmlka",
  "odolnost",
  "odpad",
  "odpis",
  "odplout",
  "odpor",
  "odpustit",
  "odpykat",
  "odrazka",
  "odsoudit",
  "odstup",
  "odsun",
  "odtok",
  "odtud",
  "odvaha",
  "odveta",
  "odvolat",
  "odvracet",
  "odznak",
  "ofina",
  "ofsajd",
  "ohlas",
  "ohnisko",
  "ohrada",
  "ohrozit",
  "ohryzek",
  "okap",
  "okenice",
  "oklika",
  "okno",
  "okouzlit",
  "okovy",
  "okrasa",
  "okres",
  "okrsek",
  "okruh",
  "okupant",
  "okurka",
  "okusit",
  "olejnina",
  "olizovat",
  "omak",
  "omeleta",
  "omezit",
  "omladina",
  "omlouvat",
  "omluva",
  "omyl",
  "onehdy",
  "opakovat",
  "opasek",
  "operace",
  "opice",
  "opilost",
  "opisovat",
  "opora",
  "opozice",
  "opravdu",
  "oproti",
  "orbital",
  "orchestr",
  "orgie",
  "orlice",
  "orloj",
  "ortel",
  "osada",
  "oschnout",
  "osika",
  "osivo",
  "oslava",
  "oslepit",
  "oslnit",
  "oslovit",
  "osnova",
  "osoba",
  "osolit",
  "ospalec",
  "osten",
  "ostraha",
  "ostuda",
  "ostych",
  "osvojit",
  "oteplit",
  "otisk",
  "otop",
  "otrhat",
  "otrlost",
  "otrok",
  "otruby",
  "otvor",
  "ovanout",
  "ovar",
  "oves",
  "ovlivnit",
  "ovoce",
  "oxid",
  "ozdoba",
  "pachatel",
  "pacient",
  "padouch",
  "pahorek",
  "pakt",
  "palanda",
  "palec",
  "palivo",
  "paluba",
  "pamflet",
  "pamlsek",
  "panenka",
  "panika",
  "panna",
  "panovat",
  "panstvo",
  "pantofle",
  "paprika",
  "parketa",
  "parodie",
  "parta",
  "paruka",
  "paryba",
  "paseka",
  "pasivita",
  "pastelka",
  "patent",
  "patrona",
  "pavouk",
  "pazneht",
  "pazourek",
  "pecka",
  "pedagog",
  "pejsek",
  "peklo",
  "peloton",
  "penalta",
  "pendrek",
  "penze",
  "periskop",
  "pero",
  "pestrost",
  "petarda",
  "petice",
  "petrolej",
  "pevnina",
  "pexeso",
  "pianista",
  "piha",
  "pijavice",
  "pikle",
  "piknik",
  "pilina",
  "pilnost",
  "pilulka",
  "pinzeta",
  "pipeta",
  "pisatel",
  "pistole",
  "pitevna",
  "pivnice",
  "pivovar",
  "placenta",
  "plakat",
  "plamen",
  "planeta",
  "plastika",
  "platit",
  "plavidlo",
  "plaz",
  "plech",
  "plemeno",
  "plenta",
  "ples",
  "pletivo",
  "plevel",
  "plivat",
  "plnit",
  "plno",
  "plocha",
  "plodina",
  "plomba",
  "plout",
  "pluk",
  "plyn",
  "pobavit",
  "pobyt",
  "pochod",
  "pocit",
  "poctivec",
  "podat",
  "podcenit",
  "podepsat",
  "podhled",
  "podivit",
  "podklad",
  "podmanit",
  "podnik",
  "podoba",
  "podpora",
  "podraz",
  "podstata",
  "podvod",
  "podzim",
  "poezie",
  "pohanka",
  "pohnutka",
  "pohovor",
  "pohroma",
  "pohyb",
  "pointa",
  "pojistka",
  "pojmout",
  "pokazit",
  "pokles",
  "pokoj",
  "pokrok",
  "pokuta",
  "pokyn",
  "poledne",
  "polibek",
  "polknout",
  "poloha",
  "polynom",
  "pomalu",
  "pominout",
  "pomlka",
  "pomoc",
  "pomsta",
  "pomyslet",
  "ponechat",
  "ponorka",
  "ponurost",
  "popadat",
  "popel",
  "popisek",
  "poplach",
  "poprosit",
  "popsat",
  "popud",
  "poradce",
  "porce",
  "porod",
  "porucha",
  "poryv",
  "posadit",
  "posed",
  "posila",
  "poskok",
  "poslanec",
  "posoudit",
  "pospolu",
  "postava",
  "posudek",
  "posyp",
  "potah",
  "potkan",
  "potlesk",
  "potomek",
  "potrava",
  "potupa",
  "potvora",
  "poukaz",
  "pouto",
  "pouzdro",
  "povaha",
  "povidla",
  "povlak",
  "povoz",
  "povrch",
  "povstat",
  "povyk",
  "povzdech",
  "pozdrav",
  "pozemek",
  "poznatek",
  "pozor",
  "pozvat",
  "pracovat",
  "prahory",
  "praktika",
  "prales",
  "praotec",
  "praporek",
  "prase",
  "pravda",
  "princip",
  "prkno",
  "probudit",
  "procento",
  "prodej",
  "profese",
  "prohra",
  "projekt",
  "prolomit",
  "promile",
  "pronikat",
  "propad",
  "prorok",
  "prosba",
  "proton",
  "proutek",
  "provaz",
  "prskavka",
  "prsten",
  "prudkost",
  "prut",
  "prvek",
  "prvohory",
  "psanec",
  "psovod",
  "pstruh",
  "ptactvo",
  "puberta",
  "puch",
  "pudl",
  "pukavec",
  "puklina",
  "pukrle",
  "pult",
  "pumpa",
  "punc",
  "pupen",
  "pusa",
  "pusinka",
  "pustina",
  "putovat",
  "putyka",
  "pyramida",
  "pysk",
  "pytel",
  "racek",
  "rachot",
  "radiace",
  "radnice",
  "radon",
  "raft",
  "ragby",
  "raketa",
  "rakovina",
  "rameno",
  "rampouch",
  "rande",
  "rarach",
  "rarita",
  "rasovna",
  "rastr",
  "ratolest",
  "razance",
  "razidlo",
  "reagovat",
  "reakce",
  "recept",
  "redaktor",
  "referent",
  "reflex",
  "rejnok",
  "reklama",
  "rekord",
  "rekrut",
  "rektor",
  "reputace",
  "revize",
  "revma",
  "revolver",
  "rezerva",
  "riskovat",
  "riziko",
  "robotika",
  "rodokmen",
  "rohovka",
  "rokle",
  "rokoko",
  "romaneto",
  "ropovod",
  "ropucha",
  "rorejs",
  "rosol",
  "rostlina",
  "rotmistr",
  "rotoped",
  "rotunda",
  "roubenka",
  "roucho",
  "roup",
  "roura",
  "rovina",
  "rovnice",
  "rozbor",
  "rozchod",
  "rozdat",
  "rozeznat",
  "rozhodce",
  "rozinka",
  "rozjezd",
  "rozkaz",
  "rozloha",
  "rozmar",
  "rozpad",
  "rozruch",
  "rozsah",
  "roztok",
  "rozum",
  "rozvod",
  "rubrika",
  "ruchadlo",
  "rukavice",
  "rukopis",
  "ryba",
  "rybolov",
  "rychlost",
  "rydlo",
  "rypadlo",
  "rytina",
  "ryzost",
  "sadista",
  "sahat",
  "sako",
  "samec",
  "samizdat",
  "samota",
  "sanitka",
  "sardinka",
  "sasanka",
  "satelit",
  "sazba",
  "sazenice",
  "sbor",
  "schovat",
  "sebranka",
  "secese",
  "sedadlo",
  "sediment",
  "sedlo",
  "sehnat",
  "sejmout",
  "sekera",
  "sekta",
  "sekunda",
  "sekvoje",
  "semeno",
  "seno",
  "servis",
  "sesadit",
  "seshora",
  "seskok",
  "seslat",
  "sestra",
  "sesuv",
  "sesypat",
  "setba",
  "setina",
  "setkat",
  "setnout",
  "setrvat",
  "sever",
  "seznam",
  "shoda",
  "shrnout",
  "sifon",
  "silnice",
  "sirka",
  "sirotek",
  "sirup",
  "situace",
  "skafandr",
  "skalisko",
  "skanzen",
  "skaut",
  "skeptik",
  "skica",
  "skladba",
  "sklenice",
  "sklo",
  "skluz",
  "skoba",
  "skokan",
  "skoro",
  "skripta",
  "skrz",
  "skupina",
  "skvost",
  "skvrna",
  "slabika",
  "sladidlo",
  "slanina",
  "slast",
  "slavnost",
  "sledovat",
  "slepec",
  "sleva",
  "slezina",
  "slib",
  "slina",
  "sliznice",
  "slon",
  "sloupek",
  "slovo",
  "sluch",
  "sluha",
  "slunce",
  "slupka",
  "slza",
  "smaragd",
  "smetana",
  "smilstvo",
  "smlouva",
  "smog",
  "smrad",
  "smrk",
  "smrtka",
  "smutek",
  "smysl",
  "snad",
  "snaha",
  "snob",
  "sobota",
  "socha",
  "sodovka",
  "sokol",
  "sopka",
  "sotva",
  "souboj",
  "soucit",
  "soudce",
  "souhlas",
  "soulad",
  "soumrak",
  "souprava",
  "soused",
  "soutok",
  "souviset",
  "spalovna",
  "spasitel",
  "spis",
  "splav",
  "spodek",
  "spojenec",
  "spolu",
  "sponzor",
  "spornost",
  "spousta",
  "sprcha",
  "spustit",
  "sranda",
  "sraz",
  "srdce",
  "srna",
  "srnec",
  "srovnat",
  "srpen",
  "srst",
  "srub",
  "stanice",
  "starosta",
  "statika",
  "stavba",
  "stehno",
  "stezka",
  "stodola",
  "stolek",
  "stopa",
  "storno",
  "stoupat",
  "strach",
  "stres",
  "strhnout",
  "strom",
  "struna",
  "studna",
  "stupnice",
  "stvol",
  "styk",
  "subjekt",
  "subtropy",
  "suchar",
  "sudost",
  "sukno",
  "sundat",
  "sunout",
  "surikata",
  "surovina",
  "svah",
  "svalstvo",
  "svetr",
  "svatba",
  "svazek",
  "svisle",
  "svitek",
  "svoboda",
  "svodidlo",
  "svorka",
  "svrab",
  "sykavka",
  "sykot",
  "synek",
  "synovec",
  "sypat",
  "sypkost",
  "syrovost",
  "sysel",
  "sytost",
  "tabletka",
  "tabule",
  "tahoun",
  "tajemno",
  "tajfun",
  "tajga",
  "tajit",
  "tajnost",
  "taktika",
  "tamhle",
  "tampon",
  "tancovat",
  "tanec",
  "tanker",
  "tapeta",
  "tavenina",
  "tazatel",
  "technika",
  "tehdy",
  "tekutina",
  "telefon",
  "temnota",
  "tendence",
  "tenista",
  "tenor",
  "teplota",
  "tepna",
  "teprve",
  "terapie",
  "termoska",
  "textil",
  "ticho",
  "tiskopis",
  "titulek",
  "tkadlec",
  "tkanina",
  "tlapka",
  "tleskat",
  "tlukot",
  "tlupa",
  "tmel",
  "toaleta",
  "topinka",
  "topol",
  "torzo",
  "touha",
  "toulec",
  "tradice",
  "traktor",
  "tramp",
  "trasa",
  "traverza",
  "trefit",
  "trest",
  "trezor",
  "trhavina",
  "trhlina",
  "trochu",
  "trojice",
  "troska",
  "trouba",
  "trpce",
  "trpitel",
  "trpkost",
  "trubec",
  "truchlit",
  "truhlice",
  "trus",
  "trvat",
  "tudy",
  "tuhnout",
  "tuhost",
  "tundra",
  "turista",
  "turnaj",
  "tuzemsko",
  "tvaroh",
  "tvorba",
  "tvrdost",
  "tvrz",
  "tygr",
  "tykev",
  "ubohost",
  "uboze",
  "ubrat",
  "ubrousek",
  "ubrus",
  "ubytovna",
  "ucho",
  "uctivost",
  "udivit",
  "uhradit",
  "ujednat",
  "ujistit",
  "ujmout",
  "ukazatel",
  "uklidnit",
  "uklonit",
  "ukotvit",
  "ukrojit",
  "ulice",
  "ulita",
  "ulovit",
  "umyvadlo",
  "unavit",
  "uniforma",
  "uniknout",
  "upadnout",
  "uplatnit",
  "uplynout",
  "upoutat",
  "upravit",
  "uran",
  "urazit",
  "usednout",
  "usilovat",
  "usmrtit",
  "usnadnit",
  "usnout",
  "usoudit",
  "ustlat",
  "ustrnout",
  "utahovat",
  "utkat",
  "utlumit",
  "utonout",
  "utopenec",
  "utrousit",
  "uvalit",
  "uvolnit",
  "uvozovka",
  "uzdravit",
  "uzel",
  "uzenina",
  "uzlina",
  "uznat",
  "vagon",
  "valcha",
  "valoun",
  "vana",
  "vandal",
  "vanilka",
  "varan",
  "varhany",
  "varovat",
  "vcelku",
  "vchod",
  "vdova",
  "vedro",
  "vegetace",
  "vejce",
  "velbloud",
  "veletrh",
  "velitel",
  "velmoc",
  "velryba",
  "venkov",
  "veranda",
  "verze",
  "veselka",
  "veskrze",
  "vesnice",
  "vespodu",
  "vesta",
  "veterina",
  "veverka",
  "vibrace",
  "vichr",
  "videohra",
  "vidina",
  "vidle",
  "vila",
  "vinice",
  "viset",
  "vitalita",
  "vize",
  "vizitka",
  "vjezd",
  "vklad",
  "vkus",
  "vlajka",
  "vlak",
  "vlasec",
  "vlevo",
  "vlhkost",
  "vliv",
  "vlnovka",
  "vloupat",
  "vnucovat",
  "vnuk",
  "voda",
  "vodivost",
  "vodoznak",
  "vodstvo",
  "vojensky",
  "vojna",
  "vojsko",
  "volant",
  "volba",
  "volit",
  "volno",
  "voskovka",
  "vozidlo",
  "vozovna",
  "vpravo",
  "vrabec",
  "vracet",
  "vrah",
  "vrata",
  "vrba",
  "vrcholek",
  "vrhat",
  "vrstva",
  "vrtule",
  "vsadit",
  "vstoupit",
  "vstup",
  "vtip",
  "vybavit",
  "vybrat",
  "vychovat",
  "vydat",
  "vydra",
  "vyfotit",
  "vyhledat",
  "vyhnout",
  "vyhodit",
  "vyhradit",
  "vyhubit",
  "vyjasnit",
  "vyjet",
  "vyjmout",
  "vyklopit",
  "vykonat",
  "vylekat",
  "vymazat",
  "vymezit",
  "vymizet",
  "vymyslet",
  "vynechat",
  "vynikat",
  "vynutit",
  "vypadat",
  "vyplatit",
  "vypravit",
  "vypustit",
  "vyrazit",
  "vyrovnat",
  "vyrvat",
  "vyslovit",
  "vysoko",
  "vystavit",
  "vysunout",
  "vysypat",
  "vytasit",
  "vytesat",
  "vytratit",
  "vyvinout",
  "vyvolat",
  "vyvrhel",
  "vyzdobit",
  "vyznat",
  "vzadu",
  "vzbudit",
  "vzchopit",
  "vzdor",
  "vzduch",
  "vzdychat",
  "vzestup",
  "vzhledem",
  "vzkaz",
  "vzlykat",
  "vznik",
  "vzorek",
  "vzpoura",
  "vztah",
  "vztek",
  "xylofon",
  "zabrat",
  "zabydlet",
  "zachovat",
  "zadarmo",
  "zadusit",
  "zafoukat",
  "zahltit",
  "zahodit",
  "zahrada",
  "zahynout",
  "zajatec",
  "zajet",
  "zajistit",
  "zaklepat",
  "zakoupit",
  "zalepit",
  "zamezit",
  "zamotat",
  "zamyslet",
  "zanechat",
  "zanikat",
  "zaplatit",
  "zapojit",
  "zapsat",
  "zarazit",
  "zastavit",
  "zasunout",
  "zatajit",
  "zatemnit",
  "zatknout",
  "zaujmout",
  "zavalit",
  "zavelet",
  "zavinit",
  "zavolat",
  "zavrtat",
  "zazvonit",
  "zbavit",
  "zbrusu",
  "zbudovat",
  "zbytek",
  "zdaleka",
  "zdarma",
  "zdatnost",
  "zdivo",
  "zdobit",
  "zdroj",
  "zdvih",
  "zdymadlo",
  "zelenina",
  "zeman",
  "zemina",
  "zeptat",
  "zezadu",
  "zezdola",
  "zhatit",
  "zhltnout",
  "zhluboka",
  "zhotovit",
  "zhruba",
  "zima",
  "zimnice",
  "zjemnit",
  "zklamat",
  "zkoumat",
  "zkratka",
  "zkumavka",
  "zlato",
  "zlehka",
  "zloba",
  "zlom",
  "zlost",
  "zlozvyk",
  "zmapovat",
  "zmar",
  "zmatek",
  "zmije",
  "zmizet",
  "zmocnit",
  "zmodrat",
  "zmrzlina",
  "zmutovat",
  "znak",
  "znalost",
  "znamenat",
  "znovu",
  "zobrazit",
  "zotavit",
  "zoubek",
  "zoufale",
  "zplodit",
  "zpomalit",
  "zprava",
  "zprostit",
  "zprudka",
  "zprvu",
  "zrada",
  "zranit",
  "zrcadlo",
  "zrnitost",
  "zrno",
  "zrovna",
  "zrychlit",
  "zrzavost",
  "zticha",
  "ztratit",
  "zubovina",
  "zubr",
  "zvednout",
  "zvenku",
  "zvesela",
  "zvon",
  "zvrat",
  "zvukovod",
  "zvyk"
];
var gX = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var mX = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var bX = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var yX = [
  "abaisser",
  "abandon",
  "abdiquer",
  "abeille",
  "abolir",
  "aborder",
  "aboutir",
  "aboyer",
  "abrasif",
  "abreuver",
  "abriter",
  "abroger",
  "abrupt",
  "absence",
  "absolu",
  "absurde",
  "abusif",
  "abyssal",
  "academie",
  "acajou",
  "acarien",
  "accabler",
  "accepter",
  "acclamer",
  "accolade",
  "accroche",
  "accuser",
  "acerbe",
  "achat",
  "acheter",
  "aciduler",
  "acier",
  "acompte",
  "acquerir",
  "acronyme",
  "acteur",
  "actif",
  "actuel",
  "adepte",
  "adequat",
  "adhesif",
  "adjectif",
  "adjuger",
  "admettre",
  "admirer",
  "adopter",
  "adorer",
  "adoucir",
  "adresse",
  "adroit",
  "adulte",
  "adverbe",
  "aerer",
  "aeronef",
  "affaire",
  "affecter",
  "affiche",
  "affreux",
  "affubler",
  "agacer",
  "agencer",
  "agile",
  "agiter",
  "agrafer",
  "agreable",
  "agrume",
  "aider",
  "aiguille",
  "ailier",
  "aimable",
  "aisance",
  "ajouter",
  "ajuster",
  "alarmer",
  "alchimie",
  "alerte",
  "algebre",
  "algue",
  "aliener",
  "aliment",
  "alleger",
  "alliage",
  "allouer",
  "allumer",
  "alourdir",
  "alpaga",
  "altesse",
  "alveole",
  "amateur",
  "ambigu",
  "ambre",
  "amenager",
  "amertume",
  "amidon",
  "amiral",
  "amorcer",
  "amour",
  "amovible",
  "amphibie",
  "ampleur",
  "amusant",
  "analyse",
  "anaphore",
  "anarchie",
  "anatomie",
  "ancien",
  "aneantir",
  "angle",
  "angoisse",
  "anguleux",
  "animal",
  "annexer",
  "annonce",
  "annuel",
  "anodin",
  "anomalie",
  "anonyme",
  "anormal",
  "antenne",
  "antidote",
  "anxieux",
  "apaiser",
  "aperitif",
  "aplanir",
  "apologie",
  "appareil",
  "appeler",
  "apporter",
  "appuyer",
  "aquarium",
  "aqueduc",
  "arbitre",
  "arbuste",
  "ardeur",
  "ardoise",
  "argent",
  "arlequin",
  "armature",
  "armement",
  "armoire",
  "armure",
  "arpenter",
  "arracher",
  "arriver",
  "arroser",
  "arsenic",
  "arteriel",
  "article",
  "aspect",
  "asphalte",
  "aspirer",
  "assaut",
  "asservir",
  "assiette",
  "associer",
  "assurer",
  "asticot",
  "astre",
  "astuce",
  "atelier",
  "atome",
  "atrium",
  "atroce",
  "attaque",
  "attentif",
  "attirer",
  "attraper",
  "aubaine",
  "auberge",
  "audace",
  "audible",
  "augurer",
  "aurore",
  "automne",
  "autruche",
  "avaler",
  "avancer",
  "avarice",
  "avenir",
  "averse",
  "aveugle",
  "aviateur",
  "avide",
  "avion",
  "aviser",
  "avoine",
  "avouer",
  "avril",
  "axial",
  "axiome",
  "badge",
  "bafouer",
  "bagage",
  "baguette",
  "baignade",
  "balancer",
  "balcon",
  "baleine",
  "balisage",
  "bambin",
  "bancaire",
  "bandage",
  "banlieue",
  "banniere",
  "banquier",
  "barbier",
  "baril",
  "baron",
  "barque",
  "barrage",
  "bassin",
  "bastion",
  "bataille",
  "bateau",
  "batterie",
  "baudrier",
  "bavarder",
  "belette",
  "belier",
  "belote",
  "benefice",
  "berceau",
  "berger",
  "berline",
  "bermuda",
  "besace",
  "besogne",
  "betail",
  "beurre",
  "biberon",
  "bicycle",
  "bidule",
  "bijou",
  "bilan",
  "bilingue",
  "billard",
  "binaire",
  "biologie",
  "biopsie",
  "biotype",
  "biscuit",
  "bison",
  "bistouri",
  "bitume",
  "bizarre",
  "blafard",
  "blague",
  "blanchir",
  "blessant",
  "blinder",
  "blond",
  "bloquer",
  "blouson",
  "bobard",
  "bobine",
  "boire",
  "boiser",
  "bolide",
  "bonbon",
  "bondir",
  "bonheur",
  "bonifier",
  "bonus",
  "bordure",
  "borne",
  "botte",
  "boucle",
  "boueux",
  "bougie",
  "boulon",
  "bouquin",
  "bourse",
  "boussole",
  "boutique",
  "boxeur",
  "branche",
  "brasier",
  "brave",
  "brebis",
  "breche",
  "breuvage",
  "bricoler",
  "brigade",
  "brillant",
  "brioche",
  "brique",
  "brochure",
  "broder",
  "bronzer",
  "brousse",
  "broyeur",
  "brume",
  "brusque",
  "brutal",
  "bruyant",
  "buffle",
  "buisson",
  "bulletin",
  "bureau",
  "burin",
  "bustier",
  "butiner",
  "butoir",
  "buvable",
  "buvette",
  "cabanon",
  "cabine",
  "cachette",
  "cadeau",
  "cadre",
  "cafeine",
  "caillou",
  "caisson",
  "calculer",
  "calepin",
  "calibre",
  "calmer",
  "calomnie",
  "calvaire",
  "camarade",
  "camera",
  "camion",
  "campagne",
  "canal",
  "caneton",
  "canon",
  "cantine",
  "canular",
  "capable",
  "caporal",
  "caprice",
  "capsule",
  "capter",
  "capuche",
  "carabine",
  "carbone",
  "caresser",
  "caribou",
  "carnage",
  "carotte",
  "carreau",
  "carton",
  "cascade",
  "casier",
  "casque",
  "cassure",
  "causer",
  "caution",
  "cavalier",
  "caverne",
  "caviar",
  "cedille",
  "ceinture",
  "celeste",
  "cellule",
  "cendrier",
  "censurer",
  "central",
  "cercle",
  "cerebral",
  "cerise",
  "cerner",
  "cerveau",
  "cesser",
  "chagrin",
  "chaise",
  "chaleur",
  "chambre",
  "chance",
  "chapitre",
  "charbon",
  "chasseur",
  "chaton",
  "chausson",
  "chavirer",
  "chemise",
  "chenille",
  "chequier",
  "chercher",
  "cheval",
  "chien",
  "chiffre",
  "chignon",
  "chimere",
  "chiot",
  "chlorure",
  "chocolat",
  "choisir",
  "chose",
  "chouette",
  "chrome",
  "chute",
  "cigare",
  "cigogne",
  "cimenter",
  "cinema",
  "cintrer",
  "circuler",
  "cirer",
  "cirque",
  "citerne",
  "citoyen",
  "citron",
  "civil",
  "clairon",
  "clameur",
  "claquer",
  "classe",
  "clavier",
  "client",
  "cligner",
  "climat",
  "clivage",
  "cloche",
  "clonage",
  "cloporte",
  "cobalt",
  "cobra",
  "cocasse",
  "cocotier",
  "coder",
  "codifier",
  "coffre",
  "cogner",
  "cohesion",
  "coiffer",
  "coincer",
  "colere",
  "colibri",
  "colline",
  "colmater",
  "colonel",
  "combat",
  "comedie",
  "commande",
  "compact",
  "concert",
  "conduire",
  "confier",
  "congeler",
  "connoter",
  "consonne",
  "contact",
  "convexe",
  "copain",
  "copie",
  "corail",
  "corbeau",
  "cordage",
  "corniche",
  "corpus",
  "correct",
  "cortege",
  "cosmique",
  "costume",
  "coton",
  "coude",
  "coupure",
  "courage",
  "couteau",
  "couvrir",
  "coyote",
  "crabe",
  "crainte",
  "cravate",
  "crayon",
  "creature",
  "crediter",
  "cremeux",
  "creuser",
  "crevette",
  "cribler",
  "crier",
  "cristal",
  "critere",
  "croire",
  "croquer",
  "crotale",
  "crucial",
  "cruel",
  "crypter",
  "cubique",
  "cueillir",
  "cuillere",
  "cuisine",
  "cuivre",
  "culminer",
  "cultiver",
  "cumuler",
  "cupide",
  "curatif",
  "curseur",
  "cyanure",
  "cycle",
  "cylindre",
  "cynique",
  "daigner",
  "damier",
  "danger",
  "danseur",
  "dauphin",
  "debattre",
  "debiter",
  "deborder",
  "debrider",
  "debutant",
  "decaler",
  "decembre",
  "dechirer",
  "decider",
  "declarer",
  "decorer",
  "decrire",
  "decupler",
  "dedale",
  "deductif",
  "deesse",
  "defensif",
  "defiler",
  "defrayer",
  "degager",
  "degivrer",
  "deglutir",
  "degrafer",
  "dejeuner",
  "delice",
  "deloger",
  "demander",
  "demeurer",
  "demolir",
  "denicher",
  "denouer",
  "dentelle",
  "denuder",
  "depart",
  "depenser",
  "dephaser",
  "deplacer",
  "deposer",
  "deranger",
  "derober",
  "desastre",
  "descente",
  "desert",
  "designer",
  "desobeir",
  "dessiner",
  "destrier",
  "detacher",
  "detester",
  "detourer",
  "detresse",
  "devancer",
  "devenir",
  "deviner",
  "devoir",
  "diable",
  "dialogue",
  "diamant",
  "dicter",
  "differer",
  "digerer",
  "digital",
  "digne",
  "diluer",
  "dimanche",
  "diminuer",
  "dioxyde",
  "directif",
  "diriger",
  "discuter",
  "disposer",
  "dissiper",
  "distance",
  "divertir",
  "diviser",
  "docile",
  "docteur",
  "dogme",
  "doigt",
  "domaine",
  "domicile",
  "dompter",
  "donateur",
  "donjon",
  "donner",
  "dopamine",
  "dortoir",
  "dorure",
  "dosage",
  "doseur",
  "dossier",
  "dotation",
  "douanier",
  "double",
  "douceur",
  "douter",
  "doyen",
  "dragon",
  "draper",
  "dresser",
  "dribbler",
  "droiture",
  "duperie",
  "duplexe",
  "durable",
  "durcir",
  "dynastie",
  "eblouir",
  "ecarter",
  "echarpe",
  "echelle",
  "eclairer",
  "eclipse",
  "eclore",
  "ecluse",
  "ecole",
  "economie",
  "ecorce",
  "ecouter",
  "ecraser",
  "ecremer",
  "ecrivain",
  "ecrou",
  "ecume",
  "ecureuil",
  "edifier",
  "eduquer",
  "effacer",
  "effectif",
  "effigie",
  "effort",
  "effrayer",
  "effusion",
  "egaliser",
  "egarer",
  "ejecter",
  "elaborer",
  "elargir",
  "electron",
  "elegant",
  "elephant",
  "eleve",
  "eligible",
  "elitisme",
  "eloge",
  "elucider",
  "eluder",
  "emballer",
  "embellir",
  "embryon",
  "emeraude",
  "emission",
  "emmener",
  "emotion",
  "emouvoir",
  "empereur",
  "employer",
  "emporter",
  "emprise",
  "emulsion",
  "encadrer",
  "enchere",
  "enclave",
  "encoche",
  "endiguer",
  "endosser",
  "endroit",
  "enduire",
  "energie",
  "enfance",
  "enfermer",
  "enfouir",
  "engager",
  "engin",
  "englober",
  "enigme",
  "enjamber",
  "enjeu",
  "enlever",
  "ennemi",
  "ennuyeux",
  "enrichir",
  "enrobage",
  "enseigne",
  "entasser",
  "entendre",
  "entier",
  "entourer",
  "entraver",
  "enumerer",
  "envahir",
  "enviable",
  "envoyer",
  "enzyme",
  "eolien",
  "epaissir",
  "epargne",
  "epatant",
  "epaule",
  "epicerie",
  "epidemie",
  "epier",
  "epilogue",
  "epine",
  "episode",
  "epitaphe",
  "epoque",
  "epreuve",
  "eprouver",
  "epuisant",
  "equerre",
  "equipe",
  "eriger",
  "erosion",
  "erreur",
  "eruption",
  "escalier",
  "espadon",
  "espece",
  "espiegle",
  "espoir",
  "esprit",
  "esquiver",
  "essayer",
  "essence",
  "essieu",
  "essorer",
  "estime",
  "estomac",
  "estrade",
  "etagere",
  "etaler",
  "etanche",
  "etatique",
  "eteindre",
  "etendoir",
  "eternel",
  "ethanol",
  "ethique",
  "ethnie",
  "etirer",
  "etoffer",
  "etoile",
  "etonnant",
  "etourdir",
  "etrange",
  "etroit",
  "etude",
  "euphorie",
  "evaluer",
  "evasion",
  "eventail",
  "evidence",
  "eviter",
  "evolutif",
  "evoquer",
  "exact",
  "exagerer",
  "exaucer",
  "exceller",
  "excitant",
  "exclusif",
  "excuse",
  "executer",
  "exemple",
  "exercer",
  "exhaler",
  "exhorter",
  "exigence",
  "exiler",
  "exister",
  "exotique",
  "expedier",
  "explorer",
  "exposer",
  "exprimer",
  "exquis",
  "extensif",
  "extraire",
  "exulter",
  "fable",
  "fabuleux",
  "facette",
  "facile",
  "facture",
  "faiblir",
  "falaise",
  "fameux",
  "famille",
  "farceur",
  "farfelu",
  "farine",
  "farouche",
  "fasciner",
  "fatal",
  "fatigue",
  "faucon",
  "fautif",
  "faveur",
  "favori",
  "febrile",
  "feconder",
  "federer",
  "felin",
  "femme",
  "femur",
  "fendoir",
  "feodal",
  "fermer",
  "feroce",
  "ferveur",
  "festival",
  "feuille",
  "feutre",
  "fevrier",
  "fiasco",
  "ficeler",
  "fictif",
  "fidele",
  "figure",
  "filature",
  "filetage",
  "filiere",
  "filleul",
  "filmer",
  "filou",
  "filtrer",
  "financer",
  "finir",
  "fiole",
  "firme",
  "fissure",
  "fixer",
  "flairer",
  "flamme",
  "flasque",
  "flatteur",
  "fleau",
  "fleche",
  "fleur",
  "flexion",
  "flocon",
  "flore",
  "fluctuer",
  "fluide",
  "fluvial",
  "folie",
  "fonderie",
  "fongible",
  "fontaine",
  "forcer",
  "forgeron",
  "formuler",
  "fortune",
  "fossile",
  "foudre",
  "fougere",
  "fouiller",
  "foulure",
  "fourmi",
  "fragile",
  "fraise",
  "franchir",
  "frapper",
  "frayeur",
  "fregate",
  "freiner",
  "frelon",
  "fremir",
  "frenesie",
  "frere",
  "friable",
  "friction",
  "frisson",
  "frivole",
  "froid",
  "fromage",
  "frontal",
  "frotter",
  "fruit",
  "fugitif",
  "fuite",
  "fureur",
  "furieux",
  "furtif",
  "fusion",
  "futur",
  "gagner",
  "galaxie",
  "galerie",
  "gambader",
  "garantir",
  "gardien",
  "garnir",
  "garrigue",
  "gazelle",
  "gazon",
  "geant",
  "gelatine",
  "gelule",
  "gendarme",
  "general",
  "genie",
  "genou",
  "gentil",
  "geologie",
  "geometre",
  "geranium",
  "germe",
  "gestuel",
  "geyser",
  "gibier",
  "gicler",
  "girafe",
  "givre",
  "glace",
  "glaive",
  "glisser",
  "globe",
  "gloire",
  "glorieux",
  "golfeur",
  "gomme",
  "gonfler",
  "gorge",
  "gorille",
  "goudron",
  "gouffre",
  "goulot",
  "goupille",
  "gourmand",
  "goutte",
  "graduel",
  "graffiti",
  "graine",
  "grand",
  "grappin",
  "gratuit",
  "gravir",
  "grenat",
  "griffure",
  "griller",
  "grimper",
  "grogner",
  "gronder",
  "grotte",
  "groupe",
  "gruger",
  "grutier",
  "gruyere",
  "guepard",
  "guerrier",
  "guide",
  "guimauve",
  "guitare",
  "gustatif",
  "gymnaste",
  "gyrostat",
  "habitude",
  "hachoir",
  "halte",
  "hameau",
  "hangar",
  "hanneton",
  "haricot",
  "harmonie",
  "harpon",
  "hasard",
  "helium",
  "hematome",
  "herbe",
  "herisson",
  "hermine",
  "heron",
  "hesiter",
  "heureux",
  "hiberner",
  "hibou",
  "hilarant",
  "histoire",
  "hiver",
  "homard",
  "hommage",
  "homogene",
  "honneur",
  "honorer",
  "honteux",
  "horde",
  "horizon",
  "horloge",
  "hormone",
  "horrible",
  "houleux",
  "housse",
  "hublot",
  "huileux",
  "humain",
  "humble",
  "humide",
  "humour",
  "hurler",
  "hydromel",
  "hygiene",
  "hymne",
  "hypnose",
  "idylle",
  "ignorer",
  "iguane",
  "illicite",
  "illusion",
  "image",
  "imbiber",
  "imiter",
  "immense",
  "immobile",
  "immuable",
  "impact",
  "imperial",
  "implorer",
  "imposer",
  "imprimer",
  "imputer",
  "incarner",
  "incendie",
  "incident",
  "incliner",
  "incolore",
  "indexer",
  "indice",
  "inductif",
  "inedit",
  "ineptie",
  "inexact",
  "infini",
  "infliger",
  "informer",
  "infusion",
  "ingerer",
  "inhaler",
  "inhiber",
  "injecter",
  "injure",
  "innocent",
  "inoculer",
  "inonder",
  "inscrire",
  "insecte",
  "insigne",
  "insolite",
  "inspirer",
  "instinct",
  "insulter",
  "intact",
  "intense",
  "intime",
  "intrigue",
  "intuitif",
  "inutile",
  "invasion",
  "inventer",
  "inviter",
  "invoquer",
  "ironique",
  "irradier",
  "irreel",
  "irriter",
  "isoler",
  "ivoire",
  "ivresse",
  "jaguar",
  "jaillir",
  "jambe",
  "janvier",
  "jardin",
  "jauger",
  "jaune",
  "javelot",
  "jetable",
  "jeton",
  "jeudi",
  "jeunesse",
  "joindre",
  "joncher",
  "jongler",
  "joueur",
  "jouissif",
  "journal",
  "jovial",
  "joyau",
  "joyeux",
  "jubiler",
  "jugement",
  "junior",
  "jupon",
  "juriste",
  "justice",
  "juteux",
  "juvenile",
  "kayak",
  "kimono",
  "kiosque",
  "label",
  "labial",
  "labourer",
  "lacerer",
  "lactose",
  "lagune",
  "laine",
  "laisser",
  "laitier",
  "lambeau",
  "lamelle",
  "lampe",
  "lanceur",
  "langage",
  "lanterne",
  "lapin",
  "largeur",
  "larme",
  "laurier",
  "lavabo",
  "lavoir",
  "lecture",
  "legal",
  "leger",
  "legume",
  "lessive",
  "lettre",
  "levier",
  "lexique",
  "lezard",
  "liasse",
  "liberer",
  "libre",
  "licence",
  "licorne",
  "liege",
  "lievre",
  "ligature",
  "ligoter",
  "ligue",
  "limer",
  "limite",
  "limonade",
  "limpide",
  "lineaire",
  "lingot",
  "lionceau",
  "liquide",
  "lisiere",
  "lister",
  "lithium",
  "litige",
  "littoral",
  "livreur",
  "logique",
  "lointain",
  "loisir",
  "lombric",
  "loterie",
  "louer",
  "lourd",
  "loutre",
  "louve",
  "loyal",
  "lubie",
  "lucide",
  "lucratif",
  "lueur",
  "lugubre",
  "luisant",
  "lumiere",
  "lunaire",
  "lundi",
  "luron",
  "lutter",
  "luxueux",
  "machine",
  "magasin",
  "magenta",
  "magique",
  "maigre",
  "maillon",
  "maintien",
  "mairie",
  "maison",
  "majorer",
  "malaxer",
  "malefice",
  "malheur",
  "malice",
  "mallette",
  "mammouth",
  "mandater",
  "maniable",
  "manquant",
  "manteau",
  "manuel",
  "marathon",
  "marbre",
  "marchand",
  "mardi",
  "maritime",
  "marqueur",
  "marron",
  "marteler",
  "mascotte",
  "massif",
  "materiel",
  "matiere",
  "matraque",
  "maudire",
  "maussade",
  "mauve",
  "maximal",
  "mechant",
  "meconnu",
  "medaille",
  "medecin",
  "mediter",
  "meduse",
  "meilleur",
  "melange",
  "melodie",
  "membre",
  "memoire",
  "menacer",
  "mener",
  "menhir",
  "mensonge",
  "mentor",
  "mercredi",
  "merite",
  "merle",
  "messager",
  "mesure",
  "metal",
  "meteore",
  "methode",
  "metier",
  "meuble",
  "miauler",
  "microbe",
  "miette",
  "mignon",
  "migrer",
  "milieu",
  "million",
  "mimique",
  "mince",
  "mineral",
  "minimal",
  "minorer",
  "minute",
  "miracle",
  "miroiter",
  "missile",
  "mixte",
  "mobile",
  "moderne",
  "moelleux",
  "mondial",
  "moniteur",
  "monnaie",
  "monotone",
  "monstre",
  "montagne",
  "monument",
  "moqueur",
  "morceau",
  "morsure",
  "mortier",
  "moteur",
  "motif",
  "mouche",
  "moufle",
  "moulin",
  "mousson",
  "mouton",
  "mouvant",
  "multiple",
  "munition",
  "muraille",
  "murene",
  "murmure",
  "muscle",
  "museum",
  "musicien",
  "mutation",
  "muter",
  "mutuel",
  "myriade",
  "myrtille",
  "mystere",
  "mythique",
  "nageur",
  "nappe",
  "narquois",
  "narrer",
  "natation",
  "nation",
  "nature",
  "naufrage",
  "nautique",
  "navire",
  "nebuleux",
  "nectar",
  "nefaste",
  "negation",
  "negliger",
  "negocier",
  "neige",
  "nerveux",
  "nettoyer",
  "neurone",
  "neutron",
  "neveu",
  "niche",
  "nickel",
  "nitrate",
  "niveau",
  "noble",
  "nocif",
  "nocturne",
  "noirceur",
  "noisette",
  "nomade",
  "nombreux",
  "nommer",
  "normatif",
  "notable",
  "notifier",
  "notoire",
  "nourrir",
  "nouveau",
  "novateur",
  "novembre",
  "novice",
  "nuage",
  "nuancer",
  "nuire",
  "nuisible",
  "numero",
  "nuptial",
  "nuque",
  "nutritif",
  "obeir",
  "objectif",
  "obliger",
  "obscur",
  "observer",
  "obstacle",
  "obtenir",
  "obturer",
  "occasion",
  "occuper",
  "ocean",
  "octobre",
  "octroyer",
  "octupler",
  "oculaire",
  "odeur",
  "odorant",
  "offenser",
  "officier",
  "offrir",
  "ogive",
  "oiseau",
  "oisillon",
  "olfactif",
  "olivier",
  "ombrage",
  "omettre",
  "onctueux",
  "onduler",
  "onereux",
  "onirique",
  "opale",
  "opaque",
  "operer",
  "opinion",
  "opportun",
  "opprimer",
  "opter",
  "optique",
  "orageux",
  "orange",
  "orbite",
  "ordonner",
  "oreille",
  "organe",
  "orgueil",
  "orifice",
  "ornement",
  "orque",
  "ortie",
  "osciller",
  "osmose",
  "ossature",
  "otarie",
  "ouragan",
  "ourson",
  "outil",
  "outrager",
  "ouvrage",
  "ovation",
  "oxyde",
  "oxygene",
  "ozone",
  "paisible",
  "palace",
  "palmares",
  "palourde",
  "palper",
  "panache",
  "panda",
  "pangolin",
  "paniquer",
  "panneau",
  "panorama",
  "pantalon",
  "papaye",
  "papier",
  "papoter",
  "papyrus",
  "paradoxe",
  "parcelle",
  "paresse",
  "parfumer",
  "parler",
  "parole",
  "parrain",
  "parsemer",
  "partager",
  "parure",
  "parvenir",
  "passion",
  "pasteque",
  "paternel",
  "patience",
  "patron",
  "pavillon",
  "pavoiser",
  "payer",
  "paysage",
  "peigne",
  "peintre",
  "pelage",
  "pelican",
  "pelle",
  "pelouse",
  "peluche",
  "pendule",
  "penetrer",
  "penible",
  "pensif",
  "penurie",
  "pepite",
  "peplum",
  "perdrix",
  "perforer",
  "periode",
  "permuter",
  "perplexe",
  "persil",
  "perte",
  "peser",
  "petale",
  "petit",
  "petrir",
  "peuple",
  "pharaon",
  "phobie",
  "phoque",
  "photon",
  "phrase",
  "physique",
  "piano",
  "pictural",
  "piece",
  "pierre",
  "pieuvre",
  "pilote",
  "pinceau",
  "pipette",
  "piquer",
  "pirogue",
  "piscine",
  "piston",
  "pivoter",
  "pixel",
  "pizza",
  "placard",
  "plafond",
  "plaisir",
  "planer",
  "plaque",
  "plastron",
  "plateau",
  "pleurer",
  "plexus",
  "pliage",
  "plomb",
  "plonger",
  "pluie",
  "plumage",
  "pochette",
  "poesie",
  "poete",
  "pointe",
  "poirier",
  "poisson",
  "poivre",
  "polaire",
  "policier",
  "pollen",
  "polygone",
  "pommade",
  "pompier",
  "ponctuel",
  "ponderer",
  "poney",
  "portique",
  "position",
  "posseder",
  "posture",
  "potager",
  "poteau",
  "potion",
  "pouce",
  "poulain",
  "poumon",
  "pourpre",
  "poussin",
  "pouvoir",
  "prairie",
  "pratique",
  "precieux",
  "predire",
  "prefixe",
  "prelude",
  "prenom",
  "presence",
  "pretexte",
  "prevoir",
  "primitif",
  "prince",
  "prison",
  "priver",
  "probleme",
  "proceder",
  "prodige",
  "profond",
  "progres",
  "proie",
  "projeter",
  "prologue",
  "promener",
  "propre",
  "prospere",
  "proteger",
  "prouesse",
  "proverbe",
  "prudence",
  "pruneau",
  "psychose",
  "public",
  "puceron",
  "puiser",
  "pulpe",
  "pulsar",
  "punaise",
  "punitif",
  "pupitre",
  "purifier",
  "puzzle",
  "pyramide",
  "quasar",
  "querelle",
  "question",
  "quietude",
  "quitter",
  "quotient",
  "racine",
  "raconter",
  "radieux",
  "ragondin",
  "raideur",
  "raisin",
  "ralentir",
  "rallonge",
  "ramasser",
  "rapide",
  "rasage",
  "ratisser",
  "ravager",
  "ravin",
  "rayonner",
  "reactif",
  "reagir",
  "realiser",
  "reanimer",
  "recevoir",
  "reciter",
  "reclamer",
  "recolter",
  "recruter",
  "reculer",
  "recycler",
  "rediger",
  "redouter",
  "refaire",
  "reflexe",
  "reformer",
  "refrain",
  "refuge",
  "regalien",
  "region",
  "reglage",
  "regulier",
  "reiterer",
  "rejeter",
  "rejouer",
  "relatif",
  "relever",
  "relief",
  "remarque",
  "remede",
  "remise",
  "remonter",
  "remplir",
  "remuer",
  "renard",
  "renfort",
  "renifler",
  "renoncer",
  "rentrer",
  "renvoi",
  "replier",
  "reporter",
  "reprise",
  "reptile",
  "requin",
  "reserve",
  "resineux",
  "resoudre",
  "respect",
  "rester",
  "resultat",
  "retablir",
  "retenir",
  "reticule",
  "retomber",
  "retracer",
  "reunion",
  "reussir",
  "revanche",
  "revivre",
  "revolte",
  "revulsif",
  "richesse",
  "rideau",
  "rieur",
  "rigide",
  "rigoler",
  "rincer",
  "riposter",
  "risible",
  "risque",
  "rituel",
  "rival",
  "riviere",
  "rocheux",
  "romance",
  "rompre",
  "ronce",
  "rondin",
  "roseau",
  "rosier",
  "rotatif",
  "rotor",
  "rotule",
  "rouge",
  "rouille",
  "rouleau",
  "routine",
  "royaume",
  "ruban",
  "rubis",
  "ruche",
  "ruelle",
  "rugueux",
  "ruiner",
  "ruisseau",
  "ruser",
  "rustique",
  "rythme",
  "sabler",
  "saboter",
  "sabre",
  "sacoche",
  "safari",
  "sagesse",
  "saisir",
  "salade",
  "salive",
  "salon",
  "saluer",
  "samedi",
  "sanction",
  "sanglier",
  "sarcasme",
  "sardine",
  "saturer",
  "saugrenu",
  "saumon",
  "sauter",
  "sauvage",
  "savant",
  "savonner",
  "scalpel",
  "scandale",
  "scelerat",
  "scenario",
  "sceptre",
  "schema",
  "science",
  "scinder",
  "score",
  "scrutin",
  "sculpter",
  "seance",
  "secable",
  "secher",
  "secouer",
  "secreter",
  "sedatif",
  "seduire",
  "seigneur",
  "sejour",
  "selectif",
  "semaine",
  "sembler",
  "semence",
  "seminal",
  "senateur",
  "sensible",
  "sentence",
  "separer",
  "sequence",
  "serein",
  "sergent",
  "serieux",
  "serrure",
  "serum",
  "service",
  "sesame",
  "sevir",
  "sevrage",
  "sextuple",
  "sideral",
  "siecle",
  "sieger",
  "siffler",
  "sigle",
  "signal",
  "silence",
  "silicium",
  "simple",
  "sincere",
  "sinistre",
  "siphon",
  "sirop",
  "sismique",
  "situer",
  "skier",
  "social",
  "socle",
  "sodium",
  "soigneux",
  "soldat",
  "soleil",
  "solitude",
  "soluble",
  "sombre",
  "sommeil",
  "somnoler",
  "sonde",
  "songeur",
  "sonnette",
  "sonore",
  "sorcier",
  "sortir",
  "sosie",
  "sottise",
  "soucieux",
  "soudure",
  "souffle",
  "soulever",
  "soupape",
  "source",
  "soutirer",
  "souvenir",
  "spacieux",
  "spatial",
  "special",
  "sphere",
  "spiral",
  "stable",
  "station",
  "sternum",
  "stimulus",
  "stipuler",
  "strict",
  "studieux",
  "stupeur",
  "styliste",
  "sublime",
  "substrat",
  "subtil",
  "subvenir",
  "succes",
  "sucre",
  "suffixe",
  "suggerer",
  "suiveur",
  "sulfate",
  "superbe",
  "supplier",
  "surface",
  "suricate",
  "surmener",
  "surprise",
  "sursaut",
  "survie",
  "suspect",
  "syllabe",
  "symbole",
  "symetrie",
  "synapse",
  "syntaxe",
  "systeme",
  "tabac",
  "tablier",
  "tactile",
  "tailler",
  "talent",
  "talisman",
  "talonner",
  "tambour",
  "tamiser",
  "tangible",
  "tapis",
  "taquiner",
  "tarder",
  "tarif",
  "tartine",
  "tasse",
  "tatami",
  "tatouage",
  "taupe",
  "taureau",
  "taxer",
  "temoin",
  "temporel",
  "tenaille",
  "tendre",
  "teneur",
  "tenir",
  "tension",
  "terminer",
  "terne",
  "terrible",
  "tetine",
  "texte",
  "theme",
  "theorie",
  "therapie",
  "thorax",
  "tibia",
  "tiede",
  "timide",
  "tirelire",
  "tiroir",
  "tissu",
  "titane",
  "titre",
  "tituber",
  "toboggan",
  "tolerant",
  "tomate",
  "tonique",
  "tonneau",
  "toponyme",
  "torche",
  "tordre",
  "tornade",
  "torpille",
  "torrent",
  "torse",
  "tortue",
  "totem",
  "toucher",
  "tournage",
  "tousser",
  "toxine",
  "traction",
  "trafic",
  "tragique",
  "trahir",
  "train",
  "trancher",
  "travail",
  "trefle",
  "tremper",
  "tresor",
  "treuil",
  "triage",
  "tribunal",
  "tricoter",
  "trilogie",
  "triomphe",
  "tripler",
  "triturer",
  "trivial",
  "trombone",
  "tronc",
  "tropical",
  "troupeau",
  "tuile",
  "tulipe",
  "tumulte",
  "tunnel",
  "turbine",
  "tuteur",
  "tutoyer",
  "tuyau",
  "tympan",
  "typhon",
  "typique",
  "tyran",
  "ubuesque",
  "ultime",
  "ultrason",
  "unanime",
  "unifier",
  "union",
  "unique",
  "unitaire",
  "univers",
  "uranium",
  "urbain",
  "urticant",
  "usage",
  "usine",
  "usuel",
  "usure",
  "utile",
  "utopie",
  "vacarme",
  "vaccin",
  "vagabond",
  "vague",
  "vaillant",
  "vaincre",
  "vaisseau",
  "valable",
  "valise",
  "vallon",
  "valve",
  "vampire",
  "vanille",
  "vapeur",
  "varier",
  "vaseux",
  "vassal",
  "vaste",
  "vecteur",
  "vedette",
  "vegetal",
  "vehicule",
  "veinard",
  "veloce",
  "vendredi",
  "venerer",
  "venger",
  "venimeux",
  "ventouse",
  "verdure",
  "verin",
  "vernir",
  "verrou",
  "verser",
  "vertu",
  "veston",
  "veteran",
  "vetuste",
  "vexant",
  "vexer",
  "viaduc",
  "viande",
  "victoire",
  "vidange",
  "video",
  "vignette",
  "vigueur",
  "vilain",
  "village",
  "vinaigre",
  "violon",
  "vipere",
  "virement",
  "virtuose",
  "virus",
  "visage",
  "viseur",
  "vision",
  "visqueux",
  "visuel",
  "vital",
  "vitesse",
  "viticole",
  "vitrine",
  "vivace",
  "vivipare",
  "vocation",
  "voguer",
  "voile",
  "voisin",
  "voiture",
  "volaille",
  "volcan",
  "voltiger",
  "volume",
  "vorace",
  "vortex",
  "voter",
  "vouloir",
  "voyage",
  "voyelle",
  "wagon",
  "xenon",
  "yacht",
  "zebre",
  "zenith",
  "zeste",
  "zoologie"
];
var wX = [
  "abaco",
  "abbaglio",
  "abbinato",
  "abete",
  "abisso",
  "abolire",
  "abrasivo",
  "abrogato",
  "accadere",
  "accenno",
  "accusato",
  "acetone",
  "achille",
  "acido",
  "acqua",
  "acre",
  "acrilico",
  "acrobata",
  "acuto",
  "adagio",
  "addebito",
  "addome",
  "adeguato",
  "aderire",
  "adipe",
  "adottare",
  "adulare",
  "affabile",
  "affetto",
  "affisso",
  "affranto",
  "aforisma",
  "afoso",
  "africano",
  "agave",
  "agente",
  "agevole",
  "aggancio",
  "agire",
  "agitare",
  "agonismo",
  "agricolo",
  "agrumeto",
  "aguzzo",
  "alabarda",
  "alato",
  "albatro",
  "alberato",
  "albo",
  "albume",
  "alce",
  "alcolico",
  "alettone",
  "alfa",
  "algebra",
  "aliante",
  "alibi",
  "alimento",
  "allagato",
  "allegro",
  "allievo",
  "allodola",
  "allusivo",
  "almeno",
  "alogeno",
  "alpaca",
  "alpestre",
  "altalena",
  "alterno",
  "alticcio",
  "altrove",
  "alunno",
  "alveolo",
  "alzare",
  "amalgama",
  "amanita",
  "amarena",
  "ambito",
  "ambrato",
  "ameba",
  "america",
  "ametista",
  "amico",
  "ammasso",
  "ammenda",
  "ammirare",
  "ammonito",
  "amore",
  "ampio",
  "ampliare",
  "amuleto",
  "anacardo",
  "anagrafe",
  "analista",
  "anarchia",
  "anatra",
  "anca",
  "ancella",
  "ancora",
  "andare",
  "andrea",
  "anello",
  "angelo",
  "angolare",
  "angusto",
  "anima",
  "annegare",
  "annidato",
  "anno",
  "annuncio",
  "anonimo",
  "anticipo",
  "anzi",
  "apatico",
  "apertura",
  "apode",
  "apparire",
  "appetito",
  "appoggio",
  "approdo",
  "appunto",
  "aprile",
  "arabica",
  "arachide",
  "aragosta",
  "araldica",
  "arancio",
  "aratura",
  "arazzo",
  "arbitro",
  "archivio",
  "ardito",
  "arenile",
  "argento",
  "argine",
  "arguto",
  "aria",
  "armonia",
  "arnese",
  "arredato",
  "arringa",
  "arrosto",
  "arsenico",
  "arso",
  "artefice",
  "arzillo",
  "asciutto",
  "ascolto",
  "asepsi",
  "asettico",
  "asfalto",
  "asino",
  "asola",
  "aspirato",
  "aspro",
  "assaggio",
  "asse",
  "assoluto",
  "assurdo",
  "asta",
  "astenuto",
  "astice",
  "astratto",
  "atavico",
  "ateismo",
  "atomico",
  "atono",
  "attesa",
  "attivare",
  "attorno",
  "attrito",
  "attuale",
  "ausilio",
  "austria",
  "autista",
  "autonomo",
  "autunno",
  "avanzato",
  "avere",
  "avvenire",
  "avviso",
  "avvolgere",
  "azione",
  "azoto",
  "azzimo",
  "azzurro",
  "babele",
  "baccano",
  "bacino",
  "baco",
  "badessa",
  "badilata",
  "bagnato",
  "baita",
  "balcone",
  "baldo",
  "balena",
  "ballata",
  "balzano",
  "bambino",
  "bandire",
  "baraonda",
  "barbaro",
  "barca",
  "baritono",
  "barlume",
  "barocco",
  "basilico",
  "basso",
  "batosta",
  "battuto",
  "baule",
  "bava",
  "bavosa",
  "becco",
  "beffa",
  "belgio",
  "belva",
  "benda",
  "benevole",
  "benigno",
  "benzina",
  "bere",
  "berlina",
  "beta",
  "bibita",
  "bici",
  "bidone",
  "bifido",
  "biga",
  "bilancia",
  "bimbo",
  "binocolo",
  "biologo",
  "bipede",
  "bipolare",
  "birbante",
  "birra",
  "biscotto",
  "bisesto",
  "bisnonno",
  "bisonte",
  "bisturi",
  "bizzarro",
  "blando",
  "blatta",
  "bollito",
  "bonifico",
  "bordo",
  "bosco",
  "botanico",
  "bottino",
  "bozzolo",
  "braccio",
  "bradipo",
  "brama",
  "branca",
  "bravura",
  "bretella",
  "brevetto",
  "brezza",
  "briglia",
  "brillante",
  "brindare",
  "broccolo",
  "brodo",
  "bronzina",
  "brullo",
  "bruno",
  "bubbone",
  "buca",
  "budino",
  "buffone",
  "buio",
  "bulbo",
  "buono",
  "burlone",
  "burrasca",
  "bussola",
  "busta",
  "cadetto",
  "caduco",
  "calamaro",
  "calcolo",
  "calesse",
  "calibro",
  "calmo",
  "caloria",
  "cambusa",
  "camerata",
  "camicia",
  "cammino",
  "camola",
  "campale",
  "canapa",
  "candela",
  "cane",
  "canino",
  "canotto",
  "cantina",
  "capace",
  "capello",
  "capitolo",
  "capogiro",
  "cappero",
  "capra",
  "capsula",
  "carapace",
  "carcassa",
  "cardo",
  "carisma",
  "carovana",
  "carretto",
  "cartolina",
  "casaccio",
  "cascata",
  "caserma",
  "caso",
  "cassone",
  "castello",
  "casuale",
  "catasta",
  "catena",
  "catrame",
  "cauto",
  "cavillo",
  "cedibile",
  "cedrata",
  "cefalo",
  "celebre",
  "cellulare",
  "cena",
  "cenone",
  "centesimo",
  "ceramica",
  "cercare",
  "certo",
  "cerume",
  "cervello",
  "cesoia",
  "cespo",
  "ceto",
  "chela",
  "chiaro",
  "chicca",
  "chiedere",
  "chimera",
  "china",
  "chirurgo",
  "chitarra",
  "ciao",
  "ciclismo",
  "cifrare",
  "cigno",
  "cilindro",
  "ciottolo",
  "circa",
  "cirrosi",
  "citrico",
  "cittadino",
  "ciuffo",
  "civetta",
  "civile",
  "classico",
  "clinica",
  "cloro",
  "cocco",
  "codardo",
  "codice",
  "coerente",
  "cognome",
  "collare",
  "colmato",
  "colore",
  "colposo",
  "coltivato",
  "colza",
  "coma",
  "cometa",
  "commando",
  "comodo",
  "computer",
  "comune",
  "conciso",
  "condurre",
  "conferma",
  "congelare",
  "coniuge",
  "connesso",
  "conoscere",
  "consumo",
  "continuo",
  "convegno",
  "coperto",
  "copione",
  "coppia",
  "copricapo",
  "corazza",
  "cordata",
  "coricato",
  "cornice",
  "corolla",
  "corpo",
  "corredo",
  "corsia",
  "cortese",
  "cosmico",
  "costante",
  "cottura",
  "covato",
  "cratere",
  "cravatta",
  "creato",
  "credere",
  "cremoso",
  "crescita",
  "creta",
  "criceto",
  "crinale",
  "crisi",
  "critico",
  "croce",
  "cronaca",
  "crostata",
  "cruciale",
  "crusca",
  "cucire",
  "cuculo",
  "cugino",
  "cullato",
  "cupola",
  "curatore",
  "cursore",
  "curvo",
  "cuscino",
  "custode",
  "dado",
  "daino",
  "dalmata",
  "damerino",
  "daniela",
  "dannoso",
  "danzare",
  "datato",
  "davanti",
  "davvero",
  "debutto",
  "decennio",
  "deciso",
  "declino",
  "decollo",
  "decreto",
  "dedicato",
  "definito",
  "deforme",
  "degno",
  "delegare",
  "delfino",
  "delirio",
  "delta",
  "demenza",
  "denotato",
  "dentro",
  "deposito",
  "derapata",
  "derivare",
  "deroga",
  "descritto",
  "deserto",
  "desiderio",
  "desumere",
  "detersivo",
  "devoto",
  "diametro",
  "dicembre",
  "diedro",
  "difeso",
  "diffuso",
  "digerire",
  "digitale",
  "diluvio",
  "dinamico",
  "dinnanzi",
  "dipinto",
  "diploma",
  "dipolo",
  "diradare",
  "dire",
  "dirotto",
  "dirupo",
  "disagio",
  "discreto",
  "disfare",
  "disgelo",
  "disposto",
  "distanza",
  "disumano",
  "dito",
  "divano",
  "divelto",
  "dividere",
  "divorato",
  "doblone",
  "docente",
  "doganale",
  "dogma",
  "dolce",
  "domato",
  "domenica",
  "dominare",
  "dondolo",
  "dono",
  "dormire",
  "dote",
  "dottore",
  "dovuto",
  "dozzina",
  "drago",
  "druido",
  "dubbio",
  "dubitare",
  "ducale",
  "duna",
  "duomo",
  "duplice",
  "duraturo",
  "ebano",
  "eccesso",
  "ecco",
  "eclissi",
  "economia",
  "edera",
  "edicola",
  "edile",
  "editoria",
  "educare",
  "egemonia",
  "egli",
  "egoismo",
  "egregio",
  "elaborato",
  "elargire",
  "elegante",
  "elencato",
  "eletto",
  "elevare",
  "elfico",
  "elica",
  "elmo",
  "elsa",
  "eluso",
  "emanato",
  "emblema",
  "emesso",
  "emiro",
  "emotivo",
  "emozione",
  "empirico",
  "emulo",
  "endemico",
  "enduro",
  "energia",
  "enfasi",
  "enoteca",
  "entrare",
  "enzima",
  "epatite",
  "epilogo",
  "episodio",
  "epocale",
  "eppure",
  "equatore",
  "erario",
  "erba",
  "erboso",
  "erede",
  "eremita",
  "erigere",
  "ermetico",
  "eroe",
  "erosivo",
  "errante",
  "esagono",
  "esame",
  "esanime",
  "esaudire",
  "esca",
  "esempio",
  "esercito",
  "esibito",
  "esigente",
  "esistere",
  "esito",
  "esofago",
  "esortato",
  "esoso",
  "espanso",
  "espresso",
  "essenza",
  "esso",
  "esteso",
  "estimare",
  "estonia",
  "estroso",
  "esultare",
  "etilico",
  "etnico",
  "etrusco",
  "etto",
  "euclideo",
  "europa",
  "evaso",
  "evidenza",
  "evitato",
  "evoluto",
  "evviva",
  "fabbrica",
  "faccenda",
  "fachiro",
  "falco",
  "famiglia",
  "fanale",
  "fanfara",
  "fango",
  "fantasma",
  "fare",
  "farfalla",
  "farinoso",
  "farmaco",
  "fascia",
  "fastoso",
  "fasullo",
  "faticare",
  "fato",
  "favoloso",
  "febbre",
  "fecola",
  "fede",
  "fegato",
  "felpa",
  "feltro",
  "femmina",
  "fendere",
  "fenomeno",
  "fermento",
  "ferro",
  "fertile",
  "fessura",
  "festivo",
  "fetta",
  "feudo",
  "fiaba",
  "fiducia",
  "fifa",
  "figurato",
  "filo",
  "finanza",
  "finestra",
  "finire",
  "fiore",
  "fiscale",
  "fisico",
  "fiume",
  "flacone",
  "flamenco",
  "flebo",
  "flemma",
  "florido",
  "fluente",
  "fluoro",
  "fobico",
  "focaccia",
  "focoso",
  "foderato",
  "foglio",
  "folata",
  "folclore",
  "folgore",
  "fondente",
  "fonetico",
  "fonia",
  "fontana",
  "forbito",
  "forchetta",
  "foresta",
  "formica",
  "fornaio",
  "foro",
  "fortezza",
  "forzare",
  "fosfato",
  "fosso",
  "fracasso",
  "frana",
  "frassino",
  "fratello",
  "freccetta",
  "frenata",
  "fresco",
  "frigo",
  "frollino",
  "fronde",
  "frugale",
  "frutta",
  "fucilata",
  "fucsia",
  "fuggente",
  "fulmine",
  "fulvo",
  "fumante",
  "fumetto",
  "fumoso",
  "fune",
  "funzione",
  "fuoco",
  "furbo",
  "furgone",
  "furore",
  "fuso",
  "futile",
  "gabbiano",
  "gaffe",
  "galateo",
  "gallina",
  "galoppo",
  "gambero",
  "gamma",
  "garanzia",
  "garbo",
  "garofano",
  "garzone",
  "gasdotto",
  "gasolio",
  "gastrico",
  "gatto",
  "gaudio",
  "gazebo",
  "gazzella",
  "geco",
  "gelatina",
  "gelso",
  "gemello",
  "gemmato",
  "gene",
  "genitore",
  "gennaio",
  "genotipo",
  "gergo",
  "ghepardo",
  "ghiaccio",
  "ghisa",
  "giallo",
  "gilda",
  "ginepro",
  "giocare",
  "gioiello",
  "giorno",
  "giove",
  "girato",
  "girone",
  "gittata",
  "giudizio",
  "giurato",
  "giusto",
  "globulo",
  "glutine",
  "gnomo",
  "gobba",
  "golf",
  "gomito",
  "gommone",
  "gonfio",
  "gonna",
  "governo",
  "gracile",
  "grado",
  "grafico",
  "grammo",
  "grande",
  "grattare",
  "gravoso",
  "grazia",
  "greca",
  "gregge",
  "grifone",
  "grigio",
  "grinza",
  "grotta",
  "gruppo",
  "guadagno",
  "guaio",
  "guanto",
  "guardare",
  "gufo",
  "guidare",
  "ibernato",
  "icona",
  "identico",
  "idillio",
  "idolo",
  "idra",
  "idrico",
  "idrogeno",
  "igiene",
  "ignaro",
  "ignorato",
  "ilare",
  "illeso",
  "illogico",
  "illudere",
  "imballo",
  "imbevuto",
  "imbocco",
  "imbuto",
  "immane",
  "immerso",
  "immolato",
  "impacco",
  "impeto",
  "impiego",
  "importo",
  "impronta",
  "inalare",
  "inarcare",
  "inattivo",
  "incanto",
  "incendio",
  "inchino",
  "incisivo",
  "incluso",
  "incontro",
  "incrocio",
  "incubo",
  "indagine",
  "india",
  "indole",
  "inedito",
  "infatti",
  "infilare",
  "inflitto",
  "ingaggio",
  "ingegno",
  "inglese",
  "ingordo",
  "ingrosso",
  "innesco",
  "inodore",
  "inoltrare",
  "inondato",
  "insano",
  "insetto",
  "insieme",
  "insonnia",
  "insulina",
  "intasato",
  "intero",
  "intonaco",
  "intuito",
  "inumidire",
  "invalido",
  "invece",
  "invito",
  "iperbole",
  "ipnotico",
  "ipotesi",
  "ippica",
  "iride",
  "irlanda",
  "ironico",
  "irrigato",
  "irrorare",
  "isolato",
  "isotopo",
  "isterico",
  "istituto",
  "istrice",
  "italia",
  "iterare",
  "labbro",
  "labirinto",
  "lacca",
  "lacerato",
  "lacrima",
  "lacuna",
  "laddove",
  "lago",
  "lampo",
  "lancetta",
  "lanterna",
  "lardoso",
  "larga",
  "laringe",
  "lastra",
  "latenza",
  "latino",
  "lattuga",
  "lavagna",
  "lavoro",
  "legale",
  "leggero",
  "lembo",
  "lentezza",
  "lenza",
  "leone",
  "lepre",
  "lesivo",
  "lessato",
  "lesto",
  "letterale",
  "leva",
  "levigato",
  "libero",
  "lido",
  "lievito",
  "lilla",
  "limatura",
  "limitare",
  "limpido",
  "lineare",
  "lingua",
  "liquido",
  "lira",
  "lirica",
  "lisca",
  "lite",
  "litigio",
  "livrea",
  "locanda",
  "lode",
  "logica",
  "lombare",
  "londra",
  "longevo",
  "loquace",
  "lorenzo",
  "loto",
  "lotteria",
  "luce",
  "lucidato",
  "lumaca",
  "luminoso",
  "lungo",
  "lupo",
  "luppolo",
  "lusinga",
  "lusso",
  "lutto",
  "macabro",
  "macchina",
  "macero",
  "macinato",
  "madama",
  "magico",
  "maglia",
  "magnete",
  "magro",
  "maiolica",
  "malafede",
  "malgrado",
  "malinteso",
  "malsano",
  "malto",
  "malumore",
  "mana",
  "mancia",
  "mandorla",
  "mangiare",
  "manifesto",
  "mannaro",
  "manovra",
  "mansarda",
  "mantide",
  "manubrio",
  "mappa",
  "maratona",
  "marcire",
  "maretta",
  "marmo",
  "marsupio",
  "maschera",
  "massaia",
  "mastino",
  "materasso",
  "matricola",
  "mattone",
  "maturo",
  "mazurca",
  "meandro",
  "meccanico",
  "mecenate",
  "medesimo",
  "meditare",
  "mega",
  "melassa",
  "melis",
  "melodia",
  "meninge",
  "meno",
  "mensola",
  "mercurio",
  "merenda",
  "merlo",
  "meschino",
  "mese",
  "messere",
  "mestolo",
  "metallo",
  "metodo",
  "mettere",
  "miagolare",
  "mica",
  "micelio",
  "michele",
  "microbo",
  "midollo",
  "miele",
  "migliore",
  "milano",
  "milite",
  "mimosa",
  "minerale",
  "mini",
  "minore",
  "mirino",
  "mirtillo",
  "miscela",
  "missiva",
  "misto",
  "misurare",
  "mitezza",
  "mitigare",
  "mitra",
  "mittente",
  "mnemonico",
  "modello",
  "modifica",
  "modulo",
  "mogano",
  "mogio",
  "mole",
  "molosso",
  "monastero",
  "monco",
  "mondina",
  "monetario",
  "monile",
  "monotono",
  "monsone",
  "montato",
  "monviso",
  "mora",
  "mordere",
  "morsicato",
  "mostro",
  "motivato",
  "motosega",
  "motto",
  "movenza",
  "movimento",
  "mozzo",
  "mucca",
  "mucosa",
  "muffa",
  "mughetto",
  "mugnaio",
  "mulatto",
  "mulinello",
  "multiplo",
  "mummia",
  "munto",
  "muovere",
  "murale",
  "musa",
  "muscolo",
  "musica",
  "mutevole",
  "muto",
  "nababbo",
  "nafta",
  "nanometro",
  "narciso",
  "narice",
  "narrato",
  "nascere",
  "nastrare",
  "naturale",
  "nautica",
  "naviglio",
  "nebulosa",
  "necrosi",
  "negativo",
  "negozio",
  "nemmeno",
  "neofita",
  "neretto",
  "nervo",
  "nessuno",
  "nettuno",
  "neutrale",
  "neve",
  "nevrotico",
  "nicchia",
  "ninfa",
  "nitido",
  "nobile",
  "nocivo",
  "nodo",
  "nome",
  "nomina",
  "nordico",
  "normale",
  "norvegese",
  "nostrano",
  "notare",
  "notizia",
  "notturno",
  "novella",
  "nucleo",
  "nulla",
  "numero",
  "nuovo",
  "nutrire",
  "nuvola",
  "nuziale",
  "oasi",
  "obbedire",
  "obbligo",
  "obelisco",
  "oblio",
  "obolo",
  "obsoleto",
  "occasione",
  "occhio",
  "occidente",
  "occorrere",
  "occultare",
  "ocra",
  "oculato",
  "odierno",
  "odorare",
  "offerta",
  "offrire",
  "offuscato",
  "oggetto",
  "oggi",
  "ognuno",
  "olandese",
  "olfatto",
  "oliato",
  "oliva",
  "ologramma",
  "oltre",
  "omaggio",
  "ombelico",
  "ombra",
  "omega",
  "omissione",
  "ondoso",
  "onere",
  "onice",
  "onnivoro",
  "onorevole",
  "onta",
  "operato",
  "opinione",
  "opposto",
  "oracolo",
  "orafo",
  "ordine",
  "orecchino",
  "orefice",
  "orfano",
  "organico",
  "origine",
  "orizzonte",
  "orma",
  "ormeggio",
  "ornativo",
  "orologio",
  "orrendo",
  "orribile",
  "ortensia",
  "ortica",
  "orzata",
  "orzo",
  "osare",
  "oscurare",
  "osmosi",
  "ospedale",
  "ospite",
  "ossa",
  "ossidare",
  "ostacolo",
  "oste",
  "otite",
  "otre",
  "ottagono",
  "ottimo",
  "ottobre",
  "ovale",
  "ovest",
  "ovino",
  "oviparo",
  "ovocito",
  "ovunque",
  "ovviare",
  "ozio",
  "pacchetto",
  "pace",
  "pacifico",
  "padella",
  "padrone",
  "paese",
  "paga",
  "pagina",
  "palazzina",
  "palesare",
  "pallido",
  "palo",
  "palude",
  "pandoro",
  "pannello",
  "paolo",
  "paonazzo",
  "paprica",
  "parabola",
  "parcella",
  "parere",
  "pargolo",
  "pari",
  "parlato",
  "parola",
  "partire",
  "parvenza",
  "parziale",
  "passivo",
  "pasticca",
  "patacca",
  "patologia",
  "pattume",
  "pavone",
  "peccato",
  "pedalare",
  "pedonale",
  "peggio",
  "peloso",
  "penare",
  "pendice",
  "penisola",
  "pennuto",
  "penombra",
  "pensare",
  "pentola",
  "pepe",
  "pepita",
  "perbene",
  "percorso",
  "perdonato",
  "perforare",
  "pergamena",
  "periodo",
  "permesso",
  "perno",
  "perplesso",
  "persuaso",
  "pertugio",
  "pervaso",
  "pesatore",
  "pesista",
  "peso",
  "pestifero",
  "petalo",
  "pettine",
  "petulante",
  "pezzo",
  "piacere",
  "pianta",
  "piattino",
  "piccino",
  "picozza",
  "piega",
  "pietra",
  "piffero",
  "pigiama",
  "pigolio",
  "pigro",
  "pila",
  "pilifero",
  "pillola",
  "pilota",
  "pimpante",
  "pineta",
  "pinna",
  "pinolo",
  "pioggia",
  "piombo",
  "piramide",
  "piretico",
  "pirite",
  "pirolisi",
  "pitone",
  "pizzico",
  "placebo",
  "planare",
  "plasma",
  "platano",
  "plenario",
  "pochezza",
  "poderoso",
  "podismo",
  "poesia",
  "poggiare",
  "polenta",
  "poligono",
  "pollice",
  "polmonite",
  "polpetta",
  "polso",
  "poltrona",
  "polvere",
  "pomice",
  "pomodoro",
  "ponte",
  "popoloso",
  "porfido",
  "poroso",
  "porpora",
  "porre",
  "portata",
  "posa",
  "positivo",
  "possesso",
  "postulato",
  "potassio",
  "potere",
  "pranzo",
  "prassi",
  "pratica",
  "precluso",
  "predica",
  "prefisso",
  "pregiato",
  "prelievo",
  "premere",
  "prenotare",
  "preparato",
  "presenza",
  "pretesto",
  "prevalso",
  "prima",
  "principe",
  "privato",
  "problema",
  "procura",
  "produrre",
  "profumo",
  "progetto",
  "prolunga",
  "promessa",
  "pronome",
  "proposta",
  "proroga",
  "proteso",
  "prova",
  "prudente",
  "prugna",
  "prurito",
  "psiche",
  "pubblico",
  "pudica",
  "pugilato",
  "pugno",
  "pulce",
  "pulito",
  "pulsante",
  "puntare",
  "pupazzo",
  "pupilla",
  "puro",
  "quadro",
  "qualcosa",
  "quasi",
  "querela",
  "quota",
  "raccolto",
  "raddoppio",
  "radicale",
  "radunato",
  "raffica",
  "ragazzo",
  "ragione",
  "ragno",
  "ramarro",
  "ramingo",
  "ramo",
  "randagio",
  "rantolare",
  "rapato",
  "rapina",
  "rappreso",
  "rasatura",
  "raschiato",
  "rasente",
  "rassegna",
  "rastrello",
  "rata",
  "ravveduto",
  "reale",
  "recepire",
  "recinto",
  "recluta",
  "recondito",
  "recupero",
  "reddito",
  "redimere",
  "regalato",
  "registro",
  "regola",
  "regresso",
  "relazione",
  "remare",
  "remoto",
  "renna",
  "replica",
  "reprimere",
  "reputare",
  "resa",
  "residente",
  "responso",
  "restauro",
  "rete",
  "retina",
  "retorica",
  "rettifica",
  "revocato",
  "riassunto",
  "ribadire",
  "ribelle",
  "ribrezzo",
  "ricarica",
  "ricco",
  "ricevere",
  "riciclato",
  "ricordo",
  "ricreduto",
  "ridicolo",
  "ridurre",
  "rifasare",
  "riflesso",
  "riforma",
  "rifugio",
  "rigare",
  "rigettato",
  "righello",
  "rilassato",
  "rilevato",
  "rimanere",
  "rimbalzo",
  "rimedio",
  "rimorchio",
  "rinascita",
  "rincaro",
  "rinforzo",
  "rinnovo",
  "rinomato",
  "rinsavito",
  "rintocco",
  "rinuncia",
  "rinvenire",
  "riparato",
  "ripetuto",
  "ripieno",
  "riportare",
  "ripresa",
  "ripulire",
  "risata",
  "rischio",
  "riserva",
  "risibile",
  "riso",
  "rispetto",
  "ristoro",
  "risultato",
  "risvolto",
  "ritardo",
  "ritegno",
  "ritmico",
  "ritrovo",
  "riunione",
  "riva",
  "riverso",
  "rivincita",
  "rivolto",
  "rizoma",
  "roba",
  "robotico",
  "robusto",
  "roccia",
  "roco",
  "rodaggio",
  "rodere",
  "roditore",
  "rogito",
  "rollio",
  "romantico",
  "rompere",
  "ronzio",
  "rosolare",
  "rospo",
  "rotante",
  "rotondo",
  "rotula",
  "rovescio",
  "rubizzo",
  "rubrica",
  "ruga",
  "rullino",
  "rumine",
  "rumoroso",
  "ruolo",
  "rupe",
  "russare",
  "rustico",
  "sabato",
  "sabbiare",
  "sabotato",
  "sagoma",
  "salasso",
  "saldatura",
  "salgemma",
  "salivare",
  "salmone",
  "salone",
  "saltare",
  "saluto",
  "salvo",
  "sapere",
  "sapido",
  "saporito",
  "saraceno",
  "sarcasmo",
  "sarto",
  "sassoso",
  "satellite",
  "satira",
  "satollo",
  "saturno",
  "savana",
  "savio",
  "saziato",
  "sbadiglio",
  "sbalzo",
  "sbancato",
  "sbarra",
  "sbattere",
  "sbavare",
  "sbendare",
  "sbirciare",
  "sbloccato",
  "sbocciato",
  "sbrinare",
  "sbruffone",
  "sbuffare",
  "scabroso",
  "scadenza",
  "scala",
  "scambiare",
  "scandalo",
  "scapola",
  "scarso",
  "scatenare",
  "scavato",
  "scelto",
  "scenico",
  "scettro",
  "scheda",
  "schiena",
  "sciarpa",
  "scienza",
  "scindere",
  "scippo",
  "sciroppo",
  "scivolo",
  "sclerare",
  "scodella",
  "scolpito",
  "scomparto",
  "sconforto",
  "scoprire",
  "scorta",
  "scossone",
  "scozzese",
  "scriba",
  "scrollare",
  "scrutinio",
  "scuderia",
  "scultore",
  "scuola",
  "scuro",
  "scusare",
  "sdebitare",
  "sdoganare",
  "seccatura",
  "secondo",
  "sedano",
  "seggiola",
  "segnalato",
  "segregato",
  "seguito",
  "selciato",
  "selettivo",
  "sella",
  "selvaggio",
  "semaforo",
  "sembrare",
  "seme",
  "seminato",
  "sempre",
  "senso",
  "sentire",
  "sepolto",
  "sequenza",
  "serata",
  "serbato",
  "sereno",
  "serio",
  "serpente",
  "serraglio",
  "servire",
  "sestina",
  "setola",
  "settimana",
  "sfacelo",
  "sfaldare",
  "sfamato",
  "sfarzoso",
  "sfaticato",
  "sfera",
  "sfida",
  "sfilato",
  "sfinge",
  "sfocato",
  "sfoderare",
  "sfogo",
  "sfoltire",
  "sforzato",
  "sfratto",
  "sfruttato",
  "sfuggito",
  "sfumare",
  "sfuso",
  "sgabello",
  "sgarbato",
  "sgonfiare",
  "sgorbio",
  "sgrassato",
  "sguardo",
  "sibilo",
  "siccome",
  "sierra",
  "sigla",
  "signore",
  "silenzio",
  "sillaba",
  "simbolo",
  "simpatico",
  "simulato",
  "sinfonia",
  "singolo",
  "sinistro",
  "sino",
  "sintesi",
  "sinusoide",
  "sipario",
  "sisma",
  "sistole",
  "situato",
  "slitta",
  "slogatura",
  "sloveno",
  "smarrito",
  "smemorato",
  "smentito",
  "smeraldo",
  "smilzo",
  "smontare",
  "smottato",
  "smussato",
  "snellire",
  "snervato",
  "snodo",
  "sobbalzo",
  "sobrio",
  "soccorso",
  "sociale",
  "sodale",
  "soffitto",
  "sogno",
  "soldato",
  "solenne",
  "solido",
  "sollazzo",
  "solo",
  "solubile",
  "solvente",
  "somatico",
  "somma",
  "sonda",
  "sonetto",
  "sonnifero",
  "sopire",
  "soppeso",
  "sopra",
  "sorgere",
  "sorpasso",
  "sorriso",
  "sorso",
  "sorteggio",
  "sorvolato",
  "sospiro",
  "sosta",
  "sottile",
  "spada",
  "spalla",
  "spargere",
  "spatola",
  "spavento",
  "spazzola",
  "specie",
  "spedire",
  "spegnere",
  "spelatura",
  "speranza",
  "spessore",
  "spettrale",
  "spezzato",
  "spia",
  "spigoloso",
  "spillato",
  "spinoso",
  "spirale",
  "splendido",
  "sportivo",
  "sposo",
  "spranga",
  "sprecare",
  "spronato",
  "spruzzo",
  "spuntino",
  "squillo",
  "sradicare",
  "srotolato",
  "stabile",
  "stacco",
  "staffa",
  "stagnare",
  "stampato",
  "stantio",
  "starnuto",
  "stasera",
  "statuto",
  "stelo",
  "steppa",
  "sterzo",
  "stiletto",
  "stima",
  "stirpe",
  "stivale",
  "stizzoso",
  "stonato",
  "storico",
  "strappo",
  "stregato",
  "stridulo",
  "strozzare",
  "strutto",
  "stuccare",
  "stufo",
  "stupendo",
  "subentro",
  "succoso",
  "sudore",
  "suggerito",
  "sugo",
  "sultano",
  "suonare",
  "superbo",
  "supporto",
  "surgelato",
  "surrogato",
  "sussurro",
  "sutura",
  "svagare",
  "svedese",
  "sveglio",
  "svelare",
  "svenuto",
  "svezia",
  "sviluppo",
  "svista",
  "svizzera",
  "svolta",
  "svuotare",
  "tabacco",
  "tabulato",
  "tacciare",
  "taciturno",
  "tale",
  "talismano",
  "tampone",
  "tannino",
  "tara",
  "tardivo",
  "targato",
  "tariffa",
  "tarpare",
  "tartaruga",
  "tasto",
  "tattico",
  "taverna",
  "tavolata",
  "tazza",
  "teca",
  "tecnico",
  "telefono",
  "temerario",
  "tempo",
  "temuto",
  "tendone",
  "tenero",
  "tensione",
  "tentacolo",
  "teorema",
  "terme",
  "terrazzo",
  "terzetto",
  "tesi",
  "tesserato",
  "testato",
  "tetro",
  "tettoia",
  "tifare",
  "tigella",
  "timbro",
  "tinto",
  "tipico",
  "tipografo",
  "tiraggio",
  "tiro",
  "titanio",
  "titolo",
  "titubante",
  "tizio",
  "tizzone",
  "toccare",
  "tollerare",
  "tolto",
  "tombola",
  "tomo",
  "tonfo",
  "tonsilla",
  "topazio",
  "topologia",
  "toppa",
  "torba",
  "tornare",
  "torrone",
  "tortora",
  "toscano",
  "tossire",
  "tostatura",
  "totano",
  "trabocco",
  "trachea",
  "trafila",
  "tragedia",
  "tralcio",
  "tramonto",
  "transito",
  "trapano",
  "trarre",
  "trasloco",
  "trattato",
  "trave",
  "treccia",
  "tremolio",
  "trespolo",
  "tributo",
  "tricheco",
  "trifoglio",
  "trillo",
  "trincea",
  "trio",
  "tristezza",
  "triturato",
  "trivella",
  "tromba",
  "trono",
  "troppo",
  "trottola",
  "trovare",
  "truccato",
  "tubatura",
  "tuffato",
  "tulipano",
  "tumulto",
  "tunisia",
  "turbare",
  "turchino",
  "tuta",
  "tutela",
  "ubicato",
  "uccello",
  "uccisore",
  "udire",
  "uditivo",
  "uffa",
  "ufficio",
  "uguale",
  "ulisse",
  "ultimato",
  "umano",
  "umile",
  "umorismo",
  "uncinetto",
  "ungere",
  "ungherese",
  "unicorno",
  "unificato",
  "unisono",
  "unitario",
  "unte",
  "uovo",
  "upupa",
  "uragano",
  "urgenza",
  "urlo",
  "usanza",
  "usato",
  "uscito",
  "usignolo",
  "usuraio",
  "utensile",
  "utilizzo",
  "utopia",
  "vacante",
  "vaccinato",
  "vagabondo",
  "vagliato",
  "valanga",
  "valgo",
  "valico",
  "valletta",
  "valoroso",
  "valutare",
  "valvola",
  "vampata",
  "vangare",
  "vanitoso",
  "vano",
  "vantaggio",
  "vanvera",
  "vapore",
  "varano",
  "varcato",
  "variante",
  "vasca",
  "vedetta",
  "vedova",
  "veduto",
  "vegetale",
  "veicolo",
  "velcro",
  "velina",
  "velluto",
  "veloce",
  "venato",
  "vendemmia",
  "vento",
  "verace",
  "verbale",
  "vergogna",
  "verifica",
  "vero",
  "verruca",
  "verticale",
  "vescica",
  "vessillo",
  "vestale",
  "veterano",
  "vetrina",
  "vetusto",
  "viandante",
  "vibrante",
  "vicenda",
  "vichingo",
  "vicinanza",
  "vidimare",
  "vigilia",
  "vigneto",
  "vigore",
  "vile",
  "villano",
  "vimini",
  "vincitore",
  "viola",
  "vipera",
  "virgola",
  "virologo",
  "virulento",
  "viscoso",
  "visione",
  "vispo",
  "vissuto",
  "visura",
  "vita",
  "vitello",
  "vittima",
  "vivanda",
  "vivido",
  "viziare",
  "voce",
  "voga",
  "volatile",
  "volere",
  "volpe",
  "voragine",
  "vulcano",
  "zampogna",
  "zanna",
  "zappato",
  "zattera",
  "zavorra",
  "zefiro",
  "zelante",
  "zelo",
  "zenzero",
  "zerbino",
  "zibetto",
  "zinco",
  "zircone",
  "zitto",
  "zolla",
  "zotico",
  "zucchero",
  "zufolo",
  "zulu",
  "zuppa"
];
var vX = [
  "abaco",
  "abdomen",
  "abeja",
  "abierto",
  "abogado",
  "abono",
  "aborto",
  "abrazo",
  "abrir",
  "abuelo",
  "abuso",
  "acabar",
  "academia",
  "acceso",
  "accion",
  "aceite",
  "acelga",
  "acento",
  "aceptar",
  "acido",
  "aclarar",
  "acne",
  "acoger",
  "acoso",
  "activo",
  "acto",
  "actriz",
  "actuar",
  "acudir",
  "acuerdo",
  "acusar",
  "adicto",
  "admitir",
  "adoptar",
  "adorno",
  "aduana",
  "adulto",
  "aereo",
  "afectar",
  "aficion",
  "afinar",
  "afirmar",
  "agil",
  "agitar",
  "agonia",
  "agosto",
  "agotar",
  "agregar",
  "agrio",
  "agua",
  "agudo",
  "aguila",
  "aguja",
  "ahogo",
  "ahorro",
  "aire",
  "aislar",
  "ajedrez",
  "ajeno",
  "ajuste",
  "alacran",
  "alambre",
  "alarma",
  "alba",
  "album",
  "alcalde",
  "aldea",
  "alegre",
  "alejar",
  "alerta",
  "aleta",
  "alfiler",
  "alga",
  "algodon",
  "aliado",
  "aliento",
  "alivio",
  "alma",
  "almeja",
  "almibar",
  "altar",
  "alteza",
  "altivo",
  "alto",
  "altura",
  "alumno",
  "alzar",
  "amable",
  "amante",
  "amapola",
  "amargo",
  "amasar",
  "ambar",
  "ambito",
  "ameno",
  "amigo",
  "amistad",
  "amor",
  "amparo",
  "amplio",
  "ancho",
  "anciano",
  "ancla",
  "andar",
  "anden",
  "anemia",
  "angulo",
  "anillo",
  "animo",
  "anis",
  "anotar",
  "antena",
  "antiguo",
  "antojo",
  "anual",
  "anular",
  "anuncio",
  "anadir",
  "anejo",
  "ano",
  "apagar",
  "aparato",
  "apetito",
  "apio",
  "aplicar",
  "apodo",
  "aporte",
  "apoyo",
  "aprender",
  "aprobar",
  "apuesta",
  "apuro",
  "arado",
  "arana",
  "arar",
  "arbitro",
  "arbol",
  "arbusto",
  "archivo",
  "arco",
  "arder",
  "ardilla",
  "arduo",
  "area",
  "arido",
  "aries",
  "armonia",
  "arnes",
  "aroma",
  "arpa",
  "arpon",
  "arreglo",
  "arroz",
  "arruga",
  "arte",
  "artista",
  "asa",
  "asado",
  "asalto",
  "ascenso",
  "asegurar",
  "aseo",
  "asesor",
  "asiento",
  "asilo",
  "asistir",
  "asno",
  "asombro",
  "aspero",
  "astilla",
  "astro",
  "astuto",
  "asumir",
  "asunto",
  "atajo",
  "ataque",
  "atar",
  "atento",
  "ateo",
  "atico",
  "atleta",
  "atomo",
  "atraer",
  "atroz",
  "atun",
  "audaz",
  "audio",
  "auge",
  "aula",
  "aumento",
  "ausente",
  "autor",
  "aval",
  "avance",
  "avaro",
  "ave",
  "avellana",
  "avena",
  "avestruz",
  "avion",
  "aviso",
  "ayer",
  "ayuda",
  "ayuno",
  "azafran",
  "azar",
  "azote",
  "azucar",
  "azufre",
  "azul",
  "baba",
  "babor",
  "bache",
  "bahia",
  "baile",
  "bajar",
  "balanza",
  "balcon",
  "balde",
  "bambu",
  "banco",
  "banda",
  "bano",
  "barba",
  "barco",
  "barniz",
  "barro",
  "bascula",
  "baston",
  "basura",
  "batalla",
  "bateria",
  "batir",
  "batuta",
  "baul",
  "bazar",
  "bebe",
  "bebida",
  "bello",
  "besar",
  "beso",
  "bestia",
  "bicho",
  "bien",
  "bingo",
  "blanco",
  "bloque",
  "blusa",
  "boa",
  "bobina",
  "bobo",
  "boca",
  "bocina",
  "boda",
  "bodega",
  "boina",
  "bola",
  "bolero",
  "bolsa",
  "bomba",
  "bondad",
  "bonito",
  "bono",
  "bonsai",
  "borde",
  "borrar",
  "bosque",
  "bote",
  "botin",
  "boveda",
  "bozal",
  "bravo",
  "brazo",
  "brecha",
  "breve",
  "brillo",
  "brinco",
  "brisa",
  "broca",
  "broma",
  "bronce",
  "brote",
  "bruja",
  "brusco",
  "bruto",
  "buceo",
  "bucle",
  "bueno",
  "buey",
  "bufanda",
  "bufon",
  "buho",
  "buitre",
  "bulto",
  "burbuja",
  "burla",
  "burro",
  "buscar",
  "butaca",
  "buzon",
  "caballo",
  "cabeza",
  "cabina",
  "cabra",
  "cacao",
  "cadaver",
  "cadena",
  "caer",
  "cafe",
  "caida",
  "caiman",
  "caja",
  "cajon",
  "cal",
  "calamar",
  "calcio",
  "caldo",
  "calidad",
  "calle",
  "calma",
  "calor",
  "calvo",
  "cama",
  "cambio",
  "camello",
  "camino",
  "campo",
  "cancer",
  "candil",
  "canela",
  "canguro",
  "canica",
  "canto",
  "cana",
  "canon",
  "caoba",
  "caos",
  "capaz",
  "capitan",
  "capote",
  "captar",
  "capucha",
  "cara",
  "carbon",
  "carcel",
  "careta",
  "carga",
  "carino",
  "carne",
  "carpeta",
  "carro",
  "carta",
  "casa",
  "casco",
  "casero",
  "caspa",
  "castor",
  "catorce",
  "catre",
  "caudal",
  "causa",
  "cazo",
  "cebolla",
  "ceder",
  "cedro",
  "celda",
  "celebre",
  "celoso",
  "celula",
  "cemento",
  "ceniza",
  "centro",
  "cerca",
  "cerdo",
  "cereza",
  "cero",
  "cerrar",
  "certeza",
  "cesped",
  "cetro",
  "chacal",
  "chaleco",
  "champu",
  "chancla",
  "chapa",
  "charla",
  "chico",
  "chiste",
  "chivo",
  "choque",
  "choza",
  "chuleta",
  "chupar",
  "ciclon",
  "ciego",
  "cielo",
  "cien",
  "cierto",
  "cifra",
  "cigarro",
  "cima",
  "cinco",
  "cine",
  "cinta",
  "cipres",
  "circo",
  "ciruela",
  "cisne",
  "cita",
  "ciudad",
  "clamor",
  "clan",
  "claro",
  "clase",
  "clave",
  "cliente",
  "clima",
  "clinica",
  "cobre",
  "coccion",
  "cochino",
  "cocina",
  "coco",
  "codigo",
  "codo",
  "cofre",
  "coger",
  "cohete",
  "cojin",
  "cojo",
  "cola",
  "colcha",
  "colegio",
  "colgar",
  "colina",
  "collar",
  "colmo",
  "columna",
  "combate",
  "comer",
  "comida",
  "comodo",
  "compra",
  "conde",
  "conejo",
  "conga",
  "conocer",
  "consejo",
  "contar",
  "copa",
  "copia",
  "corazon",
  "corbata",
  "corcho",
  "cordon",
  "corona",
  "correr",
  "coser",
  "cosmos",
  "costa",
  "craneo",
  "crater",
  "crear",
  "crecer",
  "creido",
  "crema",
  "cria",
  "crimen",
  "cripta",
  "crisis",
  "cromo",
  "cronica",
  "croqueta",
  "crudo",
  "cruz",
  "cuadro",
  "cuarto",
  "cuatro",
  "cubo",
  "cubrir",
  "cuchara",
  "cuello",
  "cuento",
  "cuerda",
  "cuesta",
  "cueva",
  "cuidar",
  "culebra",
  "culpa",
  "culto",
  "cumbre",
  "cumplir",
  "cuna",
  "cuneta",
  "cuota",
  "cupon",
  "cupula",
  "curar",
  "curioso",
  "curso",
  "curva",
  "cutis",
  "dama",
  "danza",
  "dar",
  "dardo",
  "datil",
  "deber",
  "debil",
  "decada",
  "decir",
  "dedo",
  "defensa",
  "definir",
  "dejar",
  "delfin",
  "delgado",
  "delito",
  "demora",
  "denso",
  "dental",
  "deporte",
  "derecho",
  "derrota",
  "desayuno",
  "deseo",
  "desfile",
  "desnudo",
  "destino",
  "desvio",
  "detalle",
  "detener",
  "deuda",
  "dia",
  "diablo",
  "diadema",
  "diamante",
  "diana",
  "diario",
  "dibujo",
  "dictar",
  "diente",
  "dieta",
  "diez",
  "dificil",
  "digno",
  "dilema",
  "diluir",
  "dinero",
  "directo",
  "dirigir",
  "disco",
  "diseno",
  "disfraz",
  "diva",
  "divino",
  "doble",
  "doce",
  "dolor",
  "domingo",
  "don",
  "donar",
  "dorado",
  "dormir",
  "dorso",
  "dos",
  "dosis",
  "dragon",
  "droga",
  "ducha",
  "duda",
  "duelo",
  "dueno",
  "dulce",
  "duo",
  "duque",
  "durar",
  "dureza",
  "duro",
  "ebano",
  "ebrio",
  "echar",
  "eco",
  "ecuador",
  "edad",
  "edicion",
  "edificio",
  "editor",
  "educar",
  "efecto",
  "eficaz",
  "eje",
  "ejemplo",
  "elefante",
  "elegir",
  "elemento",
  "elevar",
  "elipse",
  "elite",
  "elixir",
  "elogio",
  "eludir",
  "embudo",
  "emitir",
  "emocion",
  "empate",
  "empeno",
  "empleo",
  "empresa",
  "enano",
  "encargo",
  "enchufe",
  "encia",
  "enemigo",
  "enero",
  "enfado",
  "enfermo",
  "engano",
  "enigma",
  "enlace",
  "enorme",
  "enredo",
  "ensayo",
  "ensenar",
  "entero",
  "entrar",
  "envase",
  "envio",
  "epoca",
  "equipo",
  "erizo",
  "escala",
  "escena",
  "escolar",
  "escribir",
  "escudo",
  "esencia",
  "esfera",
  "esfuerzo",
  "espada",
  "espejo",
  "espia",
  "esposa",
  "espuma",
  "esqui",
  "estar",
  "este",
  "estilo",
  "estufa",
  "etapa",
  "eterno",
  "etica",
  "etnia",
  "evadir",
  "evaluar",
  "evento",
  "evitar",
  "exacto",
  "examen",
  "exceso",
  "excusa",
  "exento",
  "exigir",
  "exilio",
  "existir",
  "exito",
  "experto",
  "explicar",
  "exponer",
  "extremo",
  "fabrica",
  "fabula",
  "fachada",
  "facil",
  "factor",
  "faena",
  "faja",
  "falda",
  "fallo",
  "falso",
  "faltar",
  "fama",
  "familia",
  "famoso",
  "faraon",
  "farmacia",
  "farol",
  "farsa",
  "fase",
  "fatiga",
  "fauna",
  "favor",
  "fax",
  "febrero",
  "fecha",
  "feliz",
  "feo",
  "feria",
  "feroz",
  "fertil",
  "fervor",
  "festin",
  "fiable",
  "fianza",
  "fiar",
  "fibra",
  "ficcion",
  "ficha",
  "fideo",
  "fiebre",
  "fiel",
  "fiera",
  "fiesta",
  "figura",
  "fijar",
  "fijo",
  "fila",
  "filete",
  "filial",
  "filtro",
  "fin",
  "finca",
  "fingir",
  "finito",
  "firma",
  "flaco",
  "flauta",
  "flecha",
  "flor",
  "flota",
  "fluir",
  "flujo",
  "fluor",
  "fobia",
  "foca",
  "fogata",
  "fogon",
  "folio",
  "folleto",
  "fondo",
  "forma",
  "forro",
  "fortuna",
  "forzar",
  "fosa",
  "foto",
  "fracaso",
  "fragil",
  "franja",
  "frase",
  "fraude",
  "freir",
  "freno",
  "fresa",
  "frio",
  "frito",
  "fruta",
  "fuego",
  "fuente",
  "fuerza",
  "fuga",
  "fumar",
  "funcion",
  "funda",
  "furgon",
  "furia",
  "fusil",
  "futbol",
  "futuro",
  "gacela",
  "gafas",
  "gaita",
  "gajo",
  "gala",
  "galeria",
  "gallo",
  "gamba",
  "ganar",
  "gancho",
  "ganga",
  "ganso",
  "garaje",
  "garza",
  "gasolina",
  "gastar",
  "gato",
  "gavilan",
  "gemelo",
  "gemir",
  "gen",
  "genero",
  "genio",
  "gente",
  "geranio",
  "gerente",
  "germen",
  "gesto",
  "gigante",
  "gimnasio",
  "girar",
  "giro",
  "glaciar",
  "globo",
  "gloria",
  "gol",
  "golfo",
  "goloso",
  "golpe",
  "goma",
  "gordo",
  "gorila",
  "gorra",
  "gota",
  "goteo",
  "gozar",
  "grada",
  "grafico",
  "grano",
  "grasa",
  "gratis",
  "grave",
  "grieta",
  "grillo",
  "gripe",
  "gris",
  "grito",
  "grosor",
  "grua",
  "grueso",
  "grumo",
  "grupo",
  "guante",
  "guapo",
  "guardia",
  "guerra",
  "guia",
  "guino",
  "guion",
  "guiso",
  "guitarra",
  "gusano",
  "gustar",
  "haber",
  "habil",
  "hablar",
  "hacer",
  "hacha",
  "hada",
  "hallar",
  "hamaca",
  "harina",
  "haz",
  "hazana",
  "hebilla",
  "hebra",
  "hecho",
  "helado",
  "helio",
  "hembra",
  "herir",
  "hermano",
  "heroe",
  "hervir",
  "hielo",
  "hierro",
  "higado",
  "higiene",
  "hijo",
  "himno",
  "historia",
  "hocico",
  "hogar",
  "hoguera",
  "hoja",
  "hombre",
  "hongo",
  "honor",
  "honra",
  "hora",
  "hormiga",
  "horno",
  "hostil",
  "hoyo",
  "hueco",
  "huelga",
  "huerta",
  "hueso",
  "huevo",
  "huida",
  "huir",
  "humano",
  "humedo",
  "humilde",
  "humo",
  "hundir",
  "huracan",
  "hurto",
  "icono",
  "ideal",
  "idioma",
  "idolo",
  "iglesia",
  "iglu",
  "igual",
  "ilegal",
  "ilusion",
  "imagen",
  "iman",
  "imitar",
  "impar",
  "imperio",
  "imponer",
  "impulso",
  "incapaz",
  "indice",
  "inerte",
  "infiel",
  "informe",
  "ingenio",
  "inicio",
  "inmenso",
  "inmune",
  "innato",
  "insecto",
  "instante",
  "interes",
  "intimo",
  "intuir",
  "inutil",
  "invierno",
  "ira",
  "iris",
  "ironia",
  "isla",
  "islote",
  "jabali",
  "jabon",
  "jamon",
  "jarabe",
  "jardin",
  "jarra",
  "jaula",
  "jazmin",
  "jefe",
  "jeringa",
  "jinete",
  "jornada",
  "joroba",
  "joven",
  "joya",
  "juerga",
  "jueves",
  "juez",
  "jugador",
  "jugo",
  "juguete",
  "juicio",
  "junco",
  "jungla",
  "junio",
  "juntar",
  "jupiter",
  "jurar",
  "justo",
  "juvenil",
  "juzgar",
  "kilo",
  "koala",
  "labio",
  "lacio",
  "lacra",
  "lado",
  "ladron",
  "lagarto",
  "lagrima",
  "laguna",
  "laico",
  "lamer",
  "lamina",
  "lampara",
  "lana",
  "lancha",
  "langosta",
  "lanza",
  "lapiz",
  "largo",
  "larva",
  "lastima",
  "lata",
  "latex",
  "latir",
  "laurel",
  "lavar",
  "lazo",
  "leal",
  "leccion",
  "leche",
  "lector",
  "leer",
  "legion",
  "legumbre",
  "lejano",
  "lengua",
  "lento",
  "lena",
  "leon",
  "leopardo",
  "lesion",
  "letal",
  "letra",
  "leve",
  "leyenda",
  "libertad",
  "libro",
  "licor",
  "lider",
  "lidiar",
  "lienzo",
  "liga",
  "ligero",
  "lima",
  "limite",
  "limon",
  "limpio",
  "lince",
  "lindo",
  "linea",
  "lingote",
  "lino",
  "linterna",
  "liquido",
  "liso",
  "lista",
  "litera",
  "litio",
  "litro",
  "llaga",
  "llama",
  "llanto",
  "llave",
  "llegar",
  "llenar",
  "llevar",
  "llorar",
  "llover",
  "lluvia",
  "lobo",
  "locion",
  "loco",
  "locura",
  "logica",
  "logro",
  "lombriz",
  "lomo",
  "lonja",
  "lote",
  "lucha",
  "lucir",
  "lugar",
  "lujo",
  "luna",
  "lunes",
  "lupa",
  "lustro",
  "luto",
  "luz",
  "maceta",
  "macho",
  "madera",
  "madre",
  "maduro",
  "maestro",
  "mafia",
  "magia",
  "mago",
  "maiz",
  "maldad",
  "maleta",
  "malla",
  "malo",
  "mama",
  "mambo",
  "mamut",
  "manco",
  "mando",
  "manejar",
  "manga",
  "maniqui",
  "manjar",
  "mano",
  "manso",
  "manta",
  "manana",
  "mapa",
  "maquina",
  "mar",
  "marco",
  "marea",
  "marfil",
  "margen",
  "marido",
  "marmol",
  "marron",
  "martes",
  "marzo",
  "masa",
  "mascara",
  "masivo",
  "matar",
  "materia",
  "matiz",
  "matriz",
  "maximo",
  "mayor",
  "mazorca",
  "mecha",
  "medalla",
  "medio",
  "medula",
  "mejilla",
  "mejor",
  "melena",
  "melon",
  "memoria",
  "menor",
  "mensaje",
  "mente",
  "menu",
  "mercado",
  "merengue",
  "merito",
  "mes",
  "meson",
  "meta",
  "meter",
  "metodo",
  "metro",
  "mezcla",
  "miedo",
  "miel",
  "miembro",
  "miga",
  "mil",
  "milagro",
  "militar",
  "millon",
  "mimo",
  "mina",
  "minero",
  "minimo",
  "minuto",
  "miope",
  "mirar",
  "misa",
  "miseria",
  "misil",
  "mismo",
  "mitad",
  "mito",
  "mochila",
  "mocion",
  "moda",
  "modelo",
  "moho",
  "mojar",
  "molde",
  "moler",
  "molino",
  "momento",
  "momia",
  "monarca",
  "moneda",
  "monja",
  "monto",
  "mono",
  "morada",
  "morder",
  "moreno",
  "morir",
  "morro",
  "morsa",
  "mortal",
  "mosca",
  "mostrar",
  "motivo",
  "mover",
  "movil",
  "mozo",
  "mucho",
  "mudar",
  "mueble",
  "muela",
  "muerte",
  "muestra",
  "mugre",
  "mujer",
  "mula",
  "muleta",
  "multa",
  "mundo",
  "muneca",
  "mural",
  "muro",
  "musculo",
  "museo",
  "musgo",
  "musica",
  "muslo",
  "nacar",
  "nacion",
  "nadar",
  "naipe",
  "naranja",
  "nariz",
  "narrar",
  "nasal",
  "natal",
  "nativo",
  "natural",
  "nausea",
  "naval",
  "nave",
  "navidad",
  "necio",
  "nectar",
  "negar",
  "negocio",
  "negro",
  "neon",
  "nervio",
  "neto",
  "neutro",
  "nevar",
  "nevera",
  "nicho",
  "nido",
  "niebla",
  "nieto",
  "ninez",
  "nino",
  "nitido",
  "nivel",
  "nobleza",
  "noche",
  "nomina",
  "noria",
  "norma",
  "norte",
  "nota",
  "noticia",
  "novato",
  "novela",
  "novio",
  "nube",
  "nuca",
  "nucleo",
  "nudillo",
  "nudo",
  "nuera",
  "nueve",
  "nuez",
  "nulo",
  "numero",
  "nutria",
  "oasis",
  "obeso",
  "obispo",
  "objeto",
  "obra",
  "obrero",
  "observar",
  "obtener",
  "obvio",
  "oca",
  "ocaso",
  "oceano",
  "ochenta",
  "ocho",
  "ocio",
  "ocre",
  "octavo",
  "octubre",
  "oculto",
  "ocupar",
  "ocurrir",
  "odiar",
  "odio",
  "odisea",
  "oeste",
  "ofensa",
  "oferta",
  "oficio",
  "ofrecer",
  "ogro",
  "oido",
  "oir",
  "ojo",
  "ola",
  "oleada",
  "olfato",
  "olivo",
  "olla",
  "olmo",
  "olor",
  "olvido",
  "ombligo",
  "onda",
  "onza",
  "opaco",
  "opcion",
  "opera",
  "opinar",
  "oponer",
  "optar",
  "optica",
  "opuesto",
  "oracion",
  "orador",
  "oral",
  "orbita",
  "orca",
  "orden",
  "oreja",
  "organo",
  "orgia",
  "orgullo",
  "oriente",
  "origen",
  "orilla",
  "oro",
  "orquesta",
  "oruga",
  "osadia",
  "oscuro",
  "osezno",
  "oso",
  "ostra",
  "otono",
  "otro",
  "oveja",
  "ovulo",
  "oxido",
  "oxigeno",
  "oyente",
  "ozono",
  "pacto",
  "padre",
  "paella",
  "pagina",
  "pago",
  "pais",
  "pajaro",
  "palabra",
  "palco",
  "paleta",
  "palido",
  "palma",
  "paloma",
  "palpar",
  "pan",
  "panal",
  "panico",
  "pantera",
  "panuelo",
  "papa",
  "papel",
  "papilla",
  "paquete",
  "parar",
  "parcela",
  "pared",
  "parir",
  "paro",
  "parpado",
  "parque",
  "parrafo",
  "parte",
  "pasar",
  "paseo",
  "pasion",
  "paso",
  "pasta",
  "pata",
  "patio",
  "patria",
  "pausa",
  "pauta",
  "pavo",
  "payaso",
  "peaton",
  "pecado",
  "pecera",
  "pecho",
  "pedal",
  "pedir",
  "pegar",
  "peine",
  "pelar",
  "peldano",
  "pelea",
  "peligro",
  "pellejo",
  "pelo",
  "peluca",
  "pena",
  "pensar",
  "penon",
  "peon",
  "peor",
  "pepino",
  "pequeno",
  "pera",
  "percha",
  "perder",
  "pereza",
  "perfil",
  "perico",
  "perla",
  "permiso",
  "perro",
  "persona",
  "pesa",
  "pesca",
  "pesimo",
  "pestana",
  "petalo",
  "petroleo",
  "pez",
  "pezuna",
  "picar",
  "pichon",
  "pie",
  "piedra",
  "pierna",
  "pieza",
  "pijama",
  "pilar",
  "piloto",
  "pimienta",
  "pino",
  "pintor",
  "pinza",
  "pina",
  "piojo",
  "pipa",
  "pirata",
  "pisar",
  "piscina",
  "piso",
  "pista",
  "piton",
  "pizca",
  "placa",
  "plan",
  "plata",
  "playa",
  "plaza",
  "pleito",
  "pleno",
  "plomo",
  "pluma",
  "plural",
  "pobre",
  "poco",
  "poder",
  "podio",
  "poema",
  "poesia",
  "poeta",
  "polen",
  "policia",
  "pollo",
  "polvo",
  "pomada",
  "pomelo",
  "pomo",
  "pompa",
  "poner",
  "porcion",
  "portal",
  "posada",
  "poseer",
  "posible",
  "poste",
  "potencia",
  "potro",
  "pozo",
  "prado",
  "precoz",
  "pregunta",
  "premio",
  "prensa",
  "preso",
  "previo",
  "primo",
  "principe",
  "prision",
  "privar",
  "proa",
  "probar",
  "proceso",
  "producto",
  "proeza",
  "profesor",
  "programa",
  "prole",
  "promesa",
  "pronto",
  "propio",
  "proximo",
  "prueba",
  "publico",
  "puchero",
  "pudor",
  "pueblo",
  "puerta",
  "puesto",
  "pulga",
  "pulir",
  "pulmon",
  "pulpo",
  "pulso",
  "puma",
  "punto",
  "punal",
  "puno",
  "pupa",
  "pupila",
  "pure",
  "quedar",
  "queja",
  "quemar",
  "querer",
  "queso",
  "quieto",
  "quimica",
  "quince",
  "quitar",
  "rabano",
  "rabia",
  "rabo",
  "racion",
  "radical",
  "raiz",
  "rama",
  "rampa",
  "rancho",
  "rango",
  "rapaz",
  "rapido",
  "rapto",
  "rasgo",
  "raspa",
  "rato",
  "rayo",
  "raza",
  "razon",
  "reaccion",
  "realidad",
  "rebano",
  "rebote",
  "recaer",
  "receta",
  "rechazo",
  "recoger",
  "recreo",
  "recto",
  "recurso",
  "red",
  "redondo",
  "reducir",
  "reflejo",
  "reforma",
  "refran",
  "refugio",
  "regalo",
  "regir",
  "regla",
  "regreso",
  "rehen",
  "reino",
  "reir",
  "reja",
  "relato",
  "relevo",
  "relieve",
  "relleno",
  "reloj",
  "remar",
  "remedio",
  "remo",
  "rencor",
  "rendir",
  "renta",
  "reparto",
  "repetir",
  "reposo",
  "reptil",
  "res",
  "rescate",
  "resina",
  "respeto",
  "resto",
  "resumen",
  "retiro",
  "retorno",
  "retrato",
  "reunir",
  "reves",
  "revista",
  "rey",
  "rezar",
  "rico",
  "riego",
  "rienda",
  "riesgo",
  "rifa",
  "rigido",
  "rigor",
  "rincon",
  "rinon",
  "rio",
  "riqueza",
  "risa",
  "ritmo",
  "rito",
  "rizo",
  "roble",
  "roce",
  "rociar",
  "rodar",
  "rodeo",
  "rodilla",
  "roer",
  "rojizo",
  "rojo",
  "romero",
  "romper",
  "ron",
  "ronco",
  "ronda",
  "ropa",
  "ropero",
  "rosa",
  "rosca",
  "rostro",
  "rotar",
  "rubi",
  "rubor",
  "rudo",
  "rueda",
  "rugir",
  "ruido",
  "ruina",
  "ruleta",
  "rulo",
  "rumbo",
  "rumor",
  "ruptura",
  "ruta",
  "rutina",
  "sabado",
  "saber",
  "sabio",
  "sable",
  "sacar",
  "sagaz",
  "sagrado",
  "sala",
  "saldo",
  "salero",
  "salir",
  "salmon",
  "salon",
  "salsa",
  "salto",
  "salud",
  "salvar",
  "samba",
  "sancion",
  "sandia",
  "sanear",
  "sangre",
  "sanidad",
  "sano",
  "santo",
  "sapo",
  "saque",
  "sardina",
  "sarten",
  "sastre",
  "satan",
  "sauna",
  "saxofon",
  "seccion",
  "seco",
  "secreto",
  "secta",
  "sed",
  "seguir",
  "seis",
  "sello",
  "selva",
  "semana",
  "semilla",
  "senda",
  "sensor",
  "senal",
  "senor",
  "separar",
  "sepia",
  "sequia",
  "ser",
  "serie",
  "sermon",
  "servir",
  "sesenta",
  "sesion",
  "seta",
  "setenta",
  "severo",
  "sexo",
  "sexto",
  "sidra",
  "siesta",
  "siete",
  "siglo",
  "signo",
  "silaba",
  "silbar",
  "silencio",
  "silla",
  "simbolo",
  "simio",
  "sirena",
  "sistema",
  "sitio",
  "situar",
  "sobre",
  "socio",
  "sodio",
  "sol",
  "solapa",
  "soldado",
  "soledad",
  "solido",
  "soltar",
  "solucion",
  "sombra",
  "sondeo",
  "sonido",
  "sonoro",
  "sonrisa",
  "sopa",
  "soplar",
  "soporte",
  "sordo",
  "sorpresa",
  "sorteo",
  "sosten",
  "sotano",
  "suave",
  "subir",
  "suceso",
  "sudor",
  "suegra",
  "suelo",
  "sueno",
  "suerte",
  "sufrir",
  "sujeto",
  "sultan",
  "sumar",
  "superar",
  "suplir",
  "suponer",
  "supremo",
  "sur",
  "surco",
  "sureno",
  "surgir",
  "susto",
  "sutil",
  "tabaco",
  "tabique",
  "tabla",
  "tabu",
  "taco",
  "tacto",
  "tajo",
  "talar",
  "talco",
  "talento",
  "talla",
  "talon",
  "tamano",
  "tambor",
  "tango",
  "tanque",
  "tapa",
  "tapete",
  "tapia",
  "tapon",
  "taquilla",
  "tarde",
  "tarea",
  "tarifa",
  "tarjeta",
  "tarot",
  "tarro",
  "tarta",
  "tatuaje",
  "tauro",
  "taza",
  "tazon",
  "teatro",
  "techo",
  "tecla",
  "tecnica",
  "tejado",
  "tejer",
  "tejido",
  "tela",
  "telefono",
  "tema",
  "temor",
  "templo",
  "tenaz",
  "tender",
  "tener",
  "tenis",
  "tenso",
  "teoria",
  "terapia",
  "terco",
  "termino",
  "ternura",
  "terror",
  "tesis",
  "tesoro",
  "testigo",
  "tetera",
  "texto",
  "tez",
  "tibio",
  "tiburon",
  "tiempo",
  "tienda",
  "tierra",
  "tieso",
  "tigre",
  "tijera",
  "tilde",
  "timbre",
  "timido",
  "timo",
  "tinta",
  "tio",
  "tipico",
  "tipo",
  "tira",
  "tiron",
  "titan",
  "titere",
  "titulo",
  "tiza",
  "toalla",
  "tobillo",
  "tocar",
  "tocino",
  "todo",
  "toga",
  "toldo",
  "tomar",
  "tono",
  "tonto",
  "topar",
  "tope",
  "toque",
  "torax",
  "torero",
  "tormenta",
  "torneo",
  "toro",
  "torpedo",
  "torre",
  "torso",
  "tortuga",
  "tos",
  "tosco",
  "toser",
  "toxico",
  "trabajo",
  "tractor",
  "traer",
  "trafico",
  "trago",
  "traje",
  "tramo",
  "trance",
  "trato",
  "trauma",
  "trazar",
  "trebol",
  "tregua",
  "treinta",
  "tren",
  "trepar",
  "tres",
  "tribu",
  "trigo",
  "tripa",
  "triste",
  "triunfo",
  "trofeo",
  "trompa",
  "tronco",
  "tropa",
  "trote",
  "trozo",
  "truco",
  "trueno",
  "trufa",
  "tuberia",
  "tubo",
  "tuerto",
  "tumba",
  "tumor",
  "tunel",
  "tunica",
  "turbina",
  "turismo",
  "turno",
  "tutor",
  "ubicar",
  "ulcera",
  "umbral",
  "unidad",
  "unir",
  "universo",
  "uno",
  "untar",
  "una",
  "urbano",
  "urbe",
  "urgente",
  "urna",
  "usar",
  "usuario",
  "util",
  "utopia",
  "uva",
  "vaca",
  "vacio",
  "vacuna",
  "vagar",
  "vago",
  "vaina",
  "vajilla",
  "vale",
  "valido",
  "valle",
  "valor",
  "valvula",
  "vampiro",
  "vara",
  "variar",
  "varon",
  "vaso",
  "vecino",
  "vector",
  "vehiculo",
  "veinte",
  "vejez",
  "vela",
  "velero",
  "veloz",
  "vena",
  "vencer",
  "venda",
  "veneno",
  "vengar",
  "venir",
  "venta",
  "venus",
  "ver",
  "verano",
  "verbo",
  "verde",
  "vereda",
  "verja",
  "verso",
  "verter",
  "via",
  "viaje",
  "vibrar",
  "vicio",
  "victima",
  "vida",
  "video",
  "vidrio",
  "viejo",
  "viernes",
  "vigor",
  "vil",
  "villa",
  "vinagre",
  "vino",
  "vinedo",
  "violin",
  "viral",
  "virgo",
  "virtud",
  "visor",
  "vispera",
  "vista",
  "vitamina",
  "viudo",
  "vivaz",
  "vivero",
  "vivir",
  "vivo",
  "volcan",
  "volumen",
  "volver",
  "voraz",
  "votar",
  "voto",
  "voz",
  "vuelo",
  "vulgar",
  "yacer",
  "yate",
  "yegua",
  "yema",
  "yerno",
  "yeso",
  "yodo",
  "yoga",
  "yogur",
  "zafiro",
  "zanja",
  "zapato",
  "zarza",
  "zona",
  "zorro",
  "zumo",
  "zurdo"
];
var EX = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var xX = [
  "abacate",
  "abaixo",
  "abalar",
  "abater",
  "abduzir",
  "abelha",
  "aberto",
  "abismo",
  "abotoar",
  "abranger",
  "abreviar",
  "abrigar",
  "abrupto",
  "absinto",
  "absoluto",
  "absurdo",
  "abutre",
  "acabado",
  "acalmar",
  "acampar",
  "acanhar",
  "acaso",
  "aceitar",
  "acelerar",
  "acenar",
  "acervo",
  "acessar",
  "acetona",
  "achatar",
  "acidez",
  "acima",
  "acionado",
  "acirrar",
  "aclamar",
  "aclive",
  "acolhida",
  "acomodar",
  "acoplar",
  "acordar",
  "acumular",
  "acusador",
  "adaptar",
  "adega",
  "adentro",
  "adepto",
  "adequar",
  "aderente",
  "adesivo",
  "adeus",
  "adiante",
  "aditivo",
  "adjetivo",
  "adjunto",
  "admirar",
  "adorar",
  "adquirir",
  "adubo",
  "adverso",
  "advogado",
  "aeronave",
  "afastar",
  "aferir",
  "afetivo",
  "afinador",
  "afivelar",
  "aflito",
  "afluente",
  "afrontar",
  "agachar",
  "agarrar",
  "agasalho",
  "agenciar",
  "agilizar",
  "agiota",
  "agitado",
  "agora",
  "agradar",
  "agreste",
  "agrupar",
  "aguardar",
  "agulha",
  "ajoelhar",
  "ajudar",
  "ajustar",
  "alameda",
  "alarme",
  "alastrar",
  "alavanca",
  "albergue",
  "albino",
  "alcatra",
  "aldeia",
  "alecrim",
  "alegria",
  "alertar",
  "alface",
  "alfinete",
  "algum",
  "alheio",
  "aliar",
  "alicate",
  "alienar",
  "alinhar",
  "aliviar",
  "almofada",
  "alocar",
  "alpiste",
  "alterar",
  "altitude",
  "alucinar",
  "alugar",
  "aluno",
  "alusivo",
  "alvo",
  "amaciar",
  "amador",
  "amarelo",
  "amassar",
  "ambas",
  "ambiente",
  "ameixa",
  "amenizar",
  "amido",
  "amistoso",
  "amizade",
  "amolador",
  "amontoar",
  "amoroso",
  "amostra",
  "amparar",
  "ampliar",
  "ampola",
  "anagrama",
  "analisar",
  "anarquia",
  "anatomia",
  "andaime",
  "anel",
  "anexo",
  "angular",
  "animar",
  "anjo",
  "anomalia",
  "anotado",
  "ansioso",
  "anterior",
  "anuidade",
  "anunciar",
  "anzol",
  "apagador",
  "apalpar",
  "apanhado",
  "apego",
  "apelido",
  "apertada",
  "apesar",
  "apetite",
  "apito",
  "aplauso",
  "aplicada",
  "apoio",
  "apontar",
  "aposta",
  "aprendiz",
  "aprovar",
  "aquecer",
  "arame",
  "aranha",
  "arara",
  "arcada",
  "ardente",
  "areia",
  "arejar",
  "arenito",
  "aresta",
  "argiloso",
  "argola",
  "arma",
  "arquivo",
  "arraial",
  "arrebate",
  "arriscar",
  "arroba",
  "arrumar",
  "arsenal",
  "arterial",
  "artigo",
  "arvoredo",
  "asfaltar",
  "asilado",
  "aspirar",
  "assador",
  "assinar",
  "assoalho",
  "assunto",
  "astral",
  "atacado",
  "atadura",
  "atalho",
  "atarefar",
  "atear",
  "atender",
  "aterro",
  "ateu",
  "atingir",
  "atirador",
  "ativo",
  "atoleiro",
  "atracar",
  "atrevido",
  "atriz",
  "atual",
  "atum",
  "auditor",
  "aumentar",
  "aura",
  "aurora",
  "autismo",
  "autoria",
  "autuar",
  "avaliar",
  "avante",
  "avaria",
  "avental",
  "avesso",
  "aviador",
  "avisar",
  "avulso",
  "axila",
  "azarar",
  "azedo",
  "azeite",
  "azulejo",
  "babar",
  "babosa",
  "bacalhau",
  "bacharel",
  "bacia",
  "bagagem",
  "baiano",
  "bailar",
  "baioneta",
  "bairro",
  "baixista",
  "bajular",
  "baleia",
  "baliza",
  "balsa",
  "banal",
  "bandeira",
  "banho",
  "banir",
  "banquete",
  "barato",
  "barbado",
  "baronesa",
  "barraca",
  "barulho",
  "baseado",
  "bastante",
  "batata",
  "batedor",
  "batida",
  "batom",
  "batucar",
  "baunilha",
  "beber",
  "beijo",
  "beirada",
  "beisebol",
  "beldade",
  "beleza",
  "belga",
  "beliscar",
  "bendito",
  "bengala",
  "benzer",
  "berimbau",
  "berlinda",
  "berro",
  "besouro",
  "bexiga",
  "bezerro",
  "bico",
  "bicudo",
  "bienal",
  "bifocal",
  "bifurcar",
  "bigorna",
  "bilhete",
  "bimestre",
  "bimotor",
  "biologia",
  "biombo",
  "biosfera",
  "bipolar",
  "birrento",
  "biscoito",
  "bisneto",
  "bispo",
  "bissexto",
  "bitola",
  "bizarro",
  "blindado",
  "bloco",
  "bloquear",
  "boato",
  "bobagem",
  "bocado",
  "bocejo",
  "bochecha",
  "boicotar",
  "bolada",
  "boletim",
  "bolha",
  "bolo",
  "bombeiro",
  "bonde",
  "boneco",
  "bonita",
  "borbulha",
  "borda",
  "boreal",
  "borracha",
  "bovino",
  "boxeador",
  "branco",
  "brasa",
  "braveza",
  "breu",
  "briga",
  "brilho",
  "brincar",
  "broa",
  "brochura",
  "bronzear",
  "broto",
  "bruxo",
  "bucha",
  "budismo",
  "bufar",
  "bule",
  "buraco",
  "busca",
  "busto",
  "buzina",
  "cabana",
  "cabelo",
  "cabide",
  "cabo",
  "cabrito",
  "cacau",
  "cacetada",
  "cachorro",
  "cacique",
  "cadastro",
  "cadeado",
  "cafezal",
  "caiaque",
  "caipira",
  "caixote",
  "cajado",
  "caju",
  "calafrio",
  "calcular",
  "caldeira",
  "calibrar",
  "calmante",
  "calota",
  "camada",
  "cambista",
  "camisa",
  "camomila",
  "campanha",
  "camuflar",
  "canavial",
  "cancelar",
  "caneta",
  "canguru",
  "canhoto",
  "canivete",
  "canoa",
  "cansado",
  "cantar",
  "canudo",
  "capacho",
  "capela",
  "capinar",
  "capotar",
  "capricho",
  "captador",
  "capuz",
  "caracol",
  "carbono",
  "cardeal",
  "careca",
  "carimbar",
  "carneiro",
  "carpete",
  "carreira",
  "cartaz",
  "carvalho",
  "casaco",
  "casca",
  "casebre",
  "castelo",
  "casulo",
  "catarata",
  "cativar",
  "caule",
  "causador",
  "cautelar",
  "cavalo",
  "caverna",
  "cebola",
  "cedilha",
  "cegonha",
  "celebrar",
  "celular",
  "cenoura",
  "censo",
  "centeio",
  "cercar",
  "cerrado",
  "certeiro",
  "cerveja",
  "cetim",
  "cevada",
  "chacota",
  "chaleira",
  "chamado",
  "chapada",
  "charme",
  "chatice",
  "chave",
  "chefe",
  "chegada",
  "cheiro",
  "cheque",
  "chicote",
  "chifre",
  "chinelo",
  "chocalho",
  "chover",
  "chumbo",
  "chutar",
  "chuva",
  "cicatriz",
  "ciclone",
  "cidade",
  "cidreira",
  "ciente",
  "cigana",
  "cimento",
  "cinto",
  "cinza",
  "ciranda",
  "circuito",
  "cirurgia",
  "citar",
  "clareza",
  "clero",
  "clicar",
  "clone",
  "clube",
  "coado",
  "coagir",
  "cobaia",
  "cobertor",
  "cobrar",
  "cocada",
  "coelho",
  "coentro",
  "coeso",
  "cogumelo",
  "coibir",
  "coifa",
  "coiote",
  "colar",
  "coleira",
  "colher",
  "colidir",
  "colmeia",
  "colono",
  "coluna",
  "comando",
  "combinar",
  "comentar",
  "comitiva",
  "comover",
  "complexo",
  "comum",
  "concha",
  "condor",
  "conectar",
  "confuso",
  "congelar",
  "conhecer",
  "conjugar",
  "consumir",
  "contrato",
  "convite",
  "cooperar",
  "copeiro",
  "copiador",
  "copo",
  "coquetel",
  "coragem",
  "cordial",
  "corneta",
  "coronha",
  "corporal",
  "correio",
  "cortejo",
  "coruja",
  "corvo",
  "cosseno",
  "costela",
  "cotonete",
  "couro",
  "couve",
  "covil",
  "cozinha",
  "cratera",
  "cravo",
  "creche",
  "credor",
  "creme",
  "crer",
  "crespo",
  "criada",
  "criminal",
  "crioulo",
  "crise",
  "criticar",
  "crosta",
  "crua",
  "cruzeiro",
  "cubano",
  "cueca",
  "cuidado",
  "cujo",
  "culatra",
  "culminar",
  "culpar",
  "cultura",
  "cumprir",
  "cunhado",
  "cupido",
  "curativo",
  "curral",
  "cursar",
  "curto",
  "cuspir",
  "custear",
  "cutelo",
  "damasco",
  "datar",
  "debater",
  "debitar",
  "deboche",
  "debulhar",
  "decalque",
  "decimal",
  "declive",
  "decote",
  "decretar",
  "dedal",
  "dedicado",
  "deduzir",
  "defesa",
  "defumar",
  "degelo",
  "degrau",
  "degustar",
  "deitado",
  "deixar",
  "delator",
  "delegado",
  "delinear",
  "delonga",
  "demanda",
  "demitir",
  "demolido",
  "dentista",
  "depenado",
  "depilar",
  "depois",
  "depressa",
  "depurar",
  "deriva",
  "derramar",
  "desafio",
  "desbotar",
  "descanso",
  "desenho",
  "desfiado",
  "desgaste",
  "desigual",
  "deslize",
  "desmamar",
  "desova",
  "despesa",
  "destaque",
  "desviar",
  "detalhar",
  "detentor",
  "detonar",
  "detrito",
  "deusa",
  "dever",
  "devido",
  "devotado",
  "dezena",
  "diagrama",
  "dialeto",
  "didata",
  "difuso",
  "digitar",
  "dilatado",
  "diluente",
  "diminuir",
  "dinastia",
  "dinheiro",
  "diocese",
  "direto",
  "discreta",
  "disfarce",
  "disparo",
  "disquete",
  "dissipar",
  "distante",
  "ditador",
  "diurno",
  "diverso",
  "divisor",
  "divulgar",
  "dizer",
  "dobrador",
  "dolorido",
  "domador",
  "dominado",
  "donativo",
  "donzela",
  "dormente",
  "dorsal",
  "dosagem",
  "dourado",
  "doutor",
  "drenagem",
  "drible",
  "drogaria",
  "duelar",
  "duende",
  "dueto",
  "duplo",
  "duquesa",
  "durante",
  "duvidoso",
  "eclodir",
  "ecoar",
  "ecologia",
  "edificar",
  "edital",
  "educado",
  "efeito",
  "efetivar",
  "ejetar",
  "elaborar",
  "eleger",
  "eleitor",
  "elenco",
  "elevador",
  "eliminar",
  "elogiar",
  "embargo",
  "embolado",
  "embrulho",
  "embutido",
  "emenda",
  "emergir",
  "emissor",
  "empatia",
  "empenho",
  "empinado",
  "empolgar",
  "emprego",
  "empurrar",
  "emulador",
  "encaixe",
  "encenado",
  "enchente",
  "encontro",
  "endeusar",
  "endossar",
  "enfaixar",
  "enfeite",
  "enfim",
  "engajado",
  "engenho",
  "englobar",
  "engomado",
  "engraxar",
  "enguia",
  "enjoar",
  "enlatar",
  "enquanto",
  "enraizar",
  "enrolado",
  "enrugar",
  "ensaio",
  "enseada",
  "ensino",
  "ensopado",
  "entanto",
  "enteado",
  "entidade",
  "entortar",
  "entrada",
  "entulho",
  "envergar",
  "enviado",
  "envolver",
  "enxame",
  "enxerto",
  "enxofre",
  "enxuto",
  "epiderme",
  "equipar",
  "ereto",
  "erguido",
  "errata",
  "erva",
  "ervilha",
  "esbanjar",
  "esbelto",
  "escama",
  "escola",
  "escrita",
  "escuta",
  "esfinge",
  "esfolar",
  "esfregar",
  "esfumado",
  "esgrima",
  "esmalte",
  "espanto",
  "espelho",
  "espiga",
  "esponja",
  "espreita",
  "espumar",
  "esquerda",
  "estaca",
  "esteira",
  "esticar",
  "estofado",
  "estrela",
  "estudo",
  "esvaziar",
  "etanol",
  "etiqueta",
  "euforia",
  "europeu",
  "evacuar",
  "evaporar",
  "evasivo",
  "eventual",
  "evidente",
  "evoluir",
  "exagero",
  "exalar",
  "examinar",
  "exato",
  "exausto",
  "excesso",
  "excitar",
  "exclamar",
  "executar",
  "exemplo",
  "exibir",
  "exigente",
  "exonerar",
  "expandir",
  "expelir",
  "expirar",
  "explanar",
  "exposto",
  "expresso",
  "expulsar",
  "externo",
  "extinto",
  "extrato",
  "fabricar",
  "fabuloso",
  "faceta",
  "facial",
  "fada",
  "fadiga",
  "faixa",
  "falar",
  "falta",
  "familiar",
  "fandango",
  "fanfarra",
  "fantoche",
  "fardado",
  "farelo",
  "farinha",
  "farofa",
  "farpa",
  "fartura",
  "fatia",
  "fator",
  "favorita",
  "faxina",
  "fazenda",
  "fechado",
  "feijoada",
  "feirante",
  "felino",
  "feminino",
  "fenda",
  "feno",
  "fera",
  "feriado",
  "ferrugem",
  "ferver",
  "festejar",
  "fetal",
  "feudal",
  "fiapo",
  "fibrose",
  "ficar",
  "ficheiro",
  "figurado",
  "fileira",
  "filho",
  "filme",
  "filtrar",
  "firmeza",
  "fisgada",
  "fissura",
  "fita",
  "fivela",
  "fixador",
  "fixo",
  "flacidez",
  "flamingo",
  "flanela",
  "flechada",
  "flora",
  "flutuar",
  "fluxo",
  "focal",
  "focinho",
  "fofocar",
  "fogo",
  "foguete",
  "foice",
  "folgado",
  "folheto",
  "forjar",
  "formiga",
  "forno",
  "forte",
  "fosco",
  "fossa",
  "fragata",
  "fralda",
  "frango",
  "frasco",
  "fraterno",
  "freira",
  "frente",
  "fretar",
  "frieza",
  "friso",
  "fritura",
  "fronha",
  "frustrar",
  "fruteira",
  "fugir",
  "fulano",
  "fuligem",
  "fundar",
  "fungo",
  "funil",
  "furador",
  "furioso",
  "futebol",
  "gabarito",
  "gabinete",
  "gado",
  "gaiato",
  "gaiola",
  "gaivota",
  "galega",
  "galho",
  "galinha",
  "galocha",
  "ganhar",
  "garagem",
  "garfo",
  "gargalo",
  "garimpo",
  "garoupa",
  "garrafa",
  "gasoduto",
  "gasto",
  "gata",
  "gatilho",
  "gaveta",
  "gazela",
  "gelado",
  "geleia",
  "gelo",
  "gemada",
  "gemer",
  "gemido",
  "generoso",
  "gengiva",
  "genial",
  "genoma",
  "genro",
  "geologia",
  "gerador",
  "germinar",
  "gesso",
  "gestor",
  "ginasta",
  "gincana",
  "gingado",
  "girafa",
  "girino",
  "glacial",
  "glicose",
  "global",
  "glorioso",
  "goela",
  "goiaba",
  "golfe",
  "golpear",
  "gordura",
  "gorjeta",
  "gorro",
  "gostoso",
  "goteira",
  "governar",
  "gracejo",
  "gradual",
  "grafite",
  "gralha",
  "grampo",
  "granada",
  "gratuito",
  "graveto",
  "graxa",
  "grego",
  "grelhar",
  "greve",
  "grilo",
  "grisalho",
  "gritaria",
  "grosso",
  "grotesco",
  "grudado",
  "grunhido",
  "gruta",
  "guache",
  "guarani",
  "guaxinim",
  "guerrear",
  "guiar",
  "guincho",
  "guisado",
  "gula",
  "guloso",
  "guru",
  "habitar",
  "harmonia",
  "haste",
  "haver",
  "hectare",
  "herdar",
  "heresia",
  "hesitar",
  "hiato",
  "hibernar",
  "hidratar",
  "hiena",
  "hino",
  "hipismo",
  "hipnose",
  "hipoteca",
  "hoje",
  "holofote",
  "homem",
  "honesto",
  "honrado",
  "hormonal",
  "hospedar",
  "humorado",
  "iate",
  "ideia",
  "idoso",
  "ignorado",
  "igreja",
  "iguana",
  "ileso",
  "ilha",
  "iludido",
  "iluminar",
  "ilustrar",
  "imagem",
  "imediato",
  "imenso",
  "imersivo",
  "iminente",
  "imitador",
  "imortal",
  "impacto",
  "impedir",
  "implante",
  "impor",
  "imprensa",
  "impune",
  "imunizar",
  "inalador",
  "inapto",
  "inativo",
  "incenso",
  "inchar",
  "incidir",
  "incluir",
  "incolor",
  "indeciso",
  "indireto",
  "indutor",
  "ineficaz",
  "inerente",
  "infantil",
  "infestar",
  "infinito",
  "inflamar",
  "informal",
  "infrator",
  "ingerir",
  "inibido",
  "inicial",
  "inimigo",
  "injetar",
  "inocente",
  "inodoro",
  "inovador",
  "inox",
  "inquieto",
  "inscrito",
  "inseto",
  "insistir",
  "inspetor",
  "instalar",
  "insulto",
  "intacto",
  "integral",
  "intimar",
  "intocado",
  "intriga",
  "invasor",
  "inverno",
  "invicto",
  "invocar",
  "iogurte",
  "iraniano",
  "ironizar",
  "irreal",
  "irritado",
  "isca",
  "isento",
  "isolado",
  "isqueiro",
  "italiano",
  "janeiro",
  "jangada",
  "janta",
  "jararaca",
  "jardim",
  "jarro",
  "jasmim",
  "jato",
  "javali",
  "jazida",
  "jejum",
  "joaninha",
  "joelhada",
  "jogador",
  "joia",
  "jornal",
  "jorrar",
  "jovem",
  "juba",
  "judeu",
  "judoca",
  "juiz",
  "julgador",
  "julho",
  "jurado",
  "jurista",
  "juro",
  "justa",
  "labareda",
  "laboral",
  "lacre",
  "lactante",
  "ladrilho",
  "lagarta",
  "lagoa",
  "laje",
  "lamber",
  "lamentar",
  "laminar",
  "lampejo",
  "lanche",
  "lapidar",
  "lapso",
  "laranja",
  "lareira",
  "largura",
  "lasanha",
  "lastro",
  "lateral",
  "latido",
  "lavanda",
  "lavoura",
  "lavrador",
  "laxante",
  "lazer",
  "lealdade",
  "lebre",
  "legado",
  "legendar",
  "legista",
  "leigo",
  "leiloar",
  "leitura",
  "lembrete",
  "leme",
  "lenhador",
  "lentilha",
  "leoa",
  "lesma",
  "leste",
  "letivo",
  "letreiro",
  "levar",
  "leveza",
  "levitar",
  "liberal",
  "libido",
  "liderar",
  "ligar",
  "ligeiro",
  "limitar",
  "limoeiro",
  "limpador",
  "linda",
  "linear",
  "linhagem",
  "liquidez",
  "listagem",
  "lisura",
  "litoral",
  "livro",
  "lixa",
  "lixeira",
  "locador",
  "locutor",
  "lojista",
  "lombo",
  "lona",
  "longe",
  "lontra",
  "lorde",
  "lotado",
  "loteria",
  "loucura",
  "lousa",
  "louvar",
  "luar",
  "lucidez",
  "lucro",
  "luneta",
  "lustre",
  "lutador",
  "luva",
  "macaco",
  "macete",
  "machado",
  "macio",
  "madeira",
  "madrinha",
  "magnata",
  "magreza",
  "maior",
  "mais",
  "malandro",
  "malha",
  "malote",
  "maluco",
  "mamilo",
  "mamoeiro",
  "mamute",
  "manada",
  "mancha",
  "mandato",
  "manequim",
  "manhoso",
  "manivela",
  "manobrar",
  "mansa",
  "manter",
  "manusear",
  "mapeado",
  "maquinar",
  "marcador",
  "maresia",
  "marfim",
  "margem",
  "marinho",
  "marmita",
  "maroto",
  "marquise",
  "marreco",
  "martelo",
  "marujo",
  "mascote",
  "masmorra",
  "massagem",
  "mastigar",
  "matagal",
  "materno",
  "matinal",
  "matutar",
  "maxilar",
  "medalha",
  "medida",
  "medusa",
  "megafone",
  "meiga",
  "melancia",
  "melhor",
  "membro",
  "memorial",
  "menino",
  "menos",
  "mensagem",
  "mental",
  "merecer",
  "mergulho",
  "mesada",
  "mesclar",
  "mesmo",
  "mesquita",
  "mestre",
  "metade",
  "meteoro",
  "metragem",
  "mexer",
  "mexicano",
  "micro",
  "migalha",
  "migrar",
  "milagre",
  "milenar",
  "milhar",
  "mimado",
  "minerar",
  "minhoca",
  "ministro",
  "minoria",
  "miolo",
  "mirante",
  "mirtilo",
  "misturar",
  "mocidade",
  "moderno",
  "modular",
  "moeda",
  "moer",
  "moinho",
  "moita",
  "moldura",
  "moleza",
  "molho",
  "molinete",
  "molusco",
  "montanha",
  "moqueca",
  "morango",
  "morcego",
  "mordomo",
  "morena",
  "mosaico",
  "mosquete",
  "mostarda",
  "motel",
  "motim",
  "moto",
  "motriz",
  "muda",
  "muito",
  "mulata",
  "mulher",
  "multar",
  "mundial",
  "munido",
  "muralha",
  "murcho",
  "muscular",
  "museu",
  "musical",
  "nacional",
  "nadador",
  "naja",
  "namoro",
  "narina",
  "narrado",
  "nascer",
  "nativa",
  "natureza",
  "navalha",
  "navegar",
  "navio",
  "neblina",
  "nebuloso",
  "negativa",
  "negociar",
  "negrito",
  "nervoso",
  "neta",
  "neural",
  "nevasca",
  "nevoeiro",
  "ninar",
  "ninho",
  "nitidez",
  "nivelar",
  "nobreza",
  "noite",
  "noiva",
  "nomear",
  "nominal",
  "nordeste",
  "nortear",
  "notar",
  "noticiar",
  "noturno",
  "novelo",
  "novilho",
  "novo",
  "nublado",
  "nudez",
  "numeral",
  "nupcial",
  "nutrir",
  "nuvem",
  "obcecado",
  "obedecer",
  "objetivo",
  "obrigado",
  "obscuro",
  "obstetra",
  "obter",
  "obturar",
  "ocidente",
  "ocioso",
  "ocorrer",
  "oculista",
  "ocupado",
  "ofegante",
  "ofensiva",
  "oferenda",
  "oficina",
  "ofuscado",
  "ogiva",
  "olaria",
  "oleoso",
  "olhar",
  "oliveira",
  "ombro",
  "omelete",
  "omisso",
  "omitir",
  "ondulado",
  "oneroso",
  "ontem",
  "opcional",
  "operador",
  "oponente",
  "oportuno",
  "oposto",
  "orar",
  "orbitar",
  "ordem",
  "ordinal",
  "orfanato",
  "orgasmo",
  "orgulho",
  "oriental",
  "origem",
  "oriundo",
  "orla",
  "ortodoxo",
  "orvalho",
  "oscilar",
  "ossada",
  "osso",
  "ostentar",
  "otimismo",
  "ousadia",
  "outono",
  "outubro",
  "ouvido",
  "ovelha",
  "ovular",
  "oxidar",
  "oxigenar",
  "pacato",
  "paciente",
  "pacote",
  "pactuar",
  "padaria",
  "padrinho",
  "pagar",
  "pagode",
  "painel",
  "pairar",
  "paisagem",
  "palavra",
  "palestra",
  "palheta",
  "palito",
  "palmada",
  "palpitar",
  "pancada",
  "panela",
  "panfleto",
  "panqueca",
  "pantanal",
  "papagaio",
  "papelada",
  "papiro",
  "parafina",
  "parcial",
  "pardal",
  "parede",
  "partida",
  "pasmo",
  "passado",
  "pastel",
  "patamar",
  "patente",
  "patinar",
  "patrono",
  "paulada",
  "pausar",
  "peculiar",
  "pedalar",
  "pedestre",
  "pediatra",
  "pedra",
  "pegada",
  "peitoral",
  "peixe",
  "pele",
  "pelicano",
  "penca",
  "pendurar",
  "peneira",
  "penhasco",
  "pensador",
  "pente",
  "perceber",
  "perfeito",
  "pergunta",
  "perito",
  "permitir",
  "perna",
  "perplexo",
  "persiana",
  "pertence",
  "peruca",
  "pescado",
  "pesquisa",
  "pessoa",
  "petiscar",
  "piada",
  "picado",
  "piedade",
  "pigmento",
  "pilastra",
  "pilhado",
  "pilotar",
  "pimenta",
  "pincel",
  "pinguim",
  "pinha",
  "pinote",
  "pintar",
  "pioneiro",
  "pipoca",
  "piquete",
  "piranha",
  "pires",
  "pirueta",
  "piscar",
  "pistola",
  "pitanga",
  "pivete",
  "planta",
  "plaqueta",
  "platina",
  "plebeu",
  "plumagem",
  "pluvial",
  "pneu",
  "poda",
  "poeira",
  "poetisa",
  "polegada",
  "policiar",
  "poluente",
  "polvilho",
  "pomar",
  "pomba",
  "ponderar",
  "pontaria",
  "populoso",
  "porta",
  "possuir",
  "postal",
  "pote",
  "poupar",
  "pouso",
  "povoar",
  "praia",
  "prancha",
  "prato",
  "praxe",
  "prece",
  "predador",
  "prefeito",
  "premiar",
  "prensar",
  "preparar",
  "presilha",
  "pretexto",
  "prevenir",
  "prezar",
  "primata",
  "princesa",
  "prisma",
  "privado",
  "processo",
  "produto",
  "profeta",
  "proibido",
  "projeto",
  "prometer",
  "propagar",
  "prosa",
  "protetor",
  "provador",
  "publicar",
  "pudim",
  "pular",
  "pulmonar",
  "pulseira",
  "punhal",
  "punir",
  "pupilo",
  "pureza",
  "puxador",
  "quadra",
  "quantia",
  "quarto",
  "quase",
  "quebrar",
  "queda",
  "queijo",
  "quente",
  "querido",
  "quimono",
  "quina",
  "quiosque",
  "rabanada",
  "rabisco",
  "rachar",
  "racionar",
  "radial",
  "raiar",
  "rainha",
  "raio",
  "raiva",
  "rajada",
  "ralado",
  "ramal",
  "ranger",
  "ranhura",
  "rapadura",
  "rapel",
  "rapidez",
  "raposa",
  "raquete",
  "raridade",
  "rasante",
  "rascunho",
  "rasgar",
  "raspador",
  "rasteira",
  "rasurar",
  "ratazana",
  "ratoeira",
  "realeza",
  "reanimar",
  "reaver",
  "rebaixar",
  "rebelde",
  "rebolar",
  "recado",
  "recente",
  "recheio",
  "recibo",
  "recordar",
  "recrutar",
  "recuar",
  "rede",
  "redimir",
  "redonda",
  "reduzida",
  "reenvio",
  "refinar",
  "refletir",
  "refogar",
  "refresco",
  "refugiar",
  "regalia",
  "regime",
  "regra",
  "reinado",
  "reitor",
  "rejeitar",
  "relativo",
  "remador",
  "remendo",
  "remorso",
  "renovado",
  "reparo",
  "repelir",
  "repleto",
  "repolho",
  "represa",
  "repudiar",
  "requerer",
  "resenha",
  "resfriar",
  "resgatar",
  "residir",
  "resolver",
  "respeito",
  "ressaca",
  "restante",
  "resumir",
  "retalho",
  "reter",
  "retirar",
  "retomada",
  "retratar",
  "revelar",
  "revisor",
  "revolta",
  "riacho",
  "rica",
  "rigidez",
  "rigoroso",
  "rimar",
  "ringue",
  "risada",
  "risco",
  "risonho",
  "robalo",
  "rochedo",
  "rodada",
  "rodeio",
  "rodovia",
  "roedor",
  "roleta",
  "romano",
  "roncar",
  "rosado",
  "roseira",
  "rosto",
  "rota",
  "roteiro",
  "rotina",
  "rotular",
  "rouco",
  "roupa",
  "roxo",
  "rubro",
  "rugido",
  "rugoso",
  "ruivo",
  "rumo",
  "rupestre",
  "russo",
  "sabor",
  "saciar",
  "sacola",
  "sacudir",
  "sadio",
  "safira",
  "saga",
  "sagrada",
  "saibro",
  "salada",
  "saleiro",
  "salgado",
  "saliva",
  "salpicar",
  "salsicha",
  "saltar",
  "salvador",
  "sambar",
  "samurai",
  "sanar",
  "sanfona",
  "sangue",
  "sanidade",
  "sapato",
  "sarda",
  "sargento",
  "sarjeta",
  "saturar",
  "saudade",
  "saxofone",
  "sazonal",
  "secar",
  "secular",
  "seda",
  "sedento",
  "sediado",
  "sedoso",
  "sedutor",
  "segmento",
  "segredo",
  "segundo",
  "seiva",
  "seleto",
  "selvagem",
  "semanal",
  "semente",
  "senador",
  "senhor",
  "sensual",
  "sentado",
  "separado",
  "sereia",
  "seringa",
  "serra",
  "servo",
  "setembro",
  "setor",
  "sigilo",
  "silhueta",
  "silicone",
  "simetria",
  "simpatia",
  "simular",
  "sinal",
  "sincero",
  "singular",
  "sinopse",
  "sintonia",
  "sirene",
  "siri",
  "situado",
  "soberano",
  "sobra",
  "socorro",
  "sogro",
  "soja",
  "solda",
  "soletrar",
  "solteiro",
  "sombrio",
  "sonata",
  "sondar",
  "sonegar",
  "sonhador",
  "sono",
  "soprano",
  "soquete",
  "sorrir",
  "sorteio",
  "sossego",
  "sotaque",
  "soterrar",
  "sovado",
  "sozinho",
  "suavizar",
  "subida",
  "submerso",
  "subsolo",
  "subtrair",
  "sucata",
  "sucesso",
  "suco",
  "sudeste",
  "sufixo",
  "sugador",
  "sugerir",
  "sujeito",
  "sulfato",
  "sumir",
  "suor",
  "superior",
  "suplicar",
  "suposto",
  "suprimir",
  "surdina",
  "surfista",
  "surpresa",
  "surreal",
  "surtir",
  "suspiro",
  "sustento",
  "tabela",
  "tablete",
  "tabuada",
  "tacho",
  "tagarela",
  "talher",
  "talo",
  "talvez",
  "tamanho",
  "tamborim",
  "tampa",
  "tangente",
  "tanto",
  "tapar",
  "tapioca",
  "tardio",
  "tarefa",
  "tarja",
  "tarraxa",
  "tatuagem",
  "taurino",
  "taxativo",
  "taxista",
  "teatral",
  "tecer",
  "tecido",
  "teclado",
  "tedioso",
  "teia",
  "teimar",
  "telefone",
  "telhado",
  "tempero",
  "tenente",
  "tensor",
  "tentar",
  "termal",
  "terno",
  "terreno",
  "tese",
  "tesoura",
  "testado",
  "teto",
  "textura",
  "texugo",
  "tiara",
  "tigela",
  "tijolo",
  "timbrar",
  "timidez",
  "tingido",
  "tinteiro",
  "tiragem",
  "titular",
  "toalha",
  "tocha",
  "tolerar",
  "tolice",
  "tomada",
  "tomilho",
  "tonel",
  "tontura",
  "topete",
  "tora",
  "torcido",
  "torneio",
  "torque",
  "torrada",
  "torto",
  "tostar",
  "touca",
  "toupeira",
  "toxina",
  "trabalho",
  "tracejar",
  "tradutor",
  "trafegar",
  "trajeto",
  "trama",
  "trancar",
  "trapo",
  "traseiro",
  "tratador",
  "travar",
  "treino",
  "tremer",
  "trepidar",
  "trevo",
  "triagem",
  "tribo",
  "triciclo",
  "tridente",
  "trilogia",
  "trindade",
  "triplo",
  "triturar",
  "triunfal",
  "trocar",
  "trombeta",
  "trova",
  "trunfo",
  "truque",
  "tubular",
  "tucano",
  "tudo",
  "tulipa",
  "tupi",
  "turbo",
  "turma",
  "turquesa",
  "tutelar",
  "tutorial",
  "uivar",
  "umbigo",
  "unha",
  "unidade",
  "uniforme",
  "urologia",
  "urso",
  "urtiga",
  "urubu",
  "usado",
  "usina",
  "usufruir",
  "vacina",
  "vadiar",
  "vagaroso",
  "vaidoso",
  "vala",
  "valente",
  "validade",
  "valores",
  "vantagem",
  "vaqueiro",
  "varanda",
  "vareta",
  "varrer",
  "vascular",
  "vasilha",
  "vassoura",
  "vazar",
  "vazio",
  "veado",
  "vedar",
  "vegetar",
  "veicular",
  "veleiro",
  "velhice",
  "veludo",
  "vencedor",
  "vendaval",
  "venerar",
  "ventre",
  "verbal",
  "verdade",
  "vereador",
  "vergonha",
  "vermelho",
  "verniz",
  "versar",
  "vertente",
  "vespa",
  "vestido",
  "vetorial",
  "viaduto",
  "viagem",
  "viajar",
  "viatura",
  "vibrador",
  "videira",
  "vidraria",
  "viela",
  "viga",
  "vigente",
  "vigiar",
  "vigorar",
  "vilarejo",
  "vinco",
  "vinheta",
  "vinil",
  "violeta",
  "virada",
  "virtude",
  "visitar",
  "visto",
  "vitral",
  "viveiro",
  "vizinho",
  "voador",
  "voar",
  "vogal",
  "volante",
  "voleibol",
  "voltagem",
  "volumoso",
  "vontade",
  "vulto",
  "vuvuzela",
  "xadrez",
  "xarope",
  "xeque",
  "xeretar",
  "xerife",
  "xingar",
  "zangado",
  "zarpar",
  "zebu",
  "zelador",
  "zombar",
  "zoologia",
  "zumbido"
];
var kX = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
Object.defineProperty(jn, "__esModule", { value: true });
var wo = {};
jn.wordlists = wo;
var ur;
var os = jn._default = ur;
try {
  os = jn._default = ur = pX, wo.czech = ur;
} catch {
}
try {
  os = jn._default = ur = gX, wo.chinese_simplified = ur;
} catch {
}
try {
  os = jn._default = ur = mX, wo.chinese_traditional = ur;
} catch {
}
try {
  os = jn._default = ur = bX, wo.korean = ur;
} catch {
}
try {
  os = jn._default = ur = yX, wo.french = ur;
} catch {
}
try {
  os = jn._default = ur = wX, wo.italian = ur;
} catch {
}
try {
  os = jn._default = ur = vX, wo.spanish = ur;
} catch {
}
try {
  os = jn._default = ur = EX, wo.japanese = ur, wo.JA = ur;
} catch {
}
try {
  os = jn._default = ur = xX, wo.portuguese = ur;
} catch {
}
try {
  os = jn._default = ur = kX, wo.english = ur, wo.EN = ur;
} catch {
}
Object.defineProperty(ns, "__esModule", { value: true });
var AX = ai;
var PS = Yr;
var IS = j1;
var SX = Nc;
var ug = jn;
var Yd = ug._default;
var o6 = "Invalid mnemonic";
var vu = "Invalid entropy";
var _X = "Invalid mnemonic checksum";
var OS = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function Jd(e) {
  return (e || "").normalize("NFKD");
}
function BS(e, t, r) {
  for (; e.length < r; )
    e = t + e;
  return e;
}
function CS(e) {
  return parseInt(e, 2);
}
function NS(e) {
  return e.map((t) => BS(t.toString(2), "0", 8)).join("");
}
function US(e) {
  const r = e.length * 8 / 32, n = AX.sha256(Uint8Array.from(e));
  return NS(Array.from(n)).slice(0, r);
}
function $S(e) {
  return "mnemonic" + (e || "");
}
function TX(e, t) {
  const r = Uint8Array.from(Buffer.from(Jd(e), "utf8")), n = Uint8Array.from(Buffer.from($S(Jd(t)), "utf8")), o = IS.pbkdf2(PS.sha512, r, n, {
    c: 2048,
    dkLen: 64
  });
  return Buffer.from(o);
}
ns.mnemonicToSeedSync = TX;
function PX(e, t) {
  const r = Uint8Array.from(Buffer.from(Jd(e), "utf8")), n = Uint8Array.from(Buffer.from($S(Jd(t)), "utf8"));
  return IS.pbkdf2Async(PS.sha512, r, n, {
    c: 2048,
    dkLen: 64
  }).then((o) => Buffer.from(o));
}
var IX = ns.mnemonicToSeed = PX;
function RS(e, t) {
  if (t = t || Yd, !t)
    throw new Error(OS);
  const r = Jd(e).split(" ");
  if (r.length % 3 !== 0)
    throw new Error(o6);
  const n = r.map((l) => {
    const f = t.indexOf(l);
    if (f === -1)
      throw new Error(o6);
    return BS(f.toString(2), "0", 11);
  }).join(""), o = Math.floor(n.length / 33) * 32, i = n.slice(0, o), s = n.slice(o), a = i.match(/(.{1,8})/g).map(CS);
  if (a.length < 16)
    throw new Error(vu);
  if (a.length > 32)
    throw new Error(vu);
  if (a.length % 4 !== 0)
    throw new Error(vu);
  const c = Buffer.from(a);
  if (US(c) !== s)
    throw new Error(_X);
  return c.toString("hex");
}
ns.mnemonicToEntropy = RS;
function zS(e, t) {
  if (Buffer.isBuffer(e) || (e = Buffer.from(e, "hex")), t = t || Yd, !t)
    throw new Error(OS);
  if (e.length < 16)
    throw new TypeError(vu);
  if (e.length > 32)
    throw new TypeError(vu);
  if (e.length % 4 !== 0)
    throw new TypeError(vu);
  const r = NS(Array.from(e)), n = US(e), s = (r + n).match(/(.{1,11})/g).map((a) => {
    const c = CS(a);
    return t[c];
  });
  return t[0] === "" ? s.join("") : s.join(" ");
}
var OX = ns.entropyToMnemonic = zS;
function BX(e, t, r) {
  if (e = e || 128, e % 32 !== 0)
    throw new TypeError(vu);
  return t = t || ((n) => Buffer.from(SX.randomBytes(n))), zS(t(e / 8), r);
}
ns.generateMnemonic = BX;
function CX(e, t) {
  try {
    RS(e, t);
  } catch {
    return false;
  }
  return true;
}
ns.validateMnemonic = CX;
function NX(e) {
  const t = ug.wordlists[e];
  if (t)
    Yd = t;
  else
    throw new Error('Could not find wordlist for language "' + e + '"');
}
ns.setDefaultWordlist = NX;
function UX() {
  if (!Yd)
    throw new Error("No Default Wordlist set");
  return Object.keys(ug.wordlists).filter((e) => e === "JA" || e === "EN" ? false : ug.wordlists[e].every((t, r) => t === Yd[r]))[0];
}
ns.getDefaultWordlist = UX;
var $X = jn;
ns.wordlists = $X.wordlists;
function RX(e) {
  return Zx(Qr(e));
}
function i6(e, t) {
  return wv(lL, e, t);
}
var it = (e) => iU(e);
function zX(e) {
  if (Ur(e.isPoint(it("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Ur(!e.isPoint(it("030000000000000000000000000000000000000000000000000000000000000005"))), Ur(e.isPrivate(it("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), Ur(e.isPrivate(it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), Ur(!e.isPrivate(it("0000000000000000000000000000000000000000000000000000000000000000"))), Ur(!e.isPrivate(it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), Ur(!e.isPrivate(it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), Ur(ms(e.pointFromScalar(it("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), it("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
    Ur(e.xOnlyPointAddTweak(it("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let t = e.xOnlyPointAddTweak(it("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), it("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    Ur(ms(t.xOnlyPubkey, it("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(it("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), it("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  Ur(ms(e.pointAddScalar(it("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), it("0000000000000000000000000000000000000000000000000000000000000003")), it("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), Ur(ms(e.privateAdd(it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), it("0000000000000000000000000000000000000000000000000000000000000002")), it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && (Ur(ms(e.privateNegate(it("0000000000000000000000000000000000000000000000000000000000000001")), it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), Ur(ms(e.privateNegate(it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), it("0000000000000000000000000000000000000000000000000000000000000003")) === 0), Ur(ms(e.privateNegate(it("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), it("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), Ur(ms(e.sign(it("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), it("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), it("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), Ur(e.verify(it("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), it("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), it("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && Ur(ms(e.signSchnorr(it("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), it("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), it("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), it("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && Ur(e.verifySchnorr(it("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), it("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), it("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function Ur(e) {
  if (!e)
    throw new Error("ecc library invalid");
}
function Vw(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function HS(...e) {
  const t = (i) => i, r = (i, s) => (a) => i(s(a)), n = e.map((i) => i.encode).reduceRight(r, t), o = e.map((i) => i.decode).reduce(r, t);
  return { encode: n, decode: o };
}
function HX(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
function LX(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
function s6(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], i = Array.from(e);
  for (i.forEach((s) => {
    if (s < 0 || s >= t)
      throw new Error(`Wrong integer: ${s}`);
  }); ; ) {
    let s = 0, a = true;
    for (let c = n; c < i.length; c++) {
      const u = i[c], l = t * s + u;
      if (!Number.isSafeInteger(l) || t * s / t !== s || l - u !== t * s)
        throw new Error("convertRadix: carry overflow");
      s = l % r;
      const f = Math.floor(l / r);
      if (i[c] = f, !Number.isSafeInteger(f) || f * r + s !== l)
        throw new Error("convertRadix: carry overflow");
      if (a)
        f ? a = false : n = c;
      else continue;
    }
    if (o.push(s), a)
      break;
  }
  for (let s = 0; s < e.length - 1 && e[s] === 0; s++)
    o.push(0);
  return o.reverse();
}
function jX(e) {
  return {
    encode: (t) => {
      if (!Vw(t))
        throw new Error("radix.encode input should be Uint8Array");
      return s6(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(s6(t, e, 2 ** 8));
    }
  };
}
function FX(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!Vw(r))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!Vw(r))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), i = r.slice(-e);
      for (let s = 0; s < e; s++)
        if (o[s] !== i[s])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
var DX = (e) => HS(jX(58), HX(e), LX(""));
var KX = DX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var MX = (e) => HS(FX(4, (t) => e(e(t))), KX);
var qX = MX;
var ws;
function VX(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? (ws == null ? void 0 : ws.lang),
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (ws == null ? void 0 : ws.abortEarly),
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (ws == null ? void 0 : ws.abortPipeEarly)
  };
}
var ey;
function GX(e) {
  return ey == null ? void 0 : ey.get(e);
}
var ty;
function WX(e) {
  return ty == null ? void 0 : ty.get(e);
}
var ry;
function ZX(e, t) {
  var r;
  return (r = ry == null ? void 0 : ry.get(e)) == null ? void 0 : r.get(t);
}
function Qd(e) {
  var r, n;
  const t = typeof e;
  return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function ta(e, t, r, n, o) {
  const i = o && "input" in o ? o.input : r.value, s = (o == null ? void 0 : o.expected) ?? e.expects ?? null, a = (o == null ? void 0 : o.received) ?? Qd(i), c = {
    kind: e.kind,
    type: e.type,
    input: i,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", l = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? ZX(e.reference, c.lang) ?? (u ? WX(c.lang) : null) ?? n.message ?? GX(c.lang);
  l && (c.message = typeof l == "function" ? l(c) : l), u && (r.typed = false), r.issues ? r.issues.push(c) : r.issues = [c];
}
var XX = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(t) {
    super(t[0].message);
    Pt(this, "issues");
    this.name = "ValiError", this.issues = t;
  }
};
function F1(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: F1,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && ta(this, "integer", t, r), t;
    }
  };
}
function C3(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: C3,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && ta(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function D1(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: D1,
    async: false,
    expects: `<=${e instanceof Date ? e.toJSON() : Qd(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && ta(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Qd(r.value)
      }), r;
    }
  };
}
function K1(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: K1,
    async: false,
    expects: `>=${e instanceof Date ? e.toJSON() : Qd(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && ta(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : Qd(r.value)
      }), r;
    }
  };
}
function LS(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: LS,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && ta(this, "format", r, n), r;
    }
  };
}
function M1(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: M1,
    expects: e.name,
    async: false,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = true : ta(this, "type", r, n), r;
    }
  };
}
function q1(e) {
  return {
    kind: "schema",
    type: "number",
    reference: q1,
    expects: "number",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : ta(this, "type", t, r), t;
    }
  };
}
function Gw(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Gw,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var i;
      const o = r.value;
      if (o && typeof o == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = o[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: o,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (i = r.issues) == null || i.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in o) && (r.value[s] = c.value);
        }
      } else
        ta(this, "type", r, n);
      return r;
    }
  };
}
function jS(e) {
  return {
    kind: "schema",
    type: "string",
    reference: jS,
    expects: "string",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = true : ta(this, "type", t, r), t;
    }
  };
}
function vs(e, t, r) {
  const n = e._run(
    { typed: false, value: t },
    VX(r)
  );
  if (n.issues)
    throw new XX(n.issues);
  return n.value;
}
function Nf(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = false;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
var Ww = Nf(q1(), F1(), K1(0), D1(4294967295));
var YX = Nf(q1(), F1(), K1(0), D1(2147483647));
var JX = Nf(q1(), F1(), K1(0), D1(255));
var ny = Nf(M1(Uint8Array), C3(32));
var QX = Nf(M1(Uint8Array), C3(33));
var eY = Gw({
  wif: JX,
  bip32: Gw({
    public: Ww,
    private: Ww
  })
});
var tY = Nf(jS(), LS(/^(m\/)?(\d+'?\/)*\d+'?$/));
function rY(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  var n = new Uint8Array(34), o = new DataView(n.buffer);
  return o.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function nY(e) {
  return Dl.encode(rY(e.version, e.privateKey));
}
var a6 = qX(Qr);
var c6 = {
  encode: (e) => a6.encode(e),
  decode: (e) => a6.decode(e)
};
function oY(e) {
  zX(e);
  const t = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, r = 2147483648;
  function n(d) {
    return d.length === 32 ? d : d.slice(1, 33);
  }
  class o {
    constructor(m, y) {
      Pt(this, "__D");
      Pt(this, "__Q");
      Pt(this, "lowR", false);
      this.__D = m, this.__Q = y;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, true)), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(m, y) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (y === void 0 && (y = this.lowR), y === false)
        return e.sign(m, this.privateKey);
      {
        let b = e.sign(m, this.privateKey);
        const w = new Uint8Array(32);
        let v = 0;
        for (; b[0] > 127; )
          v++, Mc(w, 0, v, "LE"), b = e.sign(m, this.privateKey, w);
        return b;
      }
    }
    signSchnorr(m) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!e.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return e.signSchnorr(m, this.privateKey);
    }
    verify(m, y) {
      return e.verify(m, this.publicKey, y);
    }
    verifySchnorr(m, y) {
      if (!e.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e.verifySchnorr(m, this.publicKey.subarray(1, 33), y);
    }
  }
  class i extends o {
    constructor(y, b, w, v, k = 0, x = 0, _ = 0) {
      super(y, b);
      Pt(this, "chainCode");
      Pt(this, "network");
      Pt(this, "__DEPTH");
      Pt(this, "__INDEX");
      Pt(this, "__PARENT_FINGERPRINT");
      this.chainCode = w, this.network = v, this.__DEPTH = k, this.__INDEX = x, this.__PARENT_FINGERPRINT = _, vs(eY, v);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return RX(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return true;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return l(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const y = this.network, b = this.isNeutered() ? y.bip32.public : y.bip32.private, w = new Uint8Array(78);
      return Mc(w, 0, b, "BE"), H5(w, 4, this.depth), Mc(w, 5, this.parentFingerprint, "BE"), Mc(w, 9, this.index, "BE"), w.set(this.chainCode, 13), this.isNeutered() ? w.set(this.publicKey, 45) : (H5(w, 45, 0), w.set(this.privateKey, 46)), c6.encode(w);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return nY({
        version: this.network.wif,
        privateKey: this.privateKey,
        compressed: true
      });
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(y) {
      vs(Ww, y);
      const b = y >= r, w = new Uint8Array(37);
      if (b) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        w[0] = 0, w.set(this.privateKey, 1), Mc(w, 33, y, "BE");
      } else
        w.set(this.publicKey, 0), Mc(w, 33, y, "BE");
      const v = i6(this.chainCode, w), k = v.slice(0, 32), x = v.slice(32);
      if (!e.isPrivate(k))
        return this.derive(y + 1);
      let _;
      if (this.isNeutered()) {
        const I = e.pointAddScalar(this.publicKey, k, true);
        if (I === null)
          return this.derive(y + 1);
        _ = l(I, x, this.network, this.depth + 1, y, bl(this.fingerprint, 0, "BE"));
      } else {
        const I = e.privateAdd(this.privateKey, k);
        if (I == null)
          return this.derive(y + 1);
        _ = c(I, x, this.network, this.depth + 1, y, bl(this.fingerprint, 0, "BE"));
      }
      return _;
    }
    deriveHardened(y) {
      if (typeof vs(YX, y) == "number")
        return this.derive(y + r);
      throw new TypeError("Expected UInt31, got " + y);
    }
    derivePath(y) {
      vs(tY, y);
      let b = y.split("/");
      if (b[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        b = b.slice(1);
      }
      return b.reduce((w, v) => {
        let k;
        return v.slice(-1) === "'" ? (k = parseInt(v.slice(0, -1), 10), w.deriveHardened(k)) : (k = parseInt(v, 10), w.derive(k));
      }, this);
    }
    tweak(y) {
      return this.privateKey ? this.tweakFromPrivateKey(y) : this.tweakFromPublicKey(y);
    }
    tweakFromPublicKey(y) {
      const b = n(this.publicKey);
      if (!e.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const w = e.xOnlyPointAddTweak(b, y);
      if (!w || w.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const v = Uint8Array.from([
        w.parity === 0 ? 2 : 3
      ]), k = oU([
        v,
        w.xOnlyPubkey
      ]);
      return new o(void 0, k);
    }
    tweakFromPrivateKey(y) {
      const b = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, w = (() => {
        if (b) {
          if (e.privateNegate)
            return e.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        } else return this.privateKey;
      })(), v = e.privateAdd(w, y);
      if (!v)
        throw new Error("Invalid tweaked private key!");
      return new o(v, void 0);
    }
  }
  function s(d, m) {
    const y = c6.decode(d);
    if (y.length !== 78)
      throw new TypeError("Invalid buffer length");
    m = m || t;
    const b = bl(y, 0, "BE");
    if (b !== m.bip32.private && b !== m.bip32.public)
      throw new TypeError("Invalid network version");
    const w = y[4], v = bl(y, 5, "BE");
    if (w === 0 && v !== 0)
      throw new TypeError("Invalid parent fingerprint");
    const k = bl(y, 9, "BE");
    if (w === 0 && k !== 0)
      throw new TypeError("Invalid index");
    const x = y.slice(13, 45);
    let _;
    if (b === m.bip32.private) {
      if (y[45] !== 0)
        throw new TypeError("Invalid private key");
      const I = y.slice(46, 78);
      _ = c(I, x, m, w, k, v);
    } else {
      const I = y.slice(45, 78);
      _ = l(I, x, m, w, k, v);
    }
    return _;
  }
  function a(d, m, y) {
    return c(d, m, y);
  }
  function c(d, m, y, b, w, v) {
    if (vs(ny, d), vs(ny, m), y = y || t, !e.isPrivate(d))
      throw new TypeError("Private key not in range [1, n)");
    return new i(d, void 0, m, y, b, w, v);
  }
  function u(d, m, y) {
    return l(d, m, y);
  }
  function l(d, m, y, b, w, v) {
    if (vs(QX, d), vs(ny, m), y = y || t, !e.isPoint(d))
      throw new TypeError("Point is not on the curve");
    return new i(void 0, d, m, y, b, w, v);
  }
  function f(d, m) {
    if (vs(M1(Uint8Array), d), d.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (d.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    m = m || t;
    const y = i6(nU("Bitcoin seed"), d), b = y.slice(0, 32), w = y.slice(32);
    return a(b, w, m);
  }
  return {
    fromSeed: f,
    fromBase58: s,
    fromPublicKey: u,
    fromPrivateKey: a
  };
}
var iY = oY(b3);
Jx(b3);
var sY = async ({ contentBase64: e, mimeType: t, quantity: r = 1, inscriptions: n, ordinalAddress: o, paymentAddress: i, paymentPublicKey: s, signPsbt: a, network: c = Tt }) => {
  try {
    if (!e && !n)
      throw new Error("contentBase64 or inscriptions is required");
    const u = await uY(c), l = Buffer.from(u).toString("hex"), f = n || Array(r).fill({
      content: e,
      mimeType: t
    }), d = await aY({
      inscriptions: f,
      paymentAddress: i,
      paymentPublicKey: s,
      privKey: l,
      network: c
    });
    if (!d || !(d != null && d.psbtHex))
      throw new Error("couldn't get commit tx");
    const m = String(d == null ? void 0 : d.psbtHex), y = String(d == null ? void 0 : d.psbtBase64), b = await a("", m, y, true, false, c);
    if (!b)
      throw new Error("sign psbt failed");
    const v = Zt.fromHex((b == null ? void 0 : b.signedPsbtHex) || "").extractTransaction(), k = await P3(v.toHex(), c);
    if (!k)
      throw new Error("commit tx failed");
    return await cY({
      inscriptions: f,
      ordinalAddress: o,
      privKey: l,
      commitTxId: k,
      network: c
    });
  } catch (u) {
    throw u;
  }
};
var aY = async ({ inscriptions: e, paymentAddress: t, paymentPublicKey: r, privKey: n, network: o }) => {
  try {
    const i = e.length, s = e.reduce((P, $) => P + Buffer.from($.content).length, 0);
    if (s > 39e4)
      throw new Error("Content size is too large, must be less than 390kb");
    const { fastestFee: a } = await dY(o), c = e9(String(n), true), u = new Zt({
      network: Gr(o)
    }), { inscriberAddress: l } = lY(c, e, o), f = 5 * 34 * i, d = Math.floor(f * a * i), m = Math.floor(s * a / 3) + 1e3 + 546 * i, y = Math.floor(d + m), w = (await _3(t, o)).filter((P) => P.value > 3e3).sort((P, $) => $.value - P.value), v = iX(w);
    if (v === 0)
      throw new Error("insufficient funds");
    if (v < y)
      throw new Error("insufficient funds");
    let k = 0;
    const x = await hv(t, Gr(o));
    let _ = 0;
    for await (const P of w) {
      const $ = sX(t, o);
      if (console.log({ paymentAddressType: $ }), u.addInput({
        hash: P.txid,
        index: P.vout,
        witnessUtxo: { value: BigInt(P.value), script: x }
      }), $ === bd && u.updateInput(_, {
        tapInternalKey: vd(Buffer.from(r, "hex"))
      }), $ === Ax) {
        let L = tS(r, o);
        u.updateInput(_, { redeemScript: L });
      }
      if (_++, k += P.value, k > y)
        break;
    }
    const I = k - y;
    return u.addOutput({
      value: BigInt(m),
      address: l
    }), I > 546 && u.addOutput({
      value: BigInt(I),
      address: t
    }), {
      psbtHex: u.toHex(),
      psbtBase64: u.toBase64()
    };
  } catch (i) {
    throw i;
  }
};
var cY = async ({ inscriptions: e, ordinalAddress: t, commitTxId: r, privKey: n, network: o, isDry: i }) => {
  try {
    const s = fL(n), a = e9(n, true), c = FS(a, e), u = W0.encodeScript(c), [l, f] = W0.getPubKey(a, { target: u });
    if (!await fY(String(r), o))
      throw new Error("ERROR WAITING FOR COMMIT TX");
    const m = await hY(r, 0, o);
    if (m === 0 || !m)
      throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const y = oi.create({
      vin: [
        {
          txid: r,
          vout: 0,
          prevout: {
            value: m,
            scriptPubKey: ["OP_1", l]
          }
        }
      ],
      vout: [
        ...Array(e.length).fill({
          value: 546,
          scriptPubKey: Gk.toScriptPubKey(t)
        })
      ]
    }), b = qq.taproot.sign(s, y, 0, { extension: u });
    return y.vin[0].witness = [b, c, f], i ? oi.util.getTxid(y) : await P3(oi.encode(y).hex, o);
  } catch (s) {
    throw s;
  }
};
async function uY(e) {
  const t = crypto.getRandomValues(new Uint8Array(32)), r = OX(Buffer.from(t)), n = await IX(r), o = iY.fromSeed(n, Gr(e));
  return o == null ? void 0 : o.derivePath("m/44'/0'/0'/0/0").privateKey;
}
var FS = (e, t) => {
  const r = new TextEncoder(), n = r.encode("ord"), o = 546, i = (a, c) => {
    let u;
    if (c === nX) {
      const f = Buffer.from(a, "base64").toString("utf-8");
      u = Buffer.from(f, "utf-8");
    } else
      u = Buffer.from(a, "base64");
    const l = [];
    for (let f = 0; f < u.length; f += 520)
      l.push(u.slice(f, f + 520));
    return l;
  }, s = [e, "OP_CHECKSIG"];
  return t.forEach((a, c) => {
    const { content: u, mimeType: l } = a, f = i(u, l);
    if (s.push("OP_0", "OP_IF", n, "01", r.encode(l), "OP_0"), c > 0) {
      const d = o * (c + 1), m = Buffer.from([d]);
      s.push(Buffer.from([2])), s.push(m);
    }
    s.push(...f.map((d) => d), "OP_ENDIF");
  }), s;
};
var lY = (e, t, r = Tt) => {
  const n = FS(e, t), o = W0.encodeScript(n), [i] = W0.getPubKey(e, { target: o });
  return {
    inscriberAddress: Gk.p2tr.fromPubKey(i, vW(r)),
    tpubkey: i,
    tapleaf: o
  };
};
async function DS(e, t = Tt) {
  try {
    return await hr.get(`${H1(t)}/api/tx/${e}`).then((r) => r.data);
  } catch (r) {
    throw r;
  }
}
async function fY(e, t) {
  const n = Date.now();
  for (; ; )
    try {
      if (await DS(e, t))
        return console.log("Transaction found in mempool:", e), true;
      if (Date.now() - n > 6e4)
        return false;
      await new Promise((i) => setTimeout(i, 5e3));
    } catch {
      if (Date.now() - n > 6e4)
        return false;
      await new Promise((i) => setTimeout(i, 5e3));
    }
}
var dY = async (e) => await hr.get(`${H1(e)}/api/v1/fees/recommended`, {
  headers: {
    "Content-Type": "application/json"
  }
}).then((t) => t.data);
async function hY(e, t, r) {
  const o = Date.now();
  for (; ; )
    try {
      const i = await DS(e, r);
      if (i && i.vout && i.vout.length > 0)
        return Math.floor(i.vout[t].value);
      if (Date.now() - o > 6e4)
        return null;
      await new Promise((s) => setTimeout(s, 5e3));
    } catch (i) {
      if (console.error("Error fetching transaction output value:", i), Date.now() - o > 6e4)
        return null;
      await new Promise((s) => setTimeout(s, 5e3));
    }
}
var Zw = new Error("The connected wallet doesn't support this method...");
var pY = new Error("Wallet is not installed");
var Do = class {
  constructor(t, r, n) {
    Object.defineProperty(this, "parent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: r
    }), Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: n
    }), Object.defineProperty(this, "$store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$network", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), this.$store = t.$store, this.$network = t.$network, this.initialize();
  }
  disconnect() {
  }
  async requestAccounts() {
    return [this.$store.get().address, this.$store.get().paymentAddress];
  }
  async switchNetwork(t) {
    throw this.parent.disconnect(), Zw;
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Mt, Br, Vr, Cr].includes(this.$network.get()) ? this.$network.get() : Tt;
  }
  async getPublicKey() {
    return this.$store.get().publicKey;
  }
  async getBalance() {
    const { paymentAddress: t } = this.$store.get();
    return await Cf(t, this.$network.get());
  }
  async getInscriptions(t, r) {
    throw console.log("getInscriptions not implemented", t, r), Zw;
  }
  async pushPsbt(t) {
    let r = t;
    return r.startsWith("02") || (console.log("extracting tx..."), r = Zt.fromHex(r).extractTransaction().toHex()), await P3(r, this.$network.get());
  }
  async inscribe(t, r) {
    return await sY({
      contentBase64: t,
      mimeType: r,
      ordinalAddress: this.$store.get().address,
      paymentAddress: this.$store.get().paymentAddress,
      paymentPublicKey: this.$store.get().paymentPublicKey,
      signPsbt: this.signPsbt.bind(this),
      network: this.$network.get()
    });
  }
};
var gY = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window.unisat;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Vc]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      if (t.provider !== Vc) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Vc) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = sg(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(Vc);
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Unisat isn't installed");
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    await this.getNetwork().then((o) => {
      this.network !== o && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n)
      throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", Vc), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getChain());
    return t ? sg(t.enum) : this.network;
  }
  async sendBTC(t, r) {
    var o;
    const n = await ((o = this.library) == null ? void 0 : o.sendBitcoin(t, r));
    if (!n)
      throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var c;
    const s = await ((c = this.library) == null ? void 0 : c.signPsbt(r, {
      autoFinalized: o
    })), a = Zt.fromHex(s);
    if (o && i) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: a.toHex(),
        signedPsbtBase64: a.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var n;
    const r = OA(t);
    await ((n = this.library) == null ? void 0 : n.switchChain(r)), this.$network.set(t);
  }
};
var mY = (e) => /^(?:[A-Za-z0-9+\/]{4})*?(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(e);
var bY = (e) => /^[a-fA-F0-9]+$/.test(e);
function yY(e) {
  typeof window < "u" && typeof localStorage < "u" && setTimeout(() => {
    const t = document.createTextNode(" ");
    document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
  }, 1500);
}
function u2e() {
  return {
    $store: kx({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      connected: false,
      isConnecting: false,
      isInitializing: true,
      accounts: [],
      balance: void 0,
      hasProvider: {
        [kl]: false,
        [Vc]: false,
        [oc]: false,
        [Al]: false,
        [Yc]: false,
        [Xc]: false,
        [xl]: false,
        [Jc]: true,
        [Zc]: false,
        [Sl]: false,
        [Wc]: false,
        [Gc]: false
      }
    }),
    $network: Yy(Tt),
    $library: Yy(void 0)
  };
}
function l2e({ network: e }) {
  return {
    network: e
  };
}
var Qn = [
  "address",
  "paymentAddress",
  "publicKey",
  "paymentPublicKey",
  "balance"
];
var wY = (e) => {
  const t = e.match(/.{1,2}/g);
  if (!t)
    throw new Error("Invalid hex string");
  return Uint8Array.from(t.map((r) => parseInt(r, 16)));
};
var oy;
function vY(e) {
  return oy == null ? void 0 : oy.get(e);
}
var iy;
function EY(e) {
  return iy == null ? void 0 : iy.get(e);
}
var sy;
function xY(e, t) {
  var r;
  return (r = sy == null ? void 0 : sy.get(e)) == null ? void 0 : r.get(t);
}
function V1(e) {
  var r, n;
  let t = typeof e;
  return t === "object" && (t = (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null"), t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t;
}
function eo(e, t, r, n, o) {
  const i = o && "input" in o ? o.input : r.value, s = (o == null ? void 0 : o.expected) ?? e.expects ?? null, a = (o == null ? void 0 : o.received) ?? V1(i), c = {
    kind: e.kind,
    type: e.type,
    input: i,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", l = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? xY(e.reference, c.lang) ?? (u ? EY(c.lang) : null) ?? n.message ?? vY(c.lang);
  l && (c.message = typeof l == "function" ? l(c) : l), u && (r.typed = false), r.issues ? r.issues.push(c) : r.issues = [c];
}
function kY(e, t) {
  return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function KS(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function u6(e, t) {
  return !e._run({ typed: false, value: t }, { abortEarly: true }).issues;
}
function gi(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: gi,
    expects: "Array",
    async: false,
    item: e,
    message: t,
    _run(r, n) {
      var i;
      const o = r.value;
      if (Array.isArray(o)) {
        r.typed = true, r.value = [];
        for (let s = 0; s < o.length; s++) {
          const a = o[s], c = this.item._run({ typed: false, value: a }, n);
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: o,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (i = r.issues) == null || i.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), r.value.push(c.value);
        }
      } else
        eo(this, "type", r, n);
      return r;
    }
  };
}
function MS(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: MS,
    expects: "boolean",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "boolean" ? t.typed = true : eo(this, "type", t, r), t;
    }
  };
}
function Nu(e, t) {
  const r = Object.entries(e).filter(([n]) => isNaN(+n)).map(([, n]) => n);
  return {
    kind: "schema",
    type: "enum",
    reference: Nu,
    expects: r.map(V1).join(" | ") || "never",
    async: false,
    enum: e,
    options: r,
    message: t,
    _run(n, o) {
      return this.options.includes(n.value) ? n.typed = true : eo(this, "type", n, o), n;
    }
  };
}
function br(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: br,
    expects: V1(e),
    async: false,
    literal: e,
    message: t,
    _run(r, n) {
      return r.value === this.literal ? r.typed = true : eo(this, "type", r, n), r;
    }
  };
}
function qS(e, t) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: qS,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var i;
      const o = r.value;
      if (o && typeof o == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = o[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: o,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (i = r.issues) == null || i.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in o) && (r.value[s] = c.value);
        }
        if (!r.issues || !n.abortEarly)
          for (const s in o)
            kY(o, s) && !(s in this.entries) && (r.value[s] = o[s]);
      } else
        eo(this, "type", r, n);
      return r;
    }
  };
}
function N3(e, t) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: N3,
    expects: "!undefined",
    async: false,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === void 0 ? (eo(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function Zu(e) {
  return {
    kind: "schema",
    type: "null",
    reference: Zu,
    expects: "null",
    async: false,
    message: e,
    _run(t, r) {
      return t.value === null ? t.typed = true : eo(this, "type", t, r), t;
    }
  };
}
function Xu(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: Xu,
    expects: `${e.expects} | null | undefined`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = KS(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function qi(e) {
  return {
    kind: "schema",
    type: "number",
    reference: qi,
    expects: "number",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : eo(this, "type", t, r), t;
    }
  };
}
function _e(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: _e,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var i;
      const o = r.value;
      if (o && typeof o == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = o[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: o,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (i = r.issues) == null || i.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in o) && (r.value[s] = c.value);
        }
      } else
        eo(this, "type", r, n);
      return r;
    }
  };
}
function mi(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: mi,
    expects: `${e.expects} | undefined`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = KS(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function VS(e, t) {
  return {
    kind: "schema",
    type: "picklist",
    reference: VS,
    expects: e.map(V1).join(" | ") || "never",
    async: false,
    options: e,
    message: t,
    _run(r, n) {
      return this.options.includes(r.value) ? r.typed = true : eo(this, "type", r, n), r;
    }
  };
}
function Ne(e) {
  return {
    kind: "schema",
    type: "string",
    reference: Ne,
    expects: "string",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = true : eo(this, "type", t, r), t;
    }
  };
}
function U3(e) {
  return {
    kind: "schema",
    type: "undefined",
    reference: U3,
    expects: "undefined",
    async: false,
    message: e,
    _run(t, r) {
      return t.value === void 0 ? t.typed = true : eo(this, "type", t, r), t;
    }
  };
}
function l6(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function G1(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: G1,
    expects: [...new Set(e.map((r) => r.expects))].join(" | ") || "never",
    async: false,
    options: e,
    message: t,
    _run(r, n) {
      let o, i, s;
      for (const a of this.options) {
        const c = a._run(
          { typed: false, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            i ? i.push(c) : i = [c];
          else {
            o = c;
            break;
          }
        else
          s ? s.push(c) : s = [c];
      }
      if (o)
        return o;
      if (i) {
        if (i.length === 1)
          return i[0];
        eo(this, "type", r, n, {
          issues: l6(i)
        }), r.typed = true;
      } else {
        if ((s == null ? void 0 : s.length) === 1)
          return s[0];
        eo(this, "type", r, n, {
          issues: l6(s)
        });
      }
      return r;
    }
  };
}
function W1() {
  return {
    kind: "schema",
    type: "unknown",
    reference: W1,
    expects: "unknown",
    async: false,
    _run(e) {
      return e.typed = true, e;
    }
  };
}
var ko = {};
var rf = {};
var In = {};
Object.defineProperty(In, "__esModule", { value: true });
In.decode = In.encode = In.unescape = In.escape = In.pad = void 0;
var GS = If;
function $3(e) {
  return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
In.pad = $3;
function WS(e) {
  return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
In.escape = WS;
function ZS(e) {
  return $3(e).replace(/-/g, "+").replace(/_/g, "/");
}
In.unescape = ZS;
function AY(e) {
  return WS((0, GS.fromByteArray)(new TextEncoder().encode(e)));
}
In.encode = AY;
function SY(e) {
  return new TextDecoder().decode((0, GS.toByteArray)($3(ZS(e))));
}
In.decode = SY;
var Z1 = {};
var X1 = {};
var nf = {};
Object.defineProperty(nf, "__esModule", { value: true });
nf.joseToDer = nf.derToJose = void 0;
var XS = If;
var YS = In;
function ay(e) {
  return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
var _Y = {
  ES256: ay(256),
  ES384: ay(384),
  ES512: ay(521)
};
function JS(e) {
  const t = _Y[e];
  if (t)
    return t;
  throw new Error(`Unknown algorithm "${e}"`);
}
var lg = 128;
var QS = 0;
var TY = 32;
var PY = 16;
var IY = 2;
var e_ = PY | TY | QS << 6;
var fg = IY | QS << 6;
function t_(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, XS.toByteArray)((0, YS.pad)(e));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function OY(e, t) {
  const r = t_(e), n = JS(t), o = n + 1, i = r.length;
  let s = 0;
  if (r[s++] !== e_)
    throw new Error('Could not find expected "seq"');
  let a = r[s++];
  if (a === (lg | 1) && (a = r[s++]), i - s < a)
    throw new Error(`"seq" specified length of "${a}", only "${i - s}" remaining`);
  if (r[s++] !== fg)
    throw new Error('Could not find expected "int" for "r"');
  const c = r[s++];
  if (i - s - 2 < c)
    throw new Error(`"r" specified length of "${c}", only "${i - s - 2}" available`);
  if (o < c)
    throw new Error(`"r" specified length of "${c}", max of "${o}" is acceptable`);
  const u = s;
  if (s += c, r[s++] !== fg)
    throw new Error('Could not find expected "int" for "s"');
  const l = r[s++];
  if (i - s !== l)
    throw new Error(`"s" specified length of "${l}", expected "${i - s}"`);
  if (o < l)
    throw new Error(`"s" specified length of "${l}", max of "${o}" is acceptable`);
  const f = s;
  if (s += l, s !== i)
    throw new Error(`Expected to consume entire array, but "${i - s}" bytes remain`);
  const d = n - c, m = n - l, y = new Uint8Array(d + c + m + l);
  for (s = 0; s < d; ++s)
    y[s] = 0;
  y.set(r.subarray(u + Math.max(-d, 0), u + c), s), s = n;
  for (const b = s; s < b + m; ++s)
    y[s] = 0;
  return y.set(r.subarray(f + Math.max(-m, 0), f + l), s), (0, YS.escape)((0, XS.fromByteArray)(y));
}
nf.derToJose = OY;
function f6(e, t, r) {
  let n = 0;
  for (; t + n < r && e[t + n] === 0; )
    ++n;
  return e[t + n] >= lg && --n, n;
}
function BY(e, t) {
  e = t_(e);
  const r = JS(t), n = e.length;
  if (n !== r * 2)
    throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
  const o = f6(e, 0, r), i = f6(e, r, e.length), s = r - o, a = r - i, c = 2 + s + 1 + 1 + a, u = c < lg, l = new Uint8Array((u ? 2 : 3) + c);
  let f = 0;
  return l[f++] = e_, u ? l[f++] = c : (l[f++] = lg | 1, l[f++] = c & 255), l[f++] = fg, l[f++] = s, o < 0 ? (l[f++] = 0, l.set(e.subarray(0, r), f), f += r) : (l.set(e.subarray(o, r), f), f += r - o), l[f++] = fg, l[f++] = a, i < 0 ? (l[f++] = 0, l.set(e.subarray(r), f)) : l.set(e.subarray(r + i), f), l;
}
nf.joseToDer = BY;
var Gs = {};
Object.defineProperty(Gs, "__esModule", { value: true });
Gs.InvalidTokenError = Gs.MissingParametersError = void 0;
var CY = class extends Error {
  constructor(t) {
    super(), this.name = "MissingParametersError", this.message = t || "";
  }
};
Gs.MissingParametersError = CY;
var NY = class extends Error {
  constructor(t) {
    super(), this.name = "InvalidTokenError", this.message = t || "";
  }
};
Gs.InvalidTokenError = NY;
Object.defineProperty(X1, "__esModule", { value: true });
X1.SECP256K1Client = void 0;
var UY = S1;
var $Y = ai;
var h0 = c3;
var d6 = nf;
var h6 = Gs;
var p6 = Nc;
h0.utils.hmacSha256Sync = (e, ...t) => {
  const r = UY.hmac.create($Y.sha256, e);
  return t.forEach((n) => r.update(n)), r.digest();
};
var r_ = class {
  static derivePublicKey(t, r = true) {
    return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, p6.bytesToHex)(h0.getPublicKey(t, r));
  }
  static signHash(t, r, n = "jose") {
    if (!t || !r)
      throw new h6.MissingParametersError("a signing input hash and private key are all required");
    const o = h0.signSync(t, r.slice(0, 64), {
      der: true,
      canonical: false
    });
    if (n === "der")
      return (0, p6.bytesToHex)(o);
    if (n === "jose")
      return (0, d6.derToJose)(o, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(t) {
    return (0, d6.joseToDer)(t, "ES256");
  }
  static verifyHash(t, r, n) {
    if (!t || !r || !n)
      throw new h6.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return h0.verify(r, t, n, { strict: false });
  }
};
X1.SECP256K1Client = r_;
r_.algorithmName = "ES256K";
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.cryptoClients = e.SECP256K1Client = void 0;
  const t = X1;
  Object.defineProperty(e, "SECP256K1Client", { enumerable: true, get: function() {
    return t.SECP256K1Client;
  } });
  const r = {
    ES256K: t.SECP256K1Client
  };
  e.cryptoClients = r;
})(Z1);
var Uu = {};
var RY = Xe && Xe.__awaiter || function(e, t, r, n) {
  function o(i) {
    return i instanceof r ? i : new r(function(s) {
      s(i);
    });
  }
  return new (r || (r = Promise))(function(i, s) {
    function a(l) {
      try {
        u(n.next(l));
      } catch (f) {
        s(f);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (f) {
        s(f);
      }
    }
    function u(l) {
      l.done ? i(l.value) : o(l.value).then(a, c);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(Uu, "__esModule", { value: true });
Uu.hashSha256Async = Uu.hashSha256 = void 0;
var zY = ai;
function n_(e) {
  return (0, zY.sha256)(e);
}
Uu.hashSha256 = n_;
function HY(e) {
  return RY(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const r = typeof e == "string" ? new TextEncoder().encode(e) : e, n = yield crypto.subtle.digest("SHA-256", r);
        return new Uint8Array(n);
      } else {
        const r = fA;
        if (!r.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(r.createHash("sha256").update(e).digest());
      }
    } catch (t) {
      return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(n_(e));
    }
  });
}
Uu.hashSha256Async = HY;
var LY = Xe && Xe.__awaiter || function(e, t, r, n) {
  function o(i) {
    return i instanceof r ? i : new r(function(s) {
      s(i);
    });
  }
  return new (r || (r = Promise))(function(i, s) {
    function a(l) {
      try {
        u(n.next(l));
      } catch (f) {
        s(f);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (f) {
        s(f);
      }
    }
    function u(l) {
      l.done ? i(l.value) : o(l.value).then(a, c);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(rf, "__esModule", { value: true });
rf.TokenSigner = rf.createUnsecuredToken = void 0;
var Xw = In;
var g6 = Z1;
var jY = Gs;
var m6 = Uu;
function Yw(e, t) {
  const r = [], n = Xw.encode(JSON.stringify(t));
  r.push(n);
  const o = Xw.encode(JSON.stringify(e));
  return r.push(o), r.join(".");
}
function FY(e) {
  return Yw(e, { typ: "JWT", alg: "none" }) + ".";
}
rf.createUnsecuredToken = FY;
var DY = class {
  constructor(t, r) {
    if (!(t && r))
      throw new jY.MissingParametersError("a signing algorithm and private key are required");
    if (typeof t != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (t = t.toUpperCase(), !g6.cryptoClients.hasOwnProperty(t))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = g6.cryptoClients[t], this.rawPrivateKey = r;
  }
  header(t = {}) {
    const r = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, r, t);
  }
  sign(t, r = false, n = {}) {
    const o = this.header(n), i = Yw(t, o), s = (0, m6.hashSha256)(i);
    return this.createWithSignedHash(t, r, o, i, s);
  }
  signAsync(t, r = false, n = {}) {
    return LY(this, void 0, void 0, function* () {
      const o = this.header(n), i = Yw(t, o), s = yield (0, m6.hashSha256Async)(i);
      return this.createWithSignedHash(t, r, o, i, s);
    });
  }
  createWithSignedHash(t, r, n, o, i) {
    const s = this.cryptoClient.signHash(i, this.rawPrivateKey);
    return r ? {
      header: [Xw.encode(JSON.stringify(n))],
      payload: JSON.stringify(t),
      signature: [s]
    } : [o, s].join(".");
  }
};
rf.TokenSigner = DY;
var Y1 = {};
Object.defineProperty(Y1, "__esModule", { value: true });
Y1.TokenVerifier = void 0;
var KY = In;
var b6 = Z1;
var MY = Gs;
var Bp = Uu;
var qY = class {
  constructor(t, r) {
    if (!(t && r))
      throw new MY.MissingParametersError("a signing algorithm and public key are required");
    if (typeof t != "string")
      throw "signing algorithm parameter must be a string";
    if (t = t.toUpperCase(), !b6.cryptoClients.hasOwnProperty(t))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = b6.cryptoClients[t], this.rawPublicKey = r;
  }
  verify(t) {
    return typeof t == "string" ? this.verifyCompact(t, false) : typeof t == "object" ? this.verifyExpanded(t, false) : false;
  }
  verifyAsync(t) {
    return typeof t == "string" ? this.verifyCompact(t, true) : typeof t == "object" ? this.verifyExpanded(t, true) : Promise.resolve(false);
  }
  verifyCompact(t, r) {
    const n = t.split("."), o = n[0] + "." + n[1], i = (s) => {
      const a = this.cryptoClient.loadSignature(n[2]);
      return this.cryptoClient.verifyHash(s, a, this.rawPublicKey);
    };
    if (r)
      return (0, Bp.hashSha256Async)(o).then((s) => i(s));
    {
      const s = (0, Bp.hashSha256)(o);
      return i(s);
    }
  }
  verifyExpanded(t, r) {
    const n = [t.header.join("."), KY.encode(t.payload)].join(".");
    let o = true;
    const i = (s) => (t.signature.map((a) => {
      const c = this.cryptoClient.loadSignature(a);
      this.cryptoClient.verifyHash(s, c, this.rawPublicKey) || (o = false);
    }), o);
    if (r)
      return (0, Bp.hashSha256Async)(n).then((s) => i(s));
    {
      const s = (0, Bp.hashSha256)(n);
      return i(s);
    }
  }
};
Y1.TokenVerifier = qY;
var J1 = {};
Object.defineProperty(J1, "__esModule", { value: true });
J1.decodeToken = void 0;
var Cp = In;
function VY(e) {
  if (typeof e == "string") {
    const t = e.split("."), r = JSON.parse(Cp.decode(t[0])), n = JSON.parse(Cp.decode(t[1])), o = t[2];
    return {
      header: r,
      payload: n,
      signature: o
    };
  } else if (typeof e == "object") {
    if (typeof e.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let t = e.payload;
    e.payload[0] !== "{" && (t = Cp.decode(t));
    const r = [];
    return e.header.map((n) => {
      const o = JSON.parse(Cp.decode(n));
      r.push(o);
    }), {
      header: r,
      payload: JSON.parse(t),
      signature: e.signature
    };
  }
}
J1.decodeToken = VY;
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Xe && Xe.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(rf, e), r(Y1, e), r(J1, e), r(Gs, e), r(Z1, e);
})(ko);
var y6 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const e = Array(256).fill(-1);
  for (let t = 0; t < y6.length; ++t) e[y6.charCodeAt(t)] = t;
})();
var w6;
var cy;
var Np;
var R3 = (w6 = function(e, t) {
  Object.defineProperty(t, "__esModule", { value: true }), t.bech32m = t.bech32 = void 0;
  const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
  for (let f = 0; f < 32; f++) {
    const d = r.charAt(f);
    n[d] = f;
  }
  function o(f) {
    const d = f >> 25;
    return (33554431 & f) << 5 ^ 996825010 & -(d >> 0 & 1) ^ 642813549 & -(d >> 1 & 1) ^ 513874426 & -(d >> 2 & 1) ^ 1027748829 & -(d >> 3 & 1) ^ 705979059 & -(d >> 4 & 1);
  }
  function i(f) {
    let d = 1;
    for (let m = 0; m < f.length; ++m) {
      const y = f.charCodeAt(m);
      if (y < 33 || y > 126) return "Invalid prefix (" + f + ")";
      d = o(d) ^ y >> 5;
    }
    d = o(d);
    for (let m = 0; m < f.length; ++m) {
      const y = f.charCodeAt(m);
      d = o(d) ^ 31 & y;
    }
    return d;
  }
  function s(f, d, m, y) {
    let b = 0, w = 0;
    const v = (1 << m) - 1, k = [];
    for (let x = 0; x < f.length; ++x) for (b = b << d | f[x], w += d; w >= m; ) w -= m, k.push(b >> w & v);
    if (y) w > 0 && k.push(b << m - w & v);
    else {
      if (w >= d) return "Excess padding";
      if (b << m - w & v) return "Non-zero padding";
    }
    return k;
  }
  function a(f) {
    return s(f, 8, 5, true);
  }
  function c(f) {
    const d = s(f, 5, 8, false);
    if (Array.isArray(d)) return d;
  }
  function u(f) {
    const d = s(f, 5, 8, false);
    if (Array.isArray(d)) return d;
    throw new Error(d);
  }
  function l(f) {
    let d;
    function m(y, b) {
      if (b = b || 90, y.length < 8) return y + " too short";
      if (y.length > b) return "Exceeds length limit";
      const w = y.toLowerCase(), v = y.toUpperCase();
      if (y !== w && y !== v) return "Mixed-case string " + y;
      const k = (y = w).lastIndexOf("1");
      if (k === -1) return "No separator character for " + y;
      if (k === 0) return "Missing prefix for " + y;
      const x = y.slice(0, k), _ = y.slice(k + 1);
      if (_.length < 6) return "Data too short";
      let I = i(x);
      if (typeof I == "string") return I;
      const P = [];
      for (let $ = 0; $ < _.length; ++$) {
        const L = _.charAt($), V = n[L];
        if (V === void 0) return "Unknown character " + L;
        I = o(I) ^ V, $ + 6 >= _.length || P.push(V);
      }
      return I !== d ? "Invalid checksum for " + y : { prefix: x, words: P };
    }
    return d = f === "bech32" ? 1 : 734539939, { decodeUnsafe: function(y, b) {
      const w = m(y, b);
      if (typeof w == "object") return w;
    }, decode: function(y, b) {
      const w = m(y, b);
      if (typeof w == "object") return w;
      throw new Error(w);
    }, encode: function(y, b, w) {
      if (w = w || 90, y.length + 7 + b.length > w) throw new TypeError("Exceeds length limit");
      let v = i(y = y.toLowerCase());
      if (typeof v == "string") throw new Error(v);
      let k = y + "1";
      for (let x = 0; x < b.length; ++x) {
        const _ = b[x];
        if (_ >> 5) throw new Error("Non 5-bit word");
        v = o(v) ^ _, k += r.charAt(_);
      }
      for (let x = 0; x < 6; ++x) v = o(v);
      v ^= d;
      for (let x = 0; x < 6; ++x) k += r.charAt(v >> 5 * (5 - x) & 31);
      return k;
    }, toWords: a, fromWordsUnsafe: c, fromWords: u };
  }
  t.bech32 = l("bech32"), t.bech32m = l("bech32m");
}, w6(cy = { exports: {} }, cy.exports), cy.exports);
(Np = R3) && Np.__esModule && Object.prototype.hasOwnProperty.call(Np, "default") && Np.default;
R3.bech32m;
R3.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var Tl;
var Pl;
(function(e) {
  e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Tl || (Tl = {})), function(e) {
  e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(Pl || (Pl = {}));
Pl.p2pkh, Tl.mainnet, Pl.p2pkh, Tl.testnet, Pl.p2sh, Tl.mainnet, Pl.p2sh, Tl.testnet;
var GY = "accountChange";
_e({
  type: br(GY)
});
var WY = "networkChange";
_e({
  type: br(WY)
});
var ZY = "disconnect";
_e({
  type: br(ZY)
});
async function Q1(e) {
  var r;
  const t = await (e == null ? void 0 : e()) || ((r = window.XverseProviders) == null ? void 0 : r.BitcoinProvider) || window.BitcoinProvider;
  if (!t)
    throw new Error("No Bitcoin wallet installed");
  return t;
}
var o_ = ((e) => (e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Signet = "Signet", e))(o_ || {});
var z3 = mi(G1([Ne(), qi(), Zu()]));
var oo = _e({
  jsonrpc: br("2.0"),
  method: Ne(),
  params: mi(
    G1([
      gi(W1()),
      qS({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      Zu()
    ])
  ),
  id: z3
});
var xd = ((e) => (e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(xd || {});
var i_ = _e({
  jsonrpc: br("2.0"),
  result: N3(W1()),
  id: z3
});
var s_ = _e({
  jsonrpc: br("2.0"),
  error: N3(W1()),
  id: z3
});
G1([
  i_,
  s_
]);
var em = ((e) => (e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(em || {});
var a_ = ((e) => (e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(a_ || {});
var XY = _e({
  address: Ne(),
  publicKey: Ne(),
  purpose: Nu(em),
  addressType: Nu(a_)
});
var c_ = async (e) => {
  var n, o;
  const t = await Q1(e.getProvider), { purposes: r } = e.payload;
  if (!r)
    throw new Error("Address purposes are required");
  try {
    const i = ko.createUnsecuredToken(e.payload), s = await t.connect(i);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during address request", i), (o = e.onCancel) == null || o.call(e);
  }
};
var YY = "stx_getAddresses";
var JY = Xu(
  _e({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: mi(Ne())
  })
);
_e({
  ...oo.entries,
  ..._e({
    method: br(YY),
    params: JY,
    id: Ne()
  }).entries
});
var QY = "stx_signTransaction";
var eJ = _e({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: Ne(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: mi(Ne()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: mi(MS())
});
_e({
  ...oo.entries,
  ..._e({
    method: br(QY),
    params: eJ,
    id: Ne()
  }).entries
});
var tJ = ["software", "ledger"];
var rJ = VS(tJ);
var nJ = "getInfo";
var oJ = Xu(Zu());
_e({
  /**
   * Version of the wallet.
   */
  version: Ne(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: mi(gi(Ne())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: gi(Ne())
});
_e({
  ...oo.entries,
  ..._e({
    method: br(nJ),
    params: oJ,
    id: Ne()
  }).entries
});
var iJ = "getAddresses";
var sJ = _e({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: gi(Nu(em)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: mi(Ne())
});
_e({
  ...oo.entries,
  ..._e({
    method: br(iJ),
    params: sJ,
    id: Ne()
  }).entries
});
var aJ = "signMessage";
var Kh = ((e) => (e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(Kh || {});
var cJ = _e({
  /**
   * The address used for signing.
   **/
  address: Ne(),
  /**
   * The message to sign.
   **/
  message: Ne(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: mi(Nu(Kh))
});
_e({
  /**
   * The signature of the message.
   */
  signature: Ne(),
  /**
   * hash of the message.
   */
  messageHash: Ne(),
  /**
   * The address used for signing.
   */
  address: Ne(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: Nu(Kh)
});
_e({
  ...oo.entries,
  ..._e({
    method: br(aJ),
    params: cJ,
    id: Ne()
  }).entries
});
var uJ = "getAccounts";
var lJ = _e({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: gi(Nu(em)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: mi(Ne())
});
gi(
  _e({
    ...XY.entries,
    ..._e({
      walletType: rJ
    }).entries
  })
);
_e({
  ...oo.entries,
  ..._e({
    method: br(uJ),
    params: lJ,
    id: Ne()
  }).entries
});
var fJ = "getBalance";
Xu(Zu());
_e({
  ...oo.entries,
  ..._e({
    method: br(fJ),
    id: Ne()
  }).entries
});
var dJ = "wallet_requestPermissions";
var hJ = U3();
br(true);
_e({
  ...oo.entries,
  ..._e({
    method: br(dJ),
    params: hJ,
    id: Ne()
  }).entries
});
var pJ = "wallet_renouncePermissions";
var gJ = U3();
br(true);
_e({
  ...oo.entries,
  ..._e({
    method: br(pJ),
    params: gJ,
    id: Ne()
  }).entries
});
var mJ = "wallet_getWalletType";
Xu(Zu());
_e({
  ...oo.entries,
  ..._e({
    method: br(mJ),
    id: Ne()
  }).entries
});
var bJ = "runes_getBalance";
var yJ = Xu(Zu());
_e({
  balances: gi(
    _e({
      runeName: Ne(),
      amount: Ne(),
      divisibility: qi(),
      symbol: Ne(),
      inscriptionId: Xu(Ne())
    })
  )
});
_e({
  ...oo.entries,
  ..._e({
    method: br(bJ),
    params: yJ,
    id: Ne()
  }).entries
});
var wJ = "runes_transfer";
var vJ = _e({
  recipients: gi(
    _e({
      runeName: Ne(),
      amount: Ne(),
      address: Ne()
    })
  )
});
_e({
  ...oo.entries,
  ..._e({
    method: br(wJ),
    params: vJ,
    id: Ne()
  }).entries
});
var EJ = "ord_getInscriptions";
var xJ = _e({
  offset: qi(),
  limit: qi()
});
_e({
  total: qi(),
  limit: qi(),
  offset: qi(),
  inscriptions: gi(
    _e({
      inscriptionId: Ne(),
      inscriptionNumber: Ne(),
      address: Ne(),
      collectionName: mi(Ne()),
      postage: Ne(),
      contentLength: Ne(),
      contentType: Ne(),
      timestamp: qi(),
      offset: qi(),
      genesisTransaction: Ne(),
      output: Ne()
    })
  )
});
_e({
  ...oo.entries,
  ..._e({
    method: br(EJ),
    params: xJ,
    id: Ne()
  }).entries
});
var kJ = "ord_sendInscriptions";
var AJ = _e({
  transfers: gi(
    _e({
      address: Ne(),
      inscriptionId: Ne()
    })
  )
});
_e({
  ...oo.entries,
  ..._e({
    method: br(kJ),
    params: AJ,
    id: Ne()
  }).entries
});
var Up = async (e, t, r) => {
  var i;
  let n = ((i = window.XverseProviders) == null ? void 0 : i.BitcoinProvider) || window.BitcoinProvider;
  if (!n)
    throw new Error("no wallet provider was found");
  if (!e)
    throw new Error("A wallet method is required");
  const o = await n.request(e, t);
  return u6(s_, o) ? {
    status: "error",
    error: o.error
  } : u6(i_, o) ? {
    status: "success",
    result: o.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: o
    }
  };
};
var SJ = async (e) => {
  var o, i;
  const t = await Q1(e.getProvider), { address: r, message: n } = e.payload;
  if (!r)
    throw new Error("An address is required to sign a message");
  if (!n)
    throw new Error("A message to be signed is required");
  try {
    const s = ko.createUnsecuredToken(e.payload), a = await t.signMessage(s);
    (o = e.onFinish) == null || o.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign message request", s), (i = e.onCancel) == null || i.call(e);
  }
};
var _J = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
});
var TJ = async (e) => {
  var s, a;
  const t = await Q1(e.getProvider), { recipients: r, senderAddress: n, network: o, message: i } = e.payload;
  if (!r || r.length === 0)
    throw new Error("At least one recipient is required");
  if (r.some(
    (c) => typeof c.address != "string" || typeof c.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!n)
    throw new Error("The sender address is required");
  try {
    const c = _J(r), u = {
      network: o,
      senderAddress: n,
      message: i,
      recipients: c
    }, l = ko.createUnsecuredToken(u), f = await t.sendBtcTransaction(l);
    (s = e.onFinish) == null || s.call(e, f);
  } catch (c) {
    console.error("[Connect] Error during send BTC transaction request", c), (a = e.onCancel) == null || a.call(e);
  }
};
var PJ = async (e) => {
  var o, i;
  const t = await Q1(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
  if (!r)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!n)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const s = ko.createUnsecuredToken(e.payload), a = await t.signTransaction(s);
    (o = e.onFinish) == null || o.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign transaction request", s), (i = e.onCancel) == null || i.call(e);
  }
};
var v6 = (e) => e;
var gd = {};
var tc = { addEventListener() {
}, removeEventListener() {
} };
function IJ() {
  try {
    return typeof localStorage < "u";
  } catch {
    return false;
  }
}
IJ() && (gd = localStorage);
var OJ = {
  addEventListener(e, t, r) {
    window.addEventListener("storage", t), window.addEventListener("pageshow", r);
  },
  removeEventListener(e, t, r) {
    window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
  }
};
typeof window < "u" && (tc = OJ);
function Yu(e, t = {}, r = {}) {
  let n = r.encode || v6, o = r.decode || v6, i = kx(), s = i.setKey, a = (f, d) => {
    typeof d > "u" ? (r.listen !== false && tc.perKey && tc.removeEventListener(e + f, u, l), delete gd[e + f]) : (r.listen !== false && tc.perKey && !(f in i.value) && tc.addEventListener(e + f, u, l), gd[e + f] = n(d));
  };
  i.setKey = (f, d) => {
    a(f, d), s(f, d);
  };
  let c = i.set;
  i.set = function(f) {
    for (let d in f)
      a(d, f[d]);
    for (let d in i.value)
      d in f || a(d, void 0);
    c(f);
  };
  function u(f) {
    f.key ? f.key.startsWith(e) && (f.newValue === null ? s(f.key.slice(e.length), void 0) : s(f.key.slice(e.length), o(f.newValue))) : c({});
  }
  function l() {
    let f = { ...t };
    for (let d in gd)
      d.startsWith(e) && (f[d.slice(e.length)] = o(gd[d]));
    for (let d in f)
      i.setKey(d, f[d]);
  }
  return FC(i, () => {
    if (l(), r.listen !== false)
      return tc.addEventListener(e, u, l), () => {
        tc.removeEventListener(e, u, l);
        for (let f in i.value)
          tc.removeEventListener(e + f, u, l);
      };
  }), i;
}
var BJ = "XVERSE_CONNECTED_WALLET_STATE";
var CJ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Yu(BJ, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window == null ? void 0 : window.BitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Qn)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey("accounts", [t.address, t.paymentAddress].filter(Boolean));
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === Wc && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Qn.includes(n) && this.$valueStore.setKey(n, ((i = t[n]) == null ? void 0 : i.toString()) ?? ""));
  }
  initialize() {
    Eo(this.$store, ["provider"], (t) => {
      t.provider !== Wc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r, n;
      ((r = window == null ? void 0 : window.XverseProviders) == null ? void 0 : r.BitcoinProvider) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Wc]: true
      }), (n = this.observer) == null || n.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true }));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && O3(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), Cf(n, this.network).then((s) => {
            this.$store.setKey("balance", s);
          });
          return;
        }
      let o = l0(this.network || Tt);
      await c_({
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (s) => {
          const a = A3(s.addresses), c = S3(s.addresses);
          if (!a || !c)
            throw new Error("Could not find the addresses");
          a && c && (this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", c.address), this.$store.setKey("accounts", [
            a.address,
            c.address
          ])), this.$store.setKey("publicKey", String(s.addresses[0].publicKey)), this.$store.setKey("paymentPublicKey", String(s.addresses[1].publicKey));
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${Wc} wallet`);
        },
        onError: (s) => {
          throw new Error(`Can't lasereyes to ${Wc} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Mt, Br, Vr, Cr].includes(this.network) ? this.network : Tt;
  }
  async sendBTC(t, r) {
    const n = await Up("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    });
    if (n.status === "success")
      return n.result.txid;
    throw n.error.code === xd.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + n.error.message);
  }
  async signMessage(t, r) {
    const n = r || this.$store.get().paymentAddress, o = await Up("signMessage", {
      address: n,
      message: t,
      protocol: Kh.BIP322
    });
    if (o.status === "success")
      return o.result.signature;
    throw o.error.code === xd.USER_REJECTION ? new Error("User rejected the request") : new Error("Error signing message: " + o.error.message);
  }
  async signPsbt(t, r, n, o, i) {
    try {
      const s = Zt.fromBase64(String(n), {
        network: Gr(this.network)
      }), a = this.$store.get().address, c = this.$store.get().paymentAddress, u = s.data.inputs;
      let l = {};
      const f = {
        [a]: []
      }, d = {
        [c]: []
      };
      let m = 0;
      for await (let x of u) {
        if (x.witnessUtxo === void 0)
          d[c].push(Number(m));
        else {
          const { script: _ } = x.witnessUtxo, I = Ih(_, Gr(this.network));
          I === c ? d[c].push(Number(m)) : I === a && f[a].push(Number(m));
        }
        m++;
      }
      f[a].length > 0 && (l = { ...l, ...f }), d[c].length > 0 && (l = { ...l, ...d });
      let y, b, w, v;
      const k = await Up("signPsbt", {
        psbt: n,
        broadcast: !!i,
        signInputs: l
      });
      if (k.status === "success")
        v = Zt.fromBase64(k.result.psbt, {
          network: Gr(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === xd.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), b = v.toHex(), w = v.toBase64()) : (b = v.toHex(), w = v.toBase64()), {
        signedPsbtHex: b,
        signedPsbtBase64: w,
        txId: y
      };
    } catch (s) {
      throw console.error(s), s;
    }
  }
  async getInscriptions(t, r) {
    const i = await Up("ord_getInscriptions", {
      offset: t || 0,
      limit: r || 10
    });
    if (i.status === "success")
      return console.log(i.result), i.result.inscriptions;
    throw console.error(i.error), new Error("Error getting inscriptions");
  }
};
var NJ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window.wizz;
  }
  get network() {
    return this.$network.get();
  }
  handleNetworkChanged(t) {
    this.parent.connect(Sl);
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && this.$store.setKey("accounts", t);
  }
  initialize() {
    Eo(this.$store, ["provider"], (t) => {
      t.provider === Sl ? this.addLibraryListeners() : this.removeLibraryListeners();
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Sl]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true }));
  }
  removeLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.removeListener("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.removeListener("accountsChanged", this.handleAccountsChanged.bind(this));
  }
  addLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.on("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeLibraryListeners();
  }
  async connect() {
    if (!this.library)
      throw pY;
    const t = await this.library.requestAccounts();
    if (!t)
      throw new Error("No accounts found");
    const r = await this.library.getPublicKey();
    if (!r)
      throw new Error("No public key found");
    this.$store.setKey("accounts", t), this.$store.setKey("address", t[0]), this.$store.setKey("paymentAddress", t[0]), this.$store.setKey("publicKey", r), this.$store.setKey("paymentPublicKey", r), this.$store.setKey("provider", Sl), await this.getNetwork().then((n) => {
      var o;
      n && ((o = this.config) == null ? void 0 : o.network) !== n && this.parent.switchNetwork(n);
    }), this.$store.setKey("connected", true);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getNetwork());
    return t ? K4(t) : void 0;
  }
  async switchNetwork(t) {
    var n;
    if (t === Cr || t === no)
      return await this.library.switchNetwork(Ed);
    const r = K4(t);
    await ((n = this.library) == null ? void 0 : n.switchNetwork(r)), this.$network.set(t), await this.parent.getBalance();
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async sendBTC(t, r) {
    var o;
    const n = await ((o = this.library) == null ? void 0 : o.sendBitcoin(t, r));
    if (n)
      return n;
    throw new Error("Error sending BTC");
  }
  async signMessage(t) {
    var r;
    return await ((r = this.library) == null ? void 0 : r.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var u;
    const s = await ((u = this.library) == null ? void 0 : u.signPsbt(r, {
      autoFinalized: o,
      broadcast: false
    })), a = Zt.fromHex(s);
    let c;
    return o && i && (c = await this.pushPsbt(s)), {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: c
    };
  }
};
var UJ = "OYL_CONNECTED_WALLET_STATE";
var $J = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Yu(UJ, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window.oyl;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Qn)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === xl && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Qn.includes(n) && this.$valueStore.setKey(n, ((i = t[n]) == null ? void 0 : i.toString()) ?? ""));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      (window == null ? void 0 : window.oyl) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [xl]: true
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      t.provider !== xl ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Oyl isn't installed");
    if (I3(this.network))
      throw new Error(`${this.network} is not supported by Oyl`);
    const { nativeSegwit: r, taproot: n } = await this.library.getAddresses();
    if (!r || !n)
      throw new Error("No accounts found");
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", r.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), this.$store.setKey("provider", xl), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await T3(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), o = await this.signPsbt("", n, "", true, true);
    if (!o)
      throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    const n = r || this.$store.get().paymentAddress;
    return (await this.library.signMessage({
      address: n,
      message: t
    })).signature;
  }
  async signPsbt(t, r, n, o, i) {
    const { psbt: s, txid: a } = await this.library.signPsbt({
      psbt: r,
      finalize: o,
      broadcast: i
    }), c = Zt.fromHex(s);
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: a
    };
  }
  async pushPsbt(t) {
    return (await this.library.pushPsbt({ psbt: t })).txid;
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    const { total: t } = await this.library.getBalance();
    return this.$store.setKey("balance", t), t;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork() {
    throw Zw;
  }
};
var RJ = "LEATHER_CONNECTED_WALLET_STATE";
var zJ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Yu(RJ, {
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window.LeatherProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Qn)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === kl && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Qn.includes(n) && this.$valueStore.setKey(n, ((i = t[n]) == null ? void 0 : i.toString()) ?? ""));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      (window == null ? void 0 : window.LeatherProvider) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [kl]: true
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      t.provider !== kl ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    var c;
    if (!this.library)
      throw new Error("Leather isn't installed");
    const r = await this.library.request("getAddresses");
    if (!r)
      throw new Error("No accounts found");
    const o = r.result.addresses, i = o.map((u) => u.address), s = o.find((u) => u.type === bd), a = o.find((u) => u.type === Jy);
    if (!(s != null && s.publicKey) || !(a != null && a.publicKey))
      throw new Error("No accounts found");
    if ((c = String(s == null ? void 0 : s.address)) != null && c.startsWith("tb") && this.network !== Mt && this.network !== Br && this.network !== Vr)
      throw new Error(`Please switch networks to ${this.network} in the wallet settings.`);
    this.$store.setKey("accounts", i), this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", a.address), this.$store.setKey("publicKey", s.publicKey), this.$store.setKey("paymentPublicKey", a.publicKey), this.$store.setKey("provider", kl), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    var o, i;
    const n = await ((o = this.library) == null ? void 0 : o.request("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    }));
    if ((i = n == null ? void 0 : n.result) != null && i.txid)
      return n.result.txid;
    throw n.error.code === xd.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + n.error.message);
  }
  async signMessage(t, r) {
    var i;
    const n = r === this.$store.get().address ? bd : Jy;
    if (r !== this.$store.get().address && r !== this.$store.get().paymentAddress)
      throw new Error("Invalid address to sign message");
    const o = await this.library.request("signMessage", {
      message: t,
      paymentType: n
    });
    return (i = o == null ? void 0 : o.result) == null ? void 0 : i.signature;
  }
  async signPsbt(t, r, n, o, i) {
    const s = {
      hex: r,
      broadcast: false,
      network: this.network
    }, u = (await this.library.request("signPsbt", s)).result.hex, l = Zt.fromHex(String(u));
    if (o && i) {
      const f = l.finalizeAllInputs(), d = await this.pushPsbt(f.toHex());
      return {
        signedPsbtHex: l.toHex(),
        signedPsbtBase64: l.toBase64(),
        txId: d
      };
    } else if (o) {
      const f = l.finalizeAllInputs();
      return {
        signedPsbtHex: f.toHex(),
        signedPsbtBase64: f.toBase64(),
        txId: void 0
      };
    } else
      return {
        signedPsbtHex: l.toHex(),
        signedPsbtBase64: l.toBase64(),
        txId: void 0
      };
  }
  async getPublicKey() {
    const { result: t } = await this.library.request("getAddresses"), n = t.addresses.find((o) => o.type === bd);
    if (!(n != null && n.publicKey))
      throw new Error("No accounts found");
    return n.publicKey;
  }
  async getBalance() {
    const t = await Cf(this.$store.get().paymentAddress, this.network);
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    const { result: t } = await this.library.request("getAddresses"), n = t.addresses.map((o) => o.address);
    return this.$store.setKey("accounts", n), n;
  }
};
var kd = {};
var u_ = {};
var ki = {};
var l_ = {};
Object.defineProperty(l_, "__esModule", { value: true });
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Xe && Xe.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
  async function n(s) {
    var c, u;
    if (s) {
      const l = await s();
      if (l)
        return l;
    }
    const a = window.OrangeBitcoinProvider || ((c = window.OrangecryptoProviders) == null ? void 0 : c.BitcoinProvider) || ((u = window.OrangeWalletProviders) == null ? void 0 : u.OrangeBitcoinProvider);
    if (!a)
      throw new Error("No Orange Bitcoin wallet installed");
    return a;
  }
  e.getProviderOrThrow = n;
  function o() {
    return window.btc_providers || (window.btc_providers = []), window.btc_providers;
  }
  e.getProviders = o;
  function i(s) {
    var a;
    if (Array.isArray(window.btc_providers)) {
      const c = window.btc_providers.find((u) => u.id === s);
      return (a = c == null ? void 0 : c.id) == null ? void 0 : a.split(".").reduce((u, l) => u == null ? void 0 : u[l], window);
    } else {
      console.log("window.btc_providers is not defined or not an array");
      return;
    }
  }
  e.getProviderById = i, r(l_, e);
})(ki);
var f_ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.AddressType = e.AddressPurpose = void 0, function(t) {
    t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
  }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
    t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
  }(e.AddressType || (e.AddressType = {}));
})(f_);
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Xe && Xe.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.getAddress = void 0;
  const n = ko, o = ki, i = async (s) => {
    var u, l;
    const a = await (0, o.getProviderOrThrow)(s.getProvider), { purposes: c } = s.payload;
    if (!c)
      throw new Error("Address purposes are required");
    try {
      const f = (0, n.createUnsecuredToken)(s.payload), d = await a.connect(f);
      (u = s.onFinish) == null || u.call(s, d);
    } catch (f) {
      console.error("[Connect] Error during address request", f), (l = s.onCancel) == null || l.call(s);
    }
  };
  e.getAddress = i, r(f_, e);
})(u_);
var d_ = {};
var h_ = {};
var p_ = {};
Object.defineProperty(p_, "__esModule", { value: true });
var g_ = {};
Object.defineProperty(g_, "__esModule", { value: true });
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Xe && Xe.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(p_, e), r(g_, e);
})(h_);
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Xe && Xe.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.request = void 0;
  const n = ki, o = async (s, a, c) => {
    var f;
    let u = ((f = window.OrangecryptoProviders) == null ? void 0 : f.BitcoinProvider) || window.OrangeBitcoinProvider;
    if (c && (u = await (0, n.getProviderById)(c)), !u)
      throw new Error("no wallet provider was found");
    if (!s)
      throw new Error("A wallet method is required");
    const l = await u.request(s, a);
    return i(l) ? {
      status: "success",
      result: l.result
    } : {
      status: "error",
      error: l.error
    };
  };
  e.request = o;
  const i = (s) => Object.hasOwn(s, "result") && !!s.result;
  r(h_, e);
})(d_);
var m_ = {};
var b_ = {};
Object.defineProperty(b_, "__esModule", { value: true });
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(a, c, u, l) {
    l === void 0 && (l = u);
    var f = Object.getOwnPropertyDescriptor(c, u);
    (!f || ("get" in f ? !c.__esModule : f.writable || f.configurable)) && (f = { enumerable: true, get: function() {
      return c[u];
    } }), Object.defineProperty(a, l, f);
  } : function(a, c, u, l) {
    l === void 0 && (l = u), a[l] = c[u];
  }), r = Xe && Xe.__exportStar || function(a, c) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(c, u) && t(c, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.getCapabilities = void 0;
  const n = ko, o = ki, i = (a, c) => {
    const u = (f) => !(!a[f] || c && !c.has(f)), l = {
      request: u("request"),
      connect: u("connect"),
      signMessage: u("signMessage"),
      signTransaction: u("signTransaction"),
      sendBtcTransaction: u("sendBtcTransaction"),
      createInscription: u("createInscription"),
      createRepeatInscriptions: u("createRepeatInscriptions"),
      signMultipleTransactions: u("signMultipleTransactions")
    };
    return Object.entries(l).reduce((f, [d, m]) => m ? [...f, d] : f, []);
  }, s = async (a) => {
    var l, f, d;
    const c = await (0, o.getProviderOrThrow)(a.getProvider), u = (0, n.createUnsecuredToken)(a.payload);
    if (c.getCapabilities)
      try {
        const m = await c.getCapabilities(u);
        (l = a.onFinish) == null || l.call(a, i(c, new Set(m)));
      } catch (m) {
        console.error("[Connect] Error during capabilities request", m);
      }
    try {
      const m = i(c);
      (f = a.onFinish) == null || f.call(a, m);
    } catch (m) {
      console.error("[Connect] Error during capabilities request", m), (d = a.onCancel) == null || d.call(a);
    }
  };
  e.getCapabilities = s, r(b_, e);
})(m_);
var y_ = {};
var tm = {};
var Mh = {};
Object.defineProperty(Mh, "__esModule", { value: true });
Mh.validateInscriptionPayload = void 0;
var HJ = 4e5;
var LJ = 6e4;
var jJ = (e) => {
  const { contentType: t, content: r, payloadType: n, network: o, appFeeAddress: i, appFee: s } = e;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t))
    throw new Error("Invalid content type detected");
  if (!r || r.length === 0)
    throw new Error("Empty content not allowed");
  if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT")
    throw new Error("Empty invalid payloadType specified");
  if (r.length > (o.type === "Mainnet" ? HJ : LJ))
    throw new Error("Content too large");
  if (((i == null ? void 0 : i.length) ?? 0) > 0 && (s ?? 0) <= 0)
    throw new Error("Invalid combination of app fee address and fee provided");
};
Mh.validateInscriptionPayload = jJ;
Object.defineProperty(tm, "__esModule", { value: true });
tm.createInscription = void 0;
var FJ = ko;
var DJ = ki;
var KJ = Mh;
var MJ = async (e) => {
  var n, o;
  const { getProvider: t } = e, r = await (0, DJ.getProviderOrThrow)(t);
  (0, KJ.validateInscriptionPayload)(e.payload);
  try {
    const i = (0, FJ.createUnsecuredToken)(e.payload), s = await r.createInscription(i);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during create inscription", i), (o = e.onCancel) == null || o.call(e);
  }
};
tm.createInscription = MJ;
var rm = {};
Object.defineProperty(rm, "__esModule", { value: true });
rm.createRepeatInscriptions = void 0;
var qJ = ki;
var VJ = ko;
var GJ = Mh;
var WJ = async (e) => {
  var n, o;
  const { getProvider: t } = e, r = await (0, qJ.getProviderOrThrow)(t);
  (0, GJ.validateInscriptionPayload)(e.payload);
  try {
    const i = (0, VJ.createUnsecuredToken)(e.payload), s = await r.createRepeatInscriptions(i);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during create repeat inscriptions", i), (o = e.onCancel) == null || o.call(e);
  }
};
rm.createRepeatInscriptions = WJ;
var w_ = {};
Object.defineProperty(w_, "__esModule", { value: true });
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Xe && Xe.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(tm, e), r(rm, e), r(w_, e);
})(y_);
var v_ = {};
var E_ = {};
Object.defineProperty(E_, "__esModule", { value: true });
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Xe && Xe.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.signMessage = void 0;
  const n = ko, o = ki, i = async (s) => {
    var l, f;
    const a = await (0, o.getProviderOrThrow)(s.getProvider), { address: c, message: u } = s.payload;
    if (!c)
      throw new Error("An address is required to sign a message");
    if (!u)
      throw new Error("A message to be signed is required");
    try {
      const d = (0, n.createUnsecuredToken)(s.payload), m = await a.signMessage(d);
      (l = s.onFinish) == null || l.call(s, m);
    } catch (d) {
      console.error("[Connect] Error during sign message request", d), (f = s.onCancel) == null || f.call(s);
    }
  };
  e.signMessage = i, r(E_, e);
})(v_);
var x_ = {};
var nm = {};
Object.defineProperty(nm, "__esModule", { value: true });
nm.sendBtcTransaction = void 0;
var ZJ = ko;
var XJ = ki;
var YJ = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
});
var JJ = async (e) => {
  var s, a;
  const t = await (0, XJ.getProviderOrThrow)(e.getProvider), { recipients: r, senderAddress: n, network: o, message: i } = e.payload;
  if (!r || r.length === 0)
    throw new Error("At least one recipient is required");
  if (r.some((c) => typeof c.address != "string" || typeof c.amountSats != "bigint"))
    throw new Error("Incorrect recipient format");
  if (!n)
    throw new Error("The sender address is required");
  try {
    const c = YJ(r), u = {
      network: o,
      senderAddress: n,
      message: i,
      recipients: c
    }, l = (0, ZJ.createUnsecuredToken)(u), f = await t.sendBtcTransaction(l);
    (s = e.onFinish) == null || s.call(e, f);
  } catch (c) {
    console.error("[Connect] Error during send BTC transaction request", c), (a = e.onCancel) == null || a.call(e);
  }
};
nm.sendBtcTransaction = JJ;
var om = {};
Object.defineProperty(om, "__esModule", { value: true });
om.signTransaction = void 0;
var QJ = ko;
var eQ = ki;
var tQ = async (e) => {
  var o, i;
  const t = await (0, eQ.getProviderOrThrow)(e.getProvider), { psbtBase64: r, inputsToSign: n } = e.payload;
  if (!r)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!n)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const s = (0, QJ.createUnsecuredToken)(e.payload), a = await t.signTransaction(s);
    (o = e.onFinish) == null || o.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign transaction request", s), (i = e.onCancel) == null || i.call(e);
  }
};
om.signTransaction = tQ;
var im = {};
Object.defineProperty(im, "__esModule", { value: true });
im.signMultipleTransactions = void 0;
var rQ = ko;
var nQ = ki;
var oQ = async (e) => {
  var n, o;
  const t = await (0, nQ.getProviderOrThrow)(e.getProvider), { psbts: r } = e.payload;
  if (!r || !r.length)
    throw new Error("psbts array is required");
  if (r.length > 100)
    throw new Error("psbts array must contain less than 100 psbts");
  try {
    const i = (0, rQ.createUnsecuredToken)(e.payload), s = await t.signMultipleTransactions(i);
    (n = e.onFinish) == null || n.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign Multiple transactions request", i), (o = e.onCancel) == null || o.call(e);
  }
};
im.signMultipleTransactions = oQ;
var k_ = {};
Object.defineProperty(k_, "__esModule", { value: true });
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Xe && Xe.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(nm, e), r(om, e), r(im, e), r(k_, e);
})(x_);
var A_ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
    t.Mainnet = "Mainnet", t.Testnet = "Testnet";
  }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
    t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
  }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(A_);
(function(e) {
  var t = Xe && Xe.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Xe && Xe.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(u_, e), r(d_, e), r(m_, e), r(y_, e), r(v_, e), r(ki, e), r(x_, e), r(A_, e);
})(kd);
var iQ = ZN(kd);
var { signMessage: sQ, sendBtcTransaction: aQ } = iQ;
var cQ = "ORANGE_CONNECTED_WALLET_STATE";
var uQ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Yu(cQ, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : t.OrangeBitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Qn)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === Xc && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Qn.includes(n) && this.$valueStore.setKey(n, ((i = t[n]) == null ? void 0 : i.toString()) ?? ""));
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var n;
      (window == null ? void 0 : window.OrangeBitcoinProvider) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Xc]: true
      }), (n = this.observer) == null || n.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (r) => {
      r.provider !== Xc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r) {
        this.restorePersistedValues(), Cf(n, this.network).then((s) => {
          this.$store.setKey("balance", s);
        });
        return;
      }
      let o = Zb(this.network || Tt);
      const i = {
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Address for receiving Ordinals and payments",
          network: {
            type: o
          }
        },
        onFinish: (s) => {
          const a = A3(s.addresses), c = S3(s.addresses);
          if (!a || !(c != null && c.address))
            throw new Error("Could not find addresses");
          a && c && (this.$store.setKey("provider", Xc), this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", c.address)), this.$store.setKey("publicKey", String(a.publicKey)), this.$store.setKey("paymentPublicKey", String(c.publicKey));
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${Xc} wallet`);
        }
      };
      await kd.getAddress(i), this.$store.setKey("connected", true);
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [Mt, Br, Vr, Cr].includes(this.network) ? this.network : Tt;
  }
  async sendBTC(t, r) {
    let n = "";
    const o = {
      payload: {
        network: {
          type: Zb(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (i) => {
        n = i;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await aQ(o), n;
  }
  async signMessage(t, r) {
    let n = "";
    const o = r || this.$store.get().paymentAddress, i = {
      payload: {
        network: {
          type: Zb(this.network)
        },
        address: o,
        message: t
      },
      onFinish: (s) => {
        n = s;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await sQ(i), n;
  }
  async signPsbt(t, r, n, o, i) {
    try {
      const s = Zt.fromBase64(String(n), {
        network: Gr(this.network)
      }), a = this.$store.get().address, c = this.$store.get().paymentAddress, u = s.data.inputs;
      let l = {};
      const f = {
        [a]: []
      }, d = {
        [c]: []
      };
      let m = 0;
      for await (let x of u) {
        if (x.witnessUtxo === void 0)
          d[c].push(Number(m));
        else {
          const { script: _ } = x.witnessUtxo, I = Ih(_, Gr(this.network));
          I === c ? d[c].push(Number(m)) : I === a && f[a].push(Number(m));
        }
        m++;
      }
      f[a].length > 0 && (l = { ...l, ...f }), d[c].length > 0 && (l = { ...l, ...d });
      let y, b, w, v;
      const k = await kd.request("signPsbt", {
        psbt: n,
        broadcast: !!i,
        signInputs: l
      });
      if (k.status === "success")
        v = Zt.fromBase64(k.result.psbt, {
          network: Gr(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === kd.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), b = v.toHex(), w = v.toBase64()) : (b = v.toHex(), w = v.toBase64()), {
        signedPsbtHex: b,
        signedPsbtBase64: w,
        txId: y
      };
    } catch (s) {
      throw console.error(s), s;
    }
  }
};
var lQ = "OKX_CONNECTED_WALLET_STATE";
var fQ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Yu(lQ, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    var r, n;
    let t;
    return this.network === Mt || this.network === Br || this.network === Vr || this.network === Cr ? t = (r = window == null ? void 0 : window.okxwallet) == null ? void 0 : r.bitcoinTestnet : (this.network === Tt || this.network === no) && (t = (n = window == null ? void 0 : window.okxwallet) == null ? void 0 : n.bitcoin), t;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Qn)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === Al && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Qn.includes(n) && this.$valueStore.setKey(n, ((i = t[n]) == null ? void 0 : i.toString()) ?? ""));
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var n;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Al]: true
      }), (n = this.observer) == null || n.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (r) => {
      r.provider !== Al ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const r = await this.library.connect();
      if (!r)
        throw new Error("No accounts found");
      this.$store.setKey("address", r.address), this.$store.setKey("paymentAddress", r.address), this.$store.setKey("publicKey", r.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), this.$store.setKey("accounts", [r]), this.$store.setKey("provider", Al), this.$store.setKey("connected", true);
    } catch (r) {
      throw r;
    }
  }
  async requestAccounts() {
    const t = this.library, r = this.network;
    return r === Mt || r === Br || r === Cr ? await t.connect() : await t.requestAccounts();
  }
  async getNetwork() {
    const { address: t } = this.$store.get(), r = this.network;
    if (t.slice(0, 1) === "t")
      return r === Mt ? Mt : r === Br ? Br : r === Vr ? Vr : r === Cr ? Cr : Mt;
    const n = await this.library.getNetwork();
    return EW(n);
  }
  async getPublicKey() {
    const t = this.library;
    return await (t == null ? void 0 : t.getPublicKey());
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async sendBTC(t, r) {
    const o = await this.library.sendBitcoin(t, r);
    if (!o)
      throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    const n = this.library;
    return await (n == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    const a = await this.library.signPsbt(r, {
      autoFinalized: o
    }), c = Zt.fromHex(a);
    if (o && i) {
      const u = await this.pushPsbt(a);
      return {
        signedPsbtHex: c.toHex(),
        signedPsbtBase64: c.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: void 0
    };
  }
};
var dQ = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
var hQ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Yu(dQ, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.magicEden) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Qn) {
      if (r === "balance") {
        this.$store.setKey(r, BigInt(t[r]));
        continue;
      }
      this.$store.setKey(r, t[r]);
    }
    this.$store.setKey("accounts", [t.address, t.paymentAddress].filter(Boolean));
  }
  watchStateChange(t, r, n) {
    var o, i, s;
    t.provider === oc && (n ? n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Qn.includes(n) && this.$valueStore.setKey(n, ((i = t[n]) == null ? void 0 : i.toString()) ?? "") : this.$valueStore.set({
      address: t.address,
      paymentAddress: t.paymentAddress,
      paymentPublicKey: t.paymentPublicKey,
      publicKey: t.publicKey,
      balance: ((s = t.balance) == null ? void 0 : s.toString()) ?? ""
    }));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r, n;
      ((r = window == null ? void 0 : window.magicEden) == null ? void 0 : r.bitcoin) && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [oc]: true
      }), (n = this.observer) == null || n.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      t.provider !== oc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && O3(this.network))
          this.disconnect();
        else {
          Cf(n, this.network).then((s) => {
            this.$store.setKey("balance", s);
          }), this.restorePersistedValues();
          return;
        }
      if (I3(this.network))
        throw new Error(`${this.network} is not supported by ${oc}`);
      let o = l0(this.network || Tt);
      await c_({
        getProvider: async () => this.library,
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (s) => {
          const a = A3(s.addresses), c = S3(s.addresses);
          if (!a || !c)
            throw new Error("No address found");
          a && c && (this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", c.address), this.$store.setKey("accounts", [
            a.address,
            c.address
          ])), this.$store.setKey("publicKey", String(s.addresses[0].publicKey)), this.$store.setKey("paymentPublicKey", String(s.addresses[1].publicKey));
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${oc} wallet`);
        },
        onError: (s) => {
          throw new Error(`Can't lasereyes to ${oc} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async sendBTC(t, r) {
    let n;
    if (await TJ({
      getProvider: async () => this.library,
      payload: {
        network: {
          type: l0(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (o) => {
        n = o;
      },
      onCancel: () => {
        throw console.error("Request canceled"), new Error("User canceled the request");
      }
    }), !n)
      throw new Error("Error sending BTC");
    return n.txid;
  }
  async signMessage(t, r) {
    try {
      const n = r || this.$store.get().paymentAddress;
      let o = "";
      return await SJ({
        getProvider: async () => this.library,
        payload: {
          network: {
            type: o_.Mainnet
          },
          address: n,
          message: t,
          protocol: Kh.BIP322
        },
        onFinish: (i) => {
          o = i;
        },
        onCancel: () => {
          throw console.error("Request canceled"), new Error("User canceled the request");
        }
      }), o;
    } catch (n) {
      throw n;
    }
  }
  async signPsbt(t, r, n, o, i) {
    console.log("signPsbt", n, o, i);
    const { address: s, paymentAddress: a } = this.$store.get(), c = Zt.fromBase64(String(n), {
      network: Gr(this.network)
    }), u = c.data.inputs, l = [], f = {
      address: s,
      signingIndexes: []
    }, d = {
      address: a,
      signingIndexes: []
    };
    let m = 0;
    for await (let _ of u) {
      const { script: I } = _.witnessUtxo, P = Ih(I, Gr(this.network));
      P === a ? (d.signingIndexes.push(Number(m)), _.sighashType && (console.log("Updating sigHash for paymentsAddressData"), d.sigHash = _.sighashType)) : P === s && (f.signingIndexes.push(Number(m)), _.sighashType && (console.log("Updating sigHash for ordinalAddressData"), f.sigHash = _.sighashType)), m++;
    }
    f.signingIndexes.length > 0 && l.push(f), d.signingIndexes.length > 0 && l.push(d);
    let y, b, w, v;
    const k = l0(this.network), x = {
      getProvider: async () => this.library,
      payload: {
        network: {
          type: k
        },
        message: "Sign Transaction",
        psbtBase64: c.toBase64(),
        broadcast: i,
        inputsToSign: l
      },
      onFinish: async (_) => {
        _.psbtBase64 && (v = Zt.fromBase64(String(_.psbtBase64), {
          network: Gr(this.network)
        }), b = v.toHex(), w = v.toBase64());
      },
      onCancel: () => {
        throw console.log("Canceled"), new Error("User canceled the request");
      },
      onError: (_) => {
        throw console.log("error", _), _;
      }
    };
    if (await PJ(x), !v)
      throw new Error("signature failed");
    return o || i ? (v.finalizeAllInputs(), b = v.extractTransaction().toHex(), i ? (y = await this.pushPsbt(b), {
      signedPsbtHex: b,
      signedPsbtBase64: w,
      txId: y
    }) : {
      signedPsbtHex: b,
      signedPsbtBase64: w,
      txId: y
    }) : {
      signedPsbtHex: b,
      signedPsbtBase64: w,
      txId: y
    };
  }
};
var pQ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.phantom) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Zc]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      t.provider === Zc && this.library.requestAccounts().then((r) => {
        this.handleAccountsChanged(r);
      });
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Zc) : this.parent.disconnect());
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Phantom isn't installed");
    if (I3(this.network))
      throw new Error(`${this.network} is not supported by ${Zc}`);
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    this.$store.setKey("accounts", r);
    const n = r.find((i) => i.purpose === "ordinals"), o = r.find((i) => i.purpose === "payment");
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("provider", Zc), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    return this.$store.get().address.slice(0, 1) === "t" ? Mt : Tt;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await T3(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), o = await this.signPsbt("", n, "", true, true);
    if (!o)
      throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    var c;
    const n = new TextEncoder().encode(t), o = new Uint8Array(n), i = r || this.$store.get().paymentAddress, s = await ((c = this.library) == null ? void 0 : c.signMessage(i, o)), a = String.fromCharCode(...s.signature);
    return btoa(a);
  }
  async signPsbt(t, r, n, o, i) {
    const { address: s, paymentAddress: a } = this.$store.get(), u = Zt.fromHex(String(r), {
      network: Gr(this.network)
    }).data.inputs, l = [], f = {
      address: s,
      signingIndexes: []
    }, d = {
      address: a,
      signingIndexes: []
    };
    let m = 0;
    for await (let w of u) {
      const { script: v } = w.witnessUtxo, k = Ih(v, Gr(this.network));
      k === a ? d.signingIndexes.push(Number(m)) : k === s && f.signingIndexes.push(Number(m)), m++;
    }
    f.signingIndexes.length > 0 && l.push(f), d.signingIndexes.length > 0 && l.push(d);
    const y = await this.library.signPSBT(wY(r), {
      inputsToSign: l
    }), b = Zt.fromBuffer(y);
    if (o && l.forEach((w) => {
      w.signingIndexes.forEach((v) => {
        b.finalizeInput(v);
      });
    }), i) {
      const w = await this.pushPsbt(b.toHex());
      return {
        signedPsbtHex: b.toHex(),
        signedPsbtBase64: b.toBase64(),
        txId: w
      };
    }
    return {
      signedPsbtHex: b.toHex(),
      signedPsbtBase64: b.toBase64(),
      txId: void 0
    };
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
};
var gQ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window == null ? void 0 : window.opnet;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Yc]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      if (t.provider !== Yc) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Yc) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = sg(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(Yc);
  }
  async connect(t) {
    if (!this.library)
      throw new Error("OP_NET isn't installed");
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    const n = await this.library.getPublicKey();
    if (!n)
      throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", Yc), await this.getNetwork().then((o) => {
      var i;
      ((i = this.config) == null ? void 0 : i.network) !== o && this.switchNetwork(o);
    }), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getChain());
    return t ? sg(t.enum) : this.network;
  }
  async sendBTC(t, r) {
    var o;
    const n = await ((o = this.library) == null ? void 0 : o.sendBitcoin(t, r));
    if (!n)
      throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var c;
    const s = await ((c = this.library) == null ? void 0 : c.signPsbt(r, {
      autoFinalized: o
    })), a = Zt.fromHex(s);
    if (o && i) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: a.toHex(),
        signedPsbtBase64: a.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var n;
    const r = OA(t);
    await ((n = this.library) == null ? void 0 : n.switchChain(r)), this.$network.set(t);
  }
};
var $p = {};
function od(e) {
  if ($p[e])
    return console.warn(`Multiple requests for "${e}" detected`), $p[e];
  const t = new Promise((r) => {
    const n = console.log;
    console.log = (...o) => {
      o.length > 0 && typeof o[0] == "string" && (console.log = n, $p[e] = void 0, r(o[0]));
    }, n(`Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`);
  });
  return $p[e] = t, t;
}
var mQ = class {
  async requestAccounts() {
    const t = await od("address");
    if (!t)
      throw new Error("No address provided");
    const r = await od("paymentAddress");
    if (!r)
      throw new Error("No payment address provided");
    return [t, r];
  }
  async signMessage(t) {
    return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await od("message to sign");
  }
  async signPsbt(t) {
    return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await od("signed psbt hex");
  }
  async getPublicKey() {
    const t = await od("publicKey");
    if (!t)
      throw new Error("No public key provided");
    return t;
  }
  // TODO: Implement network switching between mainnet and testnet
  async getNetwork() {
    return "mainnet";
  }
  async switchNetwork(t) {
  }
};
var bQ = "SPARROW_CONNECTED_WALLET_STATE";
var yQ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$valueStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: Yu(bQ, {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      })
    }), Object.defineProperty(this, "removeSubscriber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window == null ? void 0 : window.SparrowWalletProvider;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library || (window.SparrowWalletProvider = new mQ()), this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Jc]: true
      }), (t = this.observer) == null || t.disconnect();
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      t.provider !== Jc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(this.watchStateChange.bind(this));
    });
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === Jc && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : Qn.includes(n) && this.$valueStore.setKey(n, ((i = t[n]) == null ? void 0 : i.toString()) ?? ""));
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of Qn)
      this.$store.setKey(r, t[r]);
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const { address: r, paymentAddress: n } = this.$valueStore.get();
      if (r && n)
        if (r.startsWith("tb1") && O3(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), this.$store.setKey("provider", Jc), this.$store.setKey("connected", true);
          return;
        }
      if (!this.library)
        throw new Error("Sparrow wallet isn't supported");
      const o = await this.library.requestAccounts();
      if (!o)
        throw new Error("No accounts found");
      await this.getNetwork().then((s) => {
        this.network !== s && this.switchNetwork(this.network);
      });
      const i = await this.library.getPublicKey();
      if (!i)
        throw new Error("No public key found");
      this.$store.setKey("accounts", o), this.$store.setKey("address", o[0]), this.$store.setKey("paymentAddress", o[1]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i);
    } catch (r) {
      this.disconnect(), console.error("Error during connect:", r);
    }
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtBase64: n } = await T3(this.$store.get().address, this.$store.get().paymentAddress, t, r, this.$store.get().paymentPublicKey, this.network, 7), o = await this.library.signPsbt(n);
    if (!o)
      throw new Error("No signed PSBT provided");
    const i = await this.pushPsbt(o);
    if (!i)
      throw new Error("send failed, no txid returned");
    return i;
  }
  async signMessage(t, r) {
    return await this.library.signMessage(t);
  }
  async signPsbt(t, r, n, o, i) {
    const s = Zt.fromBase64(n), a = await this.library.signPsbt(n);
    if (o && i) {
      const c = await this.pushPsbt(a);
      return {
        signedPsbtHex: a,
        signedPsbtBase64: s.toBase64(),
        txId: c
      };
    }
    return {
      signedPsbtHex: a,
      signedPsbtBase64: s.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    const t = await this.library.getPublicKey();
    return this.$store.setKey("publicKey", t), t;
  }
  async getBalance() {
    const t = await Cf(this.$store.get().paymentAddress, this.network);
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    return await this.connect(Jc), this.$store.get().accounts;
  }
};
var wQ = class extends Do {
  constructor() {
    super(...arguments), Object.defineProperty(this, "observer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  get library() {
    return window.glittr;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Gc]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Eo(this.$store, ["provider"], (t) => {
      if (t.provider !== Gc) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener("accountsChanged", this.handleAccountsChanged.bind(this)), (r = this.library) == null || r.removeListener("networkChanged", this.handleNetworkChanged.bind(this)));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(Gc) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = D4(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(Gc);
  }
  async connect(t) {
    if (!this.library)
      throw new Error("Glittr Wallet isn't installed");
    const r = await this.library.requestAccounts();
    if (!r)
      throw new Error("No accounts found");
    await this.getNetwork().then((o) => {
      this.network !== o && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n)
      throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", Gc), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    var r;
    const t = await ((r = this.library) == null ? void 0 : r.getChain());
    return t ? D4(t.enum) : this.network;
  }
  async sendBTC(t, r) {
    var o;
    const n = await ((o = this.library) == null ? void 0 : o.sendBitcoin(t, r));
    if (!n)
      throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var c;
    const s = await ((c = this.library) == null ? void 0 : c.signPsbt(r, {
      autoFinalized: o
    })), a = Zt.fromHex(s);
    if (o && i) {
      const u = await this.pushPsbt(s);
      return {
        signedPsbtHex: a.toHex(),
        signedPsbtBase64: a.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var n;
    const r = wW(t);
    await ((n = this.library) == null ? void 0 : n.switchChain(r)), this.$network.set(t);
  }
};
var f2e = class {
  dispose() {
    this.disposed = true, Object.values(this.$providerMap).forEach((t) => t == null ? void 0 : t.dispose());
  }
  constructor(t, r) {
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: r
    }), Object.defineProperty(this, "$store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$network", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "$providerMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "disposed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    }), this.$store = t.$store, this.$network = t.$network, DC(this.$store), this.$providerMap = {
      [kl]: new zJ(t, this, r),
      [oc]: new hQ(t, this, r),
      [Al]: new fQ(t, this, r),
      [Yc]: new gQ(t, this, r),
      [Xc]: new uQ(t, this, r),
      [xl]: new $J(t, this, r),
      [Zc]: new pQ(t, this, r),
      [Jc]: new yQ(t, this, r),
      [Vc]: new gY(t, this, r),
      [Wc]: new CJ(t, this, r),
      [Sl]: new NJ(t, this, r),
      [Gc]: new wQ(t, this, r)
    };
  }
  initialize() {
    this.$network.listen(this.watchNetworkChange.bind(this)), Eo(this.$store, ["isInitializing"], (t, r) => {
      if (!this.disposed && t.isInitializing !== r.isInitializing)
        return this.handleIsInitializingChanged(t.isInitializing);
    }), this.config && this.config.network && (this.$network.set(this.config.network), this.getNetwork().then((t) => {
      try {
        this.config.network !== t && this.switchNetwork(this.config.network);
      } catch {
        this.disconnect();
      }
    })), yY(() => this.$store.setKey("isInitializing", false));
  }
  handleIsInitializingChanged(t) {
    if (typeof window < "u" && typeof localStorage < "u" && !t) {
      const r = localStorage == null ? void 0 : localStorage.getItem(fb);
      r && this.connect(r);
    }
  }
  async connect(t) {
    if (this.disposed) {
      console.warn("Client disposed, cannot connect");
      return;
    }
    this.$store.setKey("isConnecting", true);
    try {
      if (localStorage == null || localStorage.setItem(fb, t), !this.$providerMap[t])
        throw new Error("Unsupported wallet provider");
      const r = this.$providerMap[t];
      await (r == null ? void 0 : r.connect(t)), this.$store.setKey("connected", true), this.$store.setKey("provider", t);
    } catch (r) {
      throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", false), this.disconnect(), r;
    } finally {
      this.$store.setKey("isConnecting", false);
    }
  }
  async requestAccounts() {
    var t;
    if (!this.$store.get().provider)
      throw new Error("No wallet provider connected");
    try {
      return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.requestAccounts());
    } catch (r) {
      throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : r;
    }
  }
  disconnect() {
    this.$store.set({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      balance: void 0,
      accounts: [],
      connected: false,
      isConnecting: false,
      isInitializing: false,
      hasProvider: this.$store.get().hasProvider
    }), localStorage == null || localStorage.removeItem(fb);
  }
  async switchNetwork(t) {
    var r;
    try {
      this.$store.get().provider && await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.switchNetwork(t));
    } catch (n) {
      throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error("The connected wallet doesn't support programmatic network changes..")) : n;
    }
  }
  watchNetworkChange() {
    this.$store.setKey("balance", void 0);
  }
  async getNetwork() {
    var t;
    return this.$store.get().provider && this.$providerMap[this.$store.get().provider] ? await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getNetwork()) : this.$network.get();
  }
  async sendBTC(t, r) {
    var n;
    if (r <= 0)
      throw new Error("Amount must be greater than 0");
    if (!Number.isInteger(r))
      throw new Error("Amount must be an integer");
    if (!this.$store.get().provider)
      throw new Error("No wallet connected");
    if (this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.sendBTC(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support sending BTC...") : o;
      }
  }
  async signMessage(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.signMessage(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support message signing...") : o;
      }
  }
  async signPsbt(t, r = false, n = false) {
    var s;
    let o, i;
    if (!t)
      throw new Error("No PSBT provided");
    if (bY(t))
      i = Zt.fromHex(t).toBase64(), o = t;
    else if (mY(t))
      i = t, o = Zt.fromBase64(t).toHex();
    else
      throw new Error("Invalid PSBT format");
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((s = this.$providerMap[this.$store.get().provider]) == null ? void 0 : s.signPsbt(t, o, i, r, n));
      } catch (a) {
        throw a instanceof Error && a.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : a;
      }
    else
      throw new Error("No wallet provider connected");
  }
  async pushPsbt(t) {
    var r;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.pushPsbt(t));
      } catch (n) {
        throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support PSBT signing...") : n;
      }
  }
  async inscribe(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.inscribe(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support inscribing...") : o;
      }
  }
  async getPublicKey() {
    var t;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getPublicKey());
      } catch (r) {
        throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : r;
      }
  }
  async getBalance() {
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        const t = await this.$providerMap[this.$store.get().provider].getBalance();
        return this.$store.setKey("balance", BigInt(t)), t;
      } catch (t) {
        throw t instanceof Error && t.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : t;
      }
  }
  async getInscriptions(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.getInscriptions(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
      }
  }
};
var vQ = Object.defineProperty;
var EQ = (e, t, r) => t in e ? vQ(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var Ee = (e, t, r) => EQ(e, typeof t != "symbol" ? t + "" : t, r);
function xQ(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const o in n)
        if (o !== "default" && !(o in e)) {
          const i = Object.getOwnPropertyDescriptor(n, o);
          i && Object.defineProperty(e, o, i.get ? i : {
            enumerable: true,
            get: () => n[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Jw = Symbol("clean");
var Vo = [];
var Oa = 0;
var Rp = 4;
var Qw = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let i = Oa + Rp; i < Vo.length; )
          Vo[i] === n ? Vo.splice(i, Rp) : i += Rp;
        let o = t.indexOf(n);
        ~o && (t.splice(o, 1), --r.lc || r.off());
      };
    },
    notify(n, o) {
      let i = !Vo.length;
      for (let s of t)
        Vo.push(
          s,
          r.value,
          n,
          o
        );
      if (i) {
        for (Oa = 0; Oa < Vo.length; Oa += Rp)
          Vo[Oa](
            Vo[Oa + 1],
            Vo[Oa + 2],
            Vo[Oa + 3]
          );
        Vo.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let o = r.value;
      o !== n && (r.value = n, r.notify(o));
    },
    subscribe(n) {
      let o = r.listen(n);
      return n(r.value), o;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[Jw] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
var kQ = 5;
var fl = 6;
var zp = 10;
var AQ = (e, t, r, n) => (e.events = e.events || {}, e.events[r + zp] || (e.events[r + zp] = n((o) => {
  e.events[r].reduceRight((i, s) => (s(i), i), {
    shared: {},
    ...o
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let o = e.events[r], i = o.indexOf(t);
  o.splice(i, 1), o.length || (delete e.events[r], e.events[r + zp](), delete e.events[r + zp]);
});
var SQ = 1e3;
var _Q = (e, t) => AQ(e, (r) => {
  let n = t(r);
  n && e.events[fl].push(n);
}, kQ, (r) => {
  let n = e.listen;
  e.listen = (...i) => (!e.lc && !e.active && (e.active = true, r()), n(...i));
  let o = e.off;
  if (e.events[fl] = [], e.off = () => {
    o(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = false;
        for (let i of e.events[fl]) i();
        e.events[fl] = [];
      }
    }, SQ);
  }, process.env.NODE_ENV !== "production") {
    let i = e[Jw];
    e[Jw] = () => {
      for (let s of e.events[fl]) s();
      e.events[fl] = [], e.active = false, i();
    };
  }
  return () => {
    e.listen = n, e.off = o;
  };
});
var TQ = (e) => {
  e.listen(() => {
  });
};
function Ao(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((o, i, s) => {
    n.has(s) && r(o, i, s);
  });
}
var S_ = (e = {}) => {
  let t = Qw(e);
  return t.setKey = function(r, n) {
    let o = t.value;
    typeof n > "u" && r in t.value ? (t.value = { ...t.value }, delete t.value[r], t.notify(o, r)) : t.value[r] !== n && (t.value = {
      ...t.value,
      [r]: n
    }, t.notify(o, r));
  }, t;
};
var cu = "oyl";
var cc = "unisat";
var tu = "glittr";
var uc = "xverse";
var lc = "phantom";
var uu = "leather";
var Bs = "magic-eden";
var lu = "okx";
var fu = "wizz";
var fc = "orange";
var dc = "op_net";
var hc = "sparrow";
var Ad = "p2tr";
var PQ = "p2pkh";
var IQ = "p2sh-p2wpkh";
var e2 = "p2wpkh";
var OQ = "p2wsh";
var __ = "p2sh";
var uy = "defaultWallet";
var Ai = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
var BQ = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
function CQ(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return false;
  const t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return false;
  const r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function NQ(e) {
  if (e.length < 8) throw new Error("DER sequence length is too short");
  if (e.length > 72) throw new Error("DER sequence length is too long");
  if (e[0] !== 48) throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2)
    throw new Error("DER sequence length is invalid");
  if (e[2] !== 2) throw new Error("Expected DER integer");
  const t = e[3];
  if (t === 0) throw new Error("R length is zero");
  if (5 + t >= e.length) throw new Error("R length is too long");
  if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
  const r = e[5 + t];
  if (r === 0) throw new Error("S length is zero");
  if (6 + t + r !== e.length) throw new Error("S length is invalid");
  if (e[4] & 128) throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128) throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.slice(4, 4 + t),
    s: e.slice(6 + t)
  };
}
function UQ(e, t) {
  const r = e.length, n = t.length;
  if (r === 0) throw new Error("R length is zero");
  if (n === 0) throw new Error("S length is zero");
  if (r > 33) throw new Error("R length is too long");
  if (n > 33) throw new Error("S length is too long");
  if (e[0] & 128) throw new Error("R value is negative");
  if (t[0] & 128) throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128))
    throw new Error("R value excessively padded");
  if (n > 1 && t[0] === 0 && !(t[1] & 128))
    throw new Error("S value excessively padded");
  const o = new Uint8Array(6 + r + n);
  return o[0] = 48, o[1] = o.length - 2, o[2] = 2, o[3] = e.length, o.set(e, 4), o[4 + r] = 2, o[5 + r] = t.length, o.set(t, 6 + r), o;
}
var zt = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
var T_ = {};
for (const e of Object.keys(zt)) {
  const t = zt[e];
  T_[t] = e;
}
var dg = "0123456789abcdefABCDEF";
var hg = dg.split("").map((e) => e.codePointAt(0));
var pg = Array(256).fill(true).map((e, t) => {
  const r = String.fromCodePoint(t), n = dg.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
var P_ = new TextEncoder();
var I_ = new TextDecoder();
function $Q(e) {
  return I_.decode(e);
}
function RQ(e) {
  return P_.encode(e);
}
function pr(e) {
  const t = e.reduce((o, i) => o + i.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function De(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? HQ(t) : zQ(t);
}
function zQ(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += dg[pg[hg[e[r] >> 4]]], t += dg[pg[hg[e[r] & 15]]];
  return t;
}
function HQ(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = hg[e[r] >> 4], t[r * 2 + 1] = hg[e[r] & 15];
  return I_.decode(t);
}
function ra(e) {
  const t = P_.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = pg[t[n * 2]], i = pg[t[n * 2 + 1]];
    if (o === void 0 || i === void 0)
      break;
    r[n] = o << 4 | i;
  }
  return n === r.length ? r : r.slice(0, n);
}
function LQ(e) {
  return btoa(String.fromCharCode(...e));
}
function O_(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
function de(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function po(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function jQ(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function qh(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function FQ(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function Ws(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function DQ(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Uf(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function B_(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function C_(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function KQ(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? n : n - 4294967296;
  } else {
    const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? n : n - 4294967296;
  }
}
function N_(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let n = 0n;
  if (r === "LE")
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
  {
    let o = 0n;
    return o = (o << 8n) + BigInt(e[t]), o = (o << 8n) + BigInt(e[t + 1]), o = (o << 8n) + BigInt(e[t + 2]), o = (o << 8n) + BigInt(e[t + 3]), o = (o << 8n) + BigInt(e[t + 4]), o = (o << 8n) + BigInt(e[t + 5]), o = (o << 8n) + BigInt(e[t + 6]), o = (o << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? o : o - 0x10000000000000000n;
  }
}
function U_(e) {
  return e < zt.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function MQ(e, t, r) {
  const n = U_(t);
  return n === 1 ? po(e, r, t) : n === 2 ? (po(e, r, zt.OP_PUSHDATA1), po(e, r + 1, t)) : n === 3 ? (po(e, r, zt.OP_PUSHDATA2), jQ(e, r + 1, t, "LE")) : (po(e, r, zt.OP_PUSHDATA4), qh(e, r + 1, t, "LE")), n;
}
function qQ(e, t) {
  const r = Ws(e, t);
  let n, o;
  if (r < zt.OP_PUSHDATA1)
    n = r, o = 1;
  else if (r === zt.OP_PUSHDATA1) {
    if (t + 2 > e.length) return null;
    n = Ws(e, t + 1), o = 2;
  } else if (r === zt.OP_PUSHDATA2) {
    if (t + 3 > e.length) return null;
    n = DQ(e, t + 1, "LE"), o = 3;
  } else {
    if (t + 5 > e.length) return null;
    if (r !== zt.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    n = Uf(e, t + 1, "LE"), o = 5;
  }
  return {
    opcode: r,
    number: n,
    size: o
  };
}
function VQ(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function GQ(e) {
  let t = Math.abs(e);
  const r = VQ(t), n = new Uint8Array(r), o = e < 0;
  for (let i = 0; i < r; ++i)
    po(n, i, t & 255), t >>= 8;
  return n[r - 1] & 128 ? po(n, r - 1, o ? 128 : 0) : o && (n[r - 1] |= 128), n;
}
function WQ(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function ZQ(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function eh(e) {
  var t, r;
  const n = typeof e;
  return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function xn(e, t, r, n, o) {
  const i = o && "input" in o ? o.input : r.value, s = (o == null ? void 0 : o.expected) ?? e.expects ?? null, a = (o == null ? void 0 : o.received) ?? eh(i), c = {
    kind: e.kind,
    type: e.type,
    input: i,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", l = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? ZQ(e.reference, c.lang) ?? (u ? (c.lang, void 0) : null) ?? n.message ?? (c.lang, void 0);
  l && (c.message = typeof l == "function" ? l(c) : l), u && (r.typed = false), r.issues ? r.issues.push(c) : r.issues = [c];
}
function XQ(e, t) {
  const r = [...new Set(e)];
  return r.length > 1 ? `(${r.join(` ${t} `)})` : r[0] ?? "never";
}
var YQ = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), Ee(this, "issues"), this.name = "ValiError", this.issues = e;
  }
};
function $_(e, t) {
  return {
    kind: "validation",
    type: "every_item",
    reference: $_,
    async: false,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.every(this.requirement) && xn(this, "item", r, n), r;
    }
  };
}
function H3(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: H3,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && xn(this, "integer", t, r), t;
    }
  };
}
function R_(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: R_,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && xn(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function sm(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: sm,
    async: false,
    expects: `<=${e instanceof Date ? e.toJSON() : eh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && xn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : eh(r.value)
      }), r;
    }
  };
}
function am(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: am,
    async: false,
    expects: `>=${e instanceof Date ? e.toJSON() : eh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && xn(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : eh(r.value)
      }), r;
    }
  };
}
function z_(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: z_,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && xn(this, "format", r, n), r;
    }
  };
}
function L3(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function cm(e, t) {
  return !e._run({ typed: false, value: t }, { abortEarly: true }).issues;
}
function H_() {
  return {
    kind: "schema",
    type: "any",
    reference: H_,
    expects: "any",
    async: false,
    _run(e) {
      return e.typed = true, e;
    }
  };
}
function Zn(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: Zn,
    expects: "Array",
    async: false,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = true, r.value = [];
        for (let s = 0; s < i.length; s++) {
          const a = i[s], c = this.item._run({ typed: false, value: a }, n);
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (o = r.issues) == null || o.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), r.value.push(c.value);
        }
      } else
        xn(this, "type", r, n);
      return r;
    }
  };
}
function L_(e) {
  return {
    kind: "schema",
    type: "bigint",
    reference: L_,
    expects: "bigint",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "bigint" ? t.typed = true : xn(this, "type", t, r), t;
    }
  };
}
function bi(e, t) {
  return {
    kind: "schema",
    type: "custom",
    reference: bi,
    expects: "unknown",
    async: false,
    check: e,
    message: t,
    _run(r, n) {
      return this.check(r.value) ? r.typed = true : xn(this, "type", r, n), r;
    }
  };
}
function um(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: um,
    expects: e.name,
    async: false,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = true : xn(this, "type", r, n), r;
    }
  };
}
function t2(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullable",
    reference: t2,
    expects: `(${e.expects} | null)`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return n.value === null && ("default" in this && (n.value = L3(
        this,
        n,
        o
      )), n.value === null) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function j_(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: j_,
    expects: `(${e.expects} | null | undefined)`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = L3(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Mn(e) {
  return {
    kind: "schema",
    type: "number",
    reference: Mn,
    expects: "number",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : xn(this, "type", t, r), t;
    }
  };
}
function Nr(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Nr,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (o = r.issues) == null || o.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
      } else
        xn(this, "type", r, n);
      return r;
    }
  };
}
function gg(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: gg,
    expects: `(${e.expects} | undefined)`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = L3(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Ju(e) {
  return {
    kind: "schema",
    type: "string",
    reference: Ju,
    expects: "string",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = true : xn(this, "type", t, r), t;
    }
  };
}
function Di(e, t) {
  return {
    kind: "schema",
    type: "tuple",
    reference: Di,
    expects: "Array",
    async: false,
    items: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = true, r.value = [];
        for (let s = 0; s < this.items.length; s++) {
          const a = i[s], c = this.items[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (o = r.issues) == null || o.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), r.value.push(c.value);
        }
      } else
        xn(this, "type", r, n);
      return r;
    }
  };
}
function E6(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function j3(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: j3,
    expects: XQ(
      e.map((r) => r.expects),
      "|"
    ),
    async: false,
    options: e,
    message: t,
    _run(r, n) {
      let o, i, s;
      for (const a of this.options) {
        const c = a._run(
          { typed: false, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            i ? i.push(c) : i = [c];
          else {
            o = c;
            break;
          }
        else
          s ? s.push(c) : s = [c];
      }
      if (o)
        return o;
      if (i) {
        if (i.length === 1)
          return i[0];
        xn(this, "type", r, n, {
          issues: E6(i)
        }), r.typed = true;
      } else {
        if ((s == null ? void 0 : s.length) === 1)
          return s[0];
        xn(this, "type", r, n, {
          issues: E6(s)
        });
      }
      return r;
    }
  };
}
function ir(e, t, r) {
  const n = e._run(
    { typed: false, value: t },
    WQ(r)
  );
  if (n.issues)
    throw new YQ(n.issues);
  return n.value;
}
function Sc(e, t) {
  const r = {};
  for (const n in e.entries)
    r[n] = gg(e.entries[n]);
  return { ...e, entries: r };
}
function $f(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = false;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
var x6 = new Uint8Array(32);
var k6 = ra(
  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
);
var Kr = (e) => $f(um(Uint8Array), R_(e));
function th(e, t) {
  return e.length !== t.length ? false : e.every((r, n) => de(r, t[n]) === 0);
}
function ci(e) {
  if (!(e instanceof Uint8Array) || e.length < 33) return false;
  const t = e[0], r = e.slice(1, 33);
  if (de(x6, r) === 0 || de(r, k6) >= 0) return false;
  if ((t === 2 || t === 3) && e.length === 33)
    return true;
  const n = e.slice(33);
  return de(x6, n) === 0 || de(n, k6) >= 0 ? false : t === 4 && e.length === 65;
}
var p0 = 254;
function F3(e) {
  return !e || !("output" in e) || !(e.output instanceof Uint8Array) ? false : e.version !== void 0 ? (e.version & p0) === e.version : true;
}
function F_(e) {
  return Array.isArray(e) ? e.length !== 2 ? false : e.every((t) => F_(t)) : F3(e);
}
var JQ = Kr(32);
var QQ = Kr(20);
var A6 = Kr(32);
var $t = um(Uint8Array);
$f(Ju(), z_(/^([0-9a-f]{2})+$/i));
var eee = $f(
  Mn(),
  H3(),
  am(0),
  sm(255)
);
var Ps = $f(
  Mn(),
  H3(),
  am(0),
  sm(4294967295)
);
var ly = $f(
  L_(),
  am(0n),
  sm(0x7fffffffffffffffn)
);
var S6 = (e) => Nr(
  Object.entries(e).reduce(
    (t, r) => ({ ...t, [r[0]]: j_(r[1]) }),
    {}
  )
);
var _6 = new Uint8Array(1);
function T6(e) {
  let t = 0;
  for (; e[t] === 0; ) ++t;
  return t === e.length ? _6 : (e = e.slice(t), e[0] & 128 ? pr([_6, e]) : e);
}
function P6(e) {
  e[0] === 0 && (e = e.slice(1));
  const t = new Uint8Array(32), r = Math.max(0, 32 - e.length);
  return t.set(e, r), t;
}
function tee(e) {
  const t = Ws(e, e.length - 1);
  if (!K3(t))
    throw new Error("Invalid hashType " + t);
  const r = NQ(e.subarray(0, -1)), n = P6(r.r), o = P6(r.s);
  return { signature: pr([n, o]), hashType: t };
}
function ree(e, t) {
  if (ir(
    Nr({
      signature: Kr(64),
      hashType: eee
    }),
    { signature: e, hashType: t }
  ), !K3(t))
    throw new Error("Invalid hashType " + t);
  const r = new Uint8Array(1);
  po(r, 0, t);
  const n = T6(e.slice(0, 32)), o = T6(e.slice(32, 64));
  return pr([UQ(n, o), r]);
}
var nee = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: tee,
  encode: ree
}, Symbol.toStringTag, { value: "Module" }));
var D_ = zt.OP_RESERVED;
var K_ = Zn(j3([um(Uint8Array), Mn()]));
function oee(e) {
  return cm(Mn(), e) && (e === zt.OP_0 || e >= zt.OP_1 && e <= zt.OP_16 || e === zt.OP_1NEGATE);
}
function M_(e) {
  return cm($t, e) || oee(e);
}
function D3(e) {
  return cm($f(H_(), $_(M_)), e);
}
function q_(e) {
  return e.length - e.filter(M_).length;
}
function mg(e) {
  if (e.length === 0) return zt.OP_0;
  if (e.length === 1) {
    if (e[0] >= 1 && e[0] <= 16) return D_ + e[0];
    if (e[0] === 129) return zt.OP_1NEGATE;
  }
}
function V_(e) {
  return e instanceof Uint8Array;
}
function iee(e) {
  return cm(K_, e);
}
function bg(e) {
  return e instanceof Uint8Array;
}
function Xn(e) {
  if (V_(e)) return e;
  ir(K_, e);
  const t = e.reduce((o, i) => bg(i) ? i.length === 1 && mg(i) !== void 0 ? o + 1 : o + U_(i.length) + i.length : o + 1, 0), r = new Uint8Array(t);
  let n = 0;
  if (e.forEach((o) => {
    if (bg(o)) {
      const i = mg(o);
      if (i !== void 0) {
        po(r, n, i), n += 1;
        return;
      }
      n += MQ(r, o.length, n), r.set(o, n), n += o.length;
    } else
      po(r, n, o), n += 1;
  }), n !== r.length) throw new Error("Could not decode chunks");
  return r;
}
function cr(e) {
  if (iee(e)) return e;
  ir($t, e);
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const n = e[r];
    if (n > zt.OP_0 && n <= zt.OP_PUSHDATA4) {
      const o = qQ(e, r);
      if (o === null || (r += o.size, r + o.number > e.length)) return null;
      const i = e.slice(r, r + o.number);
      r += o.number;
      const s = mg(i);
      s !== void 0 ? t.push(s) : t.push(i);
    } else
      t.push(n), r += 1;
  }
  return t;
}
function see(e) {
  if (V_(e) && (e = cr(e)), !e)
    throw new Error("Could not convert invalid chunks to ASM");
  return e.map((t) => {
    if (bg(t)) {
      const r = mg(t);
      if (r === void 0) return De(t);
      t = r;
    }
    return T_[t];
  }).join(" ");
}
function aee(e) {
  return e = cr(e), ir(bi(D3), e), e.map((t) => bg(t) ? t : t === zt.OP_0 ? new Uint8Array(0) : GQ(t - D_));
}
function cee(e) {
  return ci(e);
}
function K3(e) {
  const t = e & -129;
  return t > 0 && t < 4;
}
function Zs(e) {
  return !(e instanceof Uint8Array) || !K3(e[e.length - 1]) ? false : CQ(e.slice(0, -1));
}
var Sd = nee;
function Ue(e, t, r) {
  Object.defineProperty(e, t, {
    configurable: true,
    enumerable: true,
    get() {
      const n = r.call(this);
      return this[t] = n, n;
    },
    set(n) {
      Object.defineProperty(this, t, {
        configurable: true,
        enumerable: true,
        value: n,
        writable: true
      });
    }
  });
}
function Lo(e) {
  let t;
  return () => (t !== void 0 || (t = e()), t);
}
var wl = zt;
var Hp = wl.OP_RESERVED;
function lm(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {});
  function r(a) {
    return Zs(a) || (t.allowIncomplete && a === wl.OP_0) !== void 0;
  }
  ir(
    Sc(
      Nr({
        network: Nr({}),
        m: Mn(),
        n: Mn(),
        output: $t,
        pubkeys: Zn(bi(ci), "Received invalid pubkey"),
        signatures: Zn(
          bi(r),
          "Expected signature to be of type isAcceptableSignature"
        ),
        input: $t
      })
    ),
    e
  );
  const n = { network: e.network || Ai };
  let o = [], i = false;
  function s(a) {
    i || (i = true, o = cr(a), n.m = o[0] - Hp, n.n = o[o.length - 2] - Hp, n.pubkeys = o.slice(1, -2));
  }
  if (Ue(n, "output", () => {
    if (e.m && n.n && e.pubkeys)
      return Xn(
        [].concat(
          Hp + e.m,
          e.pubkeys,
          Hp + n.n,
          wl.OP_CHECKMULTISIG
        )
      );
  }), Ue(n, "m", () => {
    if (n.output)
      return s(n.output), n.m;
  }), Ue(n, "n", () => {
    if (n.pubkeys)
      return n.pubkeys.length;
  }), Ue(n, "pubkeys", () => {
    if (e.output)
      return s(e.output), n.pubkeys;
  }), Ue(n, "signatures", () => {
    if (e.input)
      return cr(e.input).slice(1);
  }), Ue(n, "input", () => {
    if (e.signatures)
      return Xn([wl.OP_0].concat(e.signatures));
  }), Ue(n, "witness", () => {
    if (n.input)
      return [];
  }), Ue(n, "name", () => {
    if (!(!n.m || !n.n))
      return `p2ms(${n.m} of ${n.n})`;
  }), t.validate) {
    if (e.output) {
      if (s(e.output), ir(Mn(), o[0], { message: "Output is invalid" }), ir(Mn(), o[o.length - 2], {
        message: "Output is invalid"
      }), o[o.length - 1] !== wl.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (n.m <= 0 || n.n > 16 || n.m > n.n || n.n !== o.length - 3)
        throw new TypeError("Output is invalid");
      if (!n.pubkeys.every((a) => ci(a)))
        throw new TypeError("Output is invalid");
      if (e.m !== void 0 && e.m !== n.m) throw new TypeError("m mismatch");
      if (e.n !== void 0 && e.n !== n.n) throw new TypeError("n mismatch");
      if (e.pubkeys && !th(e.pubkeys, n.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (e.pubkeys) {
      if (e.n !== void 0 && e.n !== e.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (n.n = e.pubkeys.length, n.n < n.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (e.signatures) {
      if (e.signatures.length < n.m)
        throw new TypeError("Not enough signatures provided");
      if (e.signatures.length > n.m)
        throw new TypeError("Too many signatures provided");
    }
    if (e.input) {
      if (e.input[0] !== wl.OP_0) throw new TypeError("Input is invalid");
      if (n.signatures.length === 0 || !n.signatures.every(r))
        throw new TypeError("Input has invalid signature(s)");
      if (e.signatures && !th(e.signatures, n.signatures))
        throw new TypeError("Signature mismatch");
      if (e.m !== void 0 && e.m !== e.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(n, e);
}
var I6 = zt;
function G_(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), ir(
    Sc(
      Nr({
        network: Nr({}),
        output: $t,
        pubkey: bi(ci, "invalid pubkey"),
        signature: bi(
          Zs,
          "Expected signature to be of type isCanonicalScriptSignature"
        ),
        input: $t
      })
    ),
    e
  );
  const r = Lo(() => cr(e.input)), n = { name: "p2pk", network: e.network || Ai };
  if (Ue(n, "output", () => {
    if (e.pubkey)
      return Xn([e.pubkey, I6.OP_CHECKSIG]);
  }), Ue(n, "pubkey", () => {
    if (e.output)
      return e.output.slice(1, -1);
  }), Ue(n, "signature", () => {
    if (e.input)
      return r()[0];
  }), Ue(n, "input", () => {
    if (e.signature)
      return Xn([e.signature]);
  }), Ue(n, "witness", () => {
    if (n.input)
      return [];
  }), t.validate) {
    if (e.output) {
      if (e.output[e.output.length - 1] !== I6.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!ci(n.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (e.pubkey && de(e.pubkey, n.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
    }
    if (e.signature && e.input && de(e.input, n.input) !== 0)
      throw new TypeError("Signature mismatch");
    if (e.input) {
      if (r().length !== 1) throw new TypeError("Input is invalid");
      if (!Zs(n.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(n, e);
}
function O6(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function uee(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function fm(e, ...t) {
  if (!uee(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function lee(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  O6(e.outputLen), O6(e.blockLen);
}
function yg(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function fee(e, t) {
  fm(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var dl = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var fy = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Ni = (e, t) => e << 32 - t | e >>> t;
var Lp = (e, t) => e << t | e >>> 32 - t >>> 0;
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function dee(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function M3(e) {
  return typeof e == "string" && (e = dee(e)), fm(e), e;
}
function hee(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    fm(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const i = e[n];
    r.set(i, o), o += i.length;
  }
  return r;
}
var W_ = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function q3(e) {
  const t = (n) => e().update(M3(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function pee(e = 32) {
  if (dl && typeof dl.getRandomValues == "function")
    return dl.getRandomValues(new Uint8Array(e));
  if (dl && typeof dl.randomBytes == "function")
    return dl.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function gee(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var mee = (e, t, r) => e & t ^ ~e & r;
var bee = (e, t, r) => e & t ^ e & r ^ t & r;
var V3 = class extends W_ {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = fy(this.buffer);
  }
  update(e) {
    yg(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = M3(e);
    const o = e.length;
    for (let i = 0; i < o; ) {
      const s = Math.min(n - this.pos, o - i);
      if (s === n) {
        const a = fy(e);
        for (; n <= o - i; i += n)
          this.process(a, i);
        continue;
      }
      r.set(e.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    yg(this), fee(e, this), this.finished = true;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: i } = this;
    t[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > n - i && (this.process(r, 0), i = 0);
    for (let l = i; l < n; l++)
      t[l] = 0;
    gee(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const s = fy(e), a = this.outputLen;
    if (a % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = a / 4, u = this.get();
    if (c > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < c; l++)
      s.setUint32(4 * l, u[l], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s } = this;
    return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;
  }
};
var yee = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Z_ = new Uint8Array(new Array(16).fill(0).map((e, t) => t));
var wee = Z_.map((e) => (9 * e + 5) % 16);
var G3 = [Z_];
var W3 = [wee];
for (let e = 0; e < 4; e++)
  for (let t of [G3, W3])
    t.push(t[e].map((r) => yee[r]));
var X_ = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e));
var vee = G3.map((e, t) => e.map((r) => X_[t][r]));
var Eee = W3.map((e, t) => e.map((r) => X_[t][r]));
var xee = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var kee = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function B6(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
var jp = new Uint32Array(16);
var Aee = class extends V3 {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: e, h1: t, h2: r, h3: n, h4: o } = this;
    return [e, t, r, n, o];
  }
  set(e, t, r, n, o) {
    this.h0 = e | 0, this.h1 = t | 0, this.h2 = r | 0, this.h3 = n | 0, this.h4 = o | 0;
  }
  process(e, t) {
    for (let d = 0; d < 16; d++, t += 4)
      jp[d] = e.getUint32(t, true);
    let r = this.h0 | 0, n = r, o = this.h1 | 0, i = o, s = this.h2 | 0, a = s, c = this.h3 | 0, u = c, l = this.h4 | 0, f = l;
    for (let d = 0; d < 5; d++) {
      const m = 4 - d, y = xee[d], b = kee[d], w = G3[d], v = W3[d], k = vee[d], x = Eee[d];
      for (let _ = 0; _ < 16; _++) {
        const I = Lp(r + B6(d, o, s, c) + jp[w[_]] + y, k[_]) + l | 0;
        r = l, l = c, c = Lp(s, 10) | 0, s = o, o = I;
      }
      for (let _ = 0; _ < 16; _++) {
        const I = Lp(n + B6(m, i, a, u) + jp[v[_]] + b, x[_]) + f | 0;
        n = f, f = u, u = Lp(a, 10) | 0, a = i, i = I;
      }
    }
    this.set(this.h1 + s + u | 0, this.h2 + c + f | 0, this.h3 + l + n | 0, this.h4 + r + i | 0, this.h0 + o + a | 0);
  }
  roundClean() {
    jp.fill(0);
  }
  destroy() {
    this.destroyed = true, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
var Y_ = q3(() => new Aee());
var See = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Ba = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Ca = new Uint32Array(64);
var _ee = class extends V3 {
  constructor() {
    super(64, 32, 8, false), this.A = Ba[0] | 0, this.B = Ba[1] | 0, this.C = Ba[2] | 0, this.D = Ba[3] | 0, this.E = Ba[4] | 0, this.F = Ba[5] | 0, this.G = Ba[6] | 0, this.H = Ba[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a } = this;
    return [e, t, r, n, o, i, s, a];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = i | 0, this.G = s | 0, this.H = a | 0;
  }
  process(e, t) {
    for (let l = 0; l < 16; l++, t += 4)
      Ca[l] = e.getUint32(t, false);
    for (let l = 16; l < 64; l++) {
      const f = Ca[l - 15], d = Ca[l - 2], m = Ni(f, 7) ^ Ni(f, 18) ^ f >>> 3, y = Ni(d, 17) ^ Ni(d, 19) ^ d >>> 10;
      Ca[l] = y + Ca[l - 7] + m + Ca[l - 16] | 0;
    }
    let { A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: u } = this;
    for (let l = 0; l < 64; l++) {
      const f = Ni(s, 6) ^ Ni(s, 11) ^ Ni(s, 25), d = u + f + mee(s, a, c) + See[l] + Ca[l] | 0, m = (Ni(r, 2) ^ Ni(r, 13) ^ Ni(r, 22)) + bee(r, n, o) | 0;
      u = c, c = a, a = s, s = i + d | 0, i = o, o = n, n = r, r = d + m | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, o, i, s, a, c, u);
  }
  roundClean() {
    Ca.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var en = q3(() => new _ee());
function js(e) {
  return Y_(en(e));
}
function Kc(e) {
  return en(en(e));
}
var Tee = {
  "BIP0340/challenge": Uint8Array.from([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": Uint8Array.from([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": Uint8Array.from([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: Uint8Array.from([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: Uint8Array.from([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: Uint8Array.from([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: Uint8Array.from([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": Uint8Array.from([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": Uint8Array.from([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function dm(e, t) {
  return en(pr([Tee[e], t]));
}
function Pee(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let u = 0; u < t.length; u++)
    t[u] = 255;
  for (let u = 0; u < e.length; u++) {
    const l = e.charAt(u), f = l.charCodeAt(0);
    if (t[f] !== 255)
      throw new TypeError(l + " is ambiguous");
    t[f] = u;
  }
  const r = e.length, n = e.charAt(0), o = Math.log(r) / Math.log(256), i = Math.log(256) / Math.log(r);
  function s(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u.length === 0)
      return "";
    let l = 0, f = 0, d = 0;
    const m = u.length;
    for (; d !== m && u[d] === 0; )
      d++, l++;
    const y = (m - d) * i + 1 >>> 0, b = new Uint8Array(y);
    for (; d !== m; ) {
      let k = u[d], x = 0;
      for (let _ = y - 1; (k !== 0 || x < f) && _ !== -1; _--, x++)
        k += 256 * b[_] >>> 0, b[_] = k % r >>> 0, k = k / r >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      f = x, d++;
    }
    let w = y - f;
    for (; w !== y && b[w] === 0; )
      w++;
    let v = n.repeat(l);
    for (; w < y; ++w)
      v += e.charAt(b[w]);
    return v;
  }
  function a(u) {
    if (typeof u != "string")
      throw new TypeError("Expected String");
    if (u.length === 0)
      return new Uint8Array();
    let l = 0, f = 0, d = 0;
    for (; u[l] === n; )
      f++, l++;
    const m = (u.length - l) * o + 1 >>> 0, y = new Uint8Array(m);
    for (; u[l]; ) {
      let k = t[u.charCodeAt(l)];
      if (k === 255)
        return;
      let x = 0;
      for (let _ = m - 1; (k !== 0 || x < d) && _ !== -1; _--, x++)
        k += r * y[_] >>> 0, y[_] = k % 256 >>> 0, k = k / 256 >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      d = x, l++;
    }
    let b = m - d;
    for (; b !== m && y[b] === 0; )
      b++;
    const w = new Uint8Array(f + (m - b));
    let v = f;
    for (; b !== m; )
      w[v++] = y[b++];
    return w;
  }
  function c(u) {
    const l = a(u);
    if (l)
      return l;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: a,
    decode: c
  };
}
var Iee = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var dy = Pee(Iee);
function Oee(e) {
  function t(i) {
    var s = Uint8Array.from(i), a = e(s), c = s.length + 4, u = new Uint8Array(c);
    return u.set(s, 0), u.set(a.subarray(0, 4), s.length), dy.encode(u);
  }
  function r(i) {
    var s = i.slice(0, -4), a = i.slice(-4), c = e(s);
    if (!(a[0] ^ c[0] | a[1] ^ c[1] | a[2] ^ c[2] | a[3] ^ c[3]))
      return s;
  }
  function n(i) {
    var s = dy.decodeUnsafe(i);
    if (s != null)
      return r(s);
  }
  function o(i) {
    var s = dy.decode(i), a = r(s);
    if (a == null)
      throw new Error("Invalid checksum");
    return a;
  }
  return {
    encode: t,
    decode: o,
    decodeUnsafe: n
  };
}
function Bee(e) {
  return en(en(e));
}
var of = Oee(Bee);
var Na = zt;
function Vh(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), ir(
    Sc(
      Nr({
        network: Nr({}),
        address: Ju(),
        hash: QQ,
        output: Kr(25),
        pubkey: bi(ci),
        signature: bi(Zs),
        input: $t
      })
    ),
    e
  );
  const r = Lo(() => {
    const s = of.decode(e.address), a = Ws(s, 0), c = s.slice(1);
    return { version: a, hash: c };
  }), n = Lo(() => cr(e.input)), o = e.network || Ai, i = { name: "p2pkh", network: o };
  if (Ue(i, "address", () => {
    if (!i.hash) return;
    const s = new Uint8Array(21);
    return po(s, 0, o.pubKeyHash), s.set(i.hash, 1), of.encode(s);
  }), Ue(i, "hash", () => {
    if (e.output) return e.output.slice(3, 23);
    if (e.address) return r().hash;
    if (e.pubkey || i.pubkey) return js(e.pubkey || i.pubkey);
  }), Ue(i, "output", () => {
    if (i.hash)
      return Xn([
        Na.OP_DUP,
        Na.OP_HASH160,
        i.hash,
        Na.OP_EQUALVERIFY,
        Na.OP_CHECKSIG
      ]);
  }), Ue(i, "pubkey", () => {
    if (e.input)
      return n()[1];
  }), Ue(i, "signature", () => {
    if (e.input)
      return n()[0];
  }), Ue(i, "input", () => {
    if (e.pubkey && e.signature)
      return Xn([e.signature, e.pubkey]);
  }), Ue(i, "witness", () => {
    if (i.input)
      return [];
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (r().version !== o.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r().hash.length !== 20) throw new TypeError("Invalid address");
      s = r().hash;
    }
    if (e.hash) {
      if (s.length > 0 && de(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 25 || e.output[0] !== Na.OP_DUP || e.output[1] !== Na.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== Na.OP_EQUALVERIFY || e.output[24] !== Na.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const a = e.output.slice(3, 23);
      if (s.length > 0 && de(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.pubkey) {
      const a = js(e.pubkey);
      if (s.length > 0 && de(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.input) {
      const a = n();
      if (a.length !== 2) throw new TypeError("Input is invalid");
      if (!Zs(a[0]))
        throw new TypeError("Input has invalid signature");
      if (!ci(a[1])) throw new TypeError("Input has invalid pubkey");
      if (e.signature && de(e.signature, a[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && de(e.pubkey, a[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const c = js(a[1]);
      if (s.length > 0 && de(s, c) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(i, e);
}
var id = zt;
function Rf(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), ir(
    Sc(
      Nr({
        network: Nr({}),
        address: Ju(),
        hash: Kr(20),
        output: Kr(23),
        redeem: Sc(
          Nr({
            network: Nr({}),
            output: $t,
            input: $t,
            witness: Zn($t)
          })
        ),
        input: $t,
        witness: Zn($t)
      })
    ),
    e
  );
  let r = e.network;
  r || (r = e.redeem && e.redeem.network || Ai);
  const n = { network: r }, o = Lo(() => {
    const a = of.decode(e.address), c = Ws(a, 0), u = a.slice(1);
    return { version: c, hash: u };
  }), i = Lo(() => cr(e.input)), s = Lo(() => {
    const a = i(), c = a[a.length - 1];
    return {
      network: r,
      output: c === id.OP_FALSE ? Uint8Array.from([]) : c,
      input: Xn(a.slice(0, -1)),
      witness: e.witness || []
    };
  });
  if (Ue(n, "address", () => {
    if (!n.hash) return;
    const a = new Uint8Array(21);
    return po(a, 0, n.network.scriptHash), a.set(n.hash, 1), of.encode(a);
  }), Ue(n, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return o().hash;
    if (n.redeem && n.redeem.output) return js(n.redeem.output);
  }), Ue(n, "output", () => {
    if (n.hash)
      return Xn([id.OP_HASH160, n.hash, id.OP_EQUAL]);
  }), Ue(n, "redeem", () => {
    if (e.input)
      return s();
  }), Ue(n, "input", () => {
    if (!(!e.redeem || !e.redeem.input || !e.redeem.output))
      return Xn(
        [].concat(cr(e.redeem.input), e.redeem.output)
      );
  }), Ue(n, "witness", () => {
    if (n.redeem && n.redeem.witness) return n.redeem.witness;
    if (n.input) return [];
  }), Ue(n, "name", () => {
    const a = ["p2sh"];
    return n.redeem !== void 0 && n.redeem.name !== void 0 && a.push(n.redeem.name), a.join("-");
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (o().version !== r.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (o().hash.length !== 20) throw new TypeError("Invalid address");
      a = o().hash;
    }
    if (e.hash) {
      if (a.length > 0 && de(a, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      a = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 23 || e.output[0] !== id.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== id.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const u = e.output.slice(2, 22);
      if (a.length > 0 && de(a, u) !== 0)
        throw new TypeError("Hash mismatch");
      a = u;
    }
    const c = (u) => {
      if (u.output) {
        const l = cr(u.output);
        if (!l || l.length < 1)
          throw new TypeError("Redeem.output too short");
        if (u.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (q_(l) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const f = js(u.output);
        if (a.length > 0 && de(a, f) !== 0)
          throw new TypeError("Hash mismatch");
        a = f;
      }
      if (u.input) {
        const l = u.input.length > 0, f = u.witness && u.witness.length > 0;
        if (!l && !f) throw new TypeError("Empty input");
        if (l && f)
          throw new TypeError("Input and witness provided");
        if (l) {
          const d = cr(u.input);
          if (!D3(d))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (e.input) {
      const u = i();
      if (!u || u.length < 1) throw new TypeError("Input too short");
      if (!(s().output instanceof Uint8Array))
        throw new TypeError("Input is invalid");
      c(s());
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== r)
        throw new TypeError("Network mismatch");
      if (e.input) {
        const u = s();
        if (e.redeem.output && de(e.redeem.output, u.output) !== 0)
          throw new TypeError("Redeem.output mismatch");
        if (e.redeem.input && de(e.redeem.input, u.input) !== 0)
          throw new TypeError("Redeem.input mismatch");
      }
      c(e.redeem);
    }
    if (e.witness && e.redeem && e.redeem.witness && !th(e.redeem.witness, e.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(n, e);
}
var Ye = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Cee(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Nee(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: true }), Object.keys(e).forEach(function(n) {
    var o = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, o.get ? o : {
      enumerable: true,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var rh = {};
Object.defineProperty(rh, "__esModule", { value: true });
var nh = rh.bech32m = mo = rh.bech32 = void 0;
var wg = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var J_ = {};
for (let e = 0; e < wg.length; e++) {
  const t = wg.charAt(e);
  J_[t] = e;
}
function zl(e) {
  const t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059;
}
function C6(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    if (n < 33 || n > 126)
      return "Invalid prefix (" + e + ")";
    t = zl(t) ^ n >> 5;
  }
  t = zl(t);
  for (let r = 0; r < e.length; ++r) {
    const n = e.charCodeAt(r);
    t = zl(t) ^ n & 31;
  }
  return t;
}
function Z3(e, t, r, n) {
  let o = 0, i = 0;
  const s = (1 << r) - 1, a = [];
  for (let c = 0; c < e.length; ++c)
    for (o = o << t | e[c], i += t; i >= r; )
      i -= r, a.push(o >> i & s);
  if (n)
    i > 0 && a.push(o << r - i & s);
  else {
    if (i >= t)
      return "Excess padding";
    if (o << r - i & s)
      return "Non-zero padding";
  }
  return a;
}
function Uee(e) {
  return Z3(e, 8, 5, true);
}
function $ee(e) {
  const t = Z3(e, 5, 8, false);
  if (Array.isArray(t))
    return t;
}
function Ree(e) {
  const t = Z3(e, 5, 8, false);
  if (Array.isArray(t))
    return t;
  throw new Error(t);
}
function Q_(e) {
  let t;
  e === "bech32" ? t = 1 : t = 734539939;
  function r(s, a, c) {
    if (c = c || 90, s.length + 7 + a.length > c)
      throw new TypeError("Exceeds length limit");
    s = s.toLowerCase();
    let u = C6(s);
    if (typeof u == "string")
      throw new Error(u);
    let l = s + "1";
    for (let f = 0; f < a.length; ++f) {
      const d = a[f];
      if (d >> 5)
        throw new Error("Non 5-bit word");
      u = zl(u) ^ d, l += wg.charAt(d);
    }
    for (let f = 0; f < 6; ++f)
      u = zl(u);
    u ^= t;
    for (let f = 0; f < 6; ++f) {
      const d = u >> (5 - f) * 5 & 31;
      l += wg.charAt(d);
    }
    return l;
  }
  function n(s, a) {
    if (a = a || 90, s.length < 8)
      return s + " too short";
    if (s.length > a)
      return "Exceeds length limit";
    const c = s.toLowerCase(), u = s.toUpperCase();
    if (s !== c && s !== u)
      return "Mixed-case string " + s;
    s = c;
    const l = s.lastIndexOf("1");
    if (l === -1)
      return "No separator character for " + s;
    if (l === 0)
      return "Missing prefix for " + s;
    const f = s.slice(0, l), d = s.slice(l + 1);
    if (d.length < 6)
      return "Data too short";
    let m = C6(f);
    if (typeof m == "string")
      return m;
    const y = [];
    for (let b = 0; b < d.length; ++b) {
      const w = d.charAt(b), v = J_[w];
      if (v === void 0)
        return "Unknown character " + w;
      m = zl(m) ^ v, !(b + 6 >= d.length) && y.push(v);
    }
    return m !== t ? "Invalid checksum for " + s : { prefix: f, words: y };
  }
  function o(s, a) {
    const c = n(s, a);
    if (typeof c == "object")
      return c;
  }
  function i(s, a) {
    const c = n(s, a);
    if (typeof c == "object")
      return c;
    throw new Error(c);
  }
  return {
    decodeUnsafe: o,
    decode: i,
    encode: r,
    toWords: Uee,
    fromWordsUnsafe: $ee,
    fromWords: Ree
  };
}
var mo = rh.bech32 = Q_("bech32");
nh = rh.bech32m = Q_("bech32m");
var N6 = zt;
var zee = new Uint8Array(0);
function Gh(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), ir(
    Sc(
      Nr({
        address: Ju(),
        hash: Kr(20),
        input: Kr(0),
        network: Nr({}),
        output: Kr(22),
        pubkey: bi(ci, "Not a valid pubkey"),
        signature: bi(Zs),
        witness: Zn($t)
      })
    ),
    e
  );
  const r = Lo(() => {
    const i = mo.decode(e.address), s = i.words.shift(), a = mo.fromWords(i.words);
    return {
      version: s,
      prefix: i.prefix,
      data: Uint8Array.from(a)
    };
  }), n = e.network || Ai, o = { name: "p2wpkh", network: n };
  if (Ue(o, "address", () => {
    if (!o.hash) return;
    const i = mo.toWords(o.hash);
    return i.unshift(0), mo.encode(n.bech32, i);
  }), Ue(o, "hash", () => {
    if (e.output) return e.output.slice(2, 22);
    if (e.address) return r().data;
    if (e.pubkey || o.pubkey) return js(e.pubkey || o.pubkey);
  }), Ue(o, "output", () => {
    if (o.hash)
      return Xn([N6.OP_0, o.hash]);
  }), Ue(o, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.witness)
      return e.witness[1];
  }), Ue(o, "signature", () => {
    if (e.witness)
      return e.witness[0];
  }), Ue(o, "input", () => {
    if (o.witness)
      return zee;
  }), Ue(o, "witness", () => {
    if (e.pubkey && e.signature)
      return [e.signature, e.pubkey];
  }), t.validate) {
    let i = Uint8Array.from([]);
    if (e.address) {
      if (n && n.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 20)
        throw new TypeError("Invalid address data");
      i = r().data;
    }
    if (e.hash) {
      if (i.length > 0 && de(i, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 22 || e.output[0] !== N6.OP_0 || e.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (i.length > 0 && de(i, e.output.slice(2)) !== 0)
        throw new TypeError("Hash mismatch");
      i = e.output.slice(2);
    }
    if (e.pubkey) {
      const s = js(e.pubkey);
      if (i.length > 0 && de(i, s) !== 0)
        throw new TypeError("Hash mismatch");
      if (i = s, !ci(e.pubkey) || e.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (e.witness) {
      if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!Zs(e.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!ci(e.witness[1]) || e.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (e.signature && de(e.signature, e.witness[0]) !== 0)
        throw new TypeError("Signature mismatch");
      if (e.pubkey && de(e.pubkey, e.witness[1]) !== 0)
        throw new TypeError("Pubkey mismatch");
      const s = js(e.witness[1]);
      if (i.length > 0 && de(i, s) !== 0)
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(o, e);
}
var U6 = zt;
var hy = new Uint8Array(0);
function Fp(e) {
  return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && ci(e));
}
function Wh(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), ir(
    S6({
      network: Nr({}),
      address: Ju(),
      hash: JQ,
      output: Kr(34),
      redeem: S6({
        input: $t,
        network: Nr({}),
        output: $t,
        witness: Zn($t)
      }),
      input: Kr(0),
      witness: Zn($t)
    }),
    e
  );
  const r = Lo(() => {
    const s = mo.decode(e.address), a = s.words.shift(), c = mo.fromWords(s.words);
    return {
      version: a,
      prefix: s.prefix,
      data: Uint8Array.from(c)
    };
  }), n = Lo(() => cr(e.redeem.input));
  let o = e.network;
  o || (o = e.redeem && e.redeem.network || Ai);
  const i = { network: o };
  if (Ue(i, "address", () => {
    if (!i.hash) return;
    const s = mo.toWords(i.hash);
    return s.unshift(0), mo.encode(o.bech32, s);
  }), Ue(i, "hash", () => {
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (i.redeem && i.redeem.output) return en(i.redeem.output);
  }), Ue(i, "output", () => {
    if (i.hash)
      return Xn([U6.OP_0, i.hash]);
  }), Ue(i, "redeem", () => {
    if (e.witness)
      return {
        output: e.witness[e.witness.length - 1],
        input: hy,
        witness: e.witness.slice(0, -1)
      };
  }), Ue(i, "input", () => {
    if (i.witness)
      return hy;
  }), Ue(i, "witness", () => {
    if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
      const s = aee(n());
      return i.redeem = Object.assign({ witness: s }, e.redeem), i.redeem.input = hy, [].concat(s, e.redeem.output);
    }
    if (e.redeem && e.redeem.output && e.redeem.witness)
      return [].concat(e.redeem.witness, e.redeem.output);
  }), Ue(i, "name", () => {
    const s = ["p2wsh"];
    return i.redeem !== void 0 && i.redeem.name !== void 0 && s.push(i.redeem.name), s.join("-");
  }), t.validate) {
    let s = Uint8Array.from([]);
    if (e.address) {
      if (r().prefix !== o.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== 0)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      s = r().data;
    }
    if (e.hash) {
      if (s.length > 0 && de(s, e.hash) !== 0)
        throw new TypeError("Hash mismatch");
      s = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== U6.OP_0 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const a = e.output.slice(2);
      if (s.length > 0 && de(s, a) !== 0)
        throw new TypeError("Hash mismatch");
      s = a;
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== o)
        throw new TypeError("Network mismatch");
      if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (e.redeem.output) {
        const a = cr(e.redeem.output);
        if (!a || a.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (e.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (q_(a) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const c = en(e.redeem.output);
        if (s.length > 0 && de(s, c) !== 0)
          throw new TypeError("Hash mismatch");
        s = c;
      }
      if (e.redeem.input && !D3(n()))
        throw new TypeError("Non push-only scriptSig");
      if (e.witness && e.redeem.witness && !th(e.witness, e.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (e.redeem.input && n().some(Fp) || e.redeem.output && (cr(e.redeem.output) || []).some(
        Fp
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (e.witness && e.witness.length > 0) {
      const a = e.witness[e.witness.length - 1];
      if (e.redeem && e.redeem.output && de(e.redeem.output, a) !== 0)
        throw new TypeError("Witness and redeem.output mismatch");
      if (e.witness.some(Fp) || (cr(a) || []).some(Fp))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(i, e);
}
var _d = {};
function eT(e) {
  e ? e !== _d.eccLib && (Hee(e), _d.eccLib = e) : _d.eccLib = e;
}
function r2() {
  if (!_d.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _d.eccLib;
}
var Es = (e) => ra(e);
function Hee(e) {
  Oo(typeof e.isXOnlyPoint == "function"), Oo(
    e.isXOnlyPoint(
      Es("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), Oo(
    e.isXOnlyPoint(
      Es("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), Oo(
    e.isXOnlyPoint(
      Es("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), Oo(
    e.isXOnlyPoint(
      Es("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), Oo(
    !e.isXOnlyPoint(
      Es("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), Oo(
    !e.isXOnlyPoint(
      Es("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), Oo(typeof e.xOnlyPointAddTweak == "function"), Lee.forEach((t) => {
    const r = e.xOnlyPointAddTweak(Es(t.pubkey), Es(t.tweak));
    t.result === null ? Oo(r === null) : (Oo(r !== null), Oo(r.parity === t.parity), Oo(de(r.xOnlyPubkey, Es(t.result)) === 0));
  });
}
function Oo(e) {
  if (!e) throw new Error("ecc library invalid");
}
var Lee = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var tT = "0123456789abcdefABCDEF";
tT.split("").map((e) => e.codePointAt(0));
var $6 = Array(256).fill(true).map((e, t) => {
  const r = String.fromCodePoint(t), n = tT.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
var rT = new TextEncoder();
new TextDecoder();
function jee(e) {
  return rT.encode(e);
}
function Fee(e) {
  const t = e.reduce((o, i) => o + i.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function Dee(e) {
  const t = rT.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = $6[t[n * 2]], i = $6[t[n * 2 + 1]];
    if (o === void 0 || i === void 0)
      break;
    r[n] = o << 4 | i;
  }
  return n === r.length ? r : r.slice(0, n);
}
function xs(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function R6(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  e[t] = r;
}
function Kee(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function qc(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function Mee(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function qee(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function vl(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function Vee(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
var Gee = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function Wee(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function nT(e) {
  typeof e == "number" ? Wee(e) : Gee(e);
}
function _c(e, t, r) {
  nT(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(Fo(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), Kee(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), qc(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), Mee(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function zf(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = qee(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = vl(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = Vee(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function Fo(e) {
  return nT(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
var Zee = 9007199254740991;
function Xee(e, t) {
  if (typeof e != "number" && typeof e != "bigint")
    throw new Error("cannot write a non-number as a number");
  if (e < 0 && e < BigInt(0))
    throw new Error("specified a negative value for writing an unsigned value");
  if (e > t && e > BigInt(t))
    throw new Error("RangeError: value out of range");
  if (Math.floor(Number(e)) !== Number(e))
    throw new Error("value has a fractional component");
}
function X3(e) {
  if (e.length < 1) return e;
  let t = e.length - 1, r = 0;
  for (let n = 0; n < e.length / 2; n++)
    r = e[n], e[n] = e[t], e[t] = r, t--;
  return e;
}
function z6(e) {
  const t = new Uint8Array(e.length);
  return t.set(e), t;
}
var mn = class _mn {
  constructor(t, r = 0) {
    Ee(this, "buffer"), Ee(this, "offset"), this.buffer = t, this.offset = r, ir(Di([$t, Ps]), [
      t,
      r
    ]);
  }
  static withCapacity(t) {
    return new _mn(new Uint8Array(t));
  }
  writeUInt8(t) {
    this.offset = po(this.buffer, this.offset, t);
  }
  writeInt32(t) {
    this.offset = B_(this.buffer, this.offset, t, "LE");
  }
  writeInt64(t) {
    this.offset = C_(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeUInt32(t) {
    this.offset = qh(this.buffer, this.offset, t, "LE");
  }
  writeUInt64(t) {
    this.offset = FQ(this.buffer, this.offset, BigInt(t), "LE");
  }
  writeVarInt(t) {
    const { bytes: r } = _c(t, this.buffer, this.offset);
    this.offset += r;
  }
  writeSlice(t) {
    if (this.buffer.length < this.offset + t.length)
      throw new Error("Cannot write slice out of bounds");
    this.buffer.set(t, this.offset), this.offset += t.length;
  }
  writeVarSlice(t) {
    this.writeVarInt(t.length), this.writeSlice(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length), t.forEach((r) => this.writeVarSlice(r));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
};
var Yee = class {
  constructor(t, r = 0) {
    Ee(this, "buffer"), Ee(this, "offset"), this.buffer = t, this.offset = r, ir(Di([$t, Ps]), [
      t,
      r
    ]);
  }
  readUInt8() {
    const t = Ws(this.buffer, this.offset);
    return this.offset++, t;
  }
  readInt32() {
    const t = KQ(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readUInt32() {
    const t = Uf(this.buffer, this.offset, "LE");
    return this.offset += 4, t;
  }
  readInt64() {
    const t = N_(this.buffer, this.offset, "LE");
    return this.offset += 8, t;
  }
  readVarInt() {
    const { bigintValue: t, bytes: r } = zf(this.buffer, this.offset);
    return this.offset += r, t;
  }
  readSlice(t) {
    Xee(t, Zee);
    const r = Number(t);
    if (this.buffer.length < this.offset + r)
      throw new Error("Cannot read slice out of bounds");
    const n = this.buffer.slice(this.offset, this.offset + r);
    return this.offset += r, n;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let n = 0; n < t; n++) r.push(this.readVarSlice());
    return r;
  }
};
var oT = 192;
var Jee = 128;
var Qee = (e) => "left" in e && "right" in e;
function n2(e, t) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const r = (e.length - 33) / 32;
  let n = t;
  for (let o = 0; o < r; o++) {
    const i = e.slice(33 + 32 * o, 65 + 32 * o);
    de(n, i) < 0 ? n = i2(n, i) : n = i2(i, n);
  }
  return n;
}
function o2(e) {
  if (F3(e)) return { hash: Rs(e) };
  const t = [o2(e[0]), o2(e[1])];
  t.sort((o, i) => de(o.hash, i.hash));
  const [r, n] = t;
  return {
    hash: i2(r.hash, n.hash),
    left: r,
    right: n
  };
}
function vg(e, t) {
  if (Qee(e)) {
    const r = vg(e.left, t);
    if (r !== void 0) return [...r, e.right.hash];
    const n = vg(e.right, t);
    if (n !== void 0) return [...n, e.left.hash];
  } else if (de(e.hash, t) === 0)
    return [];
}
function Rs(e) {
  const t = e.version || oT;
  return dm(
    "TapLeaf",
    pr([Uint8Array.from([t]), tte(e.output)])
  );
}
function ete(e, t) {
  return dm(
    "TapTweak",
    pr(t ? [e, t] : [e])
  );
}
function Dp(e, t) {
  if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
  const r = ete(e, t), n = r2().xOnlyPointAddTweak(e, r);
  return !n || n.xOnlyPubkey === null ? null : {
    parity: n.parity,
    x: Uint8Array.from(n.xOnlyPubkey)
  };
}
function i2(e, t) {
  return dm("TapBranch", pr([e, t]));
}
function tte(e) {
  const t = Fo(e.length), r = new Uint8Array(t);
  return _c(e.length, r), pr([r, e]);
}
var H6 = zt;
var L6 = 1;
var rte = 80;
function Zh(e, t) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  t = Object.assign({ validate: true }, t || {}), ir(
    Sc(
      Nr({
        address: Ju(),
        input: Kr(0),
        network: Nr({}),
        output: Kr(34),
        internalPubkey: Kr(32),
        hash: Kr(32),
        // merkle root hash, the tweak
        pubkey: Kr(32),
        // tweaked with `hash` from `internalPubkey`
        signature: j3([
          Kr(64),
          Kr(65)
        ]),
        witness: Zn($t),
        scriptTree: bi(F_, "Taptree is not of type isTaptree"),
        redeem: Sc(
          Nr({
            output: $t,
            // tapleaf script
            redeemVersion: Mn(),
            // tapleaf version
            witness: Zn($t)
          })
        ),
        redeemVersion: Mn()
      })
    ),
    e
  );
  const r = Lo(() => Y3(e.address)), n = Lo(() => {
    if (!(!e.witness || !e.witness.length))
      return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === rte ? e.witness.slice(0, -1) : e.witness.slice();
  }), o = Lo(() => {
    if (e.scriptTree) return o2(e.scriptTree);
    if (e.hash) return { hash: e.hash };
  }), i = e.network || Ai, s = { name: "p2tr", network: i };
  if (Ue(s, "address", () => {
    if (!s.pubkey) return;
    const a = nh.toWords(s.pubkey);
    return a.unshift(L6), nh.encode(i.bech32, a);
  }), Ue(s, "hash", () => {
    const a = o();
    if (a) return a.hash;
    const c = n();
    if (c && c.length > 1) {
      const u = c[c.length - 1], l = u[0] & p0, f = c[c.length - 2], d = Rs({ output: f, version: l });
      return n2(u, d);
    }
    return null;
  }), Ue(s, "output", () => {
    if (s.pubkey)
      return Xn([H6.OP_1, s.pubkey]);
  }), Ue(s, "redeemVersion", () => e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : oT), Ue(s, "redeem", () => {
    const a = n();
    if (!(!a || a.length < 2))
      return {
        output: a[a.length - 2],
        witness: a.slice(0, -2),
        redeemVersion: a[a.length - 1][0] & p0
      };
  }), Ue(s, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.output) return e.output.slice(2);
    if (e.address) return r().data;
    if (s.internalPubkey) {
      const a = Dp(s.internalPubkey, s.hash);
      if (a) return a.x;
    }
  }), Ue(s, "internalPubkey", () => {
    if (e.internalPubkey) return e.internalPubkey;
    const a = n();
    if (a && a.length > 1)
      return a[a.length - 1].slice(1, 33);
  }), Ue(s, "signature", () => {
    if (e.signature) return e.signature;
    const a = n();
    if (!(!a || a.length !== 1))
      return a[0];
  }), Ue(s, "witness", () => {
    if (e.witness) return e.witness;
    const a = o();
    if (a && e.redeem && e.redeem.output && e.internalPubkey) {
      const c = Rs({
        output: e.redeem.output,
        version: s.redeemVersion
      }), u = vg(a, c);
      if (!u) return;
      const l = Dp(e.internalPubkey, a.hash);
      if (!l) return;
      const f = pr(
        [
          Uint8Array.from([s.redeemVersion | l.parity]),
          e.internalPubkey
        ].concat(u)
      );
      return [e.redeem.output, f];
    }
    if (e.signature) return [e.signature];
  }), t.validate) {
    let a = Uint8Array.from([]);
    if (e.address) {
      if (i && i.bech32 !== r().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r().version !== L6)
        throw new TypeError("Invalid address version");
      if (r().data.length !== 32)
        throw new TypeError("Invalid address data");
      a = r().data;
    }
    if (e.pubkey) {
      if (a.length > 0 && de(a, e.pubkey) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = e.pubkey;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== H6.OP_1 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      if (a.length > 0 && de(a, e.output.slice(2)) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = e.output.slice(2);
    }
    if (e.internalPubkey) {
      const l = Dp(e.internalPubkey, s.hash);
      if (a.length > 0 && de(a, l.x) !== 0)
        throw new TypeError("Pubkey mismatch");
      a = l.x;
    }
    if (a && a.length && !r2().isXOnlyPoint(a))
      throw new TypeError("Invalid pubkey for p2tr");
    const c = o();
    if (e.hash && c && de(e.hash, c.hash) !== 0)
      throw new TypeError("Hash mismatch");
    if (e.redeem && e.redeem.output && c) {
      const l = Rs({
        output: e.redeem.output,
        version: s.redeemVersion
      });
      if (!vg(c, l))
        throw new TypeError("Redeem script not in tree");
    }
    const u = n();
    if (e.redeem && s.redeem) {
      if (e.redeem.redeemVersion && e.redeem.redeemVersion !== s.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (e.redeem.output) {
        if (cr(e.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (s.redeem.output && de(e.redeem.output, s.redeem.output) !== 0)
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (e.redeem.witness && s.redeem.witness && !th(e.redeem.witness, s.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (u && u.length)
      if (u.length === 1) {
        if (e.signature && de(e.signature, u[0]) !== 0)
          throw new TypeError("Signature mismatch");
      } else {
        const l = u[u.length - 1];
        if (l.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${l.length}, expected min 33.`
          );
        if ((l.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${l.length} is incorrect!`
          );
        const f = (l.length - 33) / 32;
        if (f > 128)
          throw new TypeError(
            `The script path is too long. Got ${f}, expected max 128.`
          );
        const d = l.slice(1, 33);
        if (e.internalPubkey && de(e.internalPubkey, d) !== 0)
          throw new TypeError("Internal pubkey mismatch");
        if (!r2().isXOnlyPoint(d))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const m = l[0] & p0, y = u[u.length - 2], b = Rs({ output: y, version: m }), w = n2(l, b), v = Dp(d, w);
        if (!v)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (a.length && de(a, v.x) !== 0)
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (v.parity !== (l[0] & 1))
          throw new Error("Incorrect parity");
      }
  }
  return Object.assign(s, e);
}
var iT = 40;
var sT = 2;
var aT = 16;
var cT = 2;
var uT = 80;
var lT = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
function nte(e, t) {
  const r = e.slice(2);
  if (r.length < sT || r.length > iT)
    throw new TypeError("Invalid program length for segwit address");
  const n = e[0] - uT;
  if (n < cT || n > aT)
    throw new TypeError("Invalid version for segwit address");
  if (e[1] !== r.length)
    throw new TypeError("Invalid script for segwit address");
  return console.warn(lT), ote(r, n, t.bech32);
}
function fT(e) {
  const t = of.decode(e);
  if (t.length < 21) throw new TypeError(e + " is too short");
  if (t.length > 21) throw new TypeError(e + " is too long");
  const r = Ws(t, 0), n = t.slice(1);
  return { version: r, hash: n };
}
function Y3(e) {
  let t, r;
  try {
    t = mo.decode(e);
  } catch {
  }
  if (t) {
    if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
  } else if (t = nh.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
  const n = mo.fromWords(t.words.slice(1));
  return {
    version: r,
    prefix: t.prefix,
    data: Uint8Array.from(n)
  };
}
function ote(e, t, r) {
  const n = mo.toWords(e);
  return n.unshift(t), t === 0 ? mo.encode(r, n) : nh.encode(r, n);
}
function Xh(e, t) {
  t = t || Ai;
  try {
    return Vh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Rf({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Gh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Wh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return Zh({ output: e, network: t }).address;
  } catch {
  }
  try {
    return nte(e, t);
  } catch {
  }
  throw new Error(see(e) + " has no matching Address");
}
function J3(e, t) {
  t = t || Ai;
  let r, n;
  try {
    r = fT(e);
  } catch {
  }
  if (r) {
    if (r.version === t.pubKeyHash)
      return Vh({ hash: r.hash }).output;
    if (r.version === t.scriptHash)
      return Rf({ hash: r.hash }).output;
  } else {
    try {
      n = Y3(e);
    } catch {
    }
    if (n) {
      if (n.prefix !== t.bech32)
        throw new Error(e + " has an invalid prefix");
      if (n.version === 0) {
        if (n.data.length === 20)
          return Gh({ hash: n.data }).output;
        if (n.data.length === 32)
          return Wh({ hash: n.data }).output;
      } else if (n.version === 1) {
        if (n.data.length === 32)
          return Zh({ pubkey: n.data }).output;
      } else if (n.version >= cT && n.version <= aT && n.data.length >= sT && n.data.length <= iT)
        return console.warn(lT), Xn([
          n.version + uT,
          n.data
        ]);
    }
  }
  throw new Error(e + " has no matching Script");
}
function ji(e) {
  const t = e.length;
  return Fo(t) + t;
}
function ite(e) {
  const t = e.length;
  return Fo(t) + e.reduce((r, n) => r + ji(n), 0);
}
var rc = new Uint8Array(0);
var j6 = [];
var py = ra(
  "0000000000000000000000000000000000000000000000000000000000000000"
);
var F6 = ra(
  "0000000000000000000000000000000000000000000000000000000000000001"
);
var ste = ra("ffffffffffffffff");
var ate = {
  script: rc,
  valueBuffer: ste
};
function cte(e) {
  return e.value !== void 0;
}
var Wo = class Kt {
  constructor() {
    Ee(this, "version", 1), Ee(this, "locktime", 0), Ee(this, "ins", []), Ee(this, "outs", []);
  }
  static fromBuffer(t, r) {
    const n = new Yee(t), o = new Kt();
    o.version = n.readInt32();
    const i = n.readUInt8(), s = n.readUInt8();
    let a = false;
    i === Kt.ADVANCED_TRANSACTION_MARKER && s === Kt.ADVANCED_TRANSACTION_FLAG ? a = true : n.offset -= 2;
    const c = n.readVarInt();
    for (let l = 0; l < c; ++l)
      o.ins.push({
        hash: n.readSlice(32),
        index: n.readUInt32(),
        script: n.readVarSlice(),
        sequence: n.readUInt32(),
        witness: j6
      });
    const u = n.readVarInt();
    for (let l = 0; l < u; ++l)
      o.outs.push({
        value: n.readInt64(),
        script: n.readVarSlice()
      });
    if (a) {
      for (let l = 0; l < c; ++l)
        o.ins[l].witness = n.readVector();
      if (!o.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (o.locktime = n.readUInt32(), r) return o;
    if (n.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return o;
  }
  static fromHex(t) {
    return Kt.fromBuffer(ra(t), false);
  }
  static isCoinbaseHash(t) {
    ir(A6, t);
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0) return false;
    return true;
  }
  isCoinbase() {
    return this.ins.length === 1 && Kt.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(t, r, n, o) {
    return ir(
      Di([
        A6,
        Ps,
        t2(gg(Ps)),
        t2(gg($t))
      ]),
      [t, r, n, o]
    ), n == null && (n = Kt.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: o || rc,
      sequence: n,
      witness: j6
    }) - 1;
  }
  addOutput(t, r) {
    return ir(Di([$t, ly]), [
      t,
      r
    ]), this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(false), r = this.byteLength(true);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = true) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + Fo(this.ins.length) + Fo(this.outs.length) + this.ins.reduce((n, o) => n + 40 + ji(o.script), 0) + this.outs.reduce((n, o) => n + 8 + ji(o.script), 0) + (r ? this.ins.reduce((n, o) => n + ite(o.witness), 0) : 0);
  }
  clone() {
    const t = new Kt();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(t, r, n) {
    if (ir(Di([Ps, $t, Mn()]), [
      t,
      r,
      n
    ]), t >= this.ins.length) return F6;
    const o = Xn(
      cr(r).filter((a) => a !== zt.OP_CODESEPARATOR)
    ), i = this.clone();
    if ((n & 31) === Kt.SIGHASH_NONE)
      i.outs = [], i.ins.forEach((a, c) => {
        c !== t && (a.sequence = 0);
      });
    else if ((n & 31) === Kt.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return F6;
      i.outs.length = t + 1;
      for (let a = 0; a < t; a++)
        i.outs[a] = ate;
      i.ins.forEach((a, c) => {
        c !== t && (a.sequence = 0);
      });
    }
    n & Kt.SIGHASH_ANYONECANPAY ? (i.ins = [i.ins[t]], i.ins[0].script = o) : (i.ins.forEach((a) => {
      a.script = rc;
    }), i.ins[t].script = o);
    const s = new Uint8Array(i.byteLength(false) + 4);
    return B_(s, s.length - 4, n, "LE"), i.__toBuffer(s, 0, false), Kc(s);
  }
  hashForWitnessV1(t, r, n, o, i, s) {
    if (ir(
      Di([
        Ps,
        Zn($t),
        Zn(ly),
        Ps
      ]),
      [t, r, n, o]
    ), n.length !== this.ins.length || r.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const a = o === Kt.SIGHASH_DEFAULT ? Kt.SIGHASH_ALL : o & Kt.SIGHASH_OUTPUT_MASK, c = (o & Kt.SIGHASH_INPUT_MASK) === Kt.SIGHASH_ANYONECANPAY, u = a === Kt.SIGHASH_NONE, l = a === Kt.SIGHASH_SINGLE;
    let f = rc, d = rc, m = rc, y = rc, b = rc;
    if (!c) {
      let x = mn.withCapacity(36 * this.ins.length);
      this.ins.forEach((_) => {
        x.writeSlice(_.hash), x.writeUInt32(_.index);
      }), f = en(x.end()), x = mn.withCapacity(8 * this.ins.length), n.forEach((_) => x.writeInt64(_)), d = en(x.end()), x = mn.withCapacity(
        r.map(ji).reduce((_, I) => _ + I)
      ), r.forEach(
        (_) => x.writeVarSlice(_)
      ), m = en(x.end()), x = mn.withCapacity(4 * this.ins.length), this.ins.forEach((_) => x.writeUInt32(_.sequence)), y = en(x.end());
    }
    if (u || l) {
      if (l && t < this.outs.length) {
        const x = this.outs[t], _ = mn.withCapacity(
          8 + ji(x.script)
        );
        _.writeInt64(x.value), _.writeVarSlice(x.script), b = en(_.end());
      }
    } else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const x = this.outs.map((I) => 8 + ji(I.script)).reduce((I, P) => I + P), _ = mn.withCapacity(x);
      this.outs.forEach((I) => {
        _.writeInt64(I.value), _.writeVarSlice(I.script);
      }), b = en(_.end());
    }
    const w = (i ? 2 : 0) + (s ? 1 : 0), v = 174 - (c ? 49 : 0) - (u ? 32 : 0) + (s ? 32 : 0) + (i ? 37 : 0), k = mn.withCapacity(v);
    if (k.writeUInt8(o), k.writeInt32(this.version), k.writeUInt32(this.locktime), k.writeSlice(f), k.writeSlice(d), k.writeSlice(m), k.writeSlice(y), u || l || k.writeSlice(b), k.writeUInt8(w), c) {
      const x = this.ins[t];
      k.writeSlice(x.hash), k.writeUInt32(x.index), k.writeInt64(n[t]), k.writeVarSlice(r[t]), k.writeUInt32(x.sequence);
    } else
      k.writeUInt32(t);
    if (s) {
      const x = mn.withCapacity(ji(s));
      x.writeVarSlice(s), k.writeSlice(en(x.end()));
    }
    return l && k.writeSlice(b), i && (k.writeSlice(i), k.writeUInt8(0), k.writeUInt32(4294967295)), dm(
      "TapSighash",
      pr([Uint8Array.from([0]), k.end()])
    );
  }
  hashForWitnessV0(t, r, n, o) {
    ir(
      Di([
        Ps,
        $t,
        ly,
        Ps
      ]),
      [t, r, n, o]
    );
    let i = Uint8Array.from([]), s, a = py, c = py, u = py;
    if (o & Kt.SIGHASH_ANYONECANPAY || (i = new Uint8Array(36 * this.ins.length), s = new mn(i, 0), this.ins.forEach((f) => {
      s.writeSlice(f.hash), s.writeUInt32(f.index);
    }), c = Kc(i)), !(o & Kt.SIGHASH_ANYONECANPAY) && (o & 31) !== Kt.SIGHASH_SINGLE && (o & 31) !== Kt.SIGHASH_NONE && (i = new Uint8Array(4 * this.ins.length), s = new mn(i, 0), this.ins.forEach((f) => {
      s.writeUInt32(f.sequence);
    }), u = Kc(i)), (o & 31) !== Kt.SIGHASH_SINGLE && (o & 31) !== Kt.SIGHASH_NONE) {
      const f = this.outs.reduce((d, m) => d + 8 + ji(m.script), 0);
      i = new Uint8Array(f), s = new mn(i, 0), this.outs.forEach((d) => {
        s.writeInt64(d.value), s.writeVarSlice(d.script);
      }), a = Kc(i);
    } else if ((o & 31) === Kt.SIGHASH_SINGLE && t < this.outs.length) {
      const f = this.outs[t];
      i = new Uint8Array(8 + ji(f.script)), s = new mn(i, 0), s.writeInt64(f.value), s.writeVarSlice(f.script), a = Kc(i);
    }
    i = new Uint8Array(156 + ji(r)), s = new mn(i, 0);
    const l = this.ins[t];
    return s.writeInt32(this.version), s.writeSlice(c), s.writeSlice(u), s.writeSlice(l.hash), s.writeUInt32(l.index), s.writeVarSlice(r), s.writeInt64(n), s.writeUInt32(l.sequence), s.writeSlice(a), s.writeUInt32(this.locktime), s.writeUInt32(o), Kc(i);
  }
  getHash(t) {
    return t && this.isCoinbase() ? new Uint8Array(32) : Kc(this.__toBuffer(void 0, void 0, t));
  }
  getId() {
    return De(X3(this.getHash(false)));
  }
  toBuffer(t, r) {
    return this.__toBuffer(t, r, true);
  }
  toHex() {
    return De(this.toBuffer(void 0, void 0));
  }
  setInputScript(t, r) {
    ir(Di([Mn(), $t]), [t, r]), this.ins[t].script = r;
  }
  setWitness(t, r) {
    ir(Di([Mn(), Zn($t)]), [
      t,
      r
    ]), this.ins[t].witness = r;
  }
  __toBuffer(t, r, n = false) {
    t || (t = new Uint8Array(this.byteLength(n)));
    const o = new mn(t, r || 0);
    o.writeInt32(this.version);
    const i = n && this.hasWitnesses();
    return i && (o.writeUInt8(Kt.ADVANCED_TRANSACTION_MARKER), o.writeUInt8(Kt.ADVANCED_TRANSACTION_FLAG)), o.writeVarInt(this.ins.length), this.ins.forEach((s) => {
      o.writeSlice(s.hash), o.writeUInt32(s.index), o.writeVarSlice(s.script), o.writeUInt32(s.sequence);
    }), o.writeVarInt(this.outs.length), this.outs.forEach((s) => {
      cte(s) ? o.writeInt64(s.value) : o.writeSlice(s.valueBuffer), o.writeVarSlice(s.script);
    }), i && this.ins.forEach((s) => {
      o.writeVector(s.witness);
    }), o.writeUInt32(this.locktime), r !== void 0 ? t.slice(r, o.offset) : t;
  }
};
Ee(Wo, "DEFAULT_SEQUENCE", 4294967295), Ee(Wo, "SIGHASH_DEFAULT", 0), Ee(Wo, "SIGHASH_ALL", 1), Ee(Wo, "SIGHASH_NONE", 2), Ee(Wo, "SIGHASH_SINGLE", 3), Ee(Wo, "SIGHASH_ANYONECANPAY", 128), Ee(Wo, "SIGHASH_OUTPUT_MASK", 3), Ee(Wo, "SIGHASH_INPUT_MASK", 128), Ee(Wo, "ADVANCED_TRANSACTION_MARKER", 0), Ee(Wo, "ADVANCED_TRANSACTION_FLAG", 1);
var Ar = Wo;
var Xi;
(function(e) {
  e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(Xi || (Xi = {}));
var ke;
(function(e) {
  e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(ke || (ke = {}));
var kr;
(function(e) {
  e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(kr || (kr = {}));
var ute = (e) => [...Array(e).keys()];
function lte(e) {
  if (e.key[0] !== Xi.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + De(e.key)
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + De(e.key)
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), r = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const n of ute(e.value.length / 4 - 1)) {
    const o = Uf(e.value, n * 4 + 4, "LE"), i = !!(o & 2147483648), s = o & 2147483647;
    r.path += "/" + s.toString(10) + (i ? "'" : "");
  }
  return r;
}
function fte(e) {
  const t = new Uint8Array([Xi.GLOBAL_XPUB]), r = pr([t, e.extendedPubkey]), n = e.path.split("/"), o = new Uint8Array(n.length * 4);
  o.set(e.masterFingerprint, 0);
  let i = 4;
  return n.slice(1).forEach((s) => {
    const a = s.slice(-1) === "'";
    let c = 2147483647 & parseInt(a ? s.slice(0, -1) : s, 10);
    a && (c += 2147483648), qh(o, i, c, "LE"), i += 4;
  }), {
    key: r,
    value: o
  };
}
var dte = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function hte(e) {
  const t = e.extendedPubkey, r = e.masterFingerprint, n = e.path;
  return t instanceof Uint8Array && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && r instanceof Uint8Array && r.length === 4 && typeof n == "string" && !!n.match(/^m(\/\d+'?)*$/);
}
function pte(e, t, r) {
  const n = De(t.extendedPubkey);
  return r.has(n) ? false : (r.add(n), e.filter((o) => de(o.extendedPubkey, t.extendedPubkey)).length === 0);
}
var gte = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: pte,
  check: hte,
  decode: lte,
  encode: fte,
  expected: dte
}, Symbol.toStringTag, { value: "Module" }));
function mte(e) {
  return {
    key: new Uint8Array([Xi.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
var bte = Object.freeze(Object.defineProperty({
  __proto__: null,
  encode: mte
}, Symbol.toStringTag, { value: "Module" }));
function yte(e) {
  if (e.key[0] !== ke.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + De(e.key)
    );
  return e.value;
}
function wte(e) {
  return {
    key: new Uint8Array([ke.FINAL_SCRIPTSIG]),
    value: e
  };
}
var vte = "Uint8Array";
function Ete(e) {
  return e instanceof Uint8Array;
}
function xte(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
var kte = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: xte,
  check: Ete,
  decode: yte,
  encode: wte,
  expected: vte
}, Symbol.toStringTag, { value: "Module" }));
function Ate(e) {
  if (e.key[0] !== ke.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + De(e.key)
    );
  return e.value;
}
function Ste(e) {
  return {
    key: new Uint8Array([ke.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
var _te = "Uint8Array";
function Tte(e) {
  return e instanceof Uint8Array;
}
function Pte(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
var Ite = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Pte,
  check: Tte,
  decode: Ate,
  encode: Ste,
  expected: _te
}, Symbol.toStringTag, { value: "Module" }));
function Ote(e) {
  if (e.key[0] !== ke.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + De(e.key)
    );
  return e.value;
}
function Bte(e) {
  return {
    key: new Uint8Array([ke.NON_WITNESS_UTXO]),
    value: e
  };
}
var Cte = "Uint8Array";
function Nte(e) {
  return e instanceof Uint8Array;
}
function Ute(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
var $te = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Ute,
  check: Nte,
  decode: Ote,
  encode: Bte,
  expected: Cte
}, Symbol.toStringTag, { value: "Module" }));
function Rte(e) {
  if (e.key[0] !== ke.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + De(e.key)
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + De(e.key)
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
function zte(e) {
  const t = new Uint8Array([ke.PARTIAL_SIG]);
  return {
    key: pr([t, e.pubkey]),
    value: e.signature
  };
}
var Hte = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function Lte(e) {
  return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && jte(e.signature);
}
function jte(e) {
  if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return false;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return false;
  const r = e[3 + t + 2];
  return !(r > 33 || r < 1 || e.length !== 3 + t + 2 + r + 2);
}
function Fte(e, t, r) {
  const n = De(t.pubkey);
  return r.has(n) ? false : (r.add(n), e.filter((o) => de(o.pubkey, t.pubkey) === 0).length === 0);
}
var Dte = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: Fte,
  check: Lte,
  decode: Rte,
  encode: zte,
  expected: Hte
}, Symbol.toStringTag, { value: "Module" }));
function Kte(e) {
  if (e.key[0] !== ke.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + De(e.key)
    );
  return $Q(e.value);
}
function Mte(e) {
  return {
    key: new Uint8Array([ke.POR_COMMITMENT]),
    value: RQ(e)
  };
}
var qte = "string";
function Vte(e) {
  return typeof e == "string";
}
function Gte(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
var Wte = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Gte,
  check: Vte,
  decode: Kte,
  encode: Mte,
  expected: qte
}, Symbol.toStringTag, { value: "Module" }));
function Zte(e) {
  if (e.key[0] !== ke.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + De(e.key)
    );
  return Number(Uf(e.value, 0, "LE"));
}
function Xte(e) {
  const t = Uint8Array.from([ke.SIGHASH_TYPE]), r = new Uint8Array(4);
  return qh(r, 0, e, "LE"), {
    key: t,
    value: r
  };
}
var Yte = "number";
function Jte(e) {
  return typeof e == "number";
}
function Qte(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
var ere = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Qte,
  check: Jte,
  decode: Zte,
  encode: Xte,
  expected: Yte
}, Symbol.toStringTag, { value: "Module" }));
function tre(e) {
  if (e.key[0] !== ke.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + De(e.key)
    );
  if (!dT(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
function rre(e) {
  return { key: Uint8Array.from([ke.TAP_KEY_SIG]), value: e };
}
var nre = "Uint8Array";
function dT(e) {
  return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function ore(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
var ire = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: ore,
  check: dT,
  decode: tre,
  encode: rre,
  expected: nre
}, Symbol.toStringTag, { value: "Module" }));
function sre(e) {
  if (e.key[0] !== ke.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + De(e.key)
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + De(e.key)
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + De(e.key)
    );
  const r = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: r, leafVersion: t };
}
function are(e) {
  const t = Uint8Array.from([ke.TAP_LEAF_SCRIPT]), r = Uint8Array.from([e.leafVersion]);
  return {
    key: pr([t, e.controlBlock]),
    value: pr([e.script, r])
  };
}
var cre = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function ure(e) {
  return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function lre(e, t, r) {
  const n = De(t.controlBlock);
  return r.has(n) ? false : (r.add(n), e.filter((o) => de(o.controlBlock, t.controlBlock) === 0).length === 0);
}
var fre = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: lre,
  check: ure,
  decode: sre,
  encode: are,
  expected: cre
}, Symbol.toStringTag, { value: "Module" }));
function dre(e) {
  if (e.key[0] !== ke.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + De(e.key)
    );
  if (!hT(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
function hre(e) {
  return { key: Uint8Array.from([ke.TAP_MERKLE_ROOT]), value: e };
}
var pre = "Uint8Array";
function hT(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function gre(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
var mre = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: gre,
  check: hT,
  decode: dre,
  encode: hre,
  expected: pre
}, Symbol.toStringTag, { value: "Module" }));
function bre(e) {
  if (e.key[0] !== ke.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + De(e.key)
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + De(e.key)
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + De(e.key)
    );
  const t = e.key.slice(1, 33), r = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: r,
    signature: e.value
  };
}
function yre(e) {
  const t = Uint8Array.from([ke.TAP_SCRIPT_SIG]);
  return {
    key: pr([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
var wre = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function vre(e) {
  return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function Ere(e, t, r) {
  const n = De(t.pubkey) + De(t.leafHash);
  return r.has(n) ? false : (r.add(n), e.filter(
    (o) => de(o.pubkey, t.pubkey) === 0 && de(o.leafHash, t.leafHash) === 0
  ).length === 0);
}
var xre = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAddToArray: Ere,
  check: vre,
  decode: bre,
  encode: yre,
  expected: wre
}, Symbol.toStringTag, { value: "Module" }));
function kre(e) {
  if (e.key[0] !== ke.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + De(e.key)
    );
  const t = N_(e.value, 0, "LE");
  let r = 8;
  const { numberValue: n, bytes: o } = zf(
    e.value,
    r
  );
  r += o;
  const i = e.value.slice(r);
  if (i.length !== n)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: i,
    value: t
  };
}
function Are(e) {
  const { script: t, value: r } = e, n = Fo(t.length), o = new Uint8Array(8 + n + t.length);
  return C_(o, 0, BigInt(r), "LE"), _c(t.length, o, 8), o.set(t, 8 + n), {
    key: Uint8Array.from([ke.WITNESS_UTXO]),
    value: o
  };
}
var Sre = "{ script: Uint8Array; value: bigint; }";
function _re(e) {
  return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function Tre(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
var Pre = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Tre,
  check: _re,
  decode: kre,
  encode: Are,
  expected: Sre
}, Symbol.toStringTag, { value: "Module" }));
function Ire(e) {
  if (e.key[0] !== kr.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + De(e.key)
    );
  let t = 0;
  const r = [];
  for (; t < e.value.length; ) {
    const n = e.value[t++], o = e.value[t++], { numberValue: i, bytes: s } = zf(
      e.value,
      t
    );
    t += s, r.push({
      depth: n,
      leafVersion: o,
      script: e.value.slice(t, t + i)
    }), t += i;
  }
  return { leaves: r };
}
function Ore(e) {
  const t = Uint8Array.from([kr.TAP_TREE]), r = [].concat(
    ...e.leaves.map((n) => [
      Uint8Array.of(n.depth, n.leafVersion),
      _c(BigInt(n.script.length)).buffer,
      n.script
    ])
  );
  return {
    key: t,
    value: pr(r)
  };
}
var Bre = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function Cre(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array
  );
}
function Nre(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
var Ure = Object.freeze(Object.defineProperty({
  __proto__: null,
  canAdd: Nre,
  check: Cre,
  decode: Ire,
  encode: Ore,
  expected: Bre
}, Symbol.toStringTag, { value: "Module" }));
var $re = (e) => [...Array(e).keys()];
var Rre = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function Q3(e, t = Rre) {
  function r(a) {
    if (a.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + De(a.key)
      );
    const c = a.key.slice(1);
    if (!t(c))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + De(a.key)
      );
    if (a.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const u = {
      masterFingerprint: a.value.slice(0, 4),
      pubkey: c,
      path: "m"
    };
    for (const l of $re(a.value.length / 4 - 1)) {
      const f = Uf(a.value, l * 4 + 4, "LE"), d = !!(f & 2147483648), m = f & 2147483647;
      u.path += "/" + m.toString(10) + (d ? "'" : "");
    }
    return u;
  }
  function n(a) {
    const c = Uint8Array.from([e]), u = pr([c, a.pubkey]), l = a.path.split("/"), f = new Uint8Array(l.length * 4);
    f.set(a.masterFingerprint, 0);
    let d = 4;
    return l.slice(1).forEach((m) => {
      const y = m.slice(-1) === "'";
      let b = 2147483647 & parseInt(y ? m.slice(0, -1) : m, 10);
      y && (b += 2147483648), qh(f, d, b, "LE"), d += 4;
    }), {
      key: u,
      value: f
    };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function i(a) {
    return a.pubkey instanceof Uint8Array && a.masterFingerprint instanceof Uint8Array && typeof a.path == "string" && t(a.pubkey) && a.masterFingerprint.length === 4;
  }
  function s(a, c, u) {
    const l = De(c.pubkey);
    return u.has(l) ? false : (u.add(l), a.filter((f) => de(f.pubkey, c.pubkey) === 0).length === 0);
  }
  return {
    decode: r,
    encode: n,
    check: i,
    expected: o,
    canAddToArray: s
  };
}
function e8(e) {
  return t;
  function t(r) {
    let n;
    if (e.includes(r.key[0]) && (n = r.key.slice(1), !(n.length === 33 || n.length === 65) || ![2, 3, 4].includes(n[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + De(r.key)
      );
    return n;
  }
}
function pT(e) {
  function t(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + De(s.key)
      );
    return s.value;
  }
  function r(s) {
    return {
      key: Uint8Array.from([e]),
      value: s
    };
  }
  const n = "Uint8Array";
  function o(s) {
    return s instanceof Uint8Array;
  }
  function i(s, a) {
    return !!s && !!a && s.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: i
  };
}
var zre = (e) => e.length === 32;
function gT(e) {
  const t = Q3(e, zre);
  function r(s) {
    const { numberValue: a, bytes: c } = zf(
      s.value
    ), u = t.decode({
      key: s.key,
      value: s.value.slice(c + Number(a) * 32)
    }), l = new Array(Number(a));
    for (let f = 0, d = c; f < a; f++, d += 32)
      l[f] = s.value.slice(d, d + 32);
    return { ...u, leafHashes: l };
  }
  function n(s) {
    const a = t.encode(s), c = Fo(s.leafHashes.length), u = new Uint8Array(c);
    _c(s.leafHashes.length, u);
    const l = pr([u, ...s.leafHashes, a.value]);
    return { ...a, value: l };
  }
  const o = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function i(s) {
    return Array.isArray(s.leafHashes) && s.leafHashes.every(
      (a) => a instanceof Uint8Array && a.length === 32
    ) && t.check(s);
  }
  return {
    decode: r,
    encode: n,
    check: i,
    expected: o,
    canAddToArray: t.canAddToArray
  };
}
function mT(e) {
  function t(s) {
    if (s.key[0] !== e || s.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + De(s.key)
      );
    if (s.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return s.value;
  }
  function r(s) {
    return { key: Uint8Array.from([e]), value: s };
  }
  const n = "Uint8Array";
  function o(s) {
    return s instanceof Uint8Array && s.length === 32;
  }
  function i(s, a) {
    return !!s && !!a && s.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: i
  };
}
function bT(e) {
  function t(s) {
    if (s.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + De(s.key)
      );
    return s.value;
  }
  function r(s) {
    return {
      key: Uint8Array.from([e]),
      value: s
    };
  }
  const n = "Uint8Array";
  function o(s) {
    return s instanceof Uint8Array;
  }
  function i(s, a) {
    return !!s && !!a && s.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: r,
    check: o,
    expected: n,
    canAdd: i
  };
}
var t8 = {
  unsignedTx: bte,
  globalXpub: gte,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: e8([])
};
var Hr = {
  nonWitnessUtxo: $te,
  partialSig: Dte,
  sighashType: ere,
  finalScriptSig: kte,
  finalScriptWitness: Ite,
  porCommitment: Wte,
  witnessUtxo: Pre,
  bip32Derivation: Q3(ke.BIP32_DERIVATION),
  redeemScript: pT(ke.REDEEM_SCRIPT),
  witnessScript: bT(ke.WITNESS_SCRIPT),
  checkPubkey: e8([
    ke.PARTIAL_SIG,
    ke.BIP32_DERIVATION
  ]),
  tapKeySig: ire,
  tapScriptSig: xre,
  tapLeafScript: fre,
  tapBip32Derivation: gT(
    ke.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: mT(ke.TAP_INTERNAL_KEY),
  tapMerkleRoot: mre
};
var Is = {
  bip32Derivation: Q3(kr.BIP32_DERIVATION),
  redeemScript: pT(kr.REDEEM_SCRIPT),
  witnessScript: bT(kr.WITNESS_SCRIPT),
  checkPubkey: e8([kr.BIP32_DERIVATION]),
  tapBip32Derivation: gT(
    kr.TAP_BIP32_DERIVATION
  ),
  tapTree: Ure,
  tapInternalKey: mT(kr.TAP_INTERNAL_KEY)
};
var Hre = Object.freeze(Object.defineProperty({
  __proto__: null,
  globals: t8,
  inputs: Hr,
  outputs: Is
}, Symbol.toStringTag, { value: "Module" }));
var Eg = (e) => [...Array(e).keys()];
function D6(e) {
  const t = e.map(Lre);
  return t.push(Uint8Array.from([0])), pr(t);
}
function Lre(e) {
  const t = e.key.length, r = e.value.length, n = Fo(t), o = Fo(r), i = new Uint8Array(n + t + o + r);
  return _c(t, i, 0), i.set(e.key, n), _c(r, i, n + t), i.set(e.value, n + t + o), i;
}
function jre(e, t) {
  let r = 0;
  function n() {
    const { numberValue: w, bytes: v } = zf(e, r);
    r += v;
    const k = e.slice(r, r + Number(w));
    return r += Number(w), k;
  }
  function o() {
    const w = Uf(e, r, "BE");
    return r += 4, w;
  }
  function i() {
    const w = Ws(e, r);
    return r += 1, w;
  }
  function s() {
    const w = n(), v = n();
    return {
      key: w,
      value: v
    };
  }
  function a() {
    if (r >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const w = Ws(e, r) === 0;
    return w && r++, w;
  }
  if (o() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (i() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const c = [], u = {};
  for (; !a(); ) {
    const w = s(), v = De(w.key);
    if (u[v])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + v
      );
    u[v] = 1, c.push(w);
  }
  const l = c.filter(
    (w) => w.key[0] === Xi.UNSIGNED_TX
  );
  if (l.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const f = t(l[0].value), { inputCount: d, outputCount: m } = f.getInputOutputCounts(), y = [], b = [];
  for (const w of Eg(d)) {
    const v = {}, k = [];
    for (; !a(); ) {
      const x = s(), _ = De(x.key);
      if (v[_])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + w + " key " + _
        );
      v[_] = 1, k.push(x);
    }
    y.push(k);
  }
  for (const w of Eg(m)) {
    const v = {}, k = [];
    for (; !a(); ) {
      const x = s(), _ = De(x.key);
      if (v[_])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + w + " key " + _
        );
      v[_] = 1, k.push(x);
    }
    b.push(k);
  }
  return yT(f, {
    globalMapKeyVals: c,
    inputKeyVals: y,
    outputKeyVals: b
  });
}
function pn(e, t, r) {
  if (de(t, Uint8Array.from([r])))
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${e} key: ${De(t)}`
    );
}
function yT(e, { globalMapKeyVals: t, inputKeyVals: r, outputKeyVals: n }) {
  const o = {
    unsignedTx: e
  };
  let i = 0;
  for (const l of t)
    switch (l.key[0]) {
      case Xi.UNSIGNED_TX:
        if (pn("global", l.key, Xi.UNSIGNED_TX), i > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        i++;
        break;
      case Xi.GLOBAL_XPUB:
        o.globalXpub === void 0 && (o.globalXpub = []), o.globalXpub.push(t8.globalXpub.decode(l));
        break;
      default:
        o.unknownKeyVals || (o.unknownKeyVals = []), o.unknownKeyVals.push(l);
    }
  const s = r.length, a = n.length, c = [], u = [];
  for (const l of Eg(s)) {
    const f = {};
    for (const d of r[l])
      switch (Hr.checkPubkey(d), d.key[0]) {
        case ke.NON_WITNESS_UTXO:
          if (pn("input", d.key, ke.NON_WITNESS_UTXO), f.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          f.nonWitnessUtxo = Hr.nonWitnessUtxo.decode(d);
          break;
        case ke.WITNESS_UTXO:
          if (pn("input", d.key, ke.WITNESS_UTXO), f.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          f.witnessUtxo = Hr.witnessUtxo.decode(d);
          break;
        case ke.PARTIAL_SIG:
          f.partialSig === void 0 && (f.partialSig = []), f.partialSig.push(Hr.partialSig.decode(d));
          break;
        case ke.SIGHASH_TYPE:
          if (pn("input", d.key, ke.SIGHASH_TYPE), f.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          f.sighashType = Hr.sighashType.decode(d);
          break;
        case ke.REDEEM_SCRIPT:
          if (pn("input", d.key, ke.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          f.redeemScript = Hr.redeemScript.decode(d);
          break;
        case ke.WITNESS_SCRIPT:
          if (pn("input", d.key, ke.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          f.witnessScript = Hr.witnessScript.decode(d);
          break;
        case ke.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            Hr.bip32Derivation.decode(d)
          );
          break;
        case ke.FINAL_SCRIPTSIG:
          pn("input", d.key, ke.FINAL_SCRIPTSIG), f.finalScriptSig = Hr.finalScriptSig.decode(d);
          break;
        case ke.FINAL_SCRIPTWITNESS:
          pn("input", d.key, ke.FINAL_SCRIPTWITNESS), f.finalScriptWitness = Hr.finalScriptWitness.decode(
            d
          );
          break;
        case ke.POR_COMMITMENT:
          pn("input", d.key, ke.POR_COMMITMENT), f.porCommitment = Hr.porCommitment.decode(d);
          break;
        case ke.TAP_KEY_SIG:
          pn("input", d.key, ke.TAP_KEY_SIG), f.tapKeySig = Hr.tapKeySig.decode(d);
          break;
        case ke.TAP_SCRIPT_SIG:
          f.tapScriptSig === void 0 && (f.tapScriptSig = []), f.tapScriptSig.push(Hr.tapScriptSig.decode(d));
          break;
        case ke.TAP_LEAF_SCRIPT:
          f.tapLeafScript === void 0 && (f.tapLeafScript = []), f.tapLeafScript.push(Hr.tapLeafScript.decode(d));
          break;
        case ke.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            Hr.tapBip32Derivation.decode(d)
          );
          break;
        case ke.TAP_INTERNAL_KEY:
          pn("input", d.key, ke.TAP_INTERNAL_KEY), f.tapInternalKey = Hr.tapInternalKey.decode(d);
          break;
        case ke.TAP_MERKLE_ROOT:
          pn("input", d.key, ke.TAP_MERKLE_ROOT), f.tapMerkleRoot = Hr.tapMerkleRoot.decode(d);
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(d);
      }
    c.push(f);
  }
  for (const l of Eg(a)) {
    const f = {};
    for (const d of n[l])
      switch (Is.checkPubkey(d), d.key[0]) {
        case kr.REDEEM_SCRIPT:
          if (pn("output", d.key, kr.REDEEM_SCRIPT), f.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          f.redeemScript = Is.redeemScript.decode(d);
          break;
        case kr.WITNESS_SCRIPT:
          if (pn("output", d.key, kr.WITNESS_SCRIPT), f.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          f.witnessScript = Is.witnessScript.decode(d);
          break;
        case kr.BIP32_DERIVATION:
          f.bip32Derivation === void 0 && (f.bip32Derivation = []), f.bip32Derivation.push(
            Is.bip32Derivation.decode(d)
          );
          break;
        case kr.TAP_INTERNAL_KEY:
          pn("output", d.key, kr.TAP_INTERNAL_KEY), f.tapInternalKey = Is.tapInternalKey.decode(d);
          break;
        case kr.TAP_TREE:
          pn("output", d.key, kr.TAP_TREE), f.tapTree = Is.tapTree.decode(d);
          break;
        case kr.TAP_BIP32_DERIVATION:
          f.tapBip32Derivation === void 0 && (f.tapBip32Derivation = []), f.tapBip32Derivation.push(
            Is.tapBip32Derivation.decode(d)
          );
          break;
        default:
          f.unknownKeyVals || (f.unknownKeyVals = []), f.unknownKeyVals.push(d);
      }
    u.push(f);
  }
  return { globalMap: o, inputs: c, outputs: u };
}
function Fre({ globalMap: e, inputs: t, outputs: r }) {
  const { globalKeyVals: n, inputKeyVals: o, outputKeyVals: i } = s2({
    globalMap: e,
    inputs: t,
    outputs: r
  }), s = D6(n), a = (f) => f.length === 0 ? [Uint8Array.from([0])] : f.map(D6), c = a(o), u = a(i), l = new Uint8Array(5);
  return l.set([112, 115, 98, 116, 255], 0), pr(
    [l, s].concat(c, u)
  );
}
var Dre = (e, t) => de(e.key, t.key);
function gy(e, t) {
  const r = /* @__PURE__ */ new Set(), n = Object.entries(e).reduce((i, [s, a]) => {
    if (s === "unknownKeyVals") return i;
    const c = t[s];
    if (c === void 0) return i;
    const u = (Array.isArray(a) ? a : [a]).map(
      c.encode
    );
    return u.map((l) => De(l.key)).forEach((l) => {
      if (r.has(l))
        throw new Error("Serialize Error: Duplicate key: " + l);
      r.add(l);
    }), i.concat(u);
  }, []), o = e.unknownKeyVals ? e.unknownKeyVals.filter((i) => !r.has(De(i.key))) : [];
  return n.concat(o).sort(Dre);
}
function s2({ globalMap: e, inputs: t, outputs: r }) {
  return {
    globalKeyVals: gy(e, t8),
    inputKeyVals: t.map((n) => gy(n, Hr)),
    outputKeyVals: r.map((n) => gy(n, Is))
  };
}
function Kre(e) {
  const t = e[0], r = s2(t), n = e.slice(1);
  if (n.length === 0) throw new Error("Combine: Nothing to combine");
  const o = K6(t);
  if (o === void 0)
    throw new Error("Combine: Self missing transaction");
  const i = hl(r.globalKeyVals), s = r.inputKeyVals.map(hl), a = r.outputKeyVals.map(hl);
  for (const c of n) {
    const u = K6(c);
    if (u === void 0 || de(u.toBuffer(), o.toBuffer()) !== 0)
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const l = s2(c);
    hl(l.globalKeyVals).forEach(
      my(
        i,
        r.globalKeyVals,
        l.globalKeyVals
      )
    ), l.inputKeyVals.map(hl).forEach(
      (f, d) => f.forEach(
        my(
          s[d],
          r.inputKeyVals[d],
          l.inputKeyVals[d]
        )
      )
    ), l.outputKeyVals.map(hl).forEach(
      (f, d) => f.forEach(
        my(
          a[d],
          r.outputKeyVals[d],
          l.outputKeyVals[d]
        )
      )
    );
  }
  return yT(o, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
}
function my(e, t, r) {
  return (n) => {
    if (e.has(n)) return;
    const o = r.filter((i) => De(i.key) === n)[0];
    t.push(o), e.add(n);
  };
}
function K6(e) {
  return e.globalMap.unsignedTx;
}
function hl(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    const n = De(r.key);
    if (t.has(n))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(n);
  }), t;
}
function un(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No input #${t}`);
  return r;
}
function oh(e, t) {
  const r = e[t];
  if (r === void 0) throw new Error(`No output #${t}`);
  return r;
}
function by(e, t, r) {
  if (e.key[0] < r)
    throw new Error(
      "Use the method for your specific key instead of addUnknownKeyVal*"
    );
  if (t && t.filter((n) => de(n.key, e.key) === 0).length !== 0)
    throw new Error(`Duplicate Key: ${De(e.key)}`);
}
function yy(e) {
  let t = 0;
  return Object.keys(e).forEach((r) => {
    Number(isNaN(Number(r))) && t++;
  }), t;
}
function Mre(e, t) {
  let r = false;
  if (t.nonWitnessUtxo || t.witnessUtxo) {
    const n = !!t.redeemScript, o = !!t.witnessScript, i = !n || !!t.finalScriptSig, s = !o || !!t.finalScriptWitness, a = !!t.finalScriptSig || !!t.finalScriptWitness;
    r = i && s && a;
  }
  if (r === false)
    throw new Error(
      `Input #${e} has too much or too little data to clean`
    );
}
function M6(e, t, r, n) {
  throw new Error(
    `Data for ${e} key ${t} is incorrect: Expected ${r} and got ${JSON.stringify(n)}`
  );
}
function r8(e) {
  return (t, r) => {
    for (const n of Object.keys(t)) {
      const o = t[n], { canAdd: i, canAddToArray: s, check: a, expected: c } = (
        // @ts-ignore
        Hre[e + "s"][n] || {}
      ), u = !!s;
      if (a)
        if (u) {
          if (!Array.isArray(o) || // @ts-ignore
          r[n] && !Array.isArray(r[n]))
            throw new Error(`Key type ${n} must be an array`);
          o.every(a) || M6(e, n, c, o);
          const l = r[n] || [], f = /* @__PURE__ */ new Set();
          if (!o.every((d) => s(l, d, f)))
            throw new Error("Can not add duplicate data to array");
          r[n] = l.concat(o);
        } else {
          if (a(o) || M6(e, n, c, o), !i(r, o))
            throw new Error(`Can not add duplicate data to ${e}`);
          r[n] = o;
        }
    }
  };
}
var qre = r8("global");
var wT = r8("input");
var vT = r8("output");
function Vre(e, t) {
  const r = e.length - 1, n = un(e, r);
  wT(t, n);
}
function Gre(e, t) {
  const r = e.length - 1, n = oh(e, r);
  vT(t, n);
}
var q6 = class {
  constructor(e) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: e
    };
  }
  static fromBase64(e, t) {
    const r = O_(e);
    return this.fromBuffer(r, t);
  }
  static fromHex(e, t) {
    const r = ra(e);
    return this.fromBuffer(r, t);
  }
  static fromBuffer(e, t) {
    const r = jre(e, t), n = new this(r.globalMap.unsignedTx);
    return Object.assign(n, r), n;
  }
  toBase64() {
    const e = this.toBuffer();
    return LQ(e);
  }
  toHex() {
    const e = this.toBuffer();
    return De(e);
  }
  toBuffer() {
    return Fre(this);
  }
  updateGlobal(e) {
    return qre(e, this.globalMap), this;
  }
  updateInput(e, t) {
    const r = un(this.inputs, e);
    return wT(t, r), this;
  }
  updateOutput(e, t) {
    const r = oh(this.outputs, e);
    return vT(t, r), this;
  }
  addUnknownKeyValToGlobal(e) {
    return by(
      e,
      this.globalMap.unknownKeyVals,
      yy(Xi)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(e), this;
  }
  addUnknownKeyValToInput(e, t) {
    const r = un(this.inputs, e);
    return by(t, r.unknownKeyVals, yy(ke)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToOutput(e, t) {
    const r = oh(this.outputs, e);
    return by(t, r.unknownKeyVals, yy(kr)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
  }
  addInput(e) {
    this.globalMap.unsignedTx.addInput(e), this.inputs.push({
      unknownKeyVals: []
    });
    const t = e.unknownKeyVals || [], r = this.inputs.length - 1;
    if (!Array.isArray(t))
      throw new Error("unknownKeyVals must be an Array");
    return t.forEach(
      (n) => this.addUnknownKeyValToInput(r, n)
    ), Vre(this.inputs, e), this;
  }
  addOutput(e) {
    this.globalMap.unsignedTx.addOutput(e), this.outputs.push({
      unknownKeyVals: []
    });
    const t = e.unknownKeyVals || [], r = this.outputs.length - 1;
    if (!Array.isArray(t))
      throw new Error("unknownKeyVals must be an Array");
    return t.forEach(
      (n) => this.addUnknownKeyValToOutput(r, n)
    ), Gre(this.outputs, e), this;
  }
  clearFinalizedInput(e) {
    const t = un(this.inputs, e);
    Mre(e, t);
    for (const r of Object.keys(t))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(r) || delete t[r];
    return this;
  }
  combine(...e) {
    const t = Kre([this].concat(e));
    return Object.assign(this, t), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function Qu(e) {
  return (t) => {
    try {
      return e({ output: t }), true;
    } catch {
      return false;
    }
  };
}
var Wre = Qu(lm);
var Zre = Qu(G_);
var Xre = Qu(Vh);
var hm = Qu(Gh);
var V6 = Qu(Wh);
var ET = Qu(Rf);
var xT = Qu(Zh);
function xg(e) {
  let t = new Uint8Array(0);
  function r(s) {
    t = pr([t, s]);
  }
  function n(s) {
    const a = t.length, c = Fo(s);
    t = pr([t, new Uint8Array(c)]), _c(s, t, a);
  }
  function o(s) {
    n(s.length), r(s);
  }
  function i(s) {
    n(s.length), s.forEach(o);
  }
  return i(e), t;
}
function kT(e, t) {
  const r = js(e), n = e.slice(1, 33), o = cr(t);
  if (o === null) throw new Error("Unknown script error");
  return o.findIndex((i) => typeof i == "number" ? false : de(e, i) === 0 || de(r, i) === 0 || de(n, i) === 0);
}
function pm(e, t) {
  return kT(e, t) !== -1;
}
function Yre(e, t) {
  return Jre(e).some(
    (r) => AT(r, Sd.decode, t)
  );
}
function AT(e, t, r) {
  const { hashType: n } = t(e), o = [];
  switch (n & Ar.SIGHASH_ANYONECANPAY && o.push("addInput"), n & 31) {
    case Ar.SIGHASH_ALL:
      break;
    case Ar.SIGHASH_SINGLE:
    case Ar.SIGHASH_NONE:
      o.push("addOutput"), o.push("setInputSequence");
      break;
  }
  return o.indexOf(r) === -1;
}
function Jre(e) {
  let t = [];
  if ((e.partialSig || []).length === 0) {
    if (!e.finalScriptSig && !e.finalScriptWitness) return [];
    t = Qre(e);
  } else
    t = e.partialSig;
  return t.map((r) => r.signature);
}
function Qre(e) {
  const t = e.finalScriptSig ? cr(e.finalScriptSig) || [] : [], r = e.finalScriptWitness ? cr(e.finalScriptWitness) || [] : [];
  return t.concat(r).filter((n) => n instanceof Uint8Array && Zs(n)).map((n) => ({ signature: n }));
}
var Td = (e) => e.length === 32 ? e : e.slice(1, 33);
function G6(e, t, r) {
  const n = hne(
    t,
    e,
    r
  );
  try {
    const o = fne(t, n).concat(n.script).concat(n.controlBlock);
    return { finalScriptWitness: xg(o) };
  } catch (o) {
    throw new Error(`Can not finalize taproot input #${e}: ${o}`);
  }
}
function Kp(e, t) {
  const r = t ? Uint8Array.from([t]) : Uint8Array.from([]);
  return pr([e, r]);
}
function Jo(e) {
  return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && xT(e.witnessUtxo.script));
}
function wy(e, t) {
  return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t);
}
function W6(e, t, r) {
  cne(e, t, r), lne(e, t, r);
}
function Z6(e, t, r) {
  une(e, t, r), ene(e, t);
}
function ene(e, t) {
  if (!t.tapTree && !t.tapInternalKey) return;
  const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
  if (r) {
    const { script: o } = e, i = tne(r, n);
    if (o && de(i, o) !== 0)
      throw new Error("Error adding output. Script or address mismatch.");
  }
}
function tne(e, t) {
  const r = t && rne(t.leaves), { output: n } = Zh({
    internalPubkey: e,
    scriptTree: r
  });
  return n;
}
function rne(e = []) {
  return e.length === 1 && e[0].depth === 0 ? {
    output: e[0].script,
    version: e[0].leafVersion
  } : ane(e);
}
function nne(e, t) {
  return ine(e).some(
    (r) => AT(r, one, t)
  );
}
function one(e) {
  return {
    signature: e.slice(0, 64),
    hashType: e.slice(64)[0] || Ar.SIGHASH_DEFAULT
  };
}
function ine(e) {
  const t = [];
  if (e.tapKeySig && t.push(e.tapKeySig), e.tapScriptSig && t.push(...e.tapScriptSig.map((r) => r.signature)), !t.length) {
    const r = sne(e.finalScriptWitness);
    r && t.push(r);
  }
  return t;
}
function sne(e) {
  if (!e) return;
  const t = e.slice(2);
  if (t.length === 64 || t.length === 65) return t;
}
function ane(e) {
  let t;
  for (const r of e)
    if (t = a2(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
  return t;
}
function a2(e, t, r = 0) {
  if (r > Jee) throw new Error("Max taptree depth exceeded.");
  if (e.depth === r)
    return t ? void 0 : {
      output: e.script,
      version: e.leafVersion
    };
  if (F3(t)) return;
  const n = a2(e, t && t[0], r + 1);
  if (n) return [n, t && t[1]];
  const o = a2(e, t && t[1], r + 1);
  if (o) return [t && t[0], o];
}
function cne(e, t, r) {
  const n = Jo(e) && Hl(t), o = Hl(e) && Jo(t), i = e === t && Jo(t) && Hl(t);
  if (n || o || i)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function une(e, t, r) {
  const n = wy(e) && Hl(t), o = Hl(e) && wy(t), i = e === t && wy(t) && Hl(t);
  if (n || o || i)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function lne(e, t, r) {
  if (t.tapMerkleRoot) {
    const n = (t.tapLeafScript || []).every(
      (i) => vy(i, t.tapMerkleRoot)
    ), o = (e.tapLeafScript || []).every(
      (i) => vy(i, t.tapMerkleRoot)
    );
    if (!n || !o)
      throw new Error(
        `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
      );
  } else if (e.tapMerkleRoot && !(t.tapLeafScript || []).every(
    (n) => vy(n, e.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`
    );
}
function vy(e, t) {
  if (!t) return true;
  const r = Rs({
    output: e.script,
    version: e.leafVersion
  }), n = n2(e.controlBlock, r);
  return de(n, t) === 0;
}
function fne(e, t) {
  const r = Rs({
    output: t.script,
    version: t.leafVersion
  });
  return (e.tapScriptSig || []).filter((n) => de(n.leafHash, r) === 0).map((n) => dne(t.script, n)).sort((n, o) => o.positionInScript - n.positionInScript).map((n) => n.signature);
}
function dne(e, t) {
  return Object.assign(
    {
      positionInScript: kT(t.pubkey, e)
    },
    t
  );
}
function hne(e, t, r) {
  if (!e.tapScriptSig || !e.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${t}. No tapleaf script signature provided.`
    );
  const n = (e.tapLeafScript || []).sort((o, i) => o.controlBlock.length - i.controlBlock.length).find(
    (o) => pne(o, e.tapScriptSig, r)
  );
  if (!n)
    throw new Error(
      `Can not finalize taproot input #${t}. Signature for tapleaf script not found.`
    );
  return n;
}
function pne(e, t, r) {
  const n = Rs({
    output: e.script,
    version: e.leafVersion
  });
  return (!r || de(n, r) === 0) && t.find((o) => de(o.leafHash, n) === 0) !== void 0;
}
function Hl(e) {
  return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
var gne = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: Ai,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
var Xt = class _Xt {
  constructor(t = {}, r = new q6(new ST())) {
    Ee(this, "data"), Ee(this, "__CACHE"), Ee(this, "opts"), this.data = r, this.opts = Object.assign({}, gne, t), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: false
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const n = (o, i, s, a) => Object.defineProperty(o, i, {
      enumerable: s,
      writable: a
    });
    n(this, "__CACHE", false, true), n(this, "opts", false, true);
  }
  static fromBase64(t, r = {}) {
    const n = O_(t);
    return this.fromBuffer(n, r);
  }
  static fromHex(t, r = {}) {
    const n = ra(t);
    return this.fromBuffer(n, r);
  }
  static fromBuffer(t, r = {}) {
    const n = q6.fromBuffer(t, mne), o = new _Xt(r, n);
    return Ene(o.__CACHE.__TX, o.__CACHE), o;
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((t) => ({
      hash: z6(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((t) => {
      let r;
      try {
        r = Xh(t.script, this.opts.network);
      } catch {
      }
      return {
        script: z6(t.script),
        value: t.value,
        address: r
      };
    });
  }
  combine(...t) {
    return this.data.combine(...t.map((r) => r.data)), this;
  }
  clone() {
    const t = _Xt.fromBuffer(this.data.toBuffer());
    return t.opts = JSON.parse(JSON.stringify(this.opts)), t;
  }
  setMaximumFeeRate(t) {
    Mp(t), this.opts.maximumFeeRate = t;
  }
  setVersion(t) {
    Mp(t), sd(this.data.inputs, "setVersion");
    const r = this.__CACHE;
    return r.__TX.version = t, r.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(t) {
    Mp(t), sd(this.data.inputs, "setLocktime");
    const r = this.__CACHE;
    return r.__TX.locktime = t, r.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(t, r) {
    Mp(r), sd(this.data.inputs, "setInputSequence");
    const n = this.__CACHE;
    if (n.__TX.ins.length <= t)
      throw new Error("Input index too high");
    return n.__TX.ins[t].sequence = r, n.__EXTRACTED_TX = void 0, this;
  }
  addInputs(t) {
    return t.forEach((r) => this.addInput(r)), this;
  }
  addInput(t) {
    if (arguments.length > 1 || !t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    W6(t, t, "addInput"), sd(this.data.inputs, "addInput"), t.witnessScript && kg(t.witnessScript);
    const r = this.__CACHE;
    this.data.addInput(t);
    const n = r.__TX.ins[r.__TX.ins.length - 1];
    PT(r, n);
    const o = this.data.inputs.length - 1, i = this.data.inputs[o];
    return i.nonWitnessUtxo && u2(this.__CACHE, i, o), r.__FEE = void 0, r.__FEE_RATE = void 0, r.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(t) {
    return t.forEach((r) => this.addOutput(r)), this;
  }
  addOutput(t) {
    if (arguments.length > 1 || !t || t.value === void 0 || t.address === void 0 && t.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    sd(this.data.inputs, "addOutput");
    const { address: r } = t;
    if (typeof r == "string") {
      const { network: o } = this.opts, i = J3(r, o);
      t = Object.assign({}, t, { script: i });
    }
    Z6(t, t, "addOutput");
    const n = this.__CACHE;
    return this.data.addOutput(t), n.__FEE = void 0, n.__FEE_RATE = void 0, n.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(t) {
    if (!this.data.inputs.every(_T)) throw new Error("Not finalized");
    const r = this.__CACHE;
    if (t || yne(this, r, this.opts), r.__EXTRACTED_TX) return r.__EXTRACTED_TX;
    const n = r.__TX.clone();
    return UT(this.data.inputs, n, r, true), n;
  }
  getFeeRate() {
    return eE(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return eE("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return un(this.data.inputs, 0), ad(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, r) {
    const n = un(this.data.inputs, t);
    return Jo(n) ? this._finalizeTaprootInput(
      t,
      n,
      void 0,
      r
    ) : this._finalizeInput(t, n, r);
  }
  finalizeTaprootInput(t, r, n = G6) {
    const o = un(this.data.inputs, t);
    if (Jo(o))
      return this._finalizeTaprootInput(
        t,
        o,
        r,
        n
      );
    throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
  }
  _finalizeInput(t, r, n = xne) {
    const { script: o, isP2SH: i, isP2WSH: s, isSegwit: a } = _ne(
      t,
      r,
      this.__CACHE
    );
    if (!o) throw new Error(`No script found for input #${t}`);
    wne(r);
    const { finalScriptSig: c, finalScriptWitness: u } = n(
      t,
      r,
      o,
      a,
      i,
      s
    );
    if (c && this.data.updateInput(t, { finalScriptSig: c }), u && this.data.updateInput(t, { finalScriptWitness: u }), !c && !u)
      throw new Error(`Unknown error finalizing input #${t}`);
    return this.data.clearFinalizedInput(t), this;
  }
  _finalizeTaprootInput(t, r, n, o = G6) {
    if (!r.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${t}. Missing withness utxo.`
      );
    if (r.tapKeySig) {
      const i = Zh({
        output: r.witnessUtxo.script,
        signature: r.tapKeySig
      }), s = xg(i.witness);
      this.data.updateInput(t, { finalScriptWitness: s });
    } else {
      const { finalScriptWitness: i } = o(
        t,
        r,
        n
      );
      this.data.updateInput(t, { finalScriptWitness: i });
    }
    return this.data.clearFinalizedInput(t), this;
  }
  getInputType(t) {
    const r = un(this.data.inputs, t), n = $T(t, r, this.__CACHE), o = mm(
      n,
      t,
      "input",
      r.redeemScript || Bne(r.finalScriptSig),
      r.witnessScript || Cne(r.finalScriptWitness)
    ), i = o.type === "raw" ? "" : o.type + "-", s = zT(o.meaningfulScript);
    return i + s;
  }
  inputHasPubkey(t, r) {
    const n = un(this.data.inputs, t);
    return Ine(r, n, t, this.__CACHE);
  }
  inputHasHDKey(t, r) {
    const n = un(this.data.inputs, t), o = Y6(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  outputHasPubkey(t, r) {
    const n = oh(this.data.outputs, t);
    return One(r, n, t, this.__CACHE);
  }
  outputHasHDKey(t, r) {
    const n = oh(this.data.outputs, t), o = Y6(r);
    return !!n.bip32Derivation && n.bip32Derivation.some(o);
  }
  validateSignaturesOfAllInputs(t) {
    return un(this.data.inputs, 0), ad(this.data.inputs.length).map(
      (r) => this.validateSignaturesOfInput(r, t)
    ).reduce((r, n) => n === true && r, true);
  }
  validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t];
    return Jo(o) ? this.validateSignaturesOfTaprootInput(
      t,
      r,
      n
    ) : this._validateSignaturesOfInput(t, r, n);
  }
  _validateSignaturesOfInput(t, r, n) {
    const o = this.data.inputs[t], i = (o || {}).partialSig;
    if (!o || !i || i.length < 1)
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    const s = n ? i.filter((f) => de(f.pubkey, n) === 0) : i;
    if (s.length < 1) throw new Error("No signatures for this pubkey");
    const a = [];
    let c, u, l;
    for (const f of s) {
      const d = Sd.decode(f.signature), { hash: m, script: y } = l !== d.hashType ? OT(
        t,
        Object.assign({}, o, { sighashType: d.hashType }),
        this.__CACHE,
        true
      ) : { hash: c, script: u };
      l = d.hashType, c = m, u = y, TT(f.pubkey, y, "verify"), a.push(r(f.pubkey, m, d.signature));
    }
    return a.every((f) => f === true);
  }
  validateSignaturesOfTaprootInput(t, r, n) {
    const o = this.data.inputs[t], i = (o || {}).tapKeySig, s = (o || {}).tapScriptSig;
    if (!o && !i && !(s && !s.length))
      throw new Error("No signatures to validate");
    if (typeof r != "function")
      throw new Error("Need validator function to validate signatures");
    n = n && Td(n);
    const a = n ? c2(
      t,
      o,
      this.data.inputs,
      n,
      this.__CACHE
    ) : Ane(
      t,
      o,
      this.data.inputs,
      this.__CACHE
    );
    if (!a.length) throw new Error("No signatures for this pubkey");
    const c = a.find((l) => !l.leafHash);
    let u = 0;
    if (i && c) {
      if (!r(
        c.pubkey,
        c.hash,
        rE(i)
      )) return false;
      u++;
    }
    if (s)
      for (const l of s) {
        const f = a.find(
          (d) => de(d.pubkey, l.pubkey) === 0
        );
        if (f) {
          if (!r(
            l.pubkey,
            f.hash,
            rE(l.signature)
          )) return false;
          u++;
        }
      }
    return u > 0;
  }
  signAllInputsHD(t, r = [Ar.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const n = [];
    for (const o of ad(this.data.inputs.length))
      try {
        this.signInputHD(o, t, r), n.push(true);
      } catch {
        n.push(false);
      }
    if (n.every((o) => o === false))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(t, r = [Ar.SIGHASH_ALL]) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey || !t.fingerprint)
        return o(new Error("Need HDSigner to sign input"));
      const i = [], s = [];
      for (const a of ad(this.data.inputs.length))
        s.push(
          this.signInputHDAsync(a, t, r).then(
            () => {
              i.push(true);
            },
            () => {
              i.push(false);
            }
          )
        );
      return Promise.all(s).then(() => {
        if (i.every((a) => a === false))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInputHD(t, r, n = [Ar.SIGHASH_ALL]) {
    if (!r || !r.publicKey || !r.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return nE(t, this.data.inputs, r).forEach((o) => this.signInput(t, o, n)), this;
  }
  signInputHDAsync(t, r, n = [Ar.SIGHASH_ALL]) {
    return new Promise((o, i) => {
      if (!r || !r.publicKey || !r.fingerprint)
        return i(new Error("Need HDSigner to sign input"));
      const s = nE(t, this.data.inputs, r).map(
        (a) => this.signInputAsync(t, a, n)
      );
      return Promise.all(s).then(() => {
        o();
      }).catch(i);
    });
  }
  signAllInputs(t, r) {
    if (!t || !t.publicKey)
      throw new Error("Need Signer to sign input");
    const n = [];
    for (const o of ad(this.data.inputs.length))
      try {
        this.signInput(o, t, r), n.push(true);
      } catch {
        n.push(false);
      }
    if (n.every((o) => o === false))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(t, r) {
    return new Promise((n, o) => {
      if (!t || !t.publicKey)
        return o(new Error("Need Signer to sign input"));
      const i = [], s = [];
      for (const [a] of this.data.inputs.entries())
        s.push(
          this.signInputAsync(a, t, r).then(
            () => {
              i.push(true);
            },
            () => {
              i.push(false);
            }
          )
        );
      return Promise.all(s).then(() => {
        if (i.every((a) => a === false))
          return o(new Error("No inputs were signed"));
        n();
      });
    });
  }
  signInput(t, r, n) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const o = un(this.data.inputs, t);
    return Jo(o) ? this._signTaprootInput(
      t,
      o,
      r,
      void 0,
      n
    ) : this._signInput(t, r, n);
  }
  signTaprootInput(t, r, n, o) {
    if (!r || !r.publicKey)
      throw new Error("Need Signer to sign input");
    const i = un(this.data.inputs, t);
    if (Jo(i))
      return this._signTaprootInput(
        t,
        i,
        r,
        n,
        o
      );
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  _signInput(t, r, n = [Ar.SIGHASH_ALL]) {
    const { hash: o, sighashType: i } = tE(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    ), s = [
      {
        pubkey: r.publicKey,
        signature: Sd.encode(r.sign(o), i)
      }
    ];
    return this.data.updateInput(t, { partialSig: s }), this;
  }
  _signTaprootInput(t, r, n, o, i = [Ar.SIGHASH_DEFAULT]) {
    const s = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      i
    ), a = s.filter((u) => !u.leafHash).map(
      (u) => Kp(
        n.signSchnorr(u.hash),
        r.sighashType
      )
    )[0], c = s.filter((u) => !!u.leafHash).map((u) => ({
      pubkey: Td(n.publicKey),
      signature: Kp(
        n.signSchnorr(u.hash),
        r.sighashType
      ),
      leafHash: u.leafHash
    }));
    return a && this.data.updateInput(t, { tapKeySig: a }), c.length && this.data.updateInput(t, { tapScriptSig: c }), this;
  }
  signInputAsync(t, r, n) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const o = un(this.data.inputs, t);
      return Jo(o) ? this._signTaprootInputAsync(
        t,
        o,
        r,
        void 0,
        n
      ) : this._signInputAsync(t, r, n);
    });
  }
  signTaprootInputAsync(t, r, n, o) {
    return Promise.resolve().then(() => {
      if (!r || !r.publicKey)
        throw new Error("Need Signer to sign input");
      const i = un(this.data.inputs, t);
      if (Jo(i))
        return this._signTaprootInputAsync(
          t,
          i,
          r,
          n,
          o
        );
      throw new Error(`Input #${t} is not of type Taproot.`);
    });
  }
  _signInputAsync(t, r, n = [Ar.SIGHASH_ALL]) {
    const { hash: o, sighashType: i } = tE(
      this.data.inputs,
      t,
      r.publicKey,
      this.__CACHE,
      n
    );
    return Promise.resolve(r.sign(o)).then((s) => {
      const a = [
        {
          pubkey: r.publicKey,
          signature: Sd.encode(s, i)
        }
      ];
      this.data.updateInput(t, { partialSig: a });
    });
  }
  async _signTaprootInputAsync(t, r, n, o, i = [Ar.SIGHASH_DEFAULT]) {
    const s = this.checkTaprootHashesForSig(
      t,
      r,
      n,
      o,
      i
    ), a = [], c = s.filter((l) => !l.leafHash)[0];
    if (c) {
      const l = Promise.resolve(
        n.signSchnorr(c.hash)
      ).then((f) => ({ tapKeySig: Kp(f, r.sighashType) }));
      a.push(l);
    }
    const u = s.filter((l) => !!l.leafHash);
    if (u.length) {
      const l = u.map((f) => Promise.resolve(n.signSchnorr(f.hash)).then(
        (d) => ({ tapScriptSig: [
          {
            pubkey: Td(n.publicKey),
            signature: Kp(
              d,
              r.sighashType
            ),
            leafHash: f.leafHash
          }
        ] })
      ));
      a.push(...l);
    }
    return Promise.all(a).then((l) => {
      l.forEach((f) => this.data.updateInput(t, f));
    });
  }
  checkTaprootHashesForSig(t, r, n, o, i) {
    if (typeof n.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${t}.`
      );
    const s = c2(
      t,
      r,
      this.data.inputs,
      n.publicKey,
      this.__CACHE,
      o,
      i
    );
    if (!s || !s.length)
      throw new Error(
        `Can not sign for input #${t} with the key ${De(n.publicKey)}`
      );
    return s;
  }
  toBuffer() {
    return Ey(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return Ey(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return Ey(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, r) {
    return r.witnessScript && kg(r.witnessScript), W6(
      this.data.inputs[t],
      r,
      "updateInput"
    ), this.data.updateInput(t, r), r.nonWitnessUtxo && u2(
      this.__CACHE,
      this.data.inputs[t],
      t
    ), this;
  }
  updateOutput(t, r) {
    const n = this.data.outputs[t];
    return Z6(n, r, "updateOutput"), this.data.updateOutput(t, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, r) {
    return this.data.addUnknownKeyValToInput(t, r), this;
  }
  addUnknownKeyValToOutput(t, r) {
    return this.data.addUnknownKeyValToOutput(t, r), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
};
var mne = (e) => new ST(e);
var ST = class {
  constructor(t = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    Ee(this, "tx"), this.tx = Ar.fromBuffer(t), vne(this.tx), Object.defineProperty(this, "tx", {
      enumerable: false,
      writable: true
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const r = typeof t.hash == "string" ? X3(ra(t.hash)) : t.hash;
    this.tx.addInput(r, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
};
function bne(e, t, r) {
  switch (r) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return X6(1, e.partialSig);
    case "multisig":
      const n = lm({ output: t });
      return X6(n.m, e.partialSig, n.pubkeys);
    default:
      return false;
  }
}
function Ey(e) {
  if (e.__UNSAFE_SIGN_NONSEGWIT !== false)
    throw new Error("Not BIP174 compliant, can not export");
}
function X6(e, t, r) {
  if (!t) return false;
  let n;
  if (r ? n = r.map((o) => {
    const i = Nne(o);
    return t.find(
      (s) => de(s.pubkey, i) === 0
    );
  }).filter((o) => !!o) : n = t, n.length > e) throw new Error("Too many signatures");
  return n.length === e;
}
function _T(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function Y6(e) {
  return (t) => !(de(e.fingerprint, t.masterFingerprint) || de(e.derivePath(t.path).publicKey, t.pubkey));
}
function Mp(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function yne(e, t, r) {
  const n = t.__FEE_RATE || e.getFeeRate(), o = t.__EXTRACTED_TX.virtualSize(), i = n * o;
  if (n >= r.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(i / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${o} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function sd(e, t) {
  e.forEach((r) => {
    if (Jo(r) ? nne(r, t) : Yre(r, t))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function wne(e) {
  if (!e.sighashType || !e.partialSig) return;
  const { partialSig: t, sighashType: r } = e;
  t.forEach((n) => {
    const { hashType: o } = Sd.decode(n.signature);
    if (r !== o)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function TT(e, t, r) {
  if (!pm(e, t))
    throw new Error(
      `Can not ${r} for this input with the key ${De(e)}`
    );
}
function vne(e) {
  if (!e.ins.every(
    (t) => t.script && t.script.length === 0 && t.witness && t.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function Ene(e, t) {
  e.ins.forEach((r) => {
    PT(t, r);
  });
}
function PT(e, t) {
  const r = De(X3(Uint8Array.from(t.hash))) + ":" + t.index;
  if (e.__TX_IN_CACHE[r]) throw new Error("Duplicate input detected.");
  e.__TX_IN_CACHE[r] = 1;
}
function IT(e, t) {
  return (r, n, o, i) => {
    const s = e({
      redeem: { output: o }
    }).output;
    if (de(n, s))
      throw new Error(
        `${t} for ${i} #${r} doesn't match the scriptPubKey in the prevout`
      );
  };
}
var J6 = IT(Rf, "Redeem script");
var Q6 = IT(
  Wh,
  "Witness script"
);
function eE(e, t, r, n) {
  if (!r.every(_T))
    throw new Error(`PSBT must be finalized to calculate ${t}`);
  if (e === "__FEE_RATE" && n.__FEE_RATE) return n.__FEE_RATE;
  if (e === "__FEE" && n.__FEE) return n.__FEE;
  let o, i = true;
  if (n.__EXTRACTED_TX ? (o = n.__EXTRACTED_TX, i = false) : o = n.__TX.clone(), UT(r, o, n, i), e === "__FEE_RATE") return n.__FEE_RATE;
  if (e === "__FEE") return n.__FEE;
}
function xne(e, t, r, n, o, i) {
  const s = zT(r);
  if (!bne(t, r, s))
    throw new Error(`Can not finalize input #${e}`);
  return kne(
    r,
    s,
    t.partialSig,
    n,
    o,
    i
  );
}
function kne(e, t, r, n, o, i) {
  let s, a;
  const c = Sne(e, t, r), u = i ? Wh({ redeem: c }) : null, l = o ? Rf({ redeem: u || c }) : null;
  return n ? (u ? a = xg(u.witness) : a = xg(c.witness), l && (s = l.input)) : l ? s = l.input : s = c.input, {
    finalScriptSig: s,
    finalScriptWitness: a
  };
}
function tE(e, t, r, n, o) {
  const i = un(e, t), { hash: s, sighashType: a, script: c } = OT(
    t,
    i,
    n,
    false,
    o
  );
  return TT(r, c, "sign"), {
    hash: s,
    sighashType: a
  };
}
function OT(e, t, r, n, o) {
  const i = r.__TX, s = t.sighashType || Ar.SIGHASH_ALL;
  CT(s, o);
  let a, c;
  if (t.nonWitnessUtxo) {
    const f = gm(
      r,
      t,
      e
    ), d = i.ins[e].hash, m = f.getHash();
    if (de(d, m) !== 0)
      throw new Error(
        `Non-witness UTXO hash for input #${e} doesn't match the hash specified in the prevout`
      );
    const y = i.ins[e].index;
    c = f.outs[y];
  } else if (t.witnessUtxo)
    c = t.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: u, type: l } = mm(
    c.script,
    e,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(l) >= 0)
    a = i.hashForWitnessV0(
      e,
      u,
      c.value,
      s
    );
  else if (hm(u)) {
    const f = Vh({
      hash: u.slice(2)
    }).output;
    a = i.hashForWitnessV0(
      e,
      f,
      c.value,
      s
    );
  } else {
    if (t.nonWitnessUtxo === void 0 && r.__UNSAFE_SIGN_NONSEGWIT === false)
      throw new Error(
        `Input #${e} has witnessUtxo but non-segwit script: ${De(u)}`
      );
    !n && r.__UNSAFE_SIGN_NONSEGWIT !== false && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), a = i.hashForSignature(
      e,
      u,
      s
    );
  }
  return {
    script: u,
    sighashType: s,
    hash: a
  };
}
function Ane(e, t, r, n) {
  const o = [];
  if (t.tapInternalKey) {
    const i = BT(e, t, n);
    i && o.push(i);
  }
  if (t.tapScriptSig) {
    const i = t.tapScriptSig.map((s) => s.pubkey);
    o.push(...i);
  }
  return o.map(
    (i) => c2(e, t, r, i, n)
  ).flat();
}
function BT(e, t, r) {
  const { script: n } = n8(e, t, r);
  return xT(n) ? n.subarray(2, 34) : null;
}
function rE(e) {
  return e.length === 64 ? e : e.subarray(0, 64);
}
function c2(e, t, r, n, o, i, s) {
  const a = o.__TX, c = t.sighashType || Ar.SIGHASH_DEFAULT;
  CT(c, s);
  const u = r.map(
    (y, b) => n8(b, y, o)
  ), l = u.map((y) => y.script), f = u.map((y) => y.value), d = [];
  if (t.tapInternalKey && !i) {
    const y = BT(e, t, o) || Uint8Array.from([]);
    if (de(Td(n), y) === 0) {
      const b = a.hashForWitnessV1(
        e,
        l,
        f,
        c
      );
      d.push({ pubkey: n, hash: b });
    }
  }
  const m = (t.tapLeafScript || []).filter((y) => pm(n, y.script)).map((y) => {
    const b = Rs({
      output: y.script,
      version: y.leafVersion
    });
    return Object.assign({ hash: b }, y);
  }).filter(
    (y) => !i || de(i, y.hash) === 0
  ).map((y) => {
    const b = a.hashForWitnessV1(
      e,
      l,
      f,
      c,
      y.hash
    );
    return {
      pubkey: n,
      hash: b,
      leafHash: y.hash
    };
  });
  return d.concat(m);
}
function CT(e, t) {
  if (t && t.indexOf(e) < 0) {
    const r = Pne(e);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${r}`
    );
  }
}
function Sne(e, t, r) {
  let n;
  switch (t) {
    case "multisig":
      const o = Tne(e, r);
      n = lm({
        output: e,
        signatures: o
      });
      break;
    case "pubkey":
      n = G_({
        output: e,
        signature: r[0].signature
      });
      break;
    case "pubkeyhash":
      n = Vh({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
    case "witnesspubkeyhash":
      n = Gh({
        output: e,
        pubkey: r[0].pubkey,
        signature: r[0].signature
      });
      break;
  }
  return n;
}
function _ne(e, t, r) {
  const n = r.__TX, o = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false
  };
  if (o.isP2SH = !!t.redeemScript, o.isP2WSH = !!t.witnessScript, t.witnessScript)
    o.script = t.witnessScript;
  else if (t.redeemScript)
    o.script = t.redeemScript;
  else if (t.nonWitnessUtxo) {
    const i = gm(
      r,
      t,
      e
    ), s = n.ins[e].index;
    o.script = i.outs[s].script;
  } else t.witnessUtxo && (o.script = t.witnessUtxo.script);
  return (t.witnessScript || hm(o.script)) && (o.isSegwit = true), o;
}
function nE(e, t, r) {
  const n = un(t, e);
  if (!n.bip32Derivation || n.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const o = n.bip32Derivation.map((i) => {
    if (de(i.masterFingerprint, r.fingerprint) === 0)
      return i;
  }).filter((i) => !!i);
  if (o.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return o.map((i) => {
    const s = r.derivePath(i.path);
    if (de(i.pubkey, s.publicKey) !== 0)
      throw new Error("pubkey did not match bip32Derivation");
    return s;
  });
}
function Tne(e, t) {
  return lm({ output: e }).pubkeys.map((r) => (t.filter((n) => de(n.pubkey, r) === 0)[0] || {}).signature).filter((r) => !!r);
}
function NT(e) {
  let t = 0;
  function r(s) {
    return t += s, e.slice(t - s, t);
  }
  function n() {
    const s = zf(e, t);
    return t += Fo(s.bigintValue), s.numberValue;
  }
  function o() {
    return r(n());
  }
  function i() {
    const s = n(), a = [];
    for (let c = 0; c < s; c++) a.push(o());
    return a;
  }
  return i();
}
function Pne(e) {
  let t = e & Ar.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case Ar.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case Ar.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case Ar.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function u2(e, t, r) {
  e.__NON_WITNESS_UTXO_BUF_CACHE[r] = t.nonWitnessUtxo;
  const n = Ar.fromBuffer(t.nonWitnessUtxo);
  e.__NON_WITNESS_UTXO_TX_CACHE[r] = n;
  const o = e, i = r;
  delete t.nonWitnessUtxo, Object.defineProperty(t, "nonWitnessUtxo", {
    enumerable: true,
    get() {
      const s = o.__NON_WITNESS_UTXO_BUF_CACHE[i], a = o.__NON_WITNESS_UTXO_TX_CACHE[i];
      if (s !== void 0)
        return s;
      {
        const c = a.toBuffer();
        return o.__NON_WITNESS_UTXO_BUF_CACHE[i] = c, c;
      }
    },
    set(s) {
      o.__NON_WITNESS_UTXO_BUF_CACHE[i] = s;
    }
  });
}
function UT(e, t, r, n) {
  let o = 0n;
  e.forEach((c, u) => {
    if (n && c.finalScriptSig && (t.ins[u].script = c.finalScriptSig), n && c.finalScriptWitness && (t.ins[u].witness = NT(
      c.finalScriptWitness
    )), c.witnessUtxo)
      o += c.witnessUtxo.value;
    else if (c.nonWitnessUtxo) {
      const l = gm(r, c, u), f = t.ins[u].index, d = l.outs[f];
      o += d.value;
    }
  });
  const i = t.outs.reduce((c, u) => c + u.value, 0n), s = o - i;
  if (s < 0)
    throw new Error("Outputs are spending more than Inputs");
  const a = t.virtualSize();
  r.__FEE = s, r.__EXTRACTED_TX = t, r.__FEE_RATE = Math.floor(Number(s / BigInt(a)));
}
function gm(e, t, r) {
  const n = e.__NON_WITNESS_UTXO_TX_CACHE;
  return n[r] || u2(e, t, r), n[r];
}
function $T(e, t, r) {
  const { script: n } = n8(e, t, r);
  return n;
}
function n8(e, t, r) {
  if (t.witnessUtxo !== void 0)
    return {
      script: t.witnessUtxo.script,
      value: t.witnessUtxo.value
    };
  if (t.nonWitnessUtxo !== void 0) {
    const n = gm(
      r,
      t,
      e
    ).outs[r.__TX.ins[e].index];
    return { script: n.script, value: n.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function Ine(e, t, r, n) {
  const o = $T(r, t, n), { meaningfulScript: i } = mm(
    o,
    r,
    "input",
    t.redeemScript,
    t.witnessScript
  );
  return pm(e, i);
}
function One(e, t, r, n) {
  const o = n.__TX.outs[r].script, { meaningfulScript: i } = mm(
    o,
    r,
    "output",
    t.redeemScript,
    t.witnessScript
  );
  return pm(e, i);
}
function Bne(e) {
  if (!e) return;
  const t = cr(e);
  if (!t) return;
  const r = t[t.length - 1];
  if (!(!(r instanceof Uint8Array) || RT(r) || Une(r) || !cr(r)))
    return r;
}
function Cne(e) {
  if (!e) return;
  const t = NT(e), r = t[t.length - 1];
  if (!(RT(r) || !cr(r)))
    return r;
}
function Nne(e) {
  if (e.length === 65) {
    const t = e[64] & 1, r = e.slice(0, 33);
    return r[0] = 2 | t, r;
  }
  return e.slice();
}
function RT(e) {
  return e.length === 33 && cee(e);
}
function Une(e) {
  return Zs(e);
}
function mm(e, t, r, n, o) {
  const i = ET(e), s = i && n && V6(n), a = V6(e);
  if (i && n === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((a || s) && o === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let c;
  return s ? (c = o, J6(t, e, n, r), Q6(t, n, o, r), kg(c)) : a ? (c = o, Q6(t, e, o, r), kg(c)) : i ? (c = n, J6(t, e, n, r)) : c = e, {
    meaningfulScript: c,
    type: s ? "p2sh-p2wsh" : i ? "p2sh" : a ? "p2wsh" : "raw"
  };
}
function kg(e) {
  if (hm(e) || ET(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function zT(e) {
  return hm(e) ? "witnesspubkeyhash" : Xre(e) ? "pubkeyhash" : Wre(e) ? "multisig" : Zre(e) ? "pubkey" : "nonstandard";
}
function ad(e) {
  return [...Array(e).keys()];
}
var HT = class extends W_ {
  constructor(e, t) {
    super(), this.finished = false, this.destroyed = false, lee(e);
    const r = M3(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, o = new Uint8Array(n);
    o.set(r.length > n ? e.create().update(r).digest() : r);
    for (let i = 0; i < o.length; i++)
      o[i] ^= 54;
    this.iHash.update(o), this.oHash = e.create();
    for (let i = 0; i < o.length; i++)
      o[i] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(e) {
    return yg(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    yg(this), fm(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: r, finished: n, destroyed: o, blockLen: i, outputLen: s } = this;
    return e = e, e.finished = n, e.destroyed = o, e.blockLen = i, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var o8 = (e, t, r) => new HT(e, t).update(r).digest();
o8.create = (e, t) => new HT(e, t);
var i8 = BigInt(0);
var bm = BigInt(1);
var $ne = BigInt(2);
function $u(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function Yh(e) {
  if (!$u(e))
    throw new Error("Uint8Array expected");
}
function sf(e, t) {
  if (typeof t != "boolean")
    throw new Error(`${e} must be valid boolean, got "${t}".`);
}
var Rne = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function af(e) {
  Yh(e);
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += Rne[e[r]];
  return t;
}
function Il(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function s8(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
var ks = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function oE(e) {
  if (e >= ks._0 && e <= ks._9)
    return e - ks._0;
  if (e >= ks._A && e <= ks._F)
    return e - (ks._A - 10);
  if (e >= ks._a && e <= ks._f)
    return e - (ks._a - 10);
}
function cf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let o = 0, i = 0; o < r; o++, i += 2) {
    const s = oE(e.charCodeAt(i)), a = oE(e.charCodeAt(i + 1));
    if (s === void 0 || a === void 0) {
      const c = e[i] + e[i + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + i);
    }
    n[o] = s * 16 + a;
  }
  return n;
}
function Eu(e) {
  return s8(af(e));
}
function a8(e) {
  return Yh(e), s8(af(Uint8Array.from(e).reverse()));
}
function uf(e, t) {
  return cf(e.toString(16).padStart(t * 2, "0"));
}
function c8(e, t) {
  return uf(e, t).reverse();
}
function zne(e) {
  return cf(Il(e));
}
function Xo(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = cf(t);
    } catch (i) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${i}`);
    }
  else if ($u(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function ih(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    Yh(o), t += o.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const i = e[n];
    r.set(i, o), o += i.length;
  }
  return r;
}
function Hne(e, t) {
  if (e.length !== t.length)
    return false;
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r |= e[n] ^ t[n];
  return r === 0;
}
function Lne(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
var xy = (e) => typeof e == "bigint" && i8 <= e;
function ym(e, t, r) {
  return xy(e) && xy(t) && xy(r) && t <= e && e < r;
}
function xu(e, t, r, n) {
  if (!ym(t, r, n))
    throw new Error(`expected valid ${e}: ${r} <= n < ${n}, got ${typeof t} ${t}`);
}
function LT(e) {
  let t;
  for (t = 0; e > i8; e >>= bm, t += 1)
    ;
  return t;
}
function jne(e, t) {
  return e >> BigInt(t) & bm;
}
function Fne(e, t, r) {
  return e | (r ? bm : i8) << BigInt(t);
}
var u8 = (e) => ($ne << BigInt(e - 1)) - bm;
var ky = (e) => new Uint8Array(e);
var iE = (e) => Uint8Array.from(e);
function jT(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = ky(e), o = ky(e), i = 0;
  const s = () => {
    n.fill(1), o.fill(0), i = 0;
  }, a = (...l) => r(o, n, ...l), c = (l = ky()) => {
    o = a(iE([0]), l), n = a(), l.length !== 0 && (o = a(iE([1]), l), n = a());
  }, u = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let l = 0;
    const f = [];
    for (; l < t; ) {
      n = a();
      const d = n.slice();
      f.push(d), l += n.length;
    }
    return ih(...f);
  };
  return (l, f) => {
    s(), c(l);
    let d;
    for (; !(d = f(u())); )
      c();
    return s(), d;
  };
}
var Dne = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || $u(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Jh(e, t, r = {}) {
  const n = (o, i, s) => {
    const a = Dne[i];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const c = e[o];
    if (!(s && c === void 0) && !a(c, e))
      throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${i}`);
  };
  for (const [o, i] of Object.entries(t))
    n(o, i, false);
  for (const [o, i] of Object.entries(r))
    n(o, i, true);
  return e;
}
var Kne = () => {
  throw new Error("not implemented");
};
function l2(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const o = t.get(r);
    if (o !== void 0)
      return o;
    const i = e(r, ...n);
    return t.set(r, i), i;
  };
}
var Mne = Object.freeze(Object.defineProperty({
  __proto__: null,
  aInRange: xu,
  abool: sf,
  abytes: Yh,
  bitGet: jne,
  bitLen: LT,
  bitMask: u8,
  bitSet: Fne,
  bytesToHex: af,
  bytesToNumberBE: Eu,
  bytesToNumberLE: a8,
  concatBytes: ih,
  createHmacDrbg: jT,
  ensureBytes: Xo,
  equalBytes: Hne,
  hexToBytes: cf,
  hexToNumber: s8,
  inRange: ym,
  isBytes: $u,
  memoized: l2,
  notImplemented: Kne,
  numberToBytesBE: uf,
  numberToBytesLE: c8,
  numberToHexUnpadded: Il,
  numberToVarBytesBE: zne,
  utf8ToBytes: Lne,
  validateObject: Jh
}, Symbol.toStringTag, { value: "Module" }));
var nn = BigInt(0);
var Tr = BigInt(1);
var ru = BigInt(2);
var qne = BigInt(3);
var f2 = BigInt(4);
var sE = BigInt(5);
var aE = BigInt(8);
BigInt(9);
BigInt(16);
function Pn(e, t) {
  const r = e % t;
  return r >= nn ? r : t + r;
}
function Vne(e, t, r) {
  if (r <= nn || t < nn)
    throw new Error("Expected power/modulo > 0");
  if (r === Tr)
    return nn;
  let n = Tr;
  for (; t > nn; )
    t & Tr && (n = n * e % r), e = e * e % r, t >>= Tr;
  return n;
}
function Bo(e, t, r) {
  let n = e;
  for (; t-- > nn; )
    n *= n, n %= r;
  return n;
}
function d2(e, t) {
  if (e === nn || t <= nn)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Pn(e, t), n = t, o = nn, i = Tr;
  for (; r !== nn; ) {
    const s = n / r, a = n % r, c = o - i * s;
    n = r, r = a, o = i, i = c;
  }
  if (n !== Tr)
    throw new Error("invert: does not exist");
  return Pn(o, t);
}
function Gne(e) {
  const t = (e - Tr) / ru;
  let r, n, o;
  for (r = e - Tr, n = 0; r % ru === nn; r /= ru, n++)
    ;
  for (o = ru; o < e && Vne(o, t, e) !== e - Tr; o++)
    ;
  if (n === 1) {
    const s = (e + Tr) / f2;
    return function(a, c) {
      const u = a.pow(c, s);
      if (!a.eql(a.sqr(u), c))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  const i = (r + Tr) / ru;
  return function(s, a) {
    if (s.pow(a, t) === s.neg(s.ONE))
      throw new Error("Cannot find square root");
    let c = n, u = s.pow(s.mul(s.ONE, o), r), l = s.pow(a, i), f = s.pow(a, r);
    for (; !s.eql(f, s.ONE); ) {
      if (s.eql(f, s.ZERO))
        return s.ZERO;
      let d = 1;
      for (let y = s.sqr(f); d < c && !s.eql(y, s.ONE); d++)
        y = s.sqr(y);
      const m = s.pow(u, Tr << BigInt(c - d - 1));
      u = s.sqr(m), l = s.mul(l, m), f = s.mul(f, u), c = d;
    }
    return l;
  };
}
function Wne(e) {
  if (e % f2 === qne) {
    const t = (e + Tr) / f2;
    return function(r, n) {
      const o = r.pow(n, t);
      if (!r.eql(r.sqr(o), n))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % aE === sE) {
    const t = (e - sE) / aE;
    return function(r, n) {
      const o = r.mul(n, ru), i = r.pow(o, t), s = r.mul(n, i), a = r.mul(r.mul(s, ru), i), c = r.mul(s, r.sub(a, r.ONE));
      if (!r.eql(r.sqr(c), n))
        throw new Error("Cannot find square root");
      return c;
    };
  }
  return Gne(e);
}
var Zne = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Xne(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = Zne.reduce((n, o) => (n[o] = "function", n), t);
  return Jh(e, r);
}
function Yne(e, t, r) {
  if (r < nn)
    throw new Error("Expected power > 0");
  if (r === nn)
    return e.ONE;
  if (r === Tr)
    return t;
  let n = e.ONE, o = t;
  for (; r > nn; )
    r & Tr && (n = e.mul(n, o)), o = e.sqr(o), r >>= Tr;
  return n;
}
function Jne(e, t) {
  const r = new Array(t.length), n = t.reduce((i, s, a) => e.is0(s) ? i : (r[a] = i, e.mul(i, s)), e.ONE), o = e.inv(n);
  return t.reduceRight((i, s, a) => e.is0(s) ? i : (r[a] = e.mul(i, r[a]), e.mul(i, s)), o), r;
}
function FT(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function l8(e, t, r = false, n = {}) {
  if (e <= nn)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: i } = FT(e, t);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = Wne(e), a = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: i,
    MASK: u8(o),
    ZERO: nn,
    ONE: Tr,
    create: (c) => Pn(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return nn <= c && c < e;
    },
    is0: (c) => c === nn,
    isOdd: (c) => (c & Tr) === Tr,
    neg: (c) => Pn(-c, e),
    eql: (c, u) => c === u,
    sqr: (c) => Pn(c * c, e),
    add: (c, u) => Pn(c + u, e),
    sub: (c, u) => Pn(c - u, e),
    mul: (c, u) => Pn(c * u, e),
    pow: (c, u) => Yne(a, c, u),
    div: (c, u) => Pn(c * d2(u, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => d2(c, e),
    sqrt: n.sqrt || ((c) => s(a, c)),
    invertBatch: (c) => Jne(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => r ? c8(c, i) : uf(c, i),
    fromBytes: (c) => {
      if (c.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${c.length}`);
      return r ? a8(c) : Eu(c);
    }
  });
  return Object.freeze(a);
}
function DT(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function KT(e) {
  const t = DT(e);
  return t + Math.ceil(t / 2);
}
function Qne(e, t, r = false) {
  const n = e.length, o = DT(t), i = KT(t);
  if (n < 16 || n < i || n > 1024)
    throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);
  const s = r ? Eu(e) : a8(e), a = Pn(s, t - Tr) + Tr;
  return r ? c8(a, o) : uf(a, o);
}
var eoe = BigInt(0);
var Ay = BigInt(1);
var Sy = /* @__PURE__ */ new WeakMap();
var cE = /* @__PURE__ */ new WeakMap();
function toe(e, t) {
  const r = (i, s) => {
    const a = s.negate();
    return i ? a : s;
  }, n = (i) => {
    if (!Number.isSafeInteger(i) || i <= 0 || i > t)
      throw new Error(`Wrong window size=${i}, should be [1..${t}]`);
  }, o = (i) => {
    n(i);
    const s = Math.ceil(t / i) + 1, a = 2 ** (i - 1);
    return { windows: s, windowSize: a };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(i, s) {
      let a = e.ZERO, c = i;
      for (; s > eoe; )
        s & Ay && (a = a.add(c)), c = c.double(), s >>= Ay;
      return a;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(i, s) {
      const { windows: a, windowSize: c } = o(s), u = [];
      let l = i, f = l;
      for (let d = 0; d < a; d++) {
        f = l, u.push(f);
        for (let m = 1; m < c; m++)
          f = f.add(l), u.push(f);
        l = f.double();
      }
      return u;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(i, s, a) {
      const { windows: c, windowSize: u } = o(i);
      let l = e.ZERO, f = e.BASE;
      const d = BigInt(2 ** i - 1), m = 2 ** i, y = BigInt(i);
      for (let b = 0; b < c; b++) {
        const w = b * u;
        let v = Number(a & d);
        a >>= y, v > u && (v -= m, a += Ay);
        const k = w, x = w + Math.abs(v) - 1, _ = b % 2 !== 0, I = v < 0;
        v === 0 ? f = f.add(r(_, s[k])) : l = l.add(r(I, s[x]));
      }
      return { p: l, f };
    },
    wNAFCached(i, s, a) {
      const c = cE.get(i) || 1;
      let u = Sy.get(i);
      return u || (u = this.precomputeWindow(i, c), c !== 1 && Sy.set(i, a(u))), this.wNAF(c, u, s);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(i, s) {
      n(s), cE.set(i, s), Sy.delete(i);
    }
  };
}
function roe(e, t, r, n) {
  if (!Array.isArray(r) || !Array.isArray(n) || n.length !== r.length)
    throw new Error("arrays of points and scalars must have equal length");
  n.forEach((l, f) => {
    if (!t.isValid(l))
      throw new Error(`wrong scalar at index ${f}`);
  }), r.forEach((l, f) => {
    if (!(l instanceof e))
      throw new Error(`wrong point at index ${f}`);
  });
  const o = LT(BigInt(r.length)), i = o > 12 ? o - 3 : o > 4 ? o - 2 : o ? 2 : 1, s = (1 << i) - 1, a = new Array(s + 1).fill(e.ZERO), c = Math.floor((t.BITS - 1) / i) * i;
  let u = e.ZERO;
  for (let l = c; l >= 0; l -= i) {
    a.fill(e.ZERO);
    for (let d = 0; d < n.length; d++) {
      const m = n[d], y = Number(m >> BigInt(l) & BigInt(s));
      a[y] = a[y].add(r[d]);
    }
    let f = e.ZERO;
    for (let d = a.length - 1, m = e.ZERO; d > 0; d--)
      m = m.add(a[d]), f = f.add(m);
    if (u = u.add(f), l !== 0)
      for (let d = 0; d < i; d++)
        u = u.double();
  }
  return u;
}
function MT(e) {
  return Xne(e.Fp), Jh(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...FT(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
function uE(e) {
  e.lowS !== void 0 && sf("lowS", e.lowS), e.prehash !== void 0 && sf("prehash", e.prehash);
}
function noe(e) {
  const t = MT(e);
  Jh(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
var { bytesToNumberBE: ooe, hexToBytes: ioe } = Mne;
var Cs = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = Cs;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, o = Il(n);
      if (o.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const i = n > 127 ? Il(o.length / 2 | 128) : "";
      return `${Il(e)}${i}${o}${t}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = Cs;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const o = t[n++], i = !!(o & 128);
      let s = 0;
      if (!i)
        s = o;
      else {
        const c = o & 127;
        if (!c)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const u = t.subarray(n, n + c);
        if (u.length !== c)
          throw new r("tlv.decode: length bytes not complete");
        if (u[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const l of u)
          s = s << 8 | l;
        if (n += c, s < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const a = t.subarray(n, n + s);
      if (a.length !== s)
        throw new r("tlv.decode: wrong value length");
      return { v: a, l: t.subarray(n + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = Cs;
      if (e < Us)
        throw new t("integer: negative integers are not allowed");
      let r = Il(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected assertion");
      return r;
    },
    decode(e) {
      const { Err: t } = Cs;
      if (e[0] & 128)
        throw new t("Invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return ooe(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = Cs, o = typeof e == "string" ? ioe(e) : e;
    Yh(o);
    const { v: i, l: s } = n.decode(48, o);
    if (s.length)
      throw new t("Invalid signature: left bytes after parsing");
    const { v: a, l: c } = n.decode(2, i), { v: u, l } = n.decode(2, c);
    if (l.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: r.decode(a), s: r.decode(u) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = Cs, n = `${t.encode(2, r.encode(e.r))}${t.encode(2, r.encode(e.s))}`;
    return t.encode(48, n);
  }
};
var Us = BigInt(0);
var Xr = BigInt(1);
BigInt(2);
var lE = BigInt(3);
BigInt(4);
function soe(e) {
  const t = noe(e), { Fp: r } = t, n = l8(t.n, t.nBitLength), o = t.toBytes || ((b, w, v) => {
    const k = w.toAffine();
    return ih(Uint8Array.from([4]), r.toBytes(k.x), r.toBytes(k.y));
  }), i = t.fromBytes || ((b) => {
    const w = b.subarray(1), v = r.fromBytes(w.subarray(0, r.BYTES)), k = r.fromBytes(w.subarray(r.BYTES, 2 * r.BYTES));
    return { x: v, y: k };
  });
  function s(b) {
    const { a: w, b: v } = t, k = r.sqr(b), x = r.mul(k, b);
    return r.add(r.add(x, r.mul(b, w)), v);
  }
  if (!r.eql(r.sqr(t.Gy), s(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(b) {
    return ym(b, Xr, t.n);
  }
  function c(b) {
    const { allowedPrivateKeyLengths: w, nByteLength: v, wrapPrivateKey: k, n: x } = t;
    if (w && typeof b != "bigint") {
      if ($u(b) && (b = af(b)), typeof b != "string" || !w.includes(b.length))
        throw new Error("Invalid key");
      b = b.padStart(v * 2, "0");
    }
    let _;
    try {
      _ = typeof b == "bigint" ? b : Eu(Xo("private key", b, v));
    } catch {
      throw new Error(`private key must be ${v} bytes, hex or bigint, not ${typeof b}`);
    }
    return k && (_ = Pn(_, x)), xu("private key", _, Xr, x), _;
  }
  function u(b) {
    if (!(b instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  const l = l2((b, w) => {
    const { px: v, py: k, pz: x } = b;
    if (r.eql(x, r.ONE))
      return { x: v, y: k };
    const _ = b.is0();
    w == null && (w = _ ? r.ONE : r.inv(x));
    const I = r.mul(v, w), P = r.mul(k, w), $ = r.mul(x, w);
    if (_)
      return { x: r.ZERO, y: r.ZERO };
    if (!r.eql($, r.ONE))
      throw new Error("invZ was invalid");
    return { x: I, y: P };
  }), f = l2((b) => {
    if (b.is0()) {
      if (t.allowInfinityPoint && !r.is0(b.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: w, y: v } = b.toAffine();
    if (!r.isValid(w) || !r.isValid(v))
      throw new Error("bad point: x or y not FE");
    const k = r.sqr(v), x = s(w);
    if (!r.eql(k, x))
      throw new Error("bad point: equation left != right");
    if (!b.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class d {
    constructor(w, v, k) {
      if (this.px = w, this.py = v, this.pz = k, w == null || !r.isValid(w))
        throw new Error("x required");
      if (v == null || !r.isValid(v))
        throw new Error("y required");
      if (k == null || !r.isValid(k))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(w) {
      const { x: v, y: k } = w || {};
      if (!w || !r.isValid(v) || !r.isValid(k))
        throw new Error("invalid affine point");
      if (w instanceof d)
        throw new Error("projective point not allowed");
      const x = (_) => r.eql(_, r.ZERO);
      return x(v) && x(k) ? d.ZERO : new d(v, k, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(w) {
      const v = r.invertBatch(w.map((k) => k.pz));
      return w.map((k, x) => k.toAffine(v[x])).map(d.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(w) {
      const v = d.fromAffine(i(Xo("pointHex", w)));
      return v.assertValidity(), v;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(w) {
      return d.BASE.multiply(c(w));
    }
    // Multiscalar Multiplication
    static msm(w, v) {
      return roe(d, n, w, v);
    }
    // "Private method", don't use it directly
    _setWindowSize(w) {
      y.setWindowSize(this, w);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      f(this);
    }
    hasEvenY() {
      const { y: w } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(w);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(w) {
      u(w);
      const { px: v, py: k, pz: x } = this, { px: _, py: I, pz: P } = w, $ = r.eql(r.mul(v, P), r.mul(_, x)), L = r.eql(r.mul(k, P), r.mul(I, x));
      return $ && L;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new d(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: w, b: v } = t, k = r.mul(v, lE), { px: x, py: _, pz: I } = this;
      let P = r.ZERO, $ = r.ZERO, L = r.ZERO, V = r.mul(x, x), ee = r.mul(_, _), G = r.mul(I, I), N = r.mul(x, _);
      return N = r.add(N, N), L = r.mul(x, I), L = r.add(L, L), P = r.mul(w, L), $ = r.mul(k, G), $ = r.add(P, $), P = r.sub(ee, $), $ = r.add(ee, $), $ = r.mul(P, $), P = r.mul(N, P), L = r.mul(k, L), G = r.mul(w, G), N = r.sub(V, G), N = r.mul(w, N), N = r.add(N, L), L = r.add(V, V), V = r.add(L, V), V = r.add(V, G), V = r.mul(V, N), $ = r.add($, V), G = r.mul(_, I), G = r.add(G, G), V = r.mul(G, N), P = r.sub(P, V), L = r.mul(G, ee), L = r.add(L, L), L = r.add(L, L), new d(P, $, L);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(w) {
      u(w);
      const { px: v, py: k, pz: x } = this, { px: _, py: I, pz: P } = w;
      let $ = r.ZERO, L = r.ZERO, V = r.ZERO;
      const ee = t.a, G = r.mul(t.b, lE);
      let N = r.mul(v, _), q = r.mul(k, I), j = r.mul(x, P), C = r.add(v, k), U = r.add(_, I);
      C = r.mul(C, U), U = r.add(N, q), C = r.sub(C, U), U = r.add(v, x);
      let M = r.add(_, P);
      return U = r.mul(U, M), M = r.add(N, j), U = r.sub(U, M), M = r.add(k, x), $ = r.add(I, P), M = r.mul(M, $), $ = r.add(q, j), M = r.sub(M, $), V = r.mul(ee, U), $ = r.mul(G, j), V = r.add($, V), $ = r.sub(q, V), V = r.add(q, V), L = r.mul($, V), q = r.add(N, N), q = r.add(q, N), j = r.mul(ee, j), U = r.mul(G, U), q = r.add(q, j), j = r.sub(N, j), j = r.mul(ee, j), U = r.add(U, j), N = r.mul(q, U), L = r.add(L, N), N = r.mul(M, U), $ = r.mul(C, $), $ = r.sub($, N), N = r.mul(C, q), V = r.mul(M, V), V = r.add(V, N), new d($, L, V);
    }
    subtract(w) {
      return this.add(w.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(w) {
      return y.wNAFCached(this, w, d.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(w) {
      xu("scalar", w, Us, t.n);
      const v = d.ZERO;
      if (w === Us)
        return v;
      if (w === Xr)
        return this;
      const { endo: k } = t;
      if (!k)
        return y.unsafeLadder(this, w);
      let { k1neg: x, k1: _, k2neg: I, k2: P } = k.splitScalar(w), $ = v, L = v, V = this;
      for (; _ > Us || P > Us; )
        _ & Xr && ($ = $.add(V)), P & Xr && (L = L.add(V)), V = V.double(), _ >>= Xr, P >>= Xr;
      return x && ($ = $.negate()), I && (L = L.negate()), L = new d(r.mul(L.px, k.beta), L.py, L.pz), $.add(L);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(w) {
      const { endo: v, n: k } = t;
      xu("scalar", w, Xr, k);
      let x, _;
      if (v) {
        const { k1neg: I, k1: P, k2neg: $, k2: L } = v.splitScalar(w);
        let { p: V, f: ee } = this.wNAF(P), { p: G, f: N } = this.wNAF(L);
        V = y.constTimeNegate(I, V), G = y.constTimeNegate($, G), G = new d(r.mul(G.px, v.beta), G.py, G.pz), x = V.add(G), _ = ee.add(N);
      } else {
        const { p: I, f: P } = this.wNAF(w);
        x = I, _ = P;
      }
      return d.normalizeZ([x, _])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(w, v, k) {
      const x = d.BASE, _ = (P, $) => $ === Us || $ === Xr || !P.equals(x) ? P.multiplyUnsafe($) : P.multiply($), I = _(this, v).add(_(w, k));
      return I.is0() ? void 0 : I;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(w) {
      return l(this, w);
    }
    isTorsionFree() {
      const { h: w, isTorsionFree: v } = t;
      if (w === Xr)
        return true;
      if (v)
        return v(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: w, clearCofactor: v } = t;
      return w === Xr ? this : v ? v(d, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(w = true) {
      return sf("isCompressed", w), this.assertValidity(), o(d, this, w);
    }
    toHex(w = true) {
      return sf("isCompressed", w), af(this.toRawBytes(w));
    }
  }
  d.BASE = new d(t.Gx, t.Gy, r.ONE), d.ZERO = new d(r.ZERO, r.ONE, r.ZERO);
  const m = t.nBitLength, y = toe(d, t.endo ? Math.ceil(m / 2) : m);
  return {
    CURVE: t,
    ProjectivePoint: d,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: a
  };
}
function aoe(e) {
  const t = MT(e);
  return Jh(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: true, ...t });
}
function coe(e) {
  const t = aoe(e), { Fp: r, n } = t, o = r.BYTES + 1, i = 2 * r.BYTES + 1;
  function s(j) {
    return Pn(j, n);
  }
  function a(j) {
    return d2(j, n);
  }
  const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: l, isWithinCurveOrder: f } = soe({
    ...t,
    toBytes(j, C, U) {
      const M = C.toAffine(), re = r.toBytes(M.x), te = ih;
      return sf("isCompressed", U), U ? te(Uint8Array.from([C.hasEvenY() ? 2 : 3]), re) : te(Uint8Array.from([4]), re, r.toBytes(M.y));
    },
    fromBytes(j) {
      const C = j.length, U = j[0], M = j.subarray(1);
      if (C === o && (U === 2 || U === 3)) {
        const re = Eu(M);
        if (!ym(re, Xr, r.ORDER))
          throw new Error("Point is not on curve");
        const te = l(re);
        let ie;
        try {
          ie = r.sqrt(te);
        } catch (le) {
          const K = le instanceof Error ? ": " + le.message : "";
          throw new Error("Point is not on curve" + K);
        }
        const ne = (ie & Xr) === Xr;
        return (U & 1) === 1 !== ne && (ie = r.neg(ie)), { x: re, y: ie };
      } else if (C === i && U === 4) {
        const re = r.fromBytes(M.subarray(0, r.BYTES)), te = r.fromBytes(M.subarray(r.BYTES, 2 * r.BYTES));
        return { x: re, y: te };
      } else
        throw new Error(`Point of length ${C} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`);
    }
  }), d = (j) => af(uf(j, t.nByteLength));
  function m(j) {
    const C = n >> Xr;
    return j > C;
  }
  function y(j) {
    return m(j) ? s(-j) : j;
  }
  const b = (j, C, U) => Eu(j.slice(C, U));
  class w {
    constructor(C, U, M) {
      this.r = C, this.s = U, this.recovery = M, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(C) {
      const U = t.nByteLength;
      return C = Xo("compactSignature", C, U * 2), new w(b(C, 0, U), b(C, U, 2 * U));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(C) {
      const { r: U, s: M } = Cs.toSig(Xo("DER", C));
      return new w(U, M);
    }
    assertValidity() {
      xu("r", this.r, Xr, n), xu("s", this.s, Xr, n);
    }
    addRecoveryBit(C) {
      return new w(this.r, this.s, C);
    }
    recoverPublicKey(C) {
      const { r: U, s: M, recovery: re } = this, te = P(Xo("msgHash", C));
      if (re == null || ![0, 1, 2, 3].includes(re))
        throw new Error("recovery id invalid");
      const ie = re === 2 || re === 3 ? U + t.n : U;
      if (ie >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const ne = re & 1 ? "03" : "02", le = c.fromHex(ne + d(ie)), K = a(ie), ve = s(-te * K), At = s(M * K), ze = c.BASE.multiplyAndAddUnsafe(le, ve, At);
      if (!ze)
        throw new Error("point at infinify");
      return ze.assertValidity(), ze;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return m(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new w(this.r, s(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return cf(this.toDERHex());
    }
    toDERHex() {
      return Cs.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return cf(this.toCompactHex());
    }
    toCompactHex() {
      return d(this.r) + d(this.s);
    }
  }
  const v = {
    isValidPrivateKey(j) {
      try {
        return u(j), true;
      } catch {
        return false;
      }
    },
    normPrivateKeyToScalar: u,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const j = KT(t.n);
      return Qne(t.randomBytes(j), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(j = 8, C = c.BASE) {
      return C._setWindowSize(j), C.multiply(BigInt(3)), C;
    }
  };
  function k(j, C = true) {
    return c.fromPrivateKey(j).toRawBytes(C);
  }
  function x(j) {
    const C = $u(j), U = typeof j == "string", M = (C || U) && j.length;
    return C ? M === o || M === i : U ? M === 2 * o || M === 2 * i : j instanceof c;
  }
  function _(j, C, U = true) {
    if (x(j))
      throw new Error("first arg must be private key");
    if (!x(C))
      throw new Error("second arg must be public key");
    return c.fromHex(C).multiply(u(j)).toRawBytes(U);
  }
  const I = t.bits2int || function(j) {
    const C = Eu(j), U = j.length * 8 - t.nBitLength;
    return U > 0 ? C >> BigInt(U) : C;
  }, P = t.bits2int_modN || function(j) {
    return s(I(j));
  }, $ = u8(t.nBitLength);
  function L(j) {
    return xu(`num < 2^${t.nBitLength}`, j, Us, $), uf(j, t.nByteLength);
  }
  function V(j, C, U = ee) {
    if (["recovered", "canonical"].some((et) => et in U))
      throw new Error("sign() legacy options not supported");
    const { hash: M, randomBytes: re } = t;
    let { lowS: te, prehash: ie, extraEntropy: ne } = U;
    te == null && (te = true), j = Xo("msgHash", j), uE(U), ie && (j = Xo("prehashed msgHash", M(j)));
    const le = P(j), K = u(C), ve = [L(K), L(le)];
    if (ne != null && ne !== false) {
      const et = ne === true ? re(r.BYTES) : ne;
      ve.push(Xo("extraEntropy", et));
    }
    const At = ih(...ve), ze = le;
    function St(et) {
      const Ge = I(et);
      if (!f(Ge))
        return;
      const ut = a(Ge), ot = c.BASE.multiply(Ge).toAffine(), He = s(ot.x);
      if (He === Us)
        return;
      const Ae = s(ut * s(ze + He * K));
      if (Ae === Us)
        return;
      let bt = (ot.x === He ? 0 : 2) | Number(ot.y & Xr), wr = Ae;
      return te && m(Ae) && (wr = y(Ae), bt ^= 1), new w(He, wr, bt);
    }
    return { seed: At, k2sig: St };
  }
  const ee = { lowS: t.lowS, prehash: false }, G = { lowS: t.lowS, prehash: false };
  function N(j, C, U = ee) {
    const { seed: M, k2sig: re } = V(j, C, U), te = t;
    return jT(te.hash.outputLen, te.nByteLength, te.hmac)(M, re);
  }
  c.BASE._setWindowSize(8);
  function q(j, C, U, M = G) {
    var re;
    const te = j;
    if (C = Xo("msgHash", C), U = Xo("publicKey", U), "strict" in M)
      throw new Error("options.strict was renamed to lowS");
    uE(M);
    const { lowS: ie, prehash: ne } = M;
    let le, K;
    try {
      if (typeof te == "string" || $u(te))
        try {
          le = w.fromDER(te);
        } catch (ot) {
          if (!(ot instanceof Cs.Err))
            throw ot;
          le = w.fromCompact(te);
        }
      else if (typeof te == "object" && typeof te.r == "bigint" && typeof te.s == "bigint") {
        const { r: ot, s: He } = te;
        le = new w(ot, He);
      } else
        throw new Error("PARSE");
      K = c.fromHex(U);
    } catch (ot) {
      if (ot.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return false;
    }
    if (ie && le.hasHighS())
      return false;
    ne && (C = t.hash(C));
    const { r: ve, s: At } = le, ze = P(C), St = a(At), et = s(ze * St), Ge = s(ve * St), ut = (re = c.BASE.multiplyAndAddUnsafe(K, et, Ge)) == null ? void 0 : re.toAffine();
    return ut ? s(ut.x) === ve : false;
  }
  return {
    CURVE: t,
    getPublicKey: k,
    getSharedSecret: _,
    sign: N,
    verify: q,
    ProjectivePoint: c,
    Signature: w,
    utils: v
  };
}
function uoe(e) {
  return {
    hash: e,
    hmac: (t, ...r) => o8(e, t, hee(...r)),
    randomBytes: pee
  };
}
function loe(e, t) {
  const r = (n) => coe({ ...e, ...uoe(n) });
  return Object.freeze({ ...r(t), create: r });
}
var qT = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var fE = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var foe = BigInt(1);
var h2 = BigInt(2);
var dE = (e, t) => (e + t / h2) / t;
function doe(e) {
  const t = qT, r = BigInt(3), n = BigInt(6), o = BigInt(11), i = BigInt(22), s = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, l = u * u * e % t, f = Bo(l, r, t) * l % t, d = Bo(f, r, t) * l % t, m = Bo(d, h2, t) * u % t, y = Bo(m, o, t) * m % t, b = Bo(y, i, t) * y % t, w = Bo(b, a, t) * b % t, v = Bo(w, c, t) * w % t, k = Bo(v, a, t) * b % t, x = Bo(k, r, t) * l % t, _ = Bo(x, s, t) * y % t, I = Bo(_, n, t) * u % t, P = Bo(I, h2, t);
  if (!p2.eql(p2.sqr(P), e))
    throw new Error("Cannot find square root");
  return P;
}
var p2 = l8(qT, void 0, void 0, { sqrt: doe });
var Ru = loe({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: p2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: fE,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = fE, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -foe * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = r, s = BigInt("0x100000000000000000000000000000000"), a = dE(i * e, t), c = dE(-n * e, t);
      let u = Pn(e - a * r - c * o, t), l = Pn(-a * n - c * i, t);
      const f = u > s, d = l > s;
      if (f && (u = t - u), d && (l = t - l), u > s || l > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: u, k2neg: d, k2: l };
    }
  }
}, en);
BigInt(0);
Ru.ProjectivePoint;
function hoe(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function hE(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function poe(e, t) {
  hoe(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var goe = (e) => e instanceof Uint8Array;
var _y = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Ui = (e, t) => e << 32 - t | e >>> t;
var moe = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!moe)
  throw new Error("Non little-endian hardware is not supported");
function boe(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function VT(e) {
  if (typeof e == "string" && (e = boe(e)), !goe(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
var yoe = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function woe(e) {
  const t = (n) => e().update(VT(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function voe(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var Eoe = class extends yoe {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = _y(this.buffer);
  }
  update(e) {
    hE(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = VT(e);
    const o = e.length;
    for (let i = 0; i < o; ) {
      const s = Math.min(n - this.pos, o - i);
      if (s === n) {
        const a = _y(e);
        for (; n <= o - i; i += n)
          this.process(a, i);
        continue;
      }
      r.set(e.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    hE(this), poe(e, this), this.finished = true;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: i } = this;
    t[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > n - i && (this.process(r, 0), i = 0);
    for (let l = i; l < n; l++)
      t[l] = 0;
    voe(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const s = _y(e), a = this.outputLen;
    if (a % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = a / 4, u = this.get();
    if (c > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < c; l++)
      s.setUint32(4 * l, u[l], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s } = this;
    return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;
  }
};
var xoe = (e, t, r) => e & t ^ ~e & r;
var koe = (e, t, r) => e & t ^ e & r ^ t & r;
var Aoe = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Ua = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var $a = new Uint32Array(64);
var Soe = class extends Eoe {
  constructor() {
    super(64, 32, 8, false), this.A = Ua[0] | 0, this.B = Ua[1] | 0, this.C = Ua[2] | 0, this.D = Ua[3] | 0, this.E = Ua[4] | 0, this.F = Ua[5] | 0, this.G = Ua[6] | 0, this.H = Ua[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a } = this;
    return [e, t, r, n, o, i, s, a];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = i | 0, this.G = s | 0, this.H = a | 0;
  }
  process(e, t) {
    for (let l = 0; l < 16; l++, t += 4)
      $a[l] = e.getUint32(t, false);
    for (let l = 16; l < 64; l++) {
      const f = $a[l - 15], d = $a[l - 2], m = Ui(f, 7) ^ Ui(f, 18) ^ f >>> 3, y = Ui(d, 17) ^ Ui(d, 19) ^ d >>> 10;
      $a[l] = y + $a[l - 7] + m + $a[l - 16] | 0;
    }
    let { A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: u } = this;
    for (let l = 0; l < 64; l++) {
      const f = Ui(s, 6) ^ Ui(s, 11) ^ Ui(s, 25), d = u + f + xoe(s, a, c) + Aoe[l] + $a[l] | 0, m = (Ui(r, 2) ^ Ui(r, 13) ^ Ui(r, 22)) + koe(r, n, o) | 0;
      u = c, c = a, a = s, s = i + d | 0, i = o, o = n, n = r, r = d + m | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, o, i, s, a, c, u);
  }
  roundClean() {
    $a.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var g2 = woe(() => new Soe());
function Qh(...e) {
  const t = (o, i) => (s) => o(i(s)), r = Array.from(e).reverse().reduce((o, i) => o ? t(o, i.encode) : i.encode, void 0), n = e.reduce((o, i) => o ? t(o, i.decode) : i.decode, void 0);
  return { encode: r, decode: n };
}
function wm(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
function vm(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
function GT(e, t = "=") {
  if (typeof t != "string")
    throw new Error("padding chr should be string");
  return {
    encode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let n of r)
        if (typeof n != "string")
          throw new Error(`padding.encode: non-string input=${n}`);
      for (; r.length * e % 8; )
        r.push(t);
      return r;
    },
    decode(r) {
      if (!Array.isArray(r) || r.length && typeof r[0] != "string")
        throw new Error("padding.encode input should be array of strings");
      for (let o of r)
        if (typeof o != "string")
          throw new Error(`padding.decode: non-string input=${o}`);
      let n = r.length;
      if (n * e % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; n > 0 && r[n - 1] === t; n--)
        if (!((n - 1) * e % 8))
          throw new Error("Invalid padding: string has too much padding");
      return r.slice(0, n);
    }
  };
}
function pE(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], i = Array.from(e);
  for (i.forEach((s) => {
    if (s < 0 || s >= t)
      throw new Error(`Wrong integer: ${s}`);
  }); ; ) {
    let s = 0, a = true;
    for (let c = n; c < i.length; c++) {
      const u = i[c], l = t * s + u;
      if (!Number.isSafeInteger(l) || t * s / t !== s || l - u !== t * s)
        throw new Error("convertRadix: carry overflow");
      s = l % r;
      const f = Math.floor(l / r);
      if (i[c] = f, !Number.isSafeInteger(f) || f * r + s !== l)
        throw new Error("convertRadix: carry overflow");
      if (a)
        f ? a = false : n = c;
      else continue;
    }
    if (o.push(s), a)
      break;
  }
  for (let s = 0; s < e.length - 1 && e[s] === 0; s++)
    o.push(0);
  return o.reverse();
}
var WT = (e, t) => t ? WT(t, e % t) : e;
var Ag = (e, t) => e + (t - WT(e, t));
function m2(e, t, r, n) {
  if (!Array.isArray(e))
    throw new Error("convertRadix2: data should be array");
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong to=${r}`);
  if (Ag(t, r) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${Ag(t, r)}`);
  let o = 0, i = 0;
  const s = 2 ** r - 1, a = [];
  for (const c of e) {
    if (c >= 2 ** t)
      throw new Error(`convertRadix2: invalid data word=${c} from=${t}`);
    if (o = o << t | c, i + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${i} from=${t}`);
    for (i += t; i >= r; i -= r)
      a.push((o >> i - r & s) >>> 0);
    o &= 2 ** i - 1;
  }
  if (o = o << r - i & s, !n && i >= t)
    throw new Error("Excess padding");
  if (!n && o)
    throw new Error(`Non-zero padding: ${o}`);
  return n && i > 0 && a.push(o >>> 0), a;
}
function _oe(e) {
  return {
    encode: (t) => {
      if (!(t instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return pE(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(pE(t, e, 2 ** 8));
    }
  };
}
function f8(e, t = false) {
  if (e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (Ag(8, e) > 32 || Ag(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (r) => {
      if (!(r instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return m2(Array.from(r), 8, e, !t);
    },
    decode: (r) => {
      if (!Array.isArray(r) || r.length && typeof r[0] != "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(m2(r, e, 8, t));
    }
  };
}
function gE(e) {
  if (typeof e != "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
function Toe(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!(r instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), i = r.slice(-e);
      for (let s = 0; s < e; s++)
        if (o[s] !== i[s])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
var mE = Qh(f8(6), wm("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), GT(6), vm(""));
var bE = Qh(f8(6), wm("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), GT(6), vm(""));
var Poe = (e) => Qh(_oe(58), wm(e), vm(""));
var Ioe = Poe("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var yE = (e) => Qh(Toe(4, (t) => e(e(t))), Ioe);
var b2 = Qh(wm("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), vm(""));
var wE = [996825010, 642813549, 513874426, 1027748829, 705979059];
function cd(e) {
  const t = e >> 25;
  let r = (e & 33554431) << 5;
  for (let n = 0; n < wE.length; n++)
    (t >> n & 1) === 1 && (r ^= wE[n]);
  return r;
}
function vE(e, t, r = 1) {
  const n = e.length;
  let o = 1;
  for (let i = 0; i < n; i++) {
    const s = e.charCodeAt(i);
    if (s < 33 || s > 126)
      throw new Error(`Invalid prefix (${e})`);
    o = cd(o) ^ s >> 5;
  }
  o = cd(o);
  for (let i = 0; i < n; i++)
    o = cd(o) ^ e.charCodeAt(i) & 31;
  for (let i of t)
    o = cd(o) ^ i;
  for (let i = 0; i < 6; i++)
    o = cd(o);
  return o ^= r, b2.encode(m2([o % 2 ** 30], 30, 5, false));
}
function ZT(e) {
  const t = e === "bech32" ? 1 : 734539939, r = f8(5), n = r.decode, o = r.encode, i = gE(n);
  function s(l, f, d = 90) {
    if (typeof l != "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof l}`);
    if (!Array.isArray(f) || f.length && typeof f[0] != "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof f}`);
    const m = l.length + 7 + f.length;
    if (d !== false && m > d)
      throw new TypeError(`Length ${m} exceeds limit ${d}`);
    const y = l.toLowerCase(), b = vE(y, f, t);
    return `${y}1${b2.encode(f)}${b}`;
  }
  function a(l, f = 90) {
    if (typeof l != "string")
      throw new Error(`bech32.decode input should be string, not ${typeof l}`);
    if (l.length < 8 || f !== false && l.length > f)
      throw new TypeError(`Wrong string length: ${l.length} (${l}). Expected (8..${f})`);
    const d = l.toLowerCase();
    if (l !== d && l !== l.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    l = d;
    const m = l.lastIndexOf("1");
    if (m === 0 || m === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const y = l.slice(0, m), b = l.slice(m + 1);
    if (b.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const w = b2.decode(b).slice(0, -6), v = vE(y, w, t);
    if (!b.endsWith(v))
      throw new Error(`Invalid checksum in ${l}: expected "${v}"`);
    return { prefix: y, words: w };
  }
  const c = gE(a);
  function u(l) {
    const { prefix: f, words: d } = a(l, false);
    return { prefix: f, words: d, bytes: n(d) };
  }
  return { encode: s, decode: a, decodeToBytes: u, decodeUnsafe: c, fromWords: n, fromWordsUnsafe: i, toWords: o };
}
var qp = ZT("bech32");
var Vp = ZT("bech32m");
var Vi = {
  b58chk: {
    encode: (e) => yE(g2).encode(e),
    decode: (e) => yE(g2).decode(e)
  },
  base64: {
    encode: (e) => mE.encode(e),
    decode: (e) => mE.decode(e)
  },
  b64url: {
    encode: (e) => bE.encode(e),
    decode: (e) => bE.decode(e)
  },
  bech32: {
    to_words: qp.toWords,
    to_bytes: qp.fromWords,
    encode: (e, t, r = false) => qp.encode(e, t, r),
    decode: (e, t = false) => {
      const { prefix: r, words: n } = qp.decode(e, t);
      return { prefix: r, words: n };
    }
  },
  bech32m: {
    to_words: Vp.toWords,
    to_bytes: Vp.fromWords,
    encode: (e, t, r = false) => Vp.encode(e, t, r),
    decode: (e, t = false) => {
      const { prefix: r, words: n } = Vp.decode(e, t);
      return { prefix: r, words: n };
    }
  }
};
function Ooe(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Boe(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function Coe(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
function XT(e, t) {
  if (e !== t)
    throw new TypeError(`Bech32 prefix does not match: ${e} !== ${t}`);
}
var Noe = BigInt(0);
var Uoe = BigInt(255);
var YT = BigInt(256);
function $oe(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Roe(e, t, r = "be") {
  t === void 0 && (t = $oe(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > Noe; ) {
    const a = e & Uoe, c = Number(a);
    n ? i.setUint8(s++, c) : i.setUint8(s--, c), e = (e - a) / YT;
  }
  return new Uint8Array(o);
}
function zoe(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * YT + BigInt(e[r]);
  return BigInt(t);
}
function Hoe(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let i = 0;
    for (let s = 0; s < 8; s++)
      i |= t[n + s] << 7 - s;
    r[o] = i;
  }
  return r;
}
function Loe(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function joe(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function Foe(e, t, r = "be") {
  t === void 0 && (t = joe(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? i.setUint8(s++, e) : i.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(o);
}
function Doe(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], Coe(t);
  return t;
}
var Koe = new TextEncoder();
var Moe = new TextDecoder();
function d8(e) {
  return Koe.encode(e);
}
function Ty(e) {
  return Moe.decode(e);
}
function qoe(e, t) {
  Boe(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function Voe(e, t, r = "le") {
  t = qoe(e, t);
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? i.setUint8(s++, u) : i.setUint8(s--, u);
  }
  return new Uint8Array(o);
}
function Goe(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
var { getRandomValues: Woe } = crypto ?? globalThis.crypto ?? window.crypto;
function Zoe(e = 32) {
  if (typeof Woe == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function JT(e) {
  return e.match(/[^a-fA-f0-9]/) === null && e.length % 2 === 0;
}
function Xoe(e) {
  return typeof e == "string" && JT(e) || typeof e == "number" || typeof e == "bigint" || e instanceof Uint8Array ? true : !!(Array.isArray(e) && e.every((t) => typeof t == "number"));
}
function Yoe(e, t, r = "be") {
  t === void 0 && (t = e.length), Ooe(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function QT(e) {
  let t, r = 0;
  const n = e.reduce((i, s) => i + s.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const i = e[t];
    o.set(i, r), r += i.length;
  }
  return o;
}
function Joe(e, t) {
  return typeof t == "bigint" ? `${t}n` : t;
}
function Qoe(e, t) {
  return typeof t == "string" && /n$/.test(t) ? BigInt(t.slice(0, -1)) : t;
}
function eie(e, t, r) {
  const n = e.length, o = r / t;
  if (r % t !== 0)
    throw new TypeError(`Invalid parameters: ${r} % ${t} !== 0`);
  if (n !== r)
    throw new TypeError(`Invalid data stream: ${n} !== ${r}`);
  if (n % t !== 0)
    throw new TypeError(`Invalid data stream: ${n} % ${t} !== 0`);
  const i = new Array(o);
  for (let s = 0; s < o; s++) {
    const a = s * t;
    i[s] = e.subarray(a, a + t);
  }
  return i;
}
function h8(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return Yoe(e, t, r);
  if (Array.isArray(e)) {
    const n = e.map((o) => h8(o, t, r));
    return QT(n);
  } else {
    if (typeof e == "string")
      return Voe(e, t, r);
    if (typeof e == "bigint")
      return Roe(e, t, r);
    if (typeof e == "number")
      return Foe(e, t, r);
    if (typeof e == "boolean")
      return Uint8Array.of(e ? 1 : 0);
  }
  throw new TypeError("Unsupported format:" + typeof e);
}
var qe;
var jt = (qe = class extends Uint8Array {
  static random(e = 32) {
    const t = Zoe(e);
    return new qe(t, e);
  }
  static now(e = 4) {
    const t = Math.floor(Date.now() / 1e3);
    return new qe(t, e);
  }
  constructor(e, t, r) {
    if (e instanceof qe && t === void 0)
      return e;
    const n = h8(e, t, r);
    super(n);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.to_num();
  }
  get big() {
    return this.to_big();
  }
  get str() {
    return this.to_str();
  }
  get hex() {
    return this.to_hex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.to_bin();
  }
  get b58chk() {
    return this.to_b58chk();
  }
  get base64() {
    return this.to_base64();
  }
  get b64url() {
    return this.to_b64url();
  }
  get digest() {
    return this.to_hash();
  }
  get id() {
    return this.to_hash().hex;
  }
  get stream() {
    return new pie(this);
  }
  to_num(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return Doe(t);
  }
  to_big(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return zoe(t);
  }
  to_bin() {
    return Loe(this);
  }
  to_hash() {
    const e = g2(this);
    return new qe(e);
  }
  to_json(e) {
    e === void 0 && (e = Qoe);
    const t = Ty(this);
    return JSON.parse(t, e);
  }
  to_bech32(e, t) {
    const { encode: r, to_words: n } = Vi.bech32, o = n(this);
    return r(e, o, t);
  }
  to_bech32m(e, t) {
    const { encode: r, to_words: n } = Vi.bech32m, o = n(this);
    return r(e, o, t);
  }
  to_str() {
    return Ty(this);
  }
  to_hex() {
    return Goe(this);
  }
  to_bytes() {
    return new Uint8Array(this);
  }
  to_b58chk() {
    return Vi.b58chk.encode(this);
  }
  to_base64() {
    return Vi.base64.encode(this);
  }
  to_b64url() {
    return Vi.b64url.encode(this);
  }
  append(e) {
    return qe.join([this, qe.bytes(e)]);
  }
  prepend(e) {
    return qe.join([qe.bytes(e), this]);
  }
  reverse() {
    const e = new Uint8Array(this).reverse();
    return new qe(e);
  }
  slice(e, t) {
    const r = new Uint8Array(this).slice(e, t);
    return new qe(r);
  }
  set(e, t) {
    this.set(e, t);
  }
  subarray(e, t) {
    const r = new Uint8Array(this).subarray(e, t);
    return new qe(r);
  }
  write(e, t) {
    const r = qe.bytes(e);
    this.set(r, t);
  }
  add_varint(e) {
    const t = qe.calc_varint(this.length, e);
    return qe.join([t, this]);
  }
  static from(e) {
    return new qe(Uint8Array.from(e));
  }
  static of(...e) {
    return new qe(Uint8Array.of(...e));
  }
  static join(e) {
    const t = e.map((n) => qe.bytes(n)), r = QT(t);
    return new qe(r);
  }
  static sort(e, t) {
    const r = e.map((n) => EE(n, t).hex);
    return r.sort(), r.map((n) => qe.hex(n, t));
  }
  static calc_varint(e, t) {
    if (e < 253)
      return qe.num(e, 1);
    if (e < 65536)
      return qe.of(253, ...qe.num(e, 2, t));
    if (e < 4294967296)
      return qe.of(254, ...qe.num(e, 4, t));
    if (BigInt(e) < 0x10000000000000000n)
      return qe.of(255, ...qe.num(e, 8, t));
    throw new Error(`Value is too large: ${e}`);
  }
}, qe.num = tie, qe.big = nie, qe.bin = rie, qe.raw = oie, qe.str = iie, qe.hex = sie, qe.bytes = EE, qe.json = aie, qe.base64 = cie, qe.b64url = uie, qe.bech32 = lie, qe.bech32m = fie, qe.b58chk = die, qe.encode = d8, qe.decode = Ty, qe.parse = hie, qe.is_bytes = Xoe, qe.is_hex = JT, qe);
function tie(e, t, r) {
  return new jt(e, t, r);
}
function rie(e, t, r) {
  return new jt(Hoe(e), t, r);
}
function nie(e, t, r) {
  return new jt(e, t, r);
}
function oie(e, t, r) {
  return new jt(e, t, r);
}
function iie(e, t, r) {
  return new jt(d8(e), t, r);
}
function sie(e, t, r) {
  return new jt(e, t, r);
}
function aie(e, t) {
  t === void 0 && (t = Joe);
  const r = JSON.stringify(e, t);
  return new jt(d8(r));
}
function cie(e) {
  return new jt(Vi.base64.decode(e));
}
function uie(e) {
  return new jt(Vi.b64url.decode(e));
}
function lie(e, t, r) {
  const { decode: n, to_bytes: o } = Vi.bech32, { prefix: i, words: s } = n(e, t), a = o(s);
  return typeof r == "string" && XT(i, r), new jt(a);
}
function fie(e, t, r) {
  const { decode: n, to_bytes: o } = Vi.bech32m, { prefix: i, words: s } = n(e, t), a = o(s);
  return typeof r == "string" && XT(i, r), new jt(a);
}
function die(e) {
  return new jt(Vi.b58chk.decode(e));
}
function hie(e, t, r) {
  const n = h8(e);
  return eie(n, t, r).map((o) => jt.bytes(o));
}
var pie = class {
  constructor(e) {
    this.data = jt.bytes(e), this.size = this.data.length;
  }
  peek(e) {
    if (e > this.size)
      throw new Error(`Size greater than stream: ${e} > ${this.size}`);
    return new jt(this.data.slice(0, e));
  }
  read(e) {
    const t = this.peek(e);
    return this.data = this.data.slice(e), this.size = this.data.length, t;
  }
  read_varint(e) {
    const t = this.read(1).num;
    switch (true) {
      case (t >= 0 && t < 253):
        return t;
      case t === 253:
        return this.read(2).to_num(e);
      case t === 254:
        return this.read(4).to_num(e);
      case t === 255:
        return this.read(8).to_num(e);
      default:
        throw new Error(`Varint is out of range: ${t}`);
    }
  }
};
function EE(e, t, r) {
  return new jt(e, t, r);
}
var Sg = Ru.CURVE;
var Em = Sg.n;
var gie = Sg.p;
var xE = { x: Sg.Gx, y: Sg.Gy };
var mie = BigInt(0);
BigInt(1);
BigInt(2);
BigInt(3);
BigInt(4);
var bie = (e) => Pn(e, Em);
function eP(e, t = false) {
  if (!t)
    return false;
  throw new Error(e);
}
function yie(e, t, r) {
  const n = jt.bytes(e);
  return n.length !== t ? eP(`Invalid byte size: ${n.hex} !== ${t}`, r) : true;
}
function wie(e, t) {
  return typeof e == "bigint" && mie < e && e < Em || eP("x value is not in the field!", t), true;
}
var vie = l8(Em, 32, true);
var kE = Ru.ProjectivePoint;
var ud = vie;
var er;
var lf = (er = class extends Uint8Array {
  static add(e) {
    return e.map((t) => er.mod(t)).reduce((t, r) => t.add(r));
  }
  static mod(e) {
    return new er(e);
  }
  static mul(e) {
    return e.map((t) => er.mod(t)).reduce((t, r) => t.mul(r));
  }
  static is_valid(e, t) {
    const r = jt.bytes(e, 32).big;
    return wie(r, t);
  }
  constructor(e) {
    const t = bie(Eie(e));
    er.is_valid(t, true), super(jt.big(t, 32), 32);
  }
  get buff() {
    return new jt(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(e) {
    return new er(e).big > this.big;
  }
  lt(e) {
    return new er(e).big < this.big;
  }
  eq(e) {
    return new er(e).big === this.big;
  }
  ne(e) {
    return new er(e).big !== this.big;
  }
  add(e) {
    const t = er.mod(e), r = ud.add(this.big, t.big);
    return new er(r);
  }
  sub(e) {
    const t = er.mod(e), r = ud.sub(this.big, t.big);
    return new er(r);
  }
  mul(e) {
    const t = er.mod(e), r = ud.mul(this.big, t.big);
    return new er(r);
  }
  pow(e) {
    const t = er.mod(e), r = ud.pow(this.big, t.big);
    return new er(r);
  }
  div(e) {
    const t = er.mod(e), r = ud.div(this.big, t.big);
    return new er(r);
  }
  negate() {
    return new er(er.N - this.big);
  }
  generate() {
    const e = Ru.ProjectivePoint.BASE.multiply(this.big);
    return p8.import(e);
  }
}, er.N = Em, er);
var Ht;
var p8 = (Ht = class {
  static from_x(e, t = false) {
    let r = xie(e);
    r.length === 32 ? r = r.prepend(2) : t && (r[0] = 2), yie(r, 33);
    const n = kE.fromHex(r.hex);
    return n.assertValidity(), new Ht(n.x, n.y);
  }
  static generate(e) {
    const t = lf.mod(e), r = Ht.base.multiply(t.big);
    return Ht.import(r);
  }
  static import(e) {
    const t = e instanceof Ht ? { x: e.x.big, y: e.y.big } : { x: e.x, y: e.y };
    return new Ht(t.x, t.y);
  }
  constructor(e, t) {
    this._p = new kE(e, t, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return jt.big(this.p.x, 32);
  }
  get y() {
    return jt.big(this.p.y, 32);
  }
  get buff() {
    return jt.raw(this.p.toRawBytes(true));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  eq(e) {
    const t = e instanceof Ht ? e : Ht.from_x(e);
    return this.x.big === t.x.big && this.y.big === t.y.big;
  }
  add(e) {
    return e instanceof Ht ? Ht.import(this.p.add(e.p)) : Ht.import(this.p.add(Ht.generate(e).p));
  }
  sub(e) {
    return e instanceof Ht ? Ht.import(this.p.subtract(e.p)) : Ht.import(this.p.subtract(Ht.generate(e).p));
  }
  mul(e) {
    return e instanceof Ht ? Ht.import(this.p.multiply(e.x.big)) : Ht.import(this.p.multiply(lf.mod(e).big));
  }
  negate() {
    return Ht.import(this.p.negate());
  }
}, Ht.P = gie, Ht.G = new Ht(xE.x, xE.y), Ht.curve = Ru.CURVE, Ht.base = Ru.ProjectivePoint.BASE, Ht.mul = Ht.generate, Ht);
function Eie(e) {
  if (e instanceof lf)
    return e.big;
  if (e instanceof p8)
    return e.x.big;
  if (e instanceof Uint8Array)
    return jt.raw(e).big;
  if (typeof e == "string")
    return jt.hex(e).big;
  if (typeof e == "number")
    return jt.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function xie(e) {
  if (e instanceof lf)
    return e.point.buff;
  if (e instanceof p8)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return jt.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return jt.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
var Gp = BigInt(2 ** 32 - 1);
var y2 = BigInt(32);
function tP(e, t = false) {
  return t ? { h: Number(e & Gp), l: Number(e >> y2 & Gp) } : { h: Number(e >> y2 & Gp) | 0, l: Number(e & Gp) | 0 };
}
function kie(e, t = false) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: i, l: s } = tP(e[o], t);
    [r[o], n[o]] = [i, s];
  }
  return [r, n];
}
var Aie = (e, t) => BigInt(e >>> 0) << y2 | BigInt(t >>> 0);
var Sie = (e, t, r) => e >>> r;
var _ie = (e, t, r) => e << 32 - r | t >>> r;
var Tie = (e, t, r) => e >>> r | t << 32 - r;
var Pie = (e, t, r) => e << 32 - r | t >>> r;
var Iie = (e, t, r) => e << 64 - r | t >>> r - 32;
var Oie = (e, t, r) => e >>> r - 32 | t << 64 - r;
var Bie = (e, t) => t;
var Cie = (e, t) => e;
var Nie = (e, t, r) => e << r | t >>> 32 - r;
var Uie = (e, t, r) => t << r | e >>> 32 - r;
var $ie = (e, t, r) => t << r - 32 | e >>> 64 - r;
var Rie = (e, t, r) => e << r - 32 | t >>> 64 - r;
function zie(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
var Hie = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
var Lie = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
var jie = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
var Fie = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
var Die = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
var Kie = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0;
var pt = {
  fromBig: tP,
  split: kie,
  toBig: Aie,
  shrSH: Sie,
  shrSL: _ie,
  rotrSH: Tie,
  rotrSL: Pie,
  rotrBH: Iie,
  rotrBL: Oie,
  rotr32H: Bie,
  rotr32L: Cie,
  rotlSH: Nie,
  rotlSL: Uie,
  rotlBH: $ie,
  rotlBL: Rie,
  add: zie,
  add3L: Hie,
  add3H: Lie,
  add4L: jie,
  add4H: Fie,
  add5H: Kie,
  add5L: Die
};
var [Mie, qie] = pt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e)));
var Ra = new Uint32Array(80);
var za = new Uint32Array(80);
var Vie = class extends V3 {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: r, Bl: n, Ch: o, Cl: i, Dh: s, Dl: a, Eh: c, El: u, Fh: l, Fl: f, Gh: d, Gl: m, Hh: y, Hl: b } = this;
    return [e, t, r, n, o, i, s, a, c, u, l, f, d, m, y, b];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a, c, u, l, f, d, m, y, b) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n | 0, this.Ch = o | 0, this.Cl = i | 0, this.Dh = s | 0, this.Dl = a | 0, this.Eh = c | 0, this.El = u | 0, this.Fh = l | 0, this.Fl = f | 0, this.Gh = d | 0, this.Gl = m | 0, this.Hh = y | 0, this.Hl = b | 0;
  }
  process(e, t) {
    for (let k = 0; k < 16; k++, t += 4)
      Ra[k] = e.getUint32(t), za[k] = e.getUint32(t += 4);
    for (let k = 16; k < 80; k++) {
      const x = Ra[k - 15] | 0, _ = za[k - 15] | 0, I = pt.rotrSH(x, _, 1) ^ pt.rotrSH(x, _, 8) ^ pt.shrSH(x, _, 7), P = pt.rotrSL(x, _, 1) ^ pt.rotrSL(x, _, 8) ^ pt.shrSL(x, _, 7), $ = Ra[k - 2] | 0, L = za[k - 2] | 0, V = pt.rotrSH($, L, 19) ^ pt.rotrBH($, L, 61) ^ pt.shrSH($, L, 6), ee = pt.rotrSL($, L, 19) ^ pt.rotrBL($, L, 61) ^ pt.shrSL($, L, 6), G = pt.add4L(P, ee, za[k - 7], za[k - 16]), N = pt.add4H(G, I, V, Ra[k - 7], Ra[k - 16]);
      Ra[k] = N | 0, za[k] = G | 0;
    }
    let { Ah: r, Al: n, Bh: o, Bl: i, Ch: s, Cl: a, Dh: c, Dl: u, Eh: l, El: f, Fh: d, Fl: m, Gh: y, Gl: b, Hh: w, Hl: v } = this;
    for (let k = 0; k < 80; k++) {
      const x = pt.rotrSH(l, f, 14) ^ pt.rotrSH(l, f, 18) ^ pt.rotrBH(l, f, 41), _ = pt.rotrSL(l, f, 14) ^ pt.rotrSL(l, f, 18) ^ pt.rotrBL(l, f, 41), I = l & d ^ ~l & y, P = f & m ^ ~f & b, $ = pt.add5L(v, _, P, qie[k], za[k]), L = pt.add5H($, w, x, I, Mie[k], Ra[k]), V = $ | 0, ee = pt.rotrSH(r, n, 28) ^ pt.rotrBH(r, n, 34) ^ pt.rotrBH(r, n, 39), G = pt.rotrSL(r, n, 28) ^ pt.rotrBL(r, n, 34) ^ pt.rotrBL(r, n, 39), N = r & o ^ r & s ^ o & s, q = n & i ^ n & a ^ i & a;
      w = y | 0, v = b | 0, y = d | 0, b = m | 0, d = l | 0, m = f | 0, { h: l, l: f } = pt.add(c | 0, u | 0, L | 0, V | 0), c = s | 0, u = a | 0, s = o | 0, a = i | 0, o = r | 0, i = n | 0;
      const j = pt.add3L(V, G, q);
      r = pt.add3H(j, L, ee, N), n = j | 0;
    }
    ({ h: r, l: n } = pt.add(this.Ah | 0, this.Al | 0, r | 0, n | 0)), { h: o, l: i } = pt.add(this.Bh | 0, this.Bl | 0, o | 0, i | 0), { h: s, l: a } = pt.add(this.Ch | 0, this.Cl | 0, s | 0, a | 0), { h: c, l: u } = pt.add(this.Dh | 0, this.Dl | 0, c | 0, u | 0), { h: l, l: f } = pt.add(this.Eh | 0, this.El | 0, l | 0, f | 0), { h: d, l: m } = pt.add(this.Fh | 0, this.Fl | 0, d | 0, m | 0), { h: y, l: b } = pt.add(this.Gh | 0, this.Gl | 0, y | 0, b | 0), { h: w, l: v } = pt.add(this.Hh | 0, this.Hl | 0, w | 0, v | 0), this.set(r, n, o, i, s, a, c, u, l, f, d, m, y, b, w, v);
  }
  roundClean() {
    Ra.fill(0), za.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gie = q3(() => new Vie());
function Wie(e, t = false) {
  const r = lf.mod(e);
  return t ? r.negated.buff : r.buff;
}
function rP(e, t = false) {
  const r = lf.mod(e).point;
  return t ? r.x : r.buff;
}
Ru.ProjectivePoint;
function w2(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Zie(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function nP(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Xie(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  w2(e.outputLen), w2(e.blockLen);
}
function Yie(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Jie(e, t) {
  nP(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var Qie = {
  number: w2,
  bool: Zie,
  bytes: nP,
  hash: Xie,
  exists: Yie,
  output: Jie
};
var Py = Qie;
var Iy = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var $i = (e, t) => e << 32 - t | e >>> t;
var ese = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ese)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function tse(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function oP(e) {
  if (typeof e == "string" && (e = tse(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
var rse = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function iP(e) {
  const t = (n) => e().update(oP(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function nse(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var ose = class extends rse {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Iy(this.buffer);
  }
  update(e) {
    Py.exists(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = oP(e);
    const o = e.length;
    for (let i = 0; i < o; ) {
      const s = Math.min(n - this.pos, o - i);
      if (s === n) {
        const a = Iy(e);
        for (; n <= o - i; i += n)
          this.process(a, i);
        continue;
      }
      r.set(e.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Py.exists(this), Py.output(e, this), this.finished = true;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: i } = this;
    t[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > n - i && (this.process(r, 0), i = 0);
    for (let l = i; l < n; l++)
      t[l] = 0;
    nse(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const s = Iy(e), a = this.outputLen;
    if (a % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = a / 4, u = this.get();
    if (c > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < c; l++)
      s.setUint32(4 * l, u[l], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s } = this;
    return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;
  }
};
var ise = (e, t, r) => e & t ^ ~e & r;
var sse = (e, t, r) => e & t ^ e & r ^ t & r;
var ase = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Ha = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var La = new Uint32Array(64);
var sP = class extends ose {
  constructor() {
    super(64, 32, 8, false), this.A = Ha[0] | 0, this.B = Ha[1] | 0, this.C = Ha[2] | 0, this.D = Ha[3] | 0, this.E = Ha[4] | 0, this.F = Ha[5] | 0, this.G = Ha[6] | 0, this.H = Ha[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a } = this;
    return [e, t, r, n, o, i, s, a];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = i | 0, this.G = s | 0, this.H = a | 0;
  }
  process(e, t) {
    for (let l = 0; l < 16; l++, t += 4)
      La[l] = e.getUint32(t, false);
    for (let l = 16; l < 64; l++) {
      const f = La[l - 15], d = La[l - 2], m = $i(f, 7) ^ $i(f, 18) ^ f >>> 3, y = $i(d, 17) ^ $i(d, 19) ^ d >>> 10;
      La[l] = y + La[l - 7] + m + La[l - 16] | 0;
    }
    let { A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: u } = this;
    for (let l = 0; l < 64; l++) {
      const f = $i(s, 6) ^ $i(s, 11) ^ $i(s, 25), d = u + f + ise(s, a, c) + ase[l] + La[l] | 0, m = ($i(r, 2) ^ $i(r, 13) ^ $i(r, 22)) + sse(r, n, o) | 0;
      u = c, c = a, a = s, s = i + d | 0, i = o, o = n, n = r, r = d + m | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, o, i, s, a, c, u);
  }
  roundClean() {
    La.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var cse = class extends sP {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var v2 = iP(() => new sP());
iP(() => new cse());
function use(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function lse(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function fse(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
var { getRandomValues: dse } = crypto ?? globalThis.crypto ?? window.crypto;
function hse(e = 32) {
  if (typeof dse == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function pse(e, t, r = "be") {
  t === void 0 && (t = e.length), use(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function aP(e) {
  let t, r = 0;
  const n = e.reduce((i, s) => i + s.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const i = e[t];
    o.set(i, r), r += i.length;
  }
  return o;
}
var gse = new TextEncoder();
var mse = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function cP(e) {
  for (const t of mse)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function bse(e, t, r = false) {
  typeof e == "string" && (e = gse.encode(e));
  const n = cP(t), o = n.length, i = [];
  let s = "", a, c = 0, u, l;
  for (a = 0; a < e.length; a++)
    for (c = 0, u = e[a], s += u > 0 || (s.length ^ a) > 0 ? "" : "1"; c in i || u > 0; )
      l = i[c], l = l > 0 ? l * 256 + u : u, u = l / o | 0, i[c] = l % o, c++;
  for (; c-- > 0; )
    s += n[i[c]];
  return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function yse(e, t) {
  const r = cP(t), n = r.length, o = [], i = [];
  e = e.replace("=", "");
  let s, a = 0, c, u;
  for (s = 0; s < e.length; s++) {
    if (a = 0, c = r.indexOf(e[s]), c < 0)
      throw new Error(`Character range out of bounds: ${c}`);
    for (c > 0 || (i.length ^ s) > 0 || i.push(0); a in o || c > 0; )
      u = o[a], u = u > 0 ? u * n + c : c, c = u >> 8, o[a] = u % 256, a++;
  }
  for (; a-- > 0; )
    i.push(o[a]);
  return new Uint8Array(i);
}
function uP(e) {
  return v2(v2(e));
}
function wse(e) {
  const t = uP(e);
  return aP([e, t.slice(0, 4)]);
}
function vse(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (uP(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
var AE = {
  encode: bse,
  decode: yse
};
var lP = {
  encode: (e) => {
    const t = wse(e);
    return AE.encode(t, "base58");
  },
  decode: (e) => {
    const t = AE.decode(e, "base58");
    return vse(t);
  }
};
var fP = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var Ese = [996825010, 642813549, 513874426, 1027748829, 705979059];
var _g = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function dP(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= Ese[o]);
  }
  return t;
}
function hP(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function xse(e, t, r) {
  const n = hP(e).concat(t);
  return dP(n) === r.const;
}
function kse(e, t, r) {
  const n = hP(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = dP(n) ^ r.const, i = [];
  for (let s = 0; s < 6; ++s)
    i.push(o >> 5 * (5 - s) & 31);
  return i;
}
function pP(e, t, r, n = true) {
  const o = [];
  let i = 0, s = 0;
  const a = (1 << r) - 1, c = (1 << t + r - 1) - 1;
  for (const u of e) {
    if (u < 0 || u >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(u));
    for (i = (i << t | u) & c, s += t; s >= r; )
      s -= r, o.push(i >> s & a);
  }
  if (n)
    s > 0 && o.push(i << r - s & a);
  else if (s >= t || (i << r - s & a) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function Ase(e, t, r) {
  const n = t.concat(kse(e, t, r));
  let o = e + "1";
  for (let i = 0; i < n.length; ++i)
    o += fP.charAt(n[i]);
  return o;
}
function gP(e) {
  if (!Sse(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !_se(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let i = r + 1; i < e.length; ++i) {
    const s = fP.indexOf(e.charAt(i));
    if (s === -1)
      throw new Error("Character idx out of bounds: " + String(i));
    t.push(s);
  }
  const o = _g.find((i) => i.version === t[0]) ?? _g[0];
  if (!xse(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function Sse(e) {
  let t, r, n = false, o = false;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return false;
    r >= 97 && r <= 122 && (n = true), r >= 65 && r <= 90 && (o = true);
  }
  return !(n && o);
}
function _se(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function Tse(e, t = "bc", r = 0) {
  const n = [r, ...pP([...e], 8, 5)], o = _g.find((s) => s.version === r) ?? _g[0], i = Ase(t, n, o);
  return mP(i), i;
}
function mP(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = gP(e), o = pP(n.slice(1), 5, 8, false), i = o.length;
  switch (true) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || i < 2 || i > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function Pse(e) {
  e = e.toLowerCase();
  const [t, r] = gP(e);
  return r[0];
}
var bP = {
  encode: Tse,
  decode: mP,
  version: Pse
};
var yP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var wP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var Ise = new TextEncoder();
function vP(e, t = false, r = true) {
  typeof e == "string" && (e = Ise.encode(e));
  const n = t ? wP : yP;
  let o = "", i = 0, s = 0;
  for (let a = 0; a < e.length; a++)
    for (s = s << 8 | e[a], i += 8; i >= 6; )
      i -= 6, o += n[s >> i & 63];
  if (i > 0)
    for (s <<= 6 - i, o += n[s & 63]; i < 6; )
      o += r ? "=" : "", i += 2;
  return o;
}
function EP(e, t = false) {
  const r = t || e.includes("-") || e.includes("_") ? wP.split("") : yP.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, i = 0;
  const s = [];
  for (let a = 0; a < n.length; a++) {
    const c = n[a], u = r.indexOf(c);
    if (u === -1)
      throw new Error("Invalid character: " + c);
    o += 6, i <<= 6, i |= u, o >= 8 && (o -= 8, s.push(i >>> o & 255));
  }
  return new Uint8Array(s);
}
var xP = {
  encode: vP,
  decode: EP
};
var kP = {
  encode: (e) => vP(e, true, false),
  decode: (e) => EP(e, true)
};
var Ose = BigInt(0);
var Bse = BigInt(255);
var AP = BigInt(256);
function Cse(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function Nse(e, t, r = "be") {
  t === void 0 && (t = Cse(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > Ose; ) {
    const a = e & Bse, c = Number(a);
    n ? i.setUint8(s++, c) : i.setUint8(s--, c), e = (e - a) / AP;
  }
  return new Uint8Array(o);
}
function Use(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * AP + BigInt(e[r]);
  return BigInt(t);
}
function $se(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let i = 0;
    for (let s = 0; s < 8; s++)
      i |= t[n + s] << 7 - s;
    r[o] = i;
  }
  return r;
}
function Rse(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function zse(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function Hse(e, t, r = "be") {
  t === void 0 && (t = zse(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? i.setUint8(s++, e) : i.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(o);
}
function Lse(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], fse(t);
  return t;
}
var jse = new TextEncoder();
var Fse = new TextDecoder();
function g8(e) {
  return jse.encode(e);
}
function Oy(e) {
  return Fse.decode(e);
}
function Dse(e, t) {
  lse(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function Kse(e, t, r = "le") {
  t = Dse(e, t);
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? i.setUint8(s++, u) : i.setUint8(s--, u);
  }
  return new Uint8Array(o);
}
function Mse(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function qse(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return g8(t);
}
function Vse(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return pse(e, t, r);
  if (typeof e == "string")
    return Kse(e, t, r);
  if (typeof e == "bigint")
    return Nse(e, t, r);
  if (typeof e == "number")
    return Hse(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
var wt;
var Z = (wt = class extends Uint8Array {
  static random(e = 32) {
    const t = hse(e);
    return new wt(t, e);
  }
  constructor(e, t, r) {
    const n = Vse(e, t, r);
    super(n);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new Hf(this);
  }
  toNum(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return Lse(t);
  }
  toBin() {
    return Rse(this);
  }
  toBig(e = "be") {
    const t = e === "be" ? this.reverse() : this;
    return Use(t);
  }
  toHash() {
    const e = v2(this);
    return new wt(e);
  }
  toJson() {
    const e = Oy(this);
    return JSON.parse(e);
  }
  toBech32(e, t = 0) {
    return bP.encode(this, e, t);
  }
  toStr() {
    return Oy(this);
  }
  toHex() {
    return Mse(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return lP.encode(this);
  }
  toBase64() {
    return xP.encode(this);
  }
  toB64url() {
    return kP.encode(this);
  }
  prepend(e) {
    return wt.join([wt.bytes(e), this]);
  }
  append(e) {
    return wt.join([this, wt.bytes(e)]);
  }
  slice(e, t) {
    const r = new Uint8Array(this).slice(e, t);
    return new wt(r);
  }
  subarray(e, t) {
    const r = new Uint8Array(this).subarray(e, t);
    return new wt(r);
  }
  reverse() {
    const e = new Uint8Array(this).reverse();
    return new wt(e);
  }
  write(e, t) {
    const r = wt.bytes(e);
    this.set(r, t);
  }
  prefixSize(e) {
    const t = wt.varInt(this.length, e);
    return wt.join([t, this]);
  }
  static from(e) {
    return new wt(Uint8Array.from(e));
  }
  static of(...e) {
    return new wt(Uint8Array.of(...e));
  }
  static join(e) {
    const t = e.map((n) => wt.bytes(n)), r = aP(t);
    return new wt(r);
  }
  static varInt(e, t) {
    if (e < 253)
      return wt.num(e, 1);
    if (e < 65536)
      return wt.of(253, ...wt.num(e, 2, t));
    if (e < 4294967296)
      return wt.of(254, ...wt.num(e, 4, t));
    if (BigInt(e) < 0x10000000000000000n)
      return wt.of(255, ...wt.num(e, 8, t));
    throw new Error(`Value is too large: ${e}`);
  }
}, wt.num = Gse, wt.big = Zse, wt.bin = Wse, wt.raw = Xse, wt.str = Yse, wt.hex = Jse, wt.bytes = Qse, wt.json = eae, wt.base64 = tae, wt.b64url = rae, wt.bech32 = nae, wt.b58chk = oae, wt.encode = g8, wt.decode = Oy, wt);
function Gse(e, t, r) {
  return new Z(e, t, r);
}
function Wse(e, t, r) {
  return new Z($se(e), t, r);
}
function Zse(e, t, r) {
  return new Z(e, t, r);
}
function Xse(e, t, r) {
  return new Z(e, t, r);
}
function Yse(e, t, r) {
  return new Z(g8(e), t, r);
}
function Jse(e, t, r) {
  return new Z(e, t, r);
}
function Qse(e, t, r) {
  return new Z(e, t, r);
}
function eae(e) {
  return new Z(qse(e));
}
function tae(e) {
  return new Z(xP.decode(e));
}
function rae(e) {
  return new Z(kP.decode(e));
}
function nae(e) {
  return new Z(bP.decode(e));
}
function oae(e) {
  return new Z(lP.decode(e));
}
var Hf = class {
  constructor(e) {
    this.data = Z.bytes(e), this.size = this.data.length;
  }
  peek(e) {
    if (e > this.size)
      throw new Error(`Size greater than stream: ${e} > ${this.size}`);
    return new Z(this.data.slice(0, e));
  }
  read(e) {
    e = e ?? this.readSize();
    const t = this.peek(e);
    return this.data = this.data.slice(e), this.size = this.data.length, t;
  }
  readSize(e) {
    const t = this.read(1).num;
    switch (true) {
      case (t >= 0 && t < 253):
        return t;
      case t === 253:
        return this.read(2).toNum(e);
      case t === 254:
        return this.read(4).toNum(e);
      case t === 255:
        return this.read(8).toNum(e);
      default:
        throw new Error(`Varint is out of range: ${t}`);
    }
  }
};
function is(e, t) {
  const r = Z.bytes(e);
  if (r.length !== t)
    throw new Error(`Invalid input size: ${r.hex} !== ${t}`);
}
function yn(e, t) {
  if (t)
    throw new Error(e);
  return false;
}
function g0(e, ...t) {
  const r = Z.str(e).digest.raw, n = t.map((o) => Z.bytes(o));
  return Z.join([r, r, Z.join(n)]).digest;
}
var SP = {
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_SUCCESS80: 80,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_SUCCESS98: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_SUCCESS126: 126,
  OP_SUCCESS127: 127,
  OP_SUCCESS128: 128,
  OP_SUCCESS129: 129,
  OP_SIZE: 130,
  OP_SUCCESS131: 131,
  OP_SUCCESS132: 132,
  OP_SUCCESS133: 133,
  OP_SUCCESS134: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_SUCCESS137: 137,
  OP_SUCCESS138: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_SUCCESS141: 141,
  OP_SUCCESS142: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_SUCCESS149: 149,
  OP_SUCCESS150: 150,
  OP_SUCCESS151: 151,
  OP_SUCCESS152: 152,
  OP_SUCCESS153: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186
};
function iae(e) {
  if (e > 186 && e < 255)
    return "OP_SUCCESS" + String(e);
  for (const [t, r] of Object.entries(SP))
    if (r === e)
      return t;
  throw new Error("OPCODE not found:" + String(e));
}
function sae(e) {
  for (const [t, r] of Object.entries(SP))
    if (t === e)
      return Number(r);
  throw new Error("OPCODE not found:" + e);
}
function aae(e) {
  switch (true) {
    case e === 0:
      return "opcode";
    case (e >= 1 && e <= 75):
      return "varint";
    case e === 76:
      return "pushdata1";
    case e === 77:
      return "pushdata2";
    case e === 78:
      return "pushdata4";
    case e <= 254:
      return "opcode";
    default:
      throw new Error(`Invalid word range: ${e}`);
  }
}
function cae(e) {
  const t = [];
  switch (true) {
    case typeof e != "number":
      return false;
    case e === 0:
      return true;
    case t.includes(e):
      return false;
    case (75 < e && e < 254):
      return true;
    default:
      return false;
  }
}
function na(e) {
  return typeof e == "string" && e.length % 2 === 0 && /[0-9a-fA-F]/.test(e);
}
function _P(e) {
  return na(e) || e instanceof Uint8Array;
}
var Tg = 520;
function el(e = [], t = true) {
  let r = Z.num(0);
  return Array.isArray(e) && (r = Z.raw(TP(e))), na(e) && (r = Z.hex(e)), e instanceof Uint8Array && (r = Z.raw(e)), t && (r = r.prefixSize("le")), r;
}
function TP(e) {
  const t = [];
  for (const r of e)
    t.push(uae(r));
  return t.length > 0 ? Z.join(t) : new Uint8Array();
}
function uae(e) {
  let t = new Uint8Array();
  if (typeof e == "string") {
    if (e.startsWith("OP_"))
      return Z.num(sae(e), 1);
    na(e) ? t = Z.hex(e) : t = Z.str(e);
  } else if (t = Z.bytes(e), t.length === 1 && t[0] <= 16)
    return t[0] !== 0 && (t[0] += 80), t;
  if (t.length > Tg) {
    const r = fae(t);
    return TP(r);
  }
  return Z.join([lae(t.length), t]);
}
function lae(e) {
  const t = Z.num(76, 1), r = Z.num(77, 1);
  switch (true) {
    case e <= 75:
      return Z.num(e);
    case (e > 75 && e < 256):
      return Z.join([t, Z.num(e, 1, "le")]);
    case (e >= 256 && e <= Tg):
      return Z.join([r, Z.num(e, 2, "le")]);
    default:
      throw new Error("Invalid word size:" + e.toString());
  }
}
function fae(e) {
  const t = [], r = new Hf(e);
  for (; r.size > Tg; )
    t.push(r.read(Tg));
  return t.push(r.read(r.size)), t;
}
function m8(e, t = false) {
  let r = Z.bytes(e);
  if (t) {
    const n = r.stream.readSize("le");
    if (r = r.slice(1), r.length !== n)
      throw new Error(`Varint does not match stream size: ${n} !== ${r.length}`);
  }
  return dae(r);
}
function dae(e) {
  const t = new Hf(e), r = [], n = t.size;
  let o, i, s, a = 0;
  for (; a < n; )
    switch (o = t.read(1).num, i = aae(o), a++, i) {
      case "varint":
        r.push(t.read(o).hex), a += o;
        break;
      case "pushdata1":
        s = t.read(1).reverse().num, r.push(t.read(s).hex), a += s + 1;
        break;
      case "pushdata2":
        s = t.read(2).reverse().num, r.push(t.read(s).hex), a += s + 2;
        break;
      case "pushdata4":
        s = t.read(4).reverse().num, r.push(t.read(s).hex), a += s + 4;
        break;
      case "opcode":
        if (!cae(o))
          throw new Error(`Invalid OPCODE: ${o}`);
        r.push(iae(o));
        break;
      default:
        throw new Error(`Word type undefined: ${o}`);
    }
  return r;
}
function hae(e, t) {
  if (Array.isArray(e) && (e = el(e, t)), e instanceof Uint8Array || na(e))
    return m8(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function pae(e, t) {
  if ((e instanceof Uint8Array || na(e)) && (e = m8(e, t)), Array.isArray(e))
    return el(e, t);
  throw new Error("Invalid format: " + typeof e);
}
function gae(e) {
  if (!Array.isArray(e))
    return Z.bytes(e);
  throw new Error("Invalid format: " + typeof e);
}
var mae = {
  toAsm: hae,
  toBytes: pae,
  toParam: gae
};
var Hn = {
  encode: el,
  decode: m8,
  fmt: mae
};
function E2(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function bae(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function PP(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function yae(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  E2(e.outputLen), E2(e.blockLen);
}
function wae(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function vae(e, t) {
  PP(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var Eae = {
  number: E2,
  bool: bae,
  bytes: PP,
  hash: yae,
  exists: wae,
  output: vae
};
var du = Eae;
var By = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var Cy = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Ri = (e, t) => e << 32 - t | e >>> t;
var xae = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!xae)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function kae(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function b8(e) {
  if (typeof e == "string" && (e = kae(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
function Aae(...e) {
  if (!e.every((n) => n instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (e.length === 1)
    return e[0];
  const t = e.reduce((n, o) => n + o.length, 0), r = new Uint8Array(t);
  for (let n = 0, o = 0; n < e.length; n++) {
    const i = e[n];
    r.set(i, o), o += i.length;
  }
  return r;
}
var IP = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function OP(e) {
  const t = (n) => e().update(b8(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function BP(e = 32) {
  if (By && typeof By.getRandomValues == "function")
    return By.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
function Sae(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var _ae = class extends IP {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Cy(this.buffer);
  }
  update(e) {
    du.exists(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = b8(e);
    const o = e.length;
    for (let i = 0; i < o; ) {
      const s = Math.min(n - this.pos, o - i);
      if (s === n) {
        const a = Cy(e);
        for (; n <= o - i; i += n)
          this.process(a, i);
        continue;
      }
      r.set(e.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    du.exists(this), du.output(e, this), this.finished = true;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: i } = this;
    t[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > n - i && (this.process(r, 0), i = 0);
    for (let l = i; l < n; l++)
      t[l] = 0;
    Sae(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const s = Cy(e), a = this.outputLen;
    if (a % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = a / 4, u = this.get();
    if (c > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < c; l++)
      s.setUint32(4 * l, u[l], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s } = this;
    return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;
  }
};
var Tae = (e, t, r) => e & t ^ ~e & r;
var Pae = (e, t, r) => e & t ^ e & r ^ t & r;
var Iae = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var ja = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Fa = new Uint32Array(64);
var CP = class extends _ae {
  constructor() {
    super(64, 32, 8, false), this.A = ja[0] | 0, this.B = ja[1] | 0, this.C = ja[2] | 0, this.D = ja[3] | 0, this.E = ja[4] | 0, this.F = ja[5] | 0, this.G = ja[6] | 0, this.H = ja[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a } = this;
    return [e, t, r, n, o, i, s, a];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = i | 0, this.G = s | 0, this.H = a | 0;
  }
  process(e, t) {
    for (let l = 0; l < 16; l++, t += 4)
      Fa[l] = e.getUint32(t, false);
    for (let l = 16; l < 64; l++) {
      const f = Fa[l - 15], d = Fa[l - 2], m = Ri(f, 7) ^ Ri(f, 18) ^ f >>> 3, y = Ri(d, 17) ^ Ri(d, 19) ^ d >>> 10;
      Fa[l] = y + Fa[l - 7] + m + Fa[l - 16] | 0;
    }
    let { A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: u } = this;
    for (let l = 0; l < 64; l++) {
      const f = Ri(s, 6) ^ Ri(s, 11) ^ Ri(s, 25), d = u + f + Tae(s, a, c) + Iae[l] + Fa[l] | 0, m = (Ri(r, 2) ^ Ri(r, 13) ^ Ri(r, 22)) + Pae(r, n, o) | 0;
      u = c, c = a, a = s, s = i + d | 0, i = o, o = n, n = r, r = d + m | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, o, i, s, a, c, u);
  }
  roundClean() {
    Fa.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Oae = class extends CP {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var Pg = OP(() => new CP());
OP(() => new Oae());
var Bae = BigInt(0);
var y8 = BigInt(1);
var Cae = BigInt(2);
var xm = (e) => e instanceof Uint8Array;
var Nae = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ff(e) {
  if (!xm(e))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += Nae[e[r]];
  return t;
}
function NP(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function w8(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function df(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (e.length % 2)
    throw new Error("hex string is invalid: unpadded " + e.length);
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < t.length; r++) {
    const n = r * 2, o = e.slice(n, n + 2), i = Number.parseInt(o, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("invalid byte sequence");
    t[r] = i;
  }
  return t;
}
function Un(e) {
  return w8(ff(e));
}
function v8(e) {
  if (!xm(e))
    throw new Error("Uint8Array expected");
  return w8(ff(Uint8Array.from(e).reverse()));
}
var mc = (e, t) => df(e.toString(16).padStart(t * 2, "0"));
var UP = (e, t) => mc(e, t).reverse();
var Uae = (e) => df(NP(e));
function fn(e, t, r) {
  let n;
  if (typeof t == "string")
    try {
      n = df(t);
    } catch (i) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${i}`);
    }
  else if (xm(t))
    n = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${e} expected ${r} bytes, got ${o}`);
  return n;
}
function fo(...e) {
  const t = new Uint8Array(e.reduce((n, o) => n + o.length, 0));
  let r = 0;
  return e.forEach((n) => {
    if (!xm(n))
      throw new Error("Uint8Array expected");
    t.set(n, r), r += n.length;
  }), t;
}
function $ae(e, t) {
  if (e.length !== t.length)
    return false;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return false;
  return true;
}
function km(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function Rae(e) {
  let t;
  for (t = 0; e > 0n; e >>= y8, t += 1)
    ;
  return t;
}
var zae = (e, t) => e >> BigInt(t) & 1n;
var Hae = (e, t, r) => e | (r ? y8 : Bae) << BigInt(t);
var E8 = (e) => (Cae << BigInt(e - 1)) - y8;
var Ny = (e) => new Uint8Array(e);
var SE = (e) => Uint8Array.from(e);
function $P(e, t, r) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = Ny(e), o = Ny(e), i = 0;
  const s = () => {
    n.fill(1), o.fill(0), i = 0;
  }, a = (...l) => r(o, n, ...l), c = (l = Ny()) => {
    o = a(SE([0]), l), n = a(), l.length !== 0 && (o = a(SE([1]), l), n = a());
  }, u = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let l = 0;
    const f = [];
    for (; l < t; ) {
      n = a();
      const d = n.slice();
      f.push(d), l += n.length;
    }
    return fo(...f);
  };
  return (l, f) => {
    s(), c(l);
    let d;
    for (; !(d = f(u())); )
      c();
    return s(), d;
  };
}
var Lae = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function Lf(e, t, r = {}) {
  const n = (o, i, s) => {
    const a = Lae[i];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const c = e[o];
    if (!(s && c === void 0) && !a(c, e))
      throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${i}`);
  };
  for (const [o, i] of Object.entries(t))
    n(o, i, false);
  for (const [o, i] of Object.entries(r))
    n(o, i, true);
  return e;
}
var jae = Object.freeze({
  __proto__: null,
  bitGet: zae,
  bitLen: Rae,
  bitMask: E8,
  bitSet: Hae,
  bytesToHex: ff,
  bytesToNumberBE: Un,
  bytesToNumberLE: v8,
  concatBytes: fo,
  createHmacDrbg: $P,
  ensureBytes: fn,
  equalBytes: $ae,
  hexToBytes: df,
  hexToNumber: w8,
  numberToBytesBE: mc,
  numberToBytesLE: UP,
  numberToHexUnpadded: NP,
  numberToVarBytesBE: Uae,
  utf8ToBytes: km,
  validateObject: Lf
});
var on = BigInt(0);
var Pr = BigInt(1);
var nu = BigInt(2);
var Fae = BigInt(3);
var x2 = BigInt(4);
var _E = BigInt(5);
var TE = BigInt(8);
BigInt(9);
BigInt(16);
function Mr(e, t) {
  const r = e % t;
  return r >= on ? r : t + r;
}
function Dae(e, t, r) {
  if (r <= on || t < on)
    throw new Error("Expected power/modulo > 0");
  if (r === Pr)
    return on;
  let n = Pr;
  for (; t > on; )
    t & Pr && (n = n * e % r), e = e * e % r, t >>= Pr;
  return n;
}
function Co(e, t, r) {
  let n = e;
  for (; t-- > on; )
    n *= n, n %= r;
  return n;
}
function k2(e, t) {
  if (e === on || t <= on)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let r = Mr(e, t), n = t, o = on, i = Pr;
  for (; r !== on; ) {
    const s = n / r, a = n % r, c = o - i * s;
    n = r, r = a, o = i, i = c;
  }
  if (n !== Pr)
    throw new Error("invert: does not exist");
  return Mr(o, t);
}
function Kae(e) {
  const t = (e - Pr) / nu;
  let r, n, o;
  for (r = e - Pr, n = 0; r % nu === on; r /= nu, n++)
    ;
  for (o = nu; o < e && Dae(o, t, e) !== e - Pr; o++)
    ;
  if (n === 1) {
    const s = (e + Pr) / x2;
    return function(a, c) {
      const u = a.pow(c, s);
      if (!a.eql(a.sqr(u), c))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  const i = (r + Pr) / nu;
  return function(s, a) {
    if (s.pow(a, t) === s.neg(s.ONE))
      throw new Error("Cannot find square root");
    let c = n, u = s.pow(s.mul(s.ONE, o), r), l = s.pow(a, i), f = s.pow(a, r);
    for (; !s.eql(f, s.ONE); ) {
      if (s.eql(f, s.ZERO))
        return s.ZERO;
      let d = 1;
      for (let y = s.sqr(f); d < c && !s.eql(y, s.ONE); d++)
        y = s.sqr(y);
      const m = s.pow(u, Pr << BigInt(c - d - 1));
      u = s.sqr(m), l = s.mul(l, m), f = s.mul(f, u), c = d;
    }
    return l;
  };
}
function Mae(e) {
  if (e % x2 === Fae) {
    const t = (e + Pr) / x2;
    return function(r, n) {
      const o = r.pow(n, t);
      if (!r.eql(r.sqr(o), n))
        throw new Error("Cannot find square root");
      return o;
    };
  }
  if (e % TE === _E) {
    const t = (e - _E) / TE;
    return function(r, n) {
      const o = r.mul(n, nu), i = r.pow(o, t), s = r.mul(n, i), a = r.mul(r.mul(s, nu), i), c = r.mul(s, r.sub(a, r.ONE));
      if (!r.eql(r.sqr(c), n))
        throw new Error("Cannot find square root");
      return c;
    };
  }
  return Kae(e);
}
var qae = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function RP(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, r = qae.reduce((n, o) => (n[o] = "function", n), t);
  return Lf(e, r);
}
function Vae(e, t, r) {
  if (r < on)
    throw new Error("Expected power > 0");
  if (r === on)
    return e.ONE;
  if (r === Pr)
    return t;
  let n = e.ONE, o = t;
  for (; r > on; )
    r & Pr && (n = e.mul(n, o)), o = e.sqr(o), r >>= Pr;
  return n;
}
function Gae(e, t) {
  const r = new Array(t.length), n = t.reduce((i, s, a) => e.is0(s) ? i : (r[a] = i, e.mul(i, s)), e.ONE), o = e.inv(n);
  return t.reduceRight((i, s, a) => e.is0(s) ? i : (r[a] = e.mul(i, r[a]), e.mul(i, s)), o), r;
}
function x8(e, t) {
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
function zP(e, t, r = false, n = {}) {
  if (e <= on)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: o, nByteLength: i } = x8(e, t);
  if (i > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s = Mae(e), a = Object.freeze({
    ORDER: e,
    BITS: o,
    BYTES: i,
    MASK: E8(o),
    ZERO: on,
    ONE: Pr,
    create: (c) => Mr(c, e),
    isValid: (c) => {
      if (typeof c != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
      return on <= c && c < e;
    },
    is0: (c) => c === on,
    isOdd: (c) => (c & Pr) === Pr,
    neg: (c) => Mr(-c, e),
    eql: (c, u) => c === u,
    sqr: (c) => Mr(c * c, e),
    add: (c, u) => Mr(c + u, e),
    sub: (c, u) => Mr(c - u, e),
    mul: (c, u) => Mr(c * u, e),
    pow: (c, u) => Vae(a, c, u),
    div: (c, u) => Mr(c * k2(u, e), e),
    // Same as above, but doesn't normalize
    sqrN: (c) => c * c,
    addN: (c, u) => c + u,
    subN: (c, u) => c - u,
    mulN: (c, u) => c * u,
    inv: (c) => k2(c, e),
    sqrt: n.sqrt || ((c) => s(a, c)),
    invertBatch: (c) => Gae(a, c),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (c, u, l) => l ? u : c,
    toBytes: (c) => r ? UP(c, i) : mc(c, i),
    fromBytes: (c) => {
      if (c.length !== i)
        throw new Error(`Fp.fromBytes: expected ${i}, got ${c.length}`);
      return r ? v8(c) : Un(c);
    }
  });
  return Object.freeze(a);
}
function Wae(e, t, r = false) {
  e = fn("privateHash", e);
  const n = e.length, o = x8(t).nByteLength + 8;
  if (o < 24 || n < o || n > 1024)
    throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${n}`);
  const i = r ? v8(e) : Un(e);
  return Mr(i, t - Pr) + Pr;
}
var Zae = BigInt(0);
var Uy = BigInt(1);
function Xae(e, t) {
  const r = (o, i) => {
    const s = i.negate();
    return o ? s : i;
  }, n = (o) => {
    const i = Math.ceil(t / o) + 1, s = 2 ** (o - 1);
    return { windows: i, windowSize: s };
  };
  return {
    constTimeNegate: r,
    // non-const time multiplication ladder
    unsafeLadder(o, i) {
      let s = e.ZERO, a = o;
      for (; i > Zae; )
        i & Uy && (s = s.add(a)), a = a.double(), i >>= Uy;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(o, i) {
      const { windows: s, windowSize: a } = n(i), c = [];
      let u = o, l = u;
      for (let f = 0; f < s; f++) {
        l = u, c.push(l);
        for (let d = 1; d < a; d++)
          l = l.add(u), c.push(l);
        u = l.double();
      }
      return c;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(o, i, s) {
      const { windows: a, windowSize: c } = n(o);
      let u = e.ZERO, l = e.BASE;
      const f = BigInt(2 ** o - 1), d = 2 ** o, m = BigInt(o);
      for (let y = 0; y < a; y++) {
        const b = y * c;
        let w = Number(s & f);
        s >>= m, w > c && (w -= d, s += Uy);
        const v = b, k = b + Math.abs(w) - 1, x = y % 2 !== 0, _ = w < 0;
        w === 0 ? l = l.add(r(x, i[v])) : u = u.add(r(_, i[k]));
      }
      return { p: u, f: l };
    },
    wNAFCached(o, i, s, a) {
      const c = o._WINDOW_SIZE || 1;
      let u = i.get(o);
      return u || (u = this.precomputeWindow(o, c), c !== 1 && i.set(o, a(u))), this.wNAF(c, u, s);
    }
  };
}
function HP(e) {
  return RP(e.Fp), Lf(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...x8(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
function Yae(e) {
  const t = HP(e);
  Lf(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: r, Fp: n, a: o } = t;
  if (r) {
    if (!n.eql(o, n.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof r != "object" || typeof r.beta != "bigint" || typeof r.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
var { bytesToNumberBE: Jae, hexToBytes: Qae } = jae;
var hu = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(e = "") {
      super(e);
    }
  },
  _parseInt(e) {
    const { Err: t } = hu;
    if (e.length < 2 || e[0] !== 2)
      throw new t("Invalid signature integer tag");
    const r = e[1], n = e.subarray(2, r + 2);
    if (!r || n.length !== r)
      throw new t("Invalid signature integer: wrong length");
    if (n[0] === 0 && n[1] <= 127)
      throw new t("Invalid signature integer: trailing length");
    return { d: Jae(n), l: e.subarray(r + 2) };
  },
  toSig(e) {
    const { Err: t } = hu, r = typeof e == "string" ? Qae(e) : e;
    if (!(r instanceof Uint8Array))
      throw new Error("ui8a expected");
    let n = r.length;
    if (n < 2 || r[0] != 48)
      throw new t("Invalid signature tag");
    if (r[1] !== n - 2)
      throw new t("Invalid signature: incorrect length");
    const { d: o, l: i } = hu._parseInt(r.subarray(2)), { d: s, l: a } = hu._parseInt(i);
    if (a.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: o, s };
  },
  hexFromSig(e) {
    const t = (u) => Number.parseInt(u[0], 16) >= 8 ? "00" + u : u, r = (u) => {
      const l = u.toString(16);
      return l.length & 1 ? `0${l}` : l;
    }, n = t(r(e.s)), o = t(r(e.r)), i = n.length / 2, s = o.length / 2, a = r(i), c = r(s);
    return `30${r(s + i + 4)}02${c}${o}02${a}${n}`;
  }
};
var ei = BigInt(0);
var jr = BigInt(1);
var As = BigInt(2);
var Ig = BigInt(3);
var PE = BigInt(4);
function ece(e) {
  const t = Yae(e), { Fp: r } = t, n = t.toBytes || ((y, b, w) => {
    const v = b.toAffine();
    return fo(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));
  }), o = t.fromBytes || ((y) => {
    const b = y.subarray(1), w = r.fromBytes(b.subarray(0, r.BYTES)), v = r.fromBytes(b.subarray(r.BYTES, 2 * r.BYTES));
    return { x: w, y: v };
  });
  function i(y) {
    const { a: b, b: w } = t, v = r.sqr(y), k = r.mul(v, y);
    return r.add(r.add(k, r.mul(y, b)), w);
  }
  function s(y) {
    return typeof y == "bigint" && ei < y && y < t.n;
  }
  function a(y) {
    if (!s(y))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function c(y) {
    const { allowedPrivateKeyLengths: b, nByteLength: w, wrapPrivateKey: v, n: k } = t;
    if (b && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = ff(y)), typeof y != "string" || !b.includes(y.length))
        throw new Error("Invalid key");
      y = y.padStart(w * 2, "0");
    }
    let x;
    try {
      x = typeof y == "bigint" ? y : Un(fn("private key", y, w));
    } catch {
      throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof y}`);
    }
    return v && (x = Mr(x, k)), a(x), x;
  }
  const u = /* @__PURE__ */ new Map();
  function l(y) {
    if (!(y instanceof f))
      throw new Error("ProjectivePoint expected");
  }
  class f {
    constructor(b, w, v) {
      if (this.px = b, this.py = w, this.pz = v, b == null || !r.isValid(b))
        throw new Error("x required");
      if (w == null || !r.isValid(w))
        throw new Error("y required");
      if (v == null || !r.isValid(v))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(b) {
      const { x: w, y: v } = b || {};
      if (!b || !r.isValid(w) || !r.isValid(v))
        throw new Error("invalid affine point");
      if (b instanceof f)
        throw new Error("projective point not allowed");
      const k = (x) => r.eql(x, r.ZERO);
      return k(w) && k(v) ? f.ZERO : new f(w, v, r.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(b) {
      const w = r.invertBatch(b.map((v) => v.pz));
      return b.map((v, k) => v.toAffine(w[k])).map(f.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(b) {
      const w = f.fromAffine(o(fn("pointHex", b)));
      return w.assertValidity(), w;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(b) {
      return f.BASE.multiply(c(b));
    }
    // "Private method", don't use it directly
    _setWindowSize(b) {
      this._WINDOW_SIZE = b, u.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: b, y: w } = this.toAffine();
      if (!r.isValid(b) || !r.isValid(w))
        throw new Error("bad point: x or y not FE");
      const v = r.sqr(w), k = i(b);
      if (!r.eql(v, k))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (r.isOdd)
        return !r.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(b) {
      l(b);
      const { px: w, py: v, pz: k } = this, { px: x, py: _, pz: I } = b, P = r.eql(r.mul(w, I), r.mul(x, k)), $ = r.eql(r.mul(v, I), r.mul(_, k));
      return P && $;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new f(this.px, r.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: b, b: w } = t, v = r.mul(w, Ig), { px: k, py: x, pz: _ } = this;
      let I = r.ZERO, P = r.ZERO, $ = r.ZERO, L = r.mul(k, k), V = r.mul(x, x), ee = r.mul(_, _), G = r.mul(k, x);
      return G = r.add(G, G), $ = r.mul(k, _), $ = r.add($, $), I = r.mul(b, $), P = r.mul(v, ee), P = r.add(I, P), I = r.sub(V, P), P = r.add(V, P), P = r.mul(I, P), I = r.mul(G, I), $ = r.mul(v, $), ee = r.mul(b, ee), G = r.sub(L, ee), G = r.mul(b, G), G = r.add(G, $), $ = r.add(L, L), L = r.add($, L), L = r.add(L, ee), L = r.mul(L, G), P = r.add(P, L), ee = r.mul(x, _), ee = r.add(ee, ee), L = r.mul(ee, G), I = r.sub(I, L), $ = r.mul(ee, V), $ = r.add($, $), $ = r.add($, $), new f(I, P, $);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(b) {
      l(b);
      const { px: w, py: v, pz: k } = this, { px: x, py: _, pz: I } = b;
      let P = r.ZERO, $ = r.ZERO, L = r.ZERO;
      const V = t.a, ee = r.mul(t.b, Ig);
      let G = r.mul(w, x), N = r.mul(v, _), q = r.mul(k, I), j = r.add(w, v), C = r.add(x, _);
      j = r.mul(j, C), C = r.add(G, N), j = r.sub(j, C), C = r.add(w, k);
      let U = r.add(x, I);
      return C = r.mul(C, U), U = r.add(G, q), C = r.sub(C, U), U = r.add(v, k), P = r.add(_, I), U = r.mul(U, P), P = r.add(N, q), U = r.sub(U, P), L = r.mul(V, C), P = r.mul(ee, q), L = r.add(P, L), P = r.sub(N, L), L = r.add(N, L), $ = r.mul(P, L), N = r.add(G, G), N = r.add(N, G), q = r.mul(V, q), C = r.mul(ee, C), N = r.add(N, q), q = r.sub(G, q), q = r.mul(V, q), C = r.add(C, q), G = r.mul(N, C), $ = r.add($, G), G = r.mul(U, C), P = r.mul(j, P), P = r.sub(P, G), G = r.mul(j, N), L = r.mul(U, L), L = r.add(L, G), new f(P, $, L);
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(f.ZERO);
    }
    wNAF(b) {
      return m.wNAFCached(this, u, b, (w) => {
        const v = r.invertBatch(w.map((k) => k.pz));
        return w.map((k, x) => k.toAffine(v[x])).map(f.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(b) {
      const w = f.ZERO;
      if (b === ei)
        return w;
      if (a(b), b === jr)
        return this;
      const { endo: v } = t;
      if (!v)
        return m.unsafeLadder(this, b);
      let { k1neg: k, k1: x, k2neg: _, k2: I } = v.splitScalar(b), P = w, $ = w, L = this;
      for (; x > ei || I > ei; )
        x & jr && (P = P.add(L)), I & jr && ($ = $.add(L)), L = L.double(), x >>= jr, I >>= jr;
      return k && (P = P.negate()), _ && ($ = $.negate()), $ = new f(r.mul($.px, v.beta), $.py, $.pz), P.add($);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(b) {
      a(b);
      let w = b, v, k;
      const { endo: x } = t;
      if (x) {
        const { k1neg: _, k1: I, k2neg: P, k2: $ } = x.splitScalar(w);
        let { p: L, f: V } = this.wNAF(I), { p: ee, f: G } = this.wNAF($);
        L = m.constTimeNegate(_, L), ee = m.constTimeNegate(P, ee), ee = new f(r.mul(ee.px, x.beta), ee.py, ee.pz), v = L.add(ee), k = V.add(G);
      } else {
        const { p: _, f: I } = this.wNAF(w);
        v = _, k = I;
      }
      return f.normalizeZ([v, k])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(b, w, v) {
      const k = f.BASE, x = (I, P) => P === ei || P === jr || !I.equals(k) ? I.multiplyUnsafe(P) : I.multiply(P), _ = x(this, w).add(x(b, v));
      return _.is0() ? void 0 : _;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(b) {
      const { px: w, py: v, pz: k } = this, x = this.is0();
      b == null && (b = x ? r.ONE : r.inv(k));
      const _ = r.mul(w, b), I = r.mul(v, b), P = r.mul(k, b);
      if (x)
        return { x: r.ZERO, y: r.ZERO };
      if (!r.eql(P, r.ONE))
        throw new Error("invZ was invalid");
      return { x: _, y: I };
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: w } = t;
      if (b === jr)
        return true;
      if (w)
        return w(f, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: b, clearCofactor: w } = t;
      return b === jr ? this : w ? w(f, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(b = true) {
      return this.assertValidity(), n(f, this, b);
    }
    toHex(b = true) {
      return ff(this.toRawBytes(b));
    }
  }
  f.BASE = new f(t.Gx, t.Gy, r.ONE), f.ZERO = new f(r.ZERO, r.ONE, r.ZERO);
  const d = t.nBitLength, m = Xae(f, t.endo ? Math.ceil(d / 2) : d);
  return {
    CURVE: t,
    ProjectivePoint: f,
    normPrivateKeyToScalar: c,
    weierstrassEquation: i,
    isWithinCurveOrder: s
  };
}
function tce(e) {
  const t = HP(e);
  return Lf(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: true, ...t });
}
function rce(e) {
  const t = tce(e), { Fp: r, n } = t, o = r.BYTES + 1, i = 2 * r.BYTES + 1;
  function s(C) {
    return ei < C && C < r.ORDER;
  }
  function a(C) {
    return Mr(C, n);
  }
  function c(C) {
    return k2(C, n);
  }
  const { ProjectivePoint: u, normPrivateKeyToScalar: l, weierstrassEquation: f, isWithinCurveOrder: d } = ece({
    ...t,
    toBytes(C, U, M) {
      const re = U.toAffine(), te = r.toBytes(re.x), ie = fo;
      return M ? ie(Uint8Array.from([U.hasEvenY() ? 2 : 3]), te) : ie(Uint8Array.from([4]), te, r.toBytes(re.y));
    },
    fromBytes(C) {
      const U = C.length, M = C[0], re = C.subarray(1);
      if (U === o && (M === 2 || M === 3)) {
        const te = Un(re);
        if (!s(te))
          throw new Error("Point is not on curve");
        const ie = f(te);
        let ne = r.sqrt(ie);
        const le = (ne & jr) === jr;
        return (M & 1) === 1 !== le && (ne = r.neg(ne)), { x: te, y: ne };
      } else if (U === i && M === 4) {
        const te = r.fromBytes(re.subarray(0, r.BYTES)), ie = r.fromBytes(re.subarray(r.BYTES, 2 * r.BYTES));
        return { x: te, y: ie };
      } else
        throw new Error(`Point of length ${U} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`);
    }
  }), m = (C) => ff(mc(C, t.nByteLength));
  function y(C) {
    const U = n >> jr;
    return C > U;
  }
  function b(C) {
    return y(C) ? a(-C) : C;
  }
  const w = (C, U, M) => Un(C.slice(U, M));
  class v {
    constructor(U, M, re) {
      this.r = U, this.s = M, this.recovery = re, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(U) {
      const M = t.nByteLength;
      return U = fn("compactSignature", U, M * 2), new v(w(U, 0, M), w(U, M, 2 * M));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(U) {
      const { r: M, s: re } = hu.toSig(fn("DER", U));
      return new v(M, re);
    }
    assertValidity() {
      if (!d(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!d(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(U) {
      return new v(this.r, this.s, U);
    }
    recoverPublicKey(U) {
      const { r: M, s: re, recovery: te } = this, ie = $(fn("msgHash", U));
      if (te == null || ![0, 1, 2, 3].includes(te))
        throw new Error("recovery id invalid");
      const ne = te === 2 || te === 3 ? M + t.n : M;
      if (ne >= r.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const le = te & 1 ? "03" : "02", K = u.fromHex(le + m(ne)), ve = c(ne), At = a(-ie * ve), ze = a(re * ve), St = u.BASE.multiplyAndAddUnsafe(K, At, ze);
      if (!St)
        throw new Error("point at infinify");
      return St.assertValidity(), St;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return df(this.toDERHex());
    }
    toDERHex() {
      return hu.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return df(this.toCompactHex());
    }
    toCompactHex() {
      return m(this.r) + m(this.s);
    }
  }
  const k = {
    isValidPrivateKey(C) {
      try {
        return l(C), true;
      } catch {
        return false;
      }
    },
    normPrivateKeyToScalar: l,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const C = t.randomBytes(r.BYTES + 8), U = Wae(C, n);
      return mc(U, t.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(C = 8, U = u.BASE) {
      return U._setWindowSize(C), U.multiply(BigInt(3)), U;
    }
  };
  function x(C, U = true) {
    return u.fromPrivateKey(C).toRawBytes(U);
  }
  function _(C) {
    const U = C instanceof Uint8Array, M = typeof C == "string", re = (U || M) && C.length;
    return U ? re === o || re === i : M ? re === 2 * o || re === 2 * i : C instanceof u;
  }
  function I(C, U, M = true) {
    if (_(C))
      throw new Error("first arg must be private key");
    if (!_(U))
      throw new Error("second arg must be public key");
    return u.fromHex(U).multiply(l(C)).toRawBytes(M);
  }
  const P = t.bits2int || function(C) {
    const U = Un(C), M = C.length * 8 - t.nBitLength;
    return M > 0 ? U >> BigInt(M) : U;
  }, $ = t.bits2int_modN || function(C) {
    return a(P(C));
  }, L = E8(t.nBitLength);
  function V(C) {
    if (typeof C != "bigint")
      throw new Error("bigint expected");
    if (!(ei <= C && C < L))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return mc(C, t.nByteLength);
  }
  function ee(C, U, M = G) {
    if (["recovered", "canonical"].some((Ge) => Ge in M))
      throw new Error("sign() legacy options not supported");
    const { hash: re, randomBytes: te } = t;
    let { lowS: ie, prehash: ne, extraEntropy: le } = M;
    ie == null && (ie = true), C = fn("msgHash", C), ne && (C = fn("prehashed msgHash", re(C)));
    const K = $(C), ve = l(U), At = [V(ve), V(K)];
    if (le != null) {
      const Ge = le === true ? te(r.BYTES) : le;
      At.push(fn("extraEntropy", Ge, r.BYTES));
    }
    const ze = fo(...At), St = K;
    function et(Ge) {
      const ut = P(Ge);
      if (!d(ut))
        return;
      const ot = c(ut), He = u.BASE.multiply(ut).toAffine(), Ae = a(He.x);
      if (Ae === ei)
        return;
      const bt = a(ot * a(St + Ae * ve));
      if (bt === ei)
        return;
      let wr = (He.x === Ae ? 0 : 2) | Number(He.y & jr), Gt = bt;
      return ie && y(bt) && (Gt = b(bt), wr ^= 1), new v(Ae, Gt, wr);
    }
    return { seed: ze, k2sig: et };
  }
  const G = { lowS: t.lowS, prehash: false }, N = { lowS: t.lowS, prehash: false };
  function q(C, U, M = G) {
    const { seed: re, k2sig: te } = ee(C, U, M);
    return $P(t.hash.outputLen, t.nByteLength, t.hmac)(re, te);
  }
  u.BASE._setWindowSize(8);
  function j(C, U, M, re = N) {
    var te;
    const ie = C;
    if (U = fn("msgHash", U), M = fn("publicKey", M), "strict" in re)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: ne, prehash: le } = re;
    let K, ve;
    try {
      if (typeof ie == "string" || ie instanceof Uint8Array)
        try {
          K = v.fromDER(ie);
        } catch (He) {
          if (!(He instanceof hu.Err))
            throw He;
          K = v.fromCompact(ie);
        }
      else if (typeof ie == "object" && typeof ie.r == "bigint" && typeof ie.s == "bigint") {
        const { r: He, s: Ae } = ie;
        K = new v(He, Ae);
      } else
        throw new Error("PARSE");
      ve = u.fromHex(M);
    } catch (He) {
      if (He.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return false;
    }
    if (ne && K.hasHighS())
      return false;
    le && (U = t.hash(U));
    const { r: At, s: ze } = K, St = $(U), et = c(ze), Ge = a(St * et), ut = a(At * et), ot = (te = u.BASE.multiplyAndAddUnsafe(ve, Ge, ut)) == null ? void 0 : te.toAffine();
    return ot ? a(ot.x) === At : false;
  }
  return {
    CURVE: t,
    getPublicKey: x,
    getSharedSecret: I,
    sign: q,
    verify: j,
    ProjectivePoint: u,
    Signature: v,
    utils: k
  };
}
function nce(e, t) {
  const r = e.ORDER;
  let n = ei;
  for (let d = r - jr; d % As === ei; d /= As)
    n += jr;
  const o = n, i = (r - jr) / As ** o, s = (i - jr) / As, a = As ** o - jr, c = As ** (o - jr), u = e.pow(t, i), l = e.pow(t, (i + jr) / As);
  let f = (d, m) => {
    let y = u, b = e.pow(m, a), w = e.sqr(b);
    w = e.mul(w, m);
    let v = e.mul(d, w);
    v = e.pow(v, s), v = e.mul(v, b), b = e.mul(v, m), w = e.mul(v, d);
    let k = e.mul(w, b);
    v = e.pow(k, c);
    let x = e.eql(v, e.ONE);
    b = e.mul(w, l), v = e.mul(k, y), w = e.cmov(b, w, x), k = e.cmov(v, k, x);
    for (let _ = o; _ > 1; _--) {
      let I = As ** (_ - As), P = e.pow(k, I);
      const $ = e.eql(P, e.ONE);
      b = e.mul(w, y), y = e.mul(y, y), P = e.mul(k, y), w = e.cmov(b, w, $), k = e.cmov(P, k, $);
    }
    return { isValid: x, value: w };
  };
  if (e.ORDER % PE === Ig) {
    const d = (e.ORDER - Ig) / PE, m = e.sqrt(e.neg(t));
    f = (y, b) => {
      let w = e.sqr(b);
      const v = e.mul(y, b);
      w = e.mul(w, v);
      let k = e.pow(w, d);
      k = e.mul(k, v);
      const x = e.mul(k, m), _ = e.mul(e.sqr(k), b), I = e.eql(_, y);
      let P = e.cmov(x, k, I);
      return { isValid: I, value: P };
    };
  }
  return f;
}
function oce(e, t) {
  if (RP(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const r = nce(e, t.Z);
  if (!e.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (n) => {
    let o, i, s, a, c, u, l, f;
    o = e.sqr(n), o = e.mul(o, t.Z), i = e.sqr(o), i = e.add(i, o), s = e.add(i, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(i), !e.eql(i, e.ZERO)), a = e.mul(a, t.A), i = e.sqr(s), u = e.sqr(a), c = e.mul(u, t.A), i = e.add(i, c), i = e.mul(i, s), u = e.mul(u, a), c = e.mul(u, t.B), i = e.add(i, c), l = e.mul(o, s);
    const { isValid: d, value: m } = r(i, u);
    f = e.mul(o, n), f = e.mul(f, m), l = e.cmov(l, s, d), f = e.cmov(f, m, d);
    const y = e.isOdd(n) === e.isOdd(f);
    return f = e.cmov(e.neg(f), f, y), l = e.div(l, a), { x: l, y: f };
  };
}
function ice(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return km(e);
  throw new Error("DST must be Uint8Array or string");
}
var sce = Un;
function sc(e, t) {
  if (e < 0 || e >= 1 << 8 * t)
    throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const r = Array.from({ length: t }).fill(0);
  for (let n = t - 1; n >= 0; n--)
    r[n] = e & 255, e >>>= 8;
  return new Uint8Array(r);
}
function ace(e, t) {
  const r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e[n] ^ t[n];
  return r;
}
function sh(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function k8(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function cce(e, t, r, n) {
  sh(e), sh(t), k8(r), t.length > 255 && (t = n(fo(km("H2C-OVERSIZE-DST-"), t)));
  const { outputLen: o, blockLen: i } = n, s = Math.ceil(r / o);
  if (s > 255)
    throw new Error("Invalid xmd length");
  const a = fo(t, sc(t.length, 1)), c = sc(0, i), u = sc(r, 2), l = new Array(s), f = n(fo(c, e, u, sc(0, 1), a));
  l[0] = n(fo(f, sc(1, 1), a));
  for (let d = 1; d <= s; d++) {
    const m = [ace(f, l[d - 1]), sc(d + 1, 1), a];
    l[d] = n(fo(...m));
  }
  return fo(...l).slice(0, r);
}
function uce(e, t, r, n, o) {
  if (sh(e), sh(t), k8(r), t.length > 255) {
    const i = Math.ceil(2 * n / 8);
    t = o.create({ dkLen: i }).update(km("H2C-OVERSIZE-DST-")).update(t).digest();
  }
  if (r > 65535 || t.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return o.create({ dkLen: r }).update(e).update(sc(r, 2)).update(t).update(sc(t.length, 1)).digest();
}
function IE(e, t, r) {
  Lf(r, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: n, k: o, m: i, hash: s, expand: a, DST: c } = r;
  sh(e), k8(t);
  const u = ice(c), l = n.toString(2).length, f = Math.ceil((l + o) / 8), d = t * i * f;
  let m;
  if (a === "xmd")
    m = cce(e, u, d, s);
  else if (a === "xof")
    m = uce(e, u, d, o, s);
  else if (a === void 0)
    m = e;
  else
    throw new Error('expand must be "xmd", "xof" or undefined');
  const y = new Array(t);
  for (let b = 0; b < t; b++) {
    const w = new Array(i);
    for (let v = 0; v < i; v++) {
      const k = f * (v + b * i), x = m.subarray(k, k + f);
      w[v] = Mr(sce(x), n);
    }
    y[b] = w;
  }
  return y;
}
function lce(e, t) {
  const r = t.map((n) => Array.from(n).reverse());
  return (n, o) => {
    const [i, s, a, c] = r.map((u) => u.reduce((l, f) => e.add(e.mul(l, n), f)));
    return n = e.div(i, s), o = e.mul(o, e.div(a, c)), { x: n, y: o };
  };
}
function fce(e, t, r) {
  if (typeof t != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(n, o) {
      const i = IE(n, 2, { ...r, DST: r.DST, ...o }), s = e.fromAffine(t(i[0])), a = e.fromAffine(t(i[1])), c = s.add(a).clearCofactor();
      return c.assertValidity(), c;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(n, o) {
      const i = IE(n, 1, { ...r, DST: r.encodeDST, ...o }), s = e.fromAffine(t(i[0])).clearCofactor();
      return s.assertValidity(), s;
    }
  };
}
var LP = class extends IP {
  constructor(e, t) {
    super(), this.finished = false, this.destroyed = false, du.hash(e);
    const r = b8(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, o = new Uint8Array(n);
    o.set(r.length > n ? e.create().update(r).digest() : r);
    for (let i = 0; i < o.length; i++)
      o[i] ^= 54;
    this.iHash.update(o), this.oHash = e.create();
    for (let i = 0; i < o.length; i++)
      o[i] ^= 106;
    this.oHash.update(o), o.fill(0);
  }
  update(e) {
    return du.exists(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    du.exists(this), du.bytes(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: r, finished: n, destroyed: o, blockLen: i, outputLen: s } = this;
    return e = e, e.finished = n, e.destroyed = o, e.blockLen = i, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var jP = (e, t, r) => new LP(e, t).update(r).digest();
jP.create = (e, t) => new LP(e, t);
function dce(e) {
  return {
    hash: e,
    hmac: (t, ...r) => jP(e, t, Aae(...r)),
    randomBytes: BP
  };
}
function hce(e, t) {
  const r = (n) => rce({ ...e, ...dce(n) });
  return Object.freeze({ ...r(t), create: r });
}
var Am = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var Og = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var FP = BigInt(1);
var Bg = BigInt(2);
var OE = (e, t) => (e + t / Bg) / t;
function DP(e) {
  const t = Am, r = BigInt(3), n = BigInt(6), o = BigInt(11), i = BigInt(22), s = BigInt(23), a = BigInt(44), c = BigInt(88), u = e * e * e % t, l = u * u * e % t, f = Co(l, r, t) * l % t, d = Co(f, r, t) * l % t, m = Co(d, Bg, t) * u % t, y = Co(m, o, t) * m % t, b = Co(y, i, t) * y % t, w = Co(b, a, t) * b % t, v = Co(w, c, t) * w % t, k = Co(v, a, t) * b % t, x = Co(k, r, t) * l % t, _ = Co(x, s, t) * y % t, I = Co(_, n, t) * u % t, P = Co(I, Bg, t);
  if (!Tc.eql(Tc.sqr(P), e))
    throw new Error("Cannot find square root");
  return P;
}
var Tc = zP(Am, void 0, void 0, { sqrt: DP });
var ss = hce({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Tc,
  n: Og,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = Og, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -FP * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = r, s = BigInt("0x100000000000000000000000000000000"), a = OE(i * e, t), c = OE(-n * e, t);
      let u = Mr(e - a * r - c * o, t), l = Mr(-a * n - c * i, t);
      const f = u > s, d = l > s;
      if (f && (u = t - u), d && (l = t - l), u > s || l > s)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: f, k1: u, k2neg: d, k2: l };
    }
  }
}, Pg);
var Sm = BigInt(0);
var KP = (e) => typeof e == "bigint" && Sm < e && e < Am;
var pce = (e) => typeof e == "bigint" && Sm < e && e < Og;
var BE = {};
function Cg(e, ...t) {
  let r = BE[e];
  if (r === void 0) {
    const n = Pg(Uint8Array.from(e, (o) => o.charCodeAt(0)));
    r = fo(n, n), BE[e] = r;
  }
  return Pg(fo(r, ...t));
}
var A8 = (e) => e.toRawBytes(true).slice(1);
var A2 = (e) => mc(e, 32);
var $y = (e) => Mr(e, Am);
var ah = (e) => Mr(e, Og);
var S8 = ss.ProjectivePoint;
var gce = (e, t, r) => S8.BASE.multiplyAndAddUnsafe(e, t, r);
function S2(e) {
  let t = ss.utils.normPrivateKeyToScalar(e), r = S8.fromPrivateKey(t);
  return { scalar: r.hasEvenY() ? t : ah(-t), bytes: A8(r) };
}
function MP(e) {
  if (!KP(e))
    throw new Error("bad x: need 0 < x < p");
  const t = $y(e * e), r = $y(t * e + BigInt(7));
  let n = DP(r);
  n % Bg !== Sm && (n = $y(-n));
  const o = new S8(e, n, FP);
  return o.assertValidity(), o;
}
function qP(...e) {
  return ah(Un(Cg("BIP0340/challenge", ...e)));
}
function mce(e) {
  return S2(e).bytes;
}
function bce(e, t, r = BP(32)) {
  const n = fn("message", e), { bytes: o, scalar: i } = S2(t), s = fn("auxRand", r, 32), a = A2(i ^ Un(Cg("BIP0340/aux", s))), c = Cg("BIP0340/nonce", a, o, n), u = ah(Un(c));
  if (u === Sm)
    throw new Error("sign failed: k is zero");
  const { bytes: l, scalar: f } = S2(u), d = qP(l, o, n), m = new Uint8Array(64);
  if (m.set(l, 0), m.set(A2(ah(f + d * i)), 32), !VP(m, n, o))
    throw new Error("sign: Invalid signature produced");
  return m;
}
function VP(e, t, r) {
  const n = fn("signature", e, 64), o = fn("message", t), i = fn("publicKey", r, 32);
  try {
    const s = MP(Un(i)), a = Un(n.subarray(0, 32));
    if (!KP(a))
      return false;
    const c = Un(n.subarray(32, 64));
    if (!pce(c))
      return false;
    const u = qP(A2(a), A8(s), o), l = gce(s, c, ah(-u));
    return !(!l || !l.hasEvenY() || l.toAffine().x !== a);
  } catch {
    return false;
  }
}
var yce = {
  getPublicKey: mce,
  sign: bce,
  verify: VP,
  utils: {
    randomPrivateKey: ss.utils.randomPrivateKey,
    lift_x: MP,
    pointToBytes: A8,
    numberToBytesBE: mc,
    bytesToNumberBE: Un,
    taggedHash: Cg,
    mod: Mr
  }
};
var wce = lce(Tc, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((e) => e.map((t) => BigInt(t))));
var vce = oce(Tc, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Tc.create(BigInt("-11"))
});
fce(ss.ProjectivePoint, (e) => {
  const { x: t, y: r } = vce(Tc.create(e[0]));
  return wce(t, r);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Tc.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: Pg
});
function _2(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Ece(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function GP(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function xce(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  _2(e.outputLen), _2(e.blockLen);
}
function kce(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ace(e, t) {
  GP(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var Sce = {
  number: _2,
  bool: Ece,
  bytes: GP,
  hash: xce,
  exists: kce,
  output: Ace
};
var Ry = Sce;
var zy = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var zi = (e, t) => e << 32 - t | e >>> t;
var _ce = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!_ce)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Tce(e) {
  if (typeof e != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof e}`);
  return new TextEncoder().encode(e);
}
function WP(e) {
  if (typeof e == "string" && (e = Tce(e)), !(e instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
  return e;
}
var Pce = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function ZP(e) {
  const t = (n) => e().update(WP(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function Ice(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var Oce = class extends Pce {
  constructor(e, t, r, n) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = zy(this.buffer);
  }
  update(e) {
    Ry.exists(this);
    const { view: t, buffer: r, blockLen: n } = this;
    e = WP(e);
    const o = e.length;
    for (let i = 0; i < o; ) {
      const s = Math.min(n - this.pos, o - i);
      if (s === n) {
        const a = zy(e);
        for (; n <= o - i; i += n)
          this.process(a, i);
        continue;
      }
      r.set(e.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === n && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Ry.exists(this), Ry.output(e, this), this.finished = true;
    const { buffer: t, view: r, blockLen: n, isLE: o } = this;
    let { pos: i } = this;
    t[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > n - i && (this.process(r, 0), i = 0);
    for (let l = i; l < n; l++)
      t[l] = 0;
    Ice(r, n - 8, BigInt(this.length * 8), o), this.process(r, 0);
    const s = zy(e), a = this.outputLen;
    if (a % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = a / 4, u = this.get();
    if (c > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let l = 0; l < c; l++)
      s.setUint32(4 * l, u[l], o);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const r = e.slice(0, t);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s } = this;
    return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;
  }
};
var Bce = (e, t, r) => e & t ^ ~e & r;
var Cce = (e, t, r) => e & t ^ e & r ^ t & r;
var Nce = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Da = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Ka = new Uint32Array(64);
var XP = class extends Oce {
  constructor() {
    super(64, 32, 8, false), this.A = Da[0] | 0, this.B = Da[1] | 0, this.C = Da[2] | 0, this.D = Da[3] | 0, this.E = Da[4] | 0, this.F = Da[5] | 0, this.G = Da[6] | 0, this.H = Da[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a } = this;
    return [e, t, r, n, o, i, s, a];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = i | 0, this.G = s | 0, this.H = a | 0;
  }
  process(e, t) {
    for (let l = 0; l < 16; l++, t += 4)
      Ka[l] = e.getUint32(t, false);
    for (let l = 16; l < 64; l++) {
      const f = Ka[l - 15], d = Ka[l - 2], m = zi(f, 7) ^ zi(f, 18) ^ f >>> 3, y = zi(d, 17) ^ zi(d, 19) ^ d >>> 10;
      Ka[l] = y + Ka[l - 7] + m + Ka[l - 16] | 0;
    }
    let { A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: u } = this;
    for (let l = 0; l < 64; l++) {
      const f = zi(s, 6) ^ zi(s, 11) ^ zi(s, 25), d = u + f + Bce(s, a, c) + Nce[l] + Ka[l] | 0, m = (zi(r, 2) ^ zi(r, 13) ^ zi(r, 22)) + Cce(r, n, o) | 0;
      u = c, c = a, a = s, s = i + d | 0, i = o, o = n, n = r, r = d + m | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, o, i, s, a, c, u);
  }
  roundClean() {
    Ka.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Uce = class extends XP {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var T2 = ZP(() => new XP());
ZP(() => new Uce());
function $ce(e, t) {
  if (e.length > t)
    throw new TypeError(`Data is larger than array size: ${e.length} > ${t}`);
}
function Rce(e) {
  if (e.match(/[^a-fA-f0-9]/) !== null)
    throw new TypeError("Invalid characters in hex string: " + e);
  if (e.length % 2 !== 0)
    throw new Error(`Length of hex string is invalid: ${e.length}`);
}
function zce(e) {
  if (e > Number.MAX_SAFE_INTEGER)
    throw new TypeError("Number exceeds safe bounds!");
}
var { getRandomValues: Hce } = crypto ?? globalThis.crypto ?? window.crypto;
function Lce(e = 32) {
  if (typeof Hce == "function")
    return crypto.getRandomValues(new Uint8Array(e));
  throw new Error("Crypto module missing getRandomValues!");
}
function jce(e, t, r = "be") {
  t === void 0 && (t = e.length), $ce(e, t);
  const n = new Uint8Array(t).fill(0), o = r === "be" ? 0 : t - e.length;
  return n.set(e, o), n;
}
function YP(e) {
  let t, r = 0;
  const n = e.reduce((i, s) => i + s.length, 0), o = new Uint8Array(n);
  for (t = 0; t < e.length; t++) {
    const i = e[t];
    o.set(i, r), r += i.length;
  }
  return o;
}
var Fce = new TextEncoder();
var Dce = [
  {
    name: "base58",
    charset: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }
];
function JP(e) {
  for (const t of Dce)
    if (t.name === e)
      return t.charset;
  throw TypeError("Charset does not exist: " + e);
}
function Kce(e, t, r = false) {
  typeof e == "string" && (e = Fce.encode(e));
  const n = JP(t), o = n.length, i = [];
  let s = "", a, c = 0, u, l;
  for (a = 0; a < e.length; a++)
    for (c = 0, u = e[a], s += u > 0 || (s.length ^ a) > 0 ? "" : "1"; c in i || u > 0; )
      l = i[c], l = l > 0 ? l * 256 + u : u, u = l / o | 0, i[c] = l % o, c++;
  for (; c-- > 0; )
    s += n[i[c]];
  return r && s.length % 4 > 0 ? s + "=".repeat(4 - s.length % 4) : s;
}
function Mce(e, t) {
  const r = JP(t), n = r.length, o = [], i = [];
  e = e.replace("=", "");
  let s, a = 0, c, u;
  for (s = 0; s < e.length; s++) {
    if (a = 0, c = r.indexOf(e[s]), c < 0)
      throw new Error(`Character range out of bounds: ${c}`);
    for (c > 0 || (i.length ^ s) > 0 || i.push(0); a in o || c > 0; )
      u = o[a], u = u > 0 ? u * n + c : c, c = u >> 8, o[a] = u % 256, a++;
  }
  for (; a-- > 0; )
    i.push(o[a]);
  return new Uint8Array(i);
}
function QP(e) {
  return T2(T2(e));
}
function qce(e) {
  const t = QP(e);
  return YP([e, t.slice(0, 4)]);
}
function Vce(e) {
  const t = e.slice(0, -4), r = e.slice(-4);
  if (QP(t).slice(0, 4).toString() !== r.toString())
    throw new Error("Invalid checksum!");
  return t;
}
var CE = {
  encode: Kce,
  decode: Mce
};
var eI = {
  encode: (e) => {
    const t = qce(e);
    return CE.encode(t, "base58");
  },
  decode: (e) => {
    const t = CE.decode(e, "base58");
    return Vce(t);
  }
};
var tI = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var Gce = [996825010, 642813549, 513874426, 1027748829, 705979059];
var Ng = [
  { version: 0, name: "bech32", const: 1 },
  { version: 1, name: "bech32m", const: 734539939 }
];
function rI(e) {
  let t = 1;
  for (let r = 0; r < e.length; ++r) {
    const n = t >> 25;
    t = (t & 33554431) << 5 ^ e[r];
    for (let o = 0; o < 5; ++o)
      n >> o & 1 && (t ^= Gce[o]);
  }
  return t;
}
function nI(e) {
  const t = [];
  let r;
  for (r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) >> 5);
  for (t.push(0), r = 0; r < e.length; ++r)
    t.push(e.charCodeAt(r) & 31);
  return t;
}
function Wce(e, t, r) {
  const n = nI(e).concat(t);
  return rI(n) === r.const;
}
function Zce(e, t, r) {
  const n = nI(e).concat(t).concat([0, 0, 0, 0, 0, 0]), o = rI(n) ^ r.const, i = [];
  for (let s = 0; s < 6; ++s)
    i.push(o >> 5 * (5 - s) & 31);
  return i;
}
function oI(e, t, r, n = true) {
  const o = [];
  let i = 0, s = 0;
  const a = (1 << r) - 1, c = (1 << t + r - 1) - 1;
  for (const u of e) {
    if (u < 0 || u >> t > 0)
      throw new Error("Failed to perform base conversion. Invalid value: " + String(u));
    for (i = (i << t | u) & c, s += t; s >= r; )
      s -= r, o.push(i >> s & a);
  }
  if (n)
    s > 0 && o.push(i << r - s & a);
  else if (s >= t || (i << r - s & a) > 0)
    throw new Error("Failed to perform base conversion. Invalid Size!");
  return o;
}
function Xce(e, t, r) {
  const n = t.concat(Zce(e, t, r));
  let o = e + "1";
  for (let i = 0; i < n.length; ++i)
    o += tI.charAt(n[i]);
  return o;
}
function iI(e) {
  if (!Yce(e))
    throw new Error("Encoded string goes out of bounds!");
  if (e = e.toLowerCase(), !Jce(e))
    throw new Error("Encoded string has invalid separator!");
  const t = [], r = e.lastIndexOf("1"), n = e.substring(0, r);
  for (let i = r + 1; i < e.length; ++i) {
    const s = tI.indexOf(e.charAt(i));
    if (s === -1)
      throw new Error("Character idx out of bounds: " + String(i));
    t.push(s);
  }
  const o = Ng.find((i) => i.version === t[0]) ?? Ng[0];
  if (!Wce(n, t, o))
    throw new Error("Checksum verification failed!");
  return [n, t.slice(0, t.length - 6)];
}
function Yce(e) {
  let t, r, n = false, o = false;
  for (t = 0; t < e.length; ++t) {
    if (r = e.charCodeAt(t), r < 33 || r > 126)
      return false;
    r >= 97 && r <= 122 && (n = true), r >= 65 && r <= 90 && (o = true);
  }
  return !(n && o);
}
function Jce(e) {
  const t = e.lastIndexOf("1");
  return !(t < 1 || t + 7 > e.length || e.length > 90);
}
function Qce(e, t = "bc", r = 0) {
  const n = [r, ...oI([...e], 8, 5)], o = Ng.find((s) => s.version === r) ?? Ng[0], i = Xce(t, n, o);
  return sI(i), i;
}
function sI(e) {
  e = e.toLowerCase();
  const t = e.split("1", 1)[0], [r, n] = iI(e), o = oI(n.slice(1), 5, 8, false), i = o.length;
  switch (true) {
    case t !== r:
      throw new Error("Returned hrp string is invalid.");
    case (o === null || i < 2 || i > 40):
      throw new Error("Decoded string is invalid or out of spec.");
    case n[0] > 16:
      throw new Error("Returned version bit is out of range.");
    default:
      return Uint8Array.from(o);
  }
}
function eue(e) {
  e = e.toLowerCase();
  const [t, r] = iI(e);
  return r[0];
}
var aI = {
  encode: Qce,
  decode: sI,
  version: eue
};
var cI = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var uI = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
var tue = new TextEncoder();
function lI(e, t = false, r = true) {
  typeof e == "string" && (e = tue.encode(e));
  const n = t ? uI : cI;
  let o = "", i = 0, s = 0;
  for (let a = 0; a < e.length; a++)
    for (s = s << 8 | e[a], i += 8; i >= 6; )
      i -= 6, o += n[s >> i & 63];
  if (i > 0)
    for (s <<= 6 - i, o += n[s & 63]; i < 6; )
      o += r ? "=" : "", i += 2;
  return o;
}
function fI(e, t = false) {
  const r = t || e.includes("-") || e.includes("_") ? uI.split("") : cI.split("");
  e = e.replace(/=+$/, "");
  const n = e.split("");
  let o = 0, i = 0;
  const s = [];
  for (let a = 0; a < n.length; a++) {
    const c = n[a], u = r.indexOf(c);
    if (u === -1)
      throw new Error("Invalid character: " + c);
    o += 6, i <<= 6, i |= u, o >= 8 && (o -= 8, s.push(i >>> o & 255));
  }
  return new Uint8Array(s);
}
var dI = {
  encode: lI,
  decode: fI
};
var hI = {
  encode: (e) => lI(e, true, false),
  decode: (e) => fI(e, true)
};
var rue = BigInt(0);
var nue = BigInt(255);
var pI = BigInt(256);
function oue(e) {
  if (e <= 0xffn)
    return 1;
  if (e <= 0xffffn)
    return 2;
  if (e <= 0xffffffffn)
    return 4;
  if (e <= 0xffffffffffffffffn)
    return 8;
  if (e <= 0xffffffffffffffffffffffffffffffffn)
    return 16;
  if (e <= 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)
    return 32;
  throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.");
}
function iue(e, t, r = "be") {
  t === void 0 && (t = oue(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > rue; ) {
    const a = e & nue, c = Number(a);
    n ? i.setUint8(s++, c) : i.setUint8(s--, c), e = (e - a) / pI;
  }
  return new Uint8Array(o);
}
function sue(e) {
  let t = BigInt(0);
  for (let r = e.length - 1; r >= 0; r--)
    t = t * pI + BigInt(e[r]);
  return BigInt(t);
}
function aue(e) {
  const t = e.split("").map(Number);
  if (t.length % 8 !== 0)
    throw new Error(`Binary array is invalid length: ${e.length}`);
  const r = new Uint8Array(t.length / 8);
  for (let n = 0, o = 0; n < t.length; n += 8, o++) {
    let i = 0;
    for (let s = 0; s < 8; s++)
      i |= t[n + s] << 7 - s;
    r[o] = i;
  }
  return r;
}
function cue(e) {
  const t = new Array(e.length * 8);
  let r = 0;
  for (const n of e) {
    if (n > 255)
      throw new Error(`Invalid byte value: ${n}. Byte values must be between 0 and 255.`);
    for (let o = 7; o >= 0; o--, r++)
      t[r] = n >> o & 1;
  }
  return t.join("");
}
function uue(e) {
  if (e <= 255)
    return 1;
  if (e <= 65535)
    return 2;
  if (e <= 4294967295)
    return 4;
  throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!");
}
function lue(e, t, r = "be") {
  t === void 0 && (t = uue(e));
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (; e > 0; ) {
    const a = e & 255;
    n ? i.setUint8(s++, e) : i.setUint8(s--, e), e = (e - a) / 256;
  }
  return new Uint8Array(o);
}
function fue(e) {
  let t = 0;
  for (let r = e.length - 1; r >= 0; r--)
    t = t * 256 + e[r], zce(t);
  return t;
}
var due = new TextEncoder();
var hue = new TextDecoder();
function _8(e) {
  return due.encode(e);
}
function P2(e) {
  return hue.decode(e);
}
function pue(e, t) {
  Rce(e);
  const r = e.length / 2;
  if (t === void 0 && (t = r), r > t)
    throw new TypeError(`Hex string is larger than array size: ${r} > ${t}`);
  return t;
}
function gue(e, t, r = "le") {
  t = pue(e, t);
  const n = r === "le", o = new ArrayBuffer(t), i = new DataView(o);
  let s = n ? 0 : t - 1;
  for (let a = 0; a < e.length; a += 2) {
    const c = e.substring(a, a + 2), u = parseInt(c, 16);
    n ? i.setUint8(s++, u) : i.setUint8(s--, u);
  }
  return new Uint8Array(o);
}
function mue(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function bue(e) {
  const t = JSON.stringify(e, (r, n) => typeof n == "bigint" ? `${n}n` : n);
  return _8(t);
}
function yue(e, t, r) {
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof Uint8Array)
    return jce(e, t, r);
  if (typeof e == "string")
    return gue(e, t, r);
  if (typeof e == "bigint")
    return iue(e, t, r);
  if (typeof e == "number")
    return lue(e, t, r);
  if (typeof e == "boolean")
    return Uint8Array.of(e ? 1 : 0);
  throw TypeError("Unsupported format:" + typeof e);
}
var _n = class Yt extends Uint8Array {
  static random(t = 32) {
    const r = Lce(t);
    return new Yt(r, t);
  }
  constructor(t, r, n) {
    const o = yue(t, r, n);
    super(o);
  }
  get arr() {
    return [...this];
  }
  get num() {
    return this.toNum();
  }
  get big() {
    return this.toBig();
  }
  get str() {
    return this.toStr();
  }
  get hex() {
    return this.toHex();
  }
  get raw() {
    return new Uint8Array(this);
  }
  get bin() {
    return this.toBin();
  }
  get b58chk() {
    return this.tob58chk();
  }
  get base64() {
    return this.toBase64();
  }
  get b64url() {
    return this.toB64url();
  }
  get digest() {
    return this.toHash();
  }
  get id() {
    return this.toHash().hex;
  }
  get stream() {
    return new Bue(this);
  }
  toNum(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return fue(r);
  }
  toBin() {
    return cue(this);
  }
  toBig(t = "be") {
    const r = t === "be" ? this.reverse() : this;
    return sue(r);
  }
  toHash() {
    const t = T2(this);
    return new Yt(t);
  }
  toJson() {
    const t = P2(this);
    return JSON.parse(t);
  }
  toBech32(t, r = 0) {
    return aI.encode(this, t, r);
  }
  toStr() {
    return P2(this);
  }
  toHex() {
    return mue(this);
  }
  toBytes() {
    return new Uint8Array(this);
  }
  tob58chk() {
    return eI.encode(this);
  }
  toBase64() {
    return dI.encode(this);
  }
  toB64url() {
    return hI.encode(this);
  }
  prepend(t) {
    return Yt.join([Yt.bytes(t), this]);
  }
  append(t) {
    return Yt.join([this, Yt.bytes(t)]);
  }
  slice(t, r) {
    const n = new Uint8Array(this).slice(t, r);
    return new Yt(n);
  }
  subarray(t, r) {
    const n = new Uint8Array(this).subarray(t, r);
    return new Yt(n);
  }
  reverse() {
    const t = new Uint8Array(this).reverse();
    return new Yt(t);
  }
  write(t, r) {
    const n = Yt.bytes(t);
    this.set(n, r);
  }
  prefixSize(t) {
    const r = Yt.varInt(this.length, t);
    return Yt.join([r, this]);
  }
  static from(t) {
    return new Yt(Uint8Array.from(t));
  }
  static of(...t) {
    return new Yt(Uint8Array.of(...t));
  }
  static join(t) {
    const r = t.map((o) => Yt.bytes(o)), n = YP(r);
    return new Yt(n);
  }
  static varInt(t, r) {
    if (t < 253)
      return Yt.num(t, 1);
    if (t < 65536)
      return Yt.of(253, ...Yt.num(t, 2, r));
    if (t < 4294967296)
      return Yt.of(254, ...Yt.num(t, 4, r));
    if (BigInt(t) < 0x10000000000000000n)
      return Yt.of(255, ...Yt.num(t, 8, r));
    throw new Error(`Value is too large: ${t}`);
  }
};
_n.num = wue, _n.big = Eue, _n.bin = vue, _n.raw = xue, _n.str = kue, _n.hex = Aue, _n.bytes = Sue, _n.json = _ue, _n.base64 = Tue, _n.b64url = Pue, _n.bech32 = Iue, _n.b58chk = Oue, _n.encode = _8, _n.decode = P2;
var Ve = _n;
function wue(e, t, r) {
  return new Ve(e, t, r);
}
function vue(e, t, r) {
  return new Ve(aue(e), t, r);
}
function Eue(e, t, r) {
  return new Ve(e, t, r);
}
function xue(e, t, r) {
  return new Ve(e, t, r);
}
function kue(e, t, r) {
  return new Ve(_8(e), t, r);
}
function Aue(e, t, r) {
  return new Ve(e, t, r);
}
function Sue(e, t, r) {
  return new Ve(e, t, r);
}
function _ue(e) {
  return new Ve(bue(e));
}
function Tue(e) {
  return new Ve(dI.decode(e));
}
function Pue(e) {
  return new Ve(hI.decode(e));
}
function Iue(e) {
  return new Ve(aI.decode(e));
}
function Oue(e) {
  return new Ve(eI.decode(e));
}
var Bue = class {
  constructor(t) {
    this.data = Ve.bytes(t), this.size = this.data.length;
  }
  peek(t) {
    if (t > this.size)
      throw new Error(`Size greater than stream: ${t} > ${this.size}`);
    return new Ve(this.data.slice(0, t));
  }
  read(t) {
    t = t ?? this.readSize();
    const r = this.peek(t);
    return this.data = this.data.slice(t), this.size = this.data.length, r;
  }
  readSize(t) {
    const r = this.read(1).num;
    switch (true) {
      case (r >= 0 && r < 253):
        return r;
      case r === 253:
        return this.read(2).toNum(t);
      case r === 254:
        return this.read(4).toNum(t);
      case r === 255:
        return this.read(8).toNum(t);
      default:
        throw new Error(`Varint is out of range: ${r}`);
    }
  }
};
var Ug = ss.CURVE;
var T8 = Ug.n;
var Cue = Ug.p;
var Nue = { x: Ug.Gx, y: Ug.Gy };
var Uue = BigInt(0);
var $ue = BigInt(1);
var Rue = BigInt(2);
var zue = BigInt(3);
var Hue = BigInt(4);
var I2 = { N: T8, P: Cue, G: Nue, _0n: Uue, _1n: $ue, _2n: Rue, _3n: zue, _4n: Hue };
var ld = zP(T8, 32, true);
var gI = (e) => Mr(e, T8);
function P8(e, t = false) {
  if (t)
    throw new Error(e);
  return false;
}
function mI(e) {
  return Ve.random(e);
}
function Lue(e) {
  const t = Ve.bytes(e).big;
  return Ve.big(gI(t), 32);
}
var jue = Object.freeze({
  __proto__: null,
  fail: P8,
  mod_bytes: Lue,
  random: mI
});
var { N: Fue, P: d2e, _0n: Due } = I2;
function Kue(e, t, r) {
  const n = Ve.bytes(e);
  return n.length !== t ? P8(`Invalid byte size: ${n.hex} !== ${t}`, r) : true;
}
function Mue(e, t) {
  return typeof e == "bigint" && Due < e && e < Fue || P8("x value is not in the field!", t), true;
}
var NE = ss.ProjectivePoint;
var bI = class Rr extends Uint8Array {
  static mod(t) {
    return new Rr(t);
  }
  static is_valid(t, r) {
    const n = Ve.bytes(t, 32).big;
    return Mue(n, r);
  }
  constructor(t) {
    let r = que(t);
    r = gI(r), Rr.is_valid(r, true), super(Ve.big(r, 32), 32);
  }
  get buff() {
    return new Ve(this);
  }
  get raw() {
    return this.buff.raw;
  }
  get big() {
    return this.buff.big;
  }
  get hex() {
    return this.buff.hex;
  }
  get point() {
    return this.generate();
  }
  get hasOddY() {
    return this.point.hasOddY;
  }
  get negated() {
    return this.hasOddY ? this.negate() : this;
  }
  gt(t) {
    return new Rr(t).big > this.big;
  }
  lt(t) {
    return new Rr(t).big < this.big;
  }
  eq(t) {
    return new Rr(t).big === this.big;
  }
  ne(t) {
    return new Rr(t).big !== this.big;
  }
  add(t) {
    const r = Rr.mod(t), n = ld.add(this.big, r.big);
    return new Rr(n);
  }
  sub(t) {
    const r = Rr.mod(t), n = ld.sub(this.big, r.big);
    return new Rr(n);
  }
  mul(t) {
    const r = Rr.mod(t), n = ld.mul(this.big, r.big);
    return new Rr(n);
  }
  pow(t) {
    const r = Rr.mod(t), n = ld.pow(this.big, r.big);
    return new Rr(n);
  }
  div(t) {
    const r = Rr.mod(t), n = ld.div(this.big, r.big);
    return new Rr(n);
  }
  negate() {
    return new Rr(Rr.N - this.big);
  }
  generate() {
    const t = ss.ProjectivePoint.BASE.multiply(this.big);
    return tl.import(t);
  }
};
bI.N = ss.CURVE.n;
var Bn = bI;
var m0 = class Ir {
  static from_x(t) {
    let r = Vue(t);
    r.length === 32 && (r = r.prepend(2)), Kue(r, 33);
    const n = NE.fromHex(r.hex);
    return n.assertValidity(), new Ir(n.x, n.y);
  }
  static generate(t) {
    const r = Bn.mod(t), n = Ir.base.multiply(r.big);
    return Ir.import(n);
  }
  static import(t) {
    const r = t instanceof Ir ? { x: t.x.big, y: t.y.big } : { x: t.x, y: t.y };
    return new Ir(r.x, r.y);
  }
  constructor(t, r) {
    this._p = new NE(t, r, 1n), this.p.assertValidity();
  }
  get p() {
    return this._p;
  }
  get x() {
    return Ve.big(this.p.x, 32);
  }
  get y() {
    return Ve.big(this.p.y, 32);
  }
  get buff() {
    return Ve.raw(this.p.toRawBytes(true));
  }
  get raw() {
    return this.buff.raw;
  }
  get hex() {
    return this.buff.hex;
  }
  get hasEvenY() {
    return this.p.hasEvenY();
  }
  get hasOddY() {
    return !this.p.hasEvenY();
  }
  eq(t) {
    const r = t instanceof Ir ? t : Ir.from_x(t);
    return this.x.big === r.x.big && this.y.big === r.y.big;
  }
  add(t) {
    return t instanceof Ir ? Ir.import(this.p.add(t.p)) : Ir.import(this.p.add(Ir.generate(t).p));
  }
  sub(t) {
    return t instanceof Ir ? Ir.import(this.p.subtract(t.p)) : Ir.import(this.p.subtract(Ir.generate(t).p));
  }
  mul(t) {
    return t instanceof Ir ? Ir.import(this.p.multiply(t.x.big)) : Ir.import(this.p.multiply(Bn.mod(t).big));
  }
  negate() {
    return Ir.import(this.p.negate());
  }
};
m0.P = I2.P, m0.G = I2.G, m0.base = ss.ProjectivePoint.BASE;
var tl = m0;
function que(e) {
  if (e instanceof Bn)
    return e.big;
  if (e instanceof tl)
    return e.x.big;
  if (e instanceof Uint8Array)
    return Ve.raw(e).big;
  if (typeof e == "string")
    return Ve.hex(e).big;
  if (typeof e == "number")
    return Ve.num(e).big;
  if (typeof e == "bigint")
    return BigInt(e);
  throw TypeError("Invalid input type:" + typeof e);
}
function Vue(e) {
  if (e instanceof Bn)
    return e.point.buff;
  if (e instanceof tl)
    return e.buff;
  if (e instanceof Uint8Array || typeof e == "string")
    return Ve.bytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return Ve.bytes(e, 32);
  throw new TypeError(`Unknown type: ${typeof e}`);
}
function O2(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function Gue(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
function yI(e, ...t) {
  if (!(e instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);
}
function Wue(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  O2(e.outputLen), O2(e.blockLen);
}
function Zue(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Xue(e, t) {
  yI(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var Yue = {
  number: O2,
  bool: Gue,
  bytes: yI,
  hash: Wue,
  exists: Zue,
  output: Xue
};
var pu = Yue;
var Jue = (e) => e instanceof Uint8Array;
var Hy = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength);
var Hi = (e, t) => e << 32 - t | e >>> t;
var Que = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Que)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function ele(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function I8(e) {
  if (typeof e == "string" && (e = ele(e)), !Jue(e))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
var wI = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function rl(e) {
  const t = (n) => e().update(I8(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function tle(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var O8 = class extends wI {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = Hy(this.buffer);
  }
  update(t) {
    pu.exists(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = I8(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = Hy(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    pu.exists(this), pu.output(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    tle(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Hy(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
var rle = (e, t, r) => e & t ^ ~e & r;
var nle = (e, t, r) => e & t ^ e & r ^ t & r;
var ole = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Ma = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var qa = new Uint32Array(64);
var vI = class extends O8 {
  constructor() {
    super(64, 32, 8, false), this.A = Ma[0] | 0, this.B = Ma[1] | 0, this.C = Ma[2] | 0, this.D = Ma[3] | 0, this.E = Ma[4] | 0, this.F = Ma[5] | 0, this.G = Ma[6] | 0, this.H = Ma[7] | 0;
  }
  get() {
    const { A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a } = this;
    return [e, t, r, n, o, i, s, a];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a) {
    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = o | 0, this.F = i | 0, this.G = s | 0, this.H = a | 0;
  }
  process(e, t) {
    for (let l = 0; l < 16; l++, t += 4)
      qa[l] = e.getUint32(t, false);
    for (let l = 16; l < 64; l++) {
      const f = qa[l - 15], d = qa[l - 2], m = Hi(f, 7) ^ Hi(f, 18) ^ f >>> 3, y = Hi(d, 17) ^ Hi(d, 19) ^ d >>> 10;
      qa[l] = y + qa[l - 7] + m + qa[l - 16] | 0;
    }
    let { A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: u } = this;
    for (let l = 0; l < 64; l++) {
      const f = Hi(s, 6) ^ Hi(s, 11) ^ Hi(s, 25), d = u + f + rle(s, a, c) + ole[l] + qa[l] | 0, m = (Hi(r, 2) ^ Hi(r, 13) ^ Hi(r, 22)) + nle(r, n, o) | 0;
      u = c, c = a, a = s, s = i + d | 0, i = o, o = n, n = r, r = d + m | 0;
    }
    r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, o, i, s, a, c, u);
  }
  roundClean() {
    qa.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var ile = class extends vI {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var $g = rl(() => new vI());
rl(() => new ile());
var Wp = BigInt(2 ** 32 - 1);
var B2 = BigInt(32);
function EI(e, t = false) {
  return t ? { h: Number(e & Wp), l: Number(e >> B2 & Wp) } : { h: Number(e >> B2 & Wp) | 0, l: Number(e & Wp) | 0 };
}
function sle(e, t = false) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: i, l: s } = EI(e[o], t);
    [r[o], n[o]] = [i, s];
  }
  return [r, n];
}
var ale = (e, t) => BigInt(e >>> 0) << B2 | BigInt(t >>> 0);
var cle = (e, t, r) => e >>> r;
var ule = (e, t, r) => e << 32 - r | t >>> r;
var lle = (e, t, r) => e >>> r | t << 32 - r;
var fle = (e, t, r) => e << 32 - r | t >>> r;
var dle = (e, t, r) => e << 64 - r | t >>> r - 32;
var hle = (e, t, r) => e >>> r - 32 | t << 64 - r;
var ple = (e, t) => t;
var gle = (e, t) => e;
var mle = (e, t, r) => e << r | t >>> 32 - r;
var ble = (e, t, r) => t << r | e >>> 32 - r;
var yle = (e, t, r) => t << r - 32 | e >>> 64 - r;
var wle = (e, t, r) => e << r - 32 | t >>> 64 - r;
function vle(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
var Ele = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
var xle = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
var kle = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
var Ale = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
var Sle = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
var _le = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0;
var Tle = {
  fromBig: EI,
  split: sle,
  toBig: ale,
  shrSH: cle,
  shrSL: ule,
  rotrSH: lle,
  rotrSL: fle,
  rotrBH: dle,
  rotrBL: hle,
  rotr32H: ple,
  rotr32L: gle,
  rotlSH: mle,
  rotlSL: ble,
  rotlBH: yle,
  rotlBL: wle,
  add: vle,
  add3L: Ele,
  add3H: xle,
  add4L: kle,
  add4H: Ale,
  add5H: _le,
  add5L: Sle
};
var gt = Tle;
var [Ple, Ile] = gt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e)));
var Va = new Uint32Array(80);
var Ga = new Uint32Array(80);
var _m = class extends O8 {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: t, Bh: r, Bl: n, Ch: o, Cl: i, Dh: s, Dl: a, Eh: c, El: u, Fh: l, Fl: f, Gh: d, Gl: m, Hh: y, Hl: b } = this;
    return [e, t, r, n, o, i, s, a, c, u, l, f, d, m, y, b];
  }
  // prettier-ignore
  set(e, t, r, n, o, i, s, a, c, u, l, f, d, m, y, b) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n | 0, this.Ch = o | 0, this.Cl = i | 0, this.Dh = s | 0, this.Dl = a | 0, this.Eh = c | 0, this.El = u | 0, this.Fh = l | 0, this.Fl = f | 0, this.Gh = d | 0, this.Gl = m | 0, this.Hh = y | 0, this.Hl = b | 0;
  }
  process(e, t) {
    for (let k = 0; k < 16; k++, t += 4)
      Va[k] = e.getUint32(t), Ga[k] = e.getUint32(t += 4);
    for (let k = 16; k < 80; k++) {
      const x = Va[k - 15] | 0, _ = Ga[k - 15] | 0, I = gt.rotrSH(x, _, 1) ^ gt.rotrSH(x, _, 8) ^ gt.shrSH(x, _, 7), P = gt.rotrSL(x, _, 1) ^ gt.rotrSL(x, _, 8) ^ gt.shrSL(x, _, 7), $ = Va[k - 2] | 0, L = Ga[k - 2] | 0, V = gt.rotrSH($, L, 19) ^ gt.rotrBH($, L, 61) ^ gt.shrSH($, L, 6), ee = gt.rotrSL($, L, 19) ^ gt.rotrBL($, L, 61) ^ gt.shrSL($, L, 6), G = gt.add4L(P, ee, Ga[k - 7], Ga[k - 16]), N = gt.add4H(G, I, V, Va[k - 7], Va[k - 16]);
      Va[k] = N | 0, Ga[k] = G | 0;
    }
    let { Ah: r, Al: n, Bh: o, Bl: i, Ch: s, Cl: a, Dh: c, Dl: u, Eh: l, El: f, Fh: d, Fl: m, Gh: y, Gl: b, Hh: w, Hl: v } = this;
    for (let k = 0; k < 80; k++) {
      const x = gt.rotrSH(l, f, 14) ^ gt.rotrSH(l, f, 18) ^ gt.rotrBH(l, f, 41), _ = gt.rotrSL(l, f, 14) ^ gt.rotrSL(l, f, 18) ^ gt.rotrBL(l, f, 41), I = l & d ^ ~l & y, P = f & m ^ ~f & b, $ = gt.add5L(v, _, P, Ile[k], Ga[k]), L = gt.add5H($, w, x, I, Ple[k], Va[k]), V = $ | 0, ee = gt.rotrSH(r, n, 28) ^ gt.rotrBH(r, n, 34) ^ gt.rotrBH(r, n, 39), G = gt.rotrSL(r, n, 28) ^ gt.rotrBL(r, n, 34) ^ gt.rotrBL(r, n, 39), N = r & o ^ r & s ^ o & s, q = n & i ^ n & a ^ i & a;
      w = y | 0, v = b | 0, y = d | 0, b = m | 0, d = l | 0, m = f | 0, { h: l, l: f } = gt.add(c | 0, u | 0, L | 0, V | 0), c = s | 0, u = a | 0, s = o | 0, a = i | 0, o = r | 0, i = n | 0;
      const j = gt.add3L(V, G, q);
      r = gt.add3H(j, L, ee, N), n = j | 0;
    }
    ({ h: r, l: n } = gt.add(this.Ah | 0, this.Al | 0, r | 0, n | 0)), { h: o, l: i } = gt.add(this.Bh | 0, this.Bl | 0, o | 0, i | 0), { h: s, l: a } = gt.add(this.Ch | 0, this.Cl | 0, s | 0, a | 0), { h: c, l: u } = gt.add(this.Dh | 0, this.Dl | 0, c | 0, u | 0), { h: l, l: f } = gt.add(this.Eh | 0, this.El | 0, l | 0, f | 0), { h: d, l: m } = gt.add(this.Fh | 0, this.Fl | 0, d | 0, m | 0), { h: y, l: b } = gt.add(this.Gh | 0, this.Gl | 0, y | 0, b | 0), { h: w, l: v } = gt.add(this.Hh | 0, this.Hl | 0, w | 0, v | 0), this.set(r, n, o, i, s, a, c, u, l, f, d, m, y, b, w, v);
  }
  roundClean() {
    Va.fill(0), Ga.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Ole = class extends _m {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
var Ble = class extends _m {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
var Cle = class extends _m {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
var Nle = rl(() => new _m());
rl(() => new Ole());
rl(() => new Ble());
rl(() => new Cle());
var Ule = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var xI = Uint8Array.from({ length: 16 }, (e, t) => t);
var $le = xI.map((e) => (9 * e + 5) % 16);
var B8 = [xI];
var C8 = [$le];
for (let e = 0; e < 4; e++)
  for (let t of [B8, C8])
    t.push(t[e].map((r) => Ule[r]));
var kI = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => new Uint8Array(e));
var Rle = B8.map((e, t) => e.map((r) => kI[t][r]));
var zle = C8.map((e, t) => e.map((r) => kI[t][r]));
var Hle = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var Lle = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
var Zp = (e, t) => e << t | e >>> 32 - t;
function UE(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
var Xp = new Uint32Array(16);
var jle = class extends O8 {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: o, h4: i } = this;
    return [t, r, n, o, i];
  }
  set(t, r, n, o, i) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = o | 0, this.h4 = i | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4)
      Xp[m] = t.getUint32(r, true);
    let n = this.h0 | 0, o = n, i = this.h1 | 0, s = i, a = this.h2 | 0, c = a, u = this.h3 | 0, l = u, f = this.h4 | 0, d = f;
    for (let m = 0; m < 5; m++) {
      const y = 4 - m, b = Hle[m], w = Lle[m], v = B8[m], k = C8[m], x = Rle[m], _ = zle[m];
      for (let I = 0; I < 16; I++) {
        const P = Zp(n + UE(m, i, a, u) + Xp[v[I]] + b, x[I]) + f | 0;
        n = f, f = u, u = Zp(a, 10) | 0, a = i, i = P;
      }
      for (let I = 0; I < 16; I++) {
        const P = Zp(o + UE(y, s, c, l) + Xp[k[I]] + w, _[I]) + d | 0;
        o = d, d = l, l = Zp(c, 10) | 0, c = s, s = P;
      }
    }
    this.set(this.h1 + a + l | 0, this.h2 + u + d | 0, this.h3 + f + o | 0, this.h4 + n + s | 0, this.h0 + i + c | 0);
  }
  roundClean() {
    Xp.fill(0);
  }
  destroy() {
    this.destroyed = true, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
var Fle = rl(() => new jle());
var AI = class extends wI {
  constructor(t, r) {
    super(), this.finished = false, this.destroyed = false, pu.hash(t);
    const n = I8(r);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, i = new Uint8Array(o);
    i.set(n.length > o ? t.create().update(n).digest() : n);
    for (let s = 0; s < i.length; s++)
      i[s] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let s = 0; s < i.length; s++)
      i[s] ^= 106;
    this.oHash.update(i), i.fill(0);
  }
  update(t) {
    return pu.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    pu.exists(this), pu.bytes(t, this.outputLen), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: r, iHash: n, finished: o, destroyed: i, blockLen: s, outputLen: a } = this;
    return t = t, t.finished = o, t.destroyed = i, t.blockLen = s, t.outputLen = a, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var SI = (e, t, r) => new AI(e, t).update(r).digest();
SI.create = (e, t) => new AI(e, t);
function Dle(e) {
  const t = Ve.bytes(e);
  return Ve.raw($g(t));
}
function hf(e) {
  const t = Ve.bytes(e);
  return Ve.raw($g($g(t)));
}
function N8(e) {
  const t = Ve.bytes(e);
  return Ve.raw(Fle($g(t)));
}
function Kle(e, t) {
  const r = Ve.bytes(e), n = Ve.bytes(t);
  return Ve.raw(SI(Nle, r, n));
}
function Mle(e) {
  const t = Ve.str(e).digest;
  return Ve.join([t, t]);
}
function qle(e = 32) {
  return U8(mI(e));
}
function U8(e) {
  return Bn.mod(e).buff;
}
function _I(e, t = false) {
  const r = Bn.mod(e).point;
  return t ? r.x : r.buff;
}
function TI(e, t) {
  const r = tl.from_x(t), n = Bn.mod(e);
  return r.mul(n).buff;
}
function Vle(e, t, r = "ecdh/code") {
  const n = Mle(r), o = U8(e), i = _I(o), s = Ve.bytes(t), a = TI(o, s), c = [i.hex, s.hex];
  return c.sort(), Kle(a, Ve.join([n, ...c]));
}
function Gle(e) {
  const t = Ve.bytes(e);
  switch (true) {
    case t.length === 32:
      return true;
    case (t.length === 33 && t[0] === 2):
      return true;
    case (t.length === 33 && t[0] === 3):
      return false;
    default:
      throw new TypeError(`Invalid public key: ${t.hex}`);
  }
}
function Wle(e) {
  const t = Ve.bytes(e);
  switch (t.length) {
    case 32:
      return t;
    case 33:
      return t.slice(1, 33);
    default:
      throw new Error(`Invalid key length: ${t.length}`);
  }
}
var Zle = Object.freeze({
  __proto__: null,
  genSecretKey: qle,
  getPublicKey: _I,
  getSecretKey: U8,
  getSharedCode: Vle,
  getSharedKey: TI,
  is_even_pub: Gle,
  xonly_pub: Wle
});
Ve.random(32);
var PI = { secp: ss, schnorr: yce };
var C2 = { ...Zle, ...jue };
function Tm(e) {
  const t = Z.bytes(e);
  return is(t, 33), N8(t);
}
function II(e) {
  const t = Hn.fmt.toBytes(e, false);
  return N8(t);
}
function OI(e) {
  const t = Hn.fmt.toBytes(e, false);
  return Dle(t);
}
function BI(e, t = "main") {
  const r = t === "main" ? ["1"] : ["m", "n"];
  for (const n of r)
    if (e.startsWith(n))
      return true;
  return false;
}
function CI(e, t = "main") {
  const r = Z.bytes(e), n = t === "main" ? Z.num(0) : Z.num(111);
  return is(e, 20), r.prepend(n).tob58chk();
}
function Xle(e, t = "main") {
  if (!BI(e, t))
    throw new TypeError("Invalid p2pkh address!");
  return Z.b58chk(e).slice(1);
}
function Yle(e) {
  const t = Z.bytes(e);
  return is(t, 20), ["OP_DUP", "OP_HASH160", t.hex, "OP_EQUALVERIFY", "OP_CHECKSIG"];
}
function Jle(e, t) {
  const r = Tm(e);
  return CI(r, t);
}
var NI = { check: BI, encode: CI, decode: Xle, hash: Tm, scriptPubKey: Yle, fromPubKey: Jle };
function UI(e, t = "main") {
  const r = t === "main" ? ["3"] : ["2"];
  for (const n of r)
    if (e.startsWith(n))
      return true;
  return false;
}
function $I(e, t = "main") {
  const r = t === "main" ? Z.num(5) : Z.num(196), n = Z.bytes(e);
  return is(n, 20), n.prepend(r).tob58chk();
}
function Qle(e, t = "main") {
  if (!UI(e, t))
    throw new TypeError(`Invalid p2sh address for network ${t}:` + e);
  return Z.b58chk(e).slice(1);
}
function efe(e) {
  return ["OP_HASH160", Z.bytes(e).hex, "OP_EQUAL"];
}
function tfe(e, t) {
  const r = II(e);
  return $I(r, t);
}
var RI = { check: UI, encode: $I, decode: Qle, hash: II, scriptPubKey: efe, fromScript: tfe };
var $8 = {
  main: "bc",
  testnet: "tb",
  signet: "tb",
  regtest: "bcrt"
};
var rfe = ["bc1q", "tb1q", "bcrt1q"];
function zI(e) {
  for (const t of rfe)
    if (e.startsWith(t))
      return true;
  return false;
}
function HI(e, t = "main") {
  const r = $8[t], n = Z.bytes(e);
  return is(n, 20), n.toBech32(r, 0);
}
function nfe(e) {
  if (!zI(e))
    throw new TypeError("Invalid segwit address!");
  return Z.bech32(e);
}
function ofe(e) {
  const t = Z.bytes(e);
  return is(t, 20), ["OP_0", t.hex];
}
function ife(e, t) {
  const r = Tm(e);
  return HI(r, t);
}
var LI = { check: zI, encode: HI, decode: nfe, hash: Tm, scriptPubKey: ofe, fromPubKey: ife };
var sfe = ["bc1q", "tb1q", "bcrt1q"];
function jI(e) {
  for (const t of sfe)
    if (e.startsWith(t))
      return true;
  return false;
}
function FI(e, t = "main") {
  const r = $8[t], n = Z.bytes(e);
  return is(n, 32), n.toBech32(r, 0);
}
function afe(e) {
  if (!jI(e))
    throw new TypeError("Invalid segwit address!");
  return Z.bech32(e);
}
function cfe(e) {
  const t = Z.bytes(e);
  return is(t, 32), ["OP_0", t.hex];
}
function ufe(e, t) {
  const r = OI(e);
  return FI(r, t);
}
var DI = { check: jI, encode: FI, decode: afe, hash: OI, scriptPubKey: cfe, fromScript: ufe };
function zu(e) {
  const t = Z.bytes(e);
  return t.length > 32 ? t.slice(1, 33) : t;
}
var lfe = ["bc1p", "tb1p", "bcrt1p"];
function KI(e) {
  for (const t of lfe)
    if (e.startsWith(t))
      return true;
  return false;
}
function MI(e, t = "main") {
  const r = $8[t], n = Z.bytes(e);
  return is(n, 32), n.toBech32(r, 1);
}
function ffe(e) {
  if (!KI(e))
    throw new TypeError("Invalid taproot address!");
  return Z.bech32(e);
}
function dfe(e) {
  const t = Z.bytes(e);
  return is(t, 32), ["OP_1", t.hex];
}
function hfe(e, t) {
  const r = zu(e);
  return MI(r, t);
}
var qI = { check: KI, encode: MI, decode: ffe, scriptPubKey: dfe, fromPubKey: hfe };
var pfe = {
  version: 2,
  vin: [],
  vout: [],
  locktime: 0
};
var gfe = {
  scriptSig: [],
  sequence: 4294967293,
  witness: []
};
var mfe = {
  value: 0n,
  scriptPubKey: []
};
function R8(e) {
  const t = { ...pfe, ...e };
  return t.vin = t.vin.map((r) => ({ ...gfe, ...r })), t.vout = t.vout.map((r) => ({ ...mfe, ...r })), t;
}
function pf(e, t) {
  const { version: r, vin: n, vout: o, locktime: i } = R8(e), s = t !== true && bfe(n), a = [z8(r)];
  s && a.push(Z.hex("0001")), a.push(yfe(n)), a.push(wfe(o));
  for (const c of n)
    s && a.push(Efe(c.witness));
  return a.push(H8(i)), Z.join(a);
}
function bfe(e) {
  for (const t of e) {
    const { witness: r } = t;
    if (typeof r == "string" || r instanceof Uint8Array || Array.isArray(r) && r.length > 0)
      return true;
  }
  return false;
}
function z8(e) {
  return Z.num(e, 4).reverse();
}
function ep(e) {
  return Z.hex(e, 32).reverse();
}
function tp(e) {
  return Z.num(e, 4).reverse();
}
function rp(e) {
  if (typeof e == "string")
    return Z.hex(e, 4).reverse();
  if (typeof e == "number")
    return Z.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function yfe(e) {
  const t = [Z.varInt(e.length, "le")];
  for (const r of e) {
    const { txid: n, vout: o, scriptSig: i, sequence: s } = r;
    t.push(ep(n)), t.push(tp(o)), t.push(el(i, true)), t.push(rp(s));
  }
  return Z.join(t);
}
function Pc(e) {
  if (typeof e == "number") {
    if (e % 1 !== 0)
      throw new Error("Value must be an integer:" + String(e));
    return Z.num(e, 8).reverse();
  }
  return Z.big(e, 8).reverse();
}
function wfe(e) {
  const t = [Z.varInt(e.length, "le")];
  for (const r of e)
    t.push(vfe(r));
  return Z.join(t);
}
function vfe(e) {
  const { value: t, scriptPubKey: r } = e, n = [];
  return n.push(Pc(t)), n.push(el(r, true)), Z.join(n);
}
function Efe(e = []) {
  const t = [];
  if (Array.isArray(e)) {
    const r = Z.varInt(e.length);
    t.push(r);
    for (const n of e)
      t.push(xfe(n));
    return Z.join(t);
  } else
    return Z.bytes(e);
}
function xfe(e) {
  return kfe(e) ? new Z(0) : el(e, true);
}
function kfe(e) {
  if (Array.isArray(e))
    return e.length === 0;
  if (typeof e == "string" && e === "")
    return true;
  const t = Z.bytes(e);
  return t.length === 1 && t[0] === 0;
}
function H8(e) {
  if (typeof e == "string")
    return Z.hex(e, 4);
  if (typeof e == "number")
    return Z.num(e, 4).reverse();
  throw new Error("Unrecognized format: " + String(e));
}
function L8(e) {
  typeof e == "string" && (e = Z.hex(e).raw);
  const t = new Hf(e), r = Afe(t), n = Sfe(t), o = _fe(t), i = Pfe(t);
  if (n)
    for (const a of o)
      a.witness = Ofe(t);
  const s = Bfe(t);
  return { version: r, vin: o, vout: i, locktime: s };
}
function Afe(e) {
  return e.read(4).reverse().toNum();
}
function Sfe(e) {
  const [t, r] = [...e.peek(2)];
  if (t === 0) {
    if (e.read(2), r === 1)
      return true;
    throw new Error(`Invalid witness flag: ${r}`);
  }
  return false;
}
function _fe(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(Tfe(e));
  return t;
}
function Tfe(e) {
  return {
    txid: e.read(32).reverse().toHex(),
    vout: e.read(4).reverse().toNum(),
    scriptSig: GI(e),
    sequence: e.read(4).reverse().toHex(),
    witness: []
  };
}
function Pfe(e) {
  const t = [], r = e.readSize("le");
  for (let n = 0; n < r; n++)
    t.push(Ife(e));
  return t;
}
function Ife(e) {
  return {
    value: e.read(8).reverse().big,
    scriptPubKey: GI(e)
  };
}
function Ofe(e) {
  const t = [], r = e.readSize();
  for (let n = 0; n < r; n++) {
    const o = VI(e);
    t.push(o ?? "");
  }
  return t;
}
function VI(e, t) {
  const r = e.readSize("le");
  return r > 0 ? e.read(r).hex : null;
}
function GI(e, t) {
  const r = VI(e);
  return r !== null ? r : [];
}
function Bfe(e) {
  return e.read(4).reverse().toNum();
}
function Cfe(e) {
  if (_P(e))
    return L8(e);
  if (typeof e == "object" && !(e instanceof Uint8Array))
    return pf(e), R8(e);
  throw new Error("Invalid format: " + typeof e);
}
function Nfe(e) {
  if (_P(e))
    return L8(e), Z.bytes(e);
  if (typeof e == "object")
    return pf(e);
  throw new Error("Invalid format: " + typeof e);
}
var j8 = {
  toBytes: Nfe,
  toJson: Cfe
};
var Ufe = [
  ["p2pkh", /^76a914(?<hash>\w{40})88ac$/],
  ["p2sh", /^a914(?<hash>\w{40})87$/],
  ["p2w-pkh", /^0014(?<hash>\w{40})$/],
  ["p2w-sh", /^0020(?<hash>\w{64})$/],
  ["p2tr", /^5120(?<hash>\w{64})$/]
];
var $fe = [
  192,
  194,
  196,
  198,
  200,
  202,
  204,
  206,
  208,
  210,
  212,
  214,
  216,
  218,
  220,
  222,
  224,
  226,
  228,
  230,
  232,
  234,
  236,
  238,
  240,
  242,
  244,
  246,
  248,
  250,
  252,
  254,
  102,
  126,
  128,
  132,
  150,
  152,
  186,
  188,
  190
];
function Rfe(e) {
  let t = e.at(-1);
  return na(t) && (t = Z.hex(t)), e.length > 1 && t instanceof Uint8Array && t[0] === 80 ? (e.pop(), Z.raw(t)) : null;
}
function zfe(e) {
  let t = e.at(-1);
  return na(t) && (t = Z.hex(t)), e.length > 1 && t instanceof Uint8Array && t.length > 32 && $fe.includes(t[0] & 254) ? (e.pop(), Z.raw(t)) : null;
}
function Hfe(e) {
  if (e.length > 1) {
    const t = e.at(-1);
    try {
      const r = Hn.fmt.toBytes(t);
      return e.pop(), r;
    } catch {
      return null;
    }
  }
  return null;
}
function Lfe(e) {
  const t = [];
  for (const r of e)
    if (na(r) || r instanceof Uint8Array || typeof r == "number")
      t.push(Z.bytes(r));
    else
      throw new Error("unrecognized value: " + String(r));
  return t;
}
function jfe(e = []) {
  const t = [...e], r = Rfe(t), n = zfe(t), o = Hfe(t), i = Lfe(t);
  return { annex: r, cblock: n, script: o, params: i };
}
function Ffe(e) {
  const t = Hn.fmt.toBytes(e, false).hex;
  for (const [r, n] of Ufe) {
    const o = r, { groups: i } = n.exec(t) ?? {}, { hash: s } = i ?? {};
    if (na(s))
      return { type: o, data: Z.hex(s) };
  }
  return { type: "raw", data: Z.hex(t) };
}
function Dfe(e) {
  const t = j8.toJson(e), r = pf(t, true);
  return hf(r).reverse().hex;
}
function Kfe(e) {
  const t = j8.toJson(e), r = pf(t, true).length, n = pf(t, false).length, o = r * 3 + n, i = o % 4 > 0 ? 1 : 0, s = Math.floor(o / 4) + i;
  return { size: n, bsize: r, vsize: s, weight: o };
}
var ui = {
  create: R8,
  encode: pf,
  decode: L8,
  fmt: j8,
  util: {
    getTxSize: Kfe,
    getTxid: Dfe,
    readScriptPubKey: Ffe,
    readWitness: jfe
  }
};
var Mfe = [
  ["1", "p2pkh", "main", 20, "base58"],
  ["3", "p2sh", "main", 20, "base58"],
  ["m", "p2pkh", "testnet", 20, "base58"],
  ["n", "p2pkh", "testnet", 20, "base58"],
  ["2", "p2sh", "testnet", 20, "base58"],
  ["bc1q", "p2w-pkh", "main", 20, "bech32"],
  ["tb1q", "p2w-pkh", "testnet", 20, "bech32"],
  ["bcrt1q", "p2w-pkh", "regtest", 20, "bech32"],
  ["bc1q", "p2w-sh", "main", 32, "bech32"],
  ["tb1q", "p2w-sh", "testnet", 32, "bech32"],
  ["bcrt1q", "p2w-sh", "regtest", 32, "bech32"],
  ["bc1p", "p2tr", "main", 32, "bech32m"],
  ["tb1p", "p2tr", "testnet", 32, "bech32m"],
  ["bcrt1p", "p2tr", "regtest", 32, "bech32m"]
];
function qfe(e, t) {
  switch (t) {
    case "base58":
      return Z.b58chk(e).slice(1);
    case "bech32":
      return Z.bech32(e);
    case "bech32m":
      return Z.bech32(e);
    default:
      throw new Error("Invalid address format: " + t);
  }
}
function Vfe(e) {
  for (const t of Mfe) {
    const [r, n, o, i, s] = t;
    if (e.startsWith(r) && qfe(e, s).length === i)
      return t;
  }
  throw new Error("Invalid address: " + e);
}
function WI(e) {
  switch (e) {
    case "p2pkh":
      return NI;
    case "p2sh":
      return RI;
    case "p2w-pkh":
      return LI;
    case "p2w-sh":
      return DI;
    case "p2tr":
      return qI;
    default:
      throw new Error("Invalid address type: " + e);
  }
}
function ZI(e) {
  const [t, r, n] = Vfe(e), o = WI(r), i = o.decode(e, n), s = o.scriptPubKey(i);
  return { prefix: t, type: r, network: n, data: i, script: s };
}
function Gfe(e, t) {
  const { type: r, data: n } = ui.util.readScriptPubKey(e);
  return WI(r).encode(n, t);
}
function Wfe(e) {
  const { script: t } = ZI(e);
  return Hn.fmt.toAsm(t, false);
}
var XI = {
  p2pkh: NI,
  p2sh: RI,
  p2wpkh: LI,
  p2wsh: DI,
  p2tr: qI,
  decode: ZI,
  fromScriptPubKey: Gfe,
  toScriptPubKey: Wfe
};
var Zfe = [1, 2, 3];
function F8(e, t, r = {}) {
  const { sigflag: n = 1 } = r, o = (n & 128) === 128, i = n % 128;
  if (!Zfe.includes(i))
    throw new Error("Invalid hash type: " + String(n));
  const s = ui.fmt.toJson(e), { version: a, vin: c, vout: u, locktime: l } = s, { txid: f, vout: d, prevout: m, sequence: y } = c[t], { value: b } = m ?? {};
  if (b === void 0)
    throw new Error("Prevout value is empty!");
  let w = r.script;
  if (w === void 0 && r.pubkey !== void 0 && (w = `76a914${N8(r.pubkey).hex}88ac`), w === void 0)
    throw new Error("No pubkey / script has been set!");
  if (Hn.fmt.toAsm(w).includes("OP_CODESEPARATOR"))
    throw new Error("This library does not currently support the use of OP_CODESEPARATOR in segwit scripts.");
  const v = [
    z8(a),
    Xfe(c, o),
    Yfe(c, i, o),
    ep(f),
    tp(d),
    Hn.encode(w, true),
    Pc(b),
    rp(y),
    Jfe(u, t, i),
    H8(l),
    Z.num(n, 4).reverse()
  ];
  return hf(Z.join(v));
}
function Xfe(e, t) {
  if (t === true)
    return Z.num(0, 32);
  const r = [];
  for (const { txid: n, vout: o } of e)
    r.push(ep(n)), r.push(tp(o));
  return hf(Z.join(r));
}
function Yfe(e, t, r) {
  if (r || t !== 1)
    return Z.num(0, 32);
  const n = [];
  for (const { sequence: o } of e)
    n.push(rp(o));
  return hf(Z.join(n));
}
function Jfe(e, t, r) {
  const n = [];
  if (r === 1) {
    for (const { value: o, scriptPubKey: i } of e)
      n.push(Pc(o)), n.push(Hn.encode(i, true));
    return hf(Z.join(n));
  }
  if (r === 3 && t < e.length) {
    const { value: o, scriptPubKey: i } = e[t];
    return n.push(Pc(o)), n.push(Hn.encode(i, true)), hf(Z.join(n));
  }
  return Z.num(0, 32);
}
function Qfe(e, t, r, n = {}) {
  const { sigflag: o = 1 } = n, i = F8(t, r, n), s = PI.secp.sign(i, e).toDERRawBytes(true);
  return Z.join([s, o]);
}
function ede(e, t, r = {}) {
  const n = ui.fmt.toJson(e), { throws: o = false } = r, { witness: i = [] } = n.vin[t], s = ui.util.readWitness(i), { script: a, params: c } = s;
  let u = null;
  if (c.length < 1)
    return yn("Invalid witness data: " + String(i), o);
  if (r.script === void 0 && a !== null && (r.script = a), r.pubkey !== void 0)
    u = Z.bytes(r.pubkey);
  else if (c.length > 1 && c[1].length === 33)
    u = Z.bytes(c[1]);
  else
    return yn("No pubkey provided!", o);
  const l = Hn.fmt.toParam(c[0]), f = l.slice(0, -1), d = l.slice(-1)[0], m = F8(n, t, { ...r, sigflag: d });
  return PI.secp.verify(f, m, u) ? true : yn("Invalid signature!", o);
}
var tde = {
  hash: F8,
  sign: Qfe,
  verify: ede
};
var rde = [0, 1, 2, 3, 129, 130, 131];
function D8(e, t, r = {}) {
  const { extension: n, sigflag: o = 0, extflag: i = 0, key_version: s = 0, separator_pos: a = 4294967295 } = r, c = ui.fmt.toJson(e), { version: u, vin: l, vout: f, locktime: d } = c;
  if (t >= l.length)
    throw new Error("Index out of bounds: " + String(t));
  if (!rde.includes(o))
    throw new Error("Invalid hash type: " + String(o));
  if (i < 0 || i > 127)
    throw new Error("Extention flag out of range: " + String(i));
  const { txid: m, vout: y, sequence: b, witness: w = [] } = l[t], v = (o & 128) === 128, k = ude(w), x = k !== void 0 ? 1 : 0, _ = (i + (n !== void 0 ? 1 : 0)) * 2 + x, I = Z.str("TapSighash").digest, P = [
    I,
    I,
    Z.num(0, 1),
    Z.num(o, 1),
    z8(u),
    H8(d)
  ];
  if (!v) {
    const $ = l.map((L) => $E(L));
    P.push(nde(l), ide($), sde($), ode(l));
  }
  if (((o & 3) < 2 || (o & 3) > 3) && P.push(ade(f)), P.push(Z.num(_, 1)), v) {
    const { value: $, scriptPubKey: L } = $E(l[t]);
    P.push(ep(m), tp(y), Pc($), Hn.encode(L, true), rp(b));
  } else
    P.push(Z.num(t, 4).reverse());
  return k !== void 0 && P.push(k), (o & 3) === 3 && P.push(cde(f[t])), n !== void 0 && P.push(Z.bytes(n), Z.num(s), Z.num(a, 4)), Z.join(P).digest;
}
function nde(e) {
  const t = [];
  for (const { txid: r, vout: n } of e)
    t.push(ep(r)), t.push(tp(n));
  return Z.join(t).digest;
}
function ode(e) {
  const t = [];
  for (const { sequence: r } of e)
    t.push(rp(r));
  return Z.join(t).digest;
}
function ide(e) {
  const t = [];
  for (const { value: r } of e)
    t.push(Pc(r));
  return Z.join(t).digest;
}
function sde(e) {
  const t = [];
  for (const { scriptPubKey: r } of e)
    t.push(el(r, true));
  return Z.join(t).digest;
}
function ade(e) {
  const t = [];
  for (const { value: r, scriptPubKey: n } of e)
    t.push(Pc(r)), t.push(Hn.encode(n, true));
  return Z.join(t).digest;
}
function cde(e) {
  return Z.join([
    Pc(e.value),
    Hn.encode(e.scriptPubKey, true)
  ]).digest;
}
function ude(e) {
  if (e === void 0 || e.length < 2)
    return;
  let t = e.at(-1);
  if (typeof t == "string" && (t = Z.hex(t)), t instanceof Uint8Array && t[0] === 80)
    return Z.raw(t).prefixSize("be").digest;
}
function $E(e) {
  if (e.prevout === void 0)
    throw new Error("Prevout data missing for input: " + String(e.txid));
  return e.prevout;
}
var lde = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
var fde = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
function dde(e, t, r, n = {}) {
  const { sigflag: o = 0 } = n, i = D8(t, r, n), s = hde(e, i);
  return o === 0 ? Z.raw(s) : Z.join([s, o]);
}
function hde(e, t, r = Z.random(32)) {
  const n = Z.bytes(t), o = new Bn(e), i = o.point, s = i.hasEvenY ? o.big : o.negated.big, a = g0("BIP0340/aux", Z.bytes(r)), c = s ^ a.big, u = g0("BIP0340/nonce", c, i.x.raw, n), l = new Bn(u), f = l.point, d = f.hasEvenY ? l.big : l.negated.big, m = new Bn(g0("BIP0340/challenge", f.x.raw, i.x.raw, n)), y = new Bn(d + m.big * s);
  return Z.join([f.x.raw, y.raw]);
}
function pde(e, t, r, n = false) {
  const o = tl.from_x(zu(r)), i = Z.bytes(t), s = Z.bytes(e).stream;
  s.size < 64 && yn("Signature length is too small: " + String(s.size), n);
  const a = s.read(32);
  a.big > lde && yn("Signature r value greater than field size!", n);
  const c = s.read(32);
  c.big > fde && yn("Signature s value greater than curve order!", n);
  const u = new Bn(g0("BIP0340/challenge", a.raw, o.x.raw, i)), l = new Bn(c).point, f = o.mul(u.big), d = l.sub(f);
  return d.hasOddY && yn("Signature R value has odd Y coordinate!", n), d.x.big === 0n && yn("Signature R value is infinite!", n), d.x.big === a.big;
}
var gde = 192;
function Pm(e) {
  const t = Z.str(e).digest;
  return Z.join([t, t]);
}
function K8(e, t = gde) {
  return Z.join([
    Pm("TapLeaf"),
    yde(t),
    Z.bytes(e)
  ]).digest.hex;
}
function mde(e, t) {
  return K8(Hn.fmt.toBytes(e), t);
}
function M8(e, t) {
  return t < e && ([e, t] = [t, e]), Z.join([
    Pm("TapBranch"),
    Z.hex(e).raw,
    Z.hex(t).raw
  ]).digest.hex;
}
function bde(e) {
  return Z.hex(Rg(e)[0]);
}
function Rg(e, t, r = []) {
  const n = [], o = [];
  if (e.length < 1)
    throw new Error("Tree is empty!");
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (Array.isArray(s)) {
      const [a, c, u] = Rg(s, t);
      t = c, n.push(a);
      for (const l of u)
        r.push(l);
    } else
      n.push(s);
  }
  if (n.length === 1)
    return [n[0], t, r];
  n.sort(), n.length % 2 !== 0 && n.push(n[n.length - 1]);
  for (let i = 0; i < n.length - 1; i += 2) {
    const s = M8(n[i], n[i + 1]);
    o.push(s), typeof t == "string" && (t === n[i] ? (r.push(n[i + 1]), t = s) : t === n[i + 1] && (r.push(n[i]), t = s));
  }
  return Rg(o, t, r);
}
function yde(e = 192) {
  return e & 254;
}
function YI(e, t = new Uint8Array(), r = false) {
  const n = r ? new Bn(e).point.x.raw : zu(e);
  return Z.join([Pm("TapTweak"), n, Z.bytes(t)]).digest;
}
function Ll(e, t, r = false) {
  t === void 0 && (t = new Uint8Array());
  const n = Z.bytes(e), o = YI(e, t, r);
  return r ? JI(n, o) : QI(n, o);
}
function wde(e, t) {
  return Ll(e, t);
}
function vde(e, t) {
  return Ll(e, t, true);
}
function JI(e, t) {
  let r = new Bn(e);
  return r.point.hasOddY && (r = r.negate()), Z.raw(r.add(t).raw);
}
function QI(e, t) {
  e = zu(e);
  const r = tl.from_x(e).add(t);
  return Z.raw(r.raw);
}
function Ede() {
  const e = Z.hex("0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8");
  return tl.from_x(e.digest).x;
}
var xde = Ede();
var kde = 192;
function Ade(e, t = {}) {
  return eO(e, { ...t, isPrivate: true });
}
function Sde(e, t = {}) {
  return eO(e, { ...t, isPrivate: false });
}
function eO(e, t = {}) {
  const { isPrivate: r = false, tree: n = [], version: o = kde } = t, i = r ? C2.getPublicKey(e, true) : zu(e);
  let { target: s } = t;
  s !== void 0 && (s = Z.bytes(s).hex);
  let a, c = [];
  if (n.length > 0) {
    const [d, m, y] = Rg(n, s);
    c = y, a = Ll(e, d, r);
  } else
    s !== void 0 ? a = Ll(e, s, r) : a = Ll(e, void 0, r);
  const u = r ? C2.getPublicKey(a)[0] : a[0], l = [Z.num(o + rO(u)), i];
  c.length > 0 && c.forEach((d) => l.push(Z.hex(d)));
  const f = Z.join(l);
  if (s !== void 0 && !q8(a, s, f, t))
    throw new Error("Path checking failed! Unable to generate path.");
  return [zu(a).hex, f.hex];
}
function q8(e, t, r, n = {}) {
  const { isPrivate: o = false, throws: i = false } = n, { parity: s, paths: a, intkey: c } = tO(r), u = o ? C2.getPublicKey(e, true) : zu(e), l = Z.join([s, u]);
  if (l.length !== 33)
    return yn("Invalid tapkey: " + l.hex, i);
  let f = Z.bytes(t).hex;
  for (const m of a)
    f = M8(f, m);
  const d = Ll(c, f);
  return Z.raw(d).hex === Z.raw(l).hex;
}
function tO(e) {
  const t = new Hf(Z.bytes(e)), r = t.read(1).num, n = t.read(32), [o, i] = r % 2 === 0 ? [r, 2] : [r - 1, 3], s = [];
  for (; t.size >= 32; )
    s.push(t.read(32).hex);
  if (t.size !== 0)
    throw new Error("Non-empty buffer on control block: " + String(t));
  return { intkey: n, paths: s, parity: i, version: o };
}
function rO(e = 2) {
  if (e === 0 || e === 1)
    return e;
  if (e === 2 || e === "02")
    return 0;
  if (e === 3 || e === "03")
    return 1;
  throw new Error("Invalid parity bit: " + String(e));
}
function _de(e, t, r = {}) {
  const n = ui.fmt.toJson(e), { throws: o = false } = r, { prevout: i, witness: s = [] } = n.vin[t], a = ui.util.readWitness(s), { cblock: c, script: u, params: l } = a;
  let f;
  if (l.length < 1)
    return yn("Invalid witness data: " + String(s), o);
  const { scriptPubKey: d } = i ?? {};
  if (d === void 0)
    return yn("Prevout scriptPubKey is empty!", o);
  const { type: m, data: y } = ui.util.readScriptPubKey(d);
  if (m !== "p2tr")
    return yn("Prevout script is not a valid taproot output:" + y.hex, o);
  if (y.length !== 32)
    return yn("Invalid tapkey length: " + String(y.length), o);
  if (c !== null && u !== null) {
    const x = c[0] & 254, _ = K8(u, x);
    if (r.extension = _, !q8(y, _, c, { throws: o }))
      return yn("cblock verification failed!", o);
  }
  r.pubkey !== void 0 ? f = Z.bytes(r.pubkey) : l.length > 1 && l[1].length === 32 ? f = Z.bytes(l[1]) : f = Z.bytes(y);
  const b = Hn.fmt.toParam(l[0]), w = new Hf(b), v = w.read(64).raw;
  if (w.size === 1 && (r.sigflag = w.read(1).num, r.sigflag === 0))
    return yn("0x00 is not a valid appended sigflag!", o);
  const k = D8(n, t, r);
  return pde(v, k, f, o) ? true : yn("Invalid signature!", o);
}
var Tde = {
  hash: D8,
  sign: dde,
  verify: _de
};
var Pde = {
  segwit: tde,
  taproot: Tde
};
var Ide = {
  getTag: Pm,
  getLeaf: K8,
  getBranch: M8,
  getRoot: bde
};
var Ode = {
  readCtrlBlock: tO,
  readParityBit: rO
};
var Bde = {
  getPubKey: wde,
  getSecKey: vde,
  getTweak: YI,
  tweakSecKey: JI,
  tweakPubKey: QI
};
var zg = {
  getPubKey: Sde,
  getSecKey: Ade,
  encodeScript: mde,
  checkPath: q8,
  tree: Ide,
  tweak: Bde,
  util: Ode,
  SCRIPT_PUBKEY: xde
};
var Ct;
(function(e) {
  e.assertEqual = (o) => o;
  function t(o) {
  }
  e.assertIs = t;
  function r(o) {
    throw new Error();
  }
  e.assertNever = r, e.arrayToEnum = (o) => {
    const i = {};
    for (const s of o)
      i[s] = s;
    return i;
  }, e.getValidEnumValues = (o) => {
    const i = e.objectKeys(o).filter((a) => typeof o[o[a]] != "number"), s = {};
    for (const a of i)
      s[a] = o[a];
    return e.objectValues(s);
  }, e.objectValues = (o) => e.objectKeys(o).map(function(i) {
    return o[i];
  }), e.objectKeys = typeof Object.keys == "function" ? (o) => Object.keys(o) : (o) => {
    const i = [];
    for (const s in o)
      Object.prototype.hasOwnProperty.call(o, s) && i.push(s);
    return i;
  }, e.find = (o, i) => {
    for (const s of o)
      if (i(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (o) => Number.isInteger(o) : (o) => typeof o == "number" && isFinite(o) && Math.floor(o) === o;
  function n(o, i = " | ") {
    return o.map((s) => typeof s == "string" ? `'${s}'` : s).join(i);
  }
  e.joinValues = n, e.jsonStringifyReplacer = (o, i) => typeof i == "bigint" ? i.toString() : i;
})(Ct || (Ct = {}));
var N2;
(function(e) {
  e.mergeShapes = (t, r) => ({
    ...t,
    ...r
    // second overwrites first
  });
})(N2 || (N2 = {}));
var ge = Ct.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var pc = (e) => {
  switch (typeof e) {
    case "undefined":
      return ge.undefined;
    case "string":
      return ge.string;
    case "number":
      return isNaN(e) ? ge.nan : ge.number;
    case "boolean":
      return ge.boolean;
    case "function":
      return ge.function;
    case "bigint":
      return ge.bigint;
    case "symbol":
      return ge.symbol;
    case "object":
      return Array.isArray(e) ? ge.array : e === null ? ge.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? ge.promise : typeof Map < "u" && e instanceof Map ? ge.map : typeof Set < "u" && e instanceof Set ? ge.set : typeof Date < "u" && e instanceof Date ? ge.date : ge.object;
    default:
      return ge.unknown;
  }
};
var ce = Ct.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var Cde = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
var li = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const r = t || function(i) {
      return i.message;
    }, n = { _errors: [] }, o = (i) => {
      for (const s of i.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(o);
        else if (s.code === "invalid_return_type")
          o(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          o(s.argumentsError);
        else if (s.path.length === 0)
          n._errors.push(r(s));
        else {
          let a = n, c = 0;
          for (; c < s.path.length; ) {
            const u = s.path[c];
            c === s.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(r(s))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return o(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Ct.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (r) => r.message) {
    const r = {}, n = [];
    for (const o of this.issues)
      o.path.length > 0 ? (r[o.path[0]] = r[o.path[0]] || [], r[o.path[0]].push(t(o))) : n.push(t(o));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
li.create = (e) => new li(e);
var ch = (e, t) => {
  let r;
  switch (e.code) {
    case ce.invalid_type:
      e.received === ge.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ce.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(e.expected, Ct.jsonStringifyReplacer)}`;
      break;
    case ce.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Ct.joinValues(e.keys, ", ")}`;
      break;
    case ce.invalid_union:
      r = "Invalid input";
      break;
    case ce.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Ct.joinValues(e.options)}`;
      break;
    case ce.invalid_enum_value:
      r = `Invalid enum value. Expected ${Ct.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ce.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case ce.invalid_return_type:
      r = "Invalid function return type";
      break;
    case ce.invalid_date:
      r = "Invalid date";
      break;
    case ce.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Ct.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
      break;
    case ce.too_small:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
      break;
    case ce.too_big:
      e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
      break;
    case ce.custom:
      r = "Invalid input";
      break;
    case ce.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case ce.not_multiple_of:
      r = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ce.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = t.defaultError, Ct.assertNever(e);
  }
  return { message: r };
};
var nO = ch;
function Nde(e) {
  nO = e;
}
function Hg() {
  return nO;
}
var Lg = (e) => {
  const { data: t, path: r, errorMaps: n, issueData: o } = e, i = [...r, ...o.path || []], s = {
    ...o,
    path: i
  };
  let a = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(s, { data: t, defaultError: a }).message;
  return {
    ...o,
    path: i,
    message: o.message || a
  };
};
var Ude = [];
function we(e, t) {
  const r = Lg({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Hg(),
      ch
      // then global default map
    ].filter((n) => !!n)
  });
  e.common.issues.push(r);
}
var kn = class _kn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, r) {
    const n = [];
    for (const o of r) {
      if (o.status === "aborted")
        return Qe;
      o.status === "dirty" && t.dirty(), n.push(o.value);
    }
    return { status: t.value, value: n };
  }
  static async mergeObjectAsync(t, r) {
    const n = [];
    for (const o of r)
      n.push({
        key: await o.key,
        value: await o.value
      });
    return _kn.mergeObjectSync(t, n);
  }
  static mergeObjectSync(t, r) {
    const n = {};
    for (const o of r) {
      const { key: i, value: s } = o;
      if (i.status === "aborted" || s.status === "aborted")
        return Qe;
      i.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), (typeof s.value < "u" || o.alwaysSet) && (n[i.value] = s.value);
    }
    return { status: t.value, value: n };
  }
};
var Qe = Object.freeze({
  status: "aborted"
});
var oO = (e) => ({ status: "dirty", value: e });
var Ln = (e) => ({ status: "valid", value: e });
var U2 = (e) => e.status === "aborted";
var $2 = (e) => e.status === "dirty";
var jg = (e) => e.status === "valid";
var Fg = (e) => typeof Promise < "u" && e instanceof Promise;
var Be;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Be || (Be = {}));
var es = class {
  constructor(t, r, n, o) {
    this._cachedPath = [], this.parent = t, this.data = r, this._path = n, this._key = o;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var RE = (e, t) => {
  if (jg(t))
    return { success: true, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const r = new li(e.common.issues);
      return this._error = r, this._error;
    }
  };
};
function ct(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: r, required_error: n, description: o } = e;
  if (t && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: o } : { errorMap: (i, s) => i.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: n ?? s.defaultError } : { message: r ?? s.defaultError }, description: o };
}
var xt = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return pc(t.data);
  }
  _getOrReturnCtx(t, r) {
    return r || {
      common: t.parent.common,
      data: t.data,
      parsedType: pc(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new kn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: pc(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const r = this._parse(t);
    if (Fg(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(t) {
    const r = this._parse(t);
    return Promise.resolve(r);
  }
  parse(t, r) {
    const n = this.safeParse(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(t, r) {
    var n;
    const o = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : false,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: pc(t)
    }, i = this._parseSync({ data: t, path: o.path, parent: o });
    return RE(o, i);
  }
  async parseAsync(t, r) {
    const n = await this.safeParseAsync(t, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(t, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: true
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: pc(t)
    }, o = this._parse({ data: t, path: n.path, parent: n }), i = await (Fg(o) ? o : Promise.resolve(o));
    return RE(n, i);
  }
  refine(t, r) {
    const n = (o) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(o) : r;
    return this._refinement((o, i) => {
      const s = t(o), a = () => i.addIssue({
        code: ce.custom,
        ...n(o)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((c) => c ? true : (a(), false)) : s ? true : (a(), false);
    });
  }
  refinement(t, r) {
    return this._refinement((n, o) => t(n) ? true : (o.addIssue(typeof r == "function" ? r(n, o) : r), false));
  }
  _refinement(t) {
    return new yi({
      schema: this,
      typeName: je.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Fs.create(this, this._def);
  }
  nullable() {
    return ju.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return fi.create(this, this._def);
  }
  promise() {
    return mf.create(this, this._def);
  }
  or(t) {
    return dh.create([this, t], this._def);
  }
  and(t) {
    return hh.create(this, t, this._def);
  }
  transform(t) {
    return new yi({
      ...ct(this._def),
      schema: this,
      typeName: je.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const r = typeof t == "function" ? t : () => t;
    return new yh({
      ...ct(this._def),
      innerType: this,
      defaultValue: r,
      typeName: je.ZodDefault
    });
  }
  brand() {
    return new sO({
      typeName: je.ZodBranded,
      type: this,
      ...ct(this._def)
    });
  }
  catch(t) {
    const r = typeof t == "function" ? t : () => t;
    return new qg({
      ...ct(this._def),
      innerType: this,
      catchValue: r,
      typeName: je.ZodCatch
    });
  }
  describe(t) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return np.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var $de = /^c[^\s-]{8,}$/i;
var Rde = /^[a-z][a-z0-9]*$/;
var zde = /[0-9A-HJKMNP-TV-Z]{26}/;
var Hde = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var Lde = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var jde = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
var Fde = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var Dde = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var Kde = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Mde(e, t) {
  return !!((t === "v4" || !t) && Fde.test(e) || (t === "v6" || !t) && Dde.test(e));
}
var ri = class _ri extends xt {
  constructor() {
    super(...arguments), this._regex = (t, r, n) => this.refinement((o) => t.test(o), {
      validation: r,
      code: ce.invalid_string,
      ...Be.errToObj(n)
    }), this.nonempty = (t) => this.min(1, Be.errToObj(t)), this.trim = () => new _ri({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new _ri({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new _ri({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ge.string) {
      const o = this._getOrReturnCtx(t);
      return we(
        o,
        {
          code: ce.invalid_type,
          expected: ge.string,
          received: o.parsedType
        }
        //
      ), Qe;
    }
    const r = new kn();
    let n;
    for (const o of this._def.checks)
      if (o.kind === "min")
        t.data.length < o.value && (n = this._getOrReturnCtx(t, n), we(n, {
          code: ce.too_small,
          minimum: o.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: o.message
        }), r.dirty());
      else if (o.kind === "max")
        t.data.length > o.value && (n = this._getOrReturnCtx(t, n), we(n, {
          code: ce.too_big,
          maximum: o.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: o.message
        }), r.dirty());
      else if (o.kind === "length") {
        const i = t.data.length > o.value, s = t.data.length < o.value;
        (i || s) && (n = this._getOrReturnCtx(t, n), i ? we(n, {
          code: ce.too_big,
          maximum: o.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: o.message
        }) : s && we(n, {
          code: ce.too_small,
          minimum: o.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: o.message
        }), r.dirty());
      } else if (o.kind === "email")
        Lde.test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
          validation: "email",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "emoji")
        jde.test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
          validation: "emoji",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "uuid")
        Hde.test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
          validation: "uuid",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid")
        $de.test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
          validation: "cuid",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "cuid2")
        Rde.test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
          validation: "cuid2",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "ulid")
        zde.test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
          validation: "ulid",
          code: ce.invalid_string,
          message: o.message
        }), r.dirty());
      else if (o.kind === "url")
        try {
          new URL(t.data);
        } catch {
          n = this._getOrReturnCtx(t, n), we(n, {
            validation: "url",
            code: ce.invalid_string,
            message: o.message
          }), r.dirty();
        }
      else o.kind === "regex" ? (o.regex.lastIndex = 0, o.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
        validation: "regex",
        code: ce.invalid_string,
        message: o.message
      }), r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (n = this._getOrReturnCtx(t, n), we(n, {
        code: ce.invalid_string,
        validation: { includes: o.value, position: o.position },
        message: o.message
      }), r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (n = this._getOrReturnCtx(t, n), we(n, {
        code: ce.invalid_string,
        validation: { startsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (n = this._getOrReturnCtx(t, n), we(n, {
        code: ce.invalid_string,
        validation: { endsWith: o.value },
        message: o.message
      }), r.dirty()) : o.kind === "datetime" ? Kde(o).test(t.data) || (n = this._getOrReturnCtx(t, n), we(n, {
        code: ce.invalid_string,
        validation: "datetime",
        message: o.message
      }), r.dirty()) : o.kind === "ip" ? Mde(t.data, o.version) || (n = this._getOrReturnCtx(t, n), we(n, {
        validation: "ip",
        code: ce.invalid_string,
        message: o.message
      }), r.dirty()) : Ct.assertNever(o);
    return { status: r.value, value: t.data };
  }
  _addCheck(t) {
    return new _ri({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Be.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Be.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Be.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Be.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Be.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Be.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Be.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Be.errToObj(t) });
  }
  datetime(t) {
    var r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : false,
      ...Be.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, r) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Be.errToObj(r)
    });
  }
  includes(t, r) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: r == null ? void 0 : r.position,
      ...Be.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(t, r) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Be.errToObj(r)
    });
  }
  endsWith(t, r) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Be.errToObj(r)
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Be.errToObj(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Be.errToObj(r)
    });
  }
  length(t, r) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Be.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
};
ri.create = (e) => {
  var t;
  return new ri({
    checks: [],
    typeName: je.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...ct(e)
  });
};
function qde(e, t) {
  const r = (e.toString().split(".")[1] || "").length, n = (t.toString().split(".")[1] || "").length, o = r > n ? r : n, i = parseInt(e.toFixed(o).replace(".", "")), s = parseInt(t.toFixed(o).replace(".", ""));
  return i % s / Math.pow(10, o);
}
var Ic = class _Ic extends xt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ge.number) {
      const o = this._getOrReturnCtx(t);
      return we(o, {
        code: ce.invalid_type,
        expected: ge.number,
        received: o.parsedType
      }), Qe;
    }
    let r;
    const n = new kn();
    for (const o of this._def.checks)
      o.kind === "int" ? Ct.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.invalid_type,
        expected: "integer",
        received: "float",
        message: o.message
      }), n.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.too_small,
        minimum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: false,
        message: o.message
      }), n.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.too_big,
        maximum: o.value,
        type: "number",
        inclusive: o.inclusive,
        exact: false,
        message: o.message
      }), n.dirty()) : o.kind === "multipleOf" ? qde(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), n.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.not_finite,
        message: o.message
      }), n.dirty()) : Ct.assertNever(o);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, true, Be.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, false, Be.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, true, Be.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, false, Be.toString(r));
  }
  setLimit(t, r, n, o) {
    return new _Ic({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Be.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new _Ic({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Be.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: Be.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: Be.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: Be.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: Be.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Be.toString(r)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Be.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: Be.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: Be.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Ct.isInteger(t.value));
  }
  get isFinite() {
    let t = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(t);
  }
};
Ic.create = (e) => new Ic({
  checks: [],
  typeName: je.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...ct(e)
});
var Oc = class _Oc extends xt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== ge.bigint) {
      const o = this._getOrReturnCtx(t);
      return we(o, {
        code: ce.invalid_type,
        expected: ge.bigint,
        received: o.parsedType
      }), Qe;
    }
    let r;
    const n = new kn();
    for (const o of this._def.checks)
      o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.too_small,
        type: "bigint",
        minimum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), n.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.too_big,
        type: "bigint",
        maximum: o.value,
        inclusive: o.inclusive,
        message: o.message
      }), n.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), we(r, {
        code: ce.not_multiple_of,
        multipleOf: o.value,
        message: o.message
      }), n.dirty()) : Ct.assertNever(o);
    return { status: n.value, value: t.data };
  }
  gte(t, r) {
    return this.setLimit("min", t, true, Be.toString(r));
  }
  gt(t, r) {
    return this.setLimit("min", t, false, Be.toString(r));
  }
  lte(t, r) {
    return this.setLimit("max", t, true, Be.toString(r));
  }
  lt(t, r) {
    return this.setLimit("max", t, false, Be.toString(r));
  }
  setLimit(t, r, n, o) {
    return new _Oc({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: r,
          inclusive: n,
          message: Be.toString(o)
        }
      ]
    });
  }
  _addCheck(t) {
    return new _Oc({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: Be.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: Be.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: Be.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: Be.toString(t)
    });
  }
  multipleOf(t, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Be.toString(r)
    });
  }
  get minValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t;
  }
};
Oc.create = (e) => {
  var t;
  return new Oc({
    checks: [],
    typeName: je.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...ct(e)
  });
};
var uh = class extends xt {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ge.boolean) {
      const r = this._getOrReturnCtx(t);
      return we(r, {
        code: ce.invalid_type,
        expected: ge.boolean,
        received: r.parsedType
      }), Qe;
    }
    return Ln(t.data);
  }
};
uh.create = (e) => new uh({
  typeName: je.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...ct(e)
});
var Hu = class _Hu extends xt {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ge.date) {
      const o = this._getOrReturnCtx(t);
      return we(o, {
        code: ce.invalid_type,
        expected: ge.date,
        received: o.parsedType
      }), Qe;
    }
    if (isNaN(t.data.getTime())) {
      const o = this._getOrReturnCtx(t);
      return we(o, {
        code: ce.invalid_date
      }), Qe;
    }
    const r = new kn();
    let n;
    for (const o of this._def.checks)
      o.kind === "min" ? t.data.getTime() < o.value && (n = this._getOrReturnCtx(t, n), we(n, {
        code: ce.too_small,
        message: o.message,
        inclusive: true,
        exact: false,
        minimum: o.value,
        type: "date"
      }), r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (n = this._getOrReturnCtx(t, n), we(n, {
        code: ce.too_big,
        message: o.message,
        inclusive: true,
        exact: false,
        maximum: o.value,
        type: "date"
      }), r.dirty()) : Ct.assertNever(o);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new _Hu({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, r) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Be.toString(r)
    });
  }
  max(t, r) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Be.toString(r)
    });
  }
  get minDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "min" && (t === null || r.value > t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const r of this._def.checks)
      r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    return t != null ? new Date(t) : null;
  }
};
Hu.create = (e) => new Hu({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || false,
  typeName: je.ZodDate,
  ...ct(e)
});
var Dg = class extends xt {
  _parse(t) {
    if (this._getType(t) !== ge.symbol) {
      const r = this._getOrReturnCtx(t);
      return we(r, {
        code: ce.invalid_type,
        expected: ge.symbol,
        received: r.parsedType
      }), Qe;
    }
    return Ln(t.data);
  }
};
Dg.create = (e) => new Dg({
  typeName: je.ZodSymbol,
  ...ct(e)
});
var lh = class extends xt {
  _parse(t) {
    if (this._getType(t) !== ge.undefined) {
      const r = this._getOrReturnCtx(t);
      return we(r, {
        code: ce.invalid_type,
        expected: ge.undefined,
        received: r.parsedType
      }), Qe;
    }
    return Ln(t.data);
  }
};
lh.create = (e) => new lh({
  typeName: je.ZodUndefined,
  ...ct(e)
});
var fh = class extends xt {
  _parse(t) {
    if (this._getType(t) !== ge.null) {
      const r = this._getOrReturnCtx(t);
      return we(r, {
        code: ce.invalid_type,
        expected: ge.null,
        received: r.parsedType
      }), Qe;
    }
    return Ln(t.data);
  }
};
fh.create = (e) => new fh({
  typeName: je.ZodNull,
  ...ct(e)
});
var gf = class extends xt {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(t) {
    return Ln(t.data);
  }
};
gf.create = (e) => new gf({
  typeName: je.ZodAny,
  ...ct(e)
});
var ku = class extends xt {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(t) {
    return Ln(t.data);
  }
};
ku.create = (e) => new ku({
  typeName: je.ZodUnknown,
  ...ct(e)
});
var Xs = class extends xt {
  _parse(t) {
    const r = this._getOrReturnCtx(t);
    return we(r, {
      code: ce.invalid_type,
      expected: ge.never,
      received: r.parsedType
    }), Qe;
  }
};
Xs.create = (e) => new Xs({
  typeName: je.ZodNever,
  ...ct(e)
});
var Kg = class extends xt {
  _parse(t) {
    if (this._getType(t) !== ge.undefined) {
      const r = this._getOrReturnCtx(t);
      return we(r, {
        code: ce.invalid_type,
        expected: ge.void,
        received: r.parsedType
      }), Qe;
    }
    return Ln(t.data);
  }
};
Kg.create = (e) => new Kg({
  typeName: je.ZodVoid,
  ...ct(e)
});
var fi = class _fi extends xt {
  _parse(t) {
    const { ctx: r, status: n } = this._processInputParams(t), o = this._def;
    if (r.parsedType !== ge.array)
      return we(r, {
        code: ce.invalid_type,
        expected: ge.array,
        received: r.parsedType
      }), Qe;
    if (o.exactLength !== null) {
      const s = r.data.length > o.exactLength.value, a = r.data.length < o.exactLength.value;
      (s || a) && (we(r, {
        code: s ? ce.too_big : ce.too_small,
        minimum: a ? o.exactLength.value : void 0,
        maximum: s ? o.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: o.exactLength.message
      }), n.dirty());
    }
    if (o.minLength !== null && r.data.length < o.minLength.value && (we(r, {
      code: ce.too_small,
      minimum: o.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: o.minLength.message
    }), n.dirty()), o.maxLength !== null && r.data.length > o.maxLength.value && (we(r, {
      code: ce.too_big,
      maximum: o.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: o.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((s, a) => o.type._parseAsync(new es(r, s, r.path, a)))).then((s) => kn.mergeArray(n, s));
    const i = [...r.data].map((s, a) => o.type._parseSync(new es(r, s, r.path, a)));
    return kn.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(t, r) {
    return new _fi({
      ...this._def,
      minLength: { value: t, message: Be.toString(r) }
    });
  }
  max(t, r) {
    return new _fi({
      ...this._def,
      maxLength: { value: t, message: Be.toString(r) }
    });
  }
  length(t, r) {
    return new _fi({
      ...this._def,
      exactLength: { value: t, message: Be.toString(r) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
fi.create = (e, t) => new fi({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: je.ZodArray,
  ...ct(t)
});
function El(e) {
  if (e instanceof rr) {
    const t = {};
    for (const r in e.shape) {
      const n = e.shape[r];
      t[r] = Fs.create(El(n));
    }
    return new rr({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof fi ? new fi({
    ...e._def,
    type: El(e.element)
  }) : e instanceof Fs ? Fs.create(El(e.unwrap())) : e instanceof ju ? ju.create(El(e.unwrap())) : e instanceof ts ? ts.create(e.items.map((t) => El(t))) : e;
}
var rr = class _rr extends xt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), r = Ct.objectKeys(t);
    return this._cached = { shape: t, keys: r };
  }
  _parse(t) {
    if (this._getType(t) !== ge.object) {
      const c = this._getOrReturnCtx(t);
      return we(c, {
        code: ce.invalid_type,
        expected: ge.object,
        received: c.parsedType
      }), Qe;
    }
    const { status: r, ctx: n } = this._processInputParams(t), { shape: o, keys: i } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Xs && this._def.unknownKeys === "strip"))
      for (const c in n.data)
        i.includes(c) || s.push(c);
    const a = [];
    for (const c of i) {
      const u = o[c], l = n.data[c];
      a.push({
        key: { status: "valid", value: c },
        value: u._parse(new es(n, l, n.path, c)),
        alwaysSet: c in n.data
      });
    }
    if (this._def.catchall instanceof Xs) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of s)
          a.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: n.data[u] }
          });
      else if (c === "strict")
        s.length > 0 && (we(n, {
          code: ce.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of s) {
        const l = n.data[u];
        a.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new es(n, l, n.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of a) {
        const l = await u.key;
        c.push({
          key: l,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => kn.mergeObjectSync(r, c)) : kn.mergeObjectSync(r, a);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return new _rr({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (r, n) => {
          var o, i, s, a;
          const c = (s = (i = (o = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(o, r, n).message) !== null && s !== void 0 ? s : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (a = Be.errToObj(t).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _rr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _rr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new _rr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new _rr({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: je.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, r) {
    return this.augment({ [t]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new _rr({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const r = {};
    return Ct.objectKeys(t).forEach((n) => {
      t[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new _rr({
      ...this._def,
      shape: () => r
    });
  }
  omit(t) {
    const r = {};
    return Ct.objectKeys(this.shape).forEach((n) => {
      t[n] || (r[n] = this.shape[n]);
    }), new _rr({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return El(this);
  }
  partial(t) {
    const r = {};
    return Ct.objectKeys(this.shape).forEach((n) => {
      const o = this.shape[n];
      t && !t[n] ? r[n] = o : r[n] = o.optional();
    }), new _rr({
      ...this._def,
      shape: () => r
    });
  }
  required(t) {
    const r = {};
    return Ct.objectKeys(this.shape).forEach((n) => {
      if (t && !t[n])
        r[n] = this.shape[n];
      else {
        let o = this.shape[n];
        for (; o instanceof Fs; )
          o = o._def.innerType;
        r[n] = o;
      }
    }), new _rr({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return iO(Ct.objectKeys(this.shape));
  }
};
rr.create = (e, t) => new rr({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Xs.create(),
  typeName: je.ZodObject,
  ...ct(t)
});
rr.strictCreate = (e, t) => new rr({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Xs.create(),
  typeName: je.ZodObject,
  ...ct(t)
});
rr.lazycreate = (e, t) => new rr({
  shape: e,
  unknownKeys: "strip",
  catchall: Xs.create(),
  typeName: je.ZodObject,
  ...ct(t)
});
var dh = class extends xt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = this._def.options;
    function o(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return r.common.issues.push(...a.ctx.common.issues), a.result;
      const s = i.map((a) => new li(a.ctx.common.issues));
      return we(r, {
        code: ce.invalid_union,
        unionErrors: s
      }), Qe;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const s = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: s
          }),
          ctx: s
        };
      })).then(o);
    {
      let i;
      const s = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && s.push(u.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const a = s.map((c) => new li(c));
      return we(r, {
        code: ce.invalid_union,
        unionErrors: a
      }), Qe;
    }
  }
  get options() {
    return this._def.options;
  }
};
dh.create = (e, t) => new dh({
  options: e,
  typeName: je.ZodUnion,
  ...ct(t)
});
var b0 = (e) => e instanceof gh ? b0(e.schema) : e instanceof yi ? b0(e.innerType()) : e instanceof mh ? [e.value] : e instanceof Bc ? e.options : e instanceof bh ? Object.keys(e.enum) : e instanceof yh ? b0(e._def.innerType) : e instanceof lh ? [void 0] : e instanceof fh ? [null] : null;
var Im = class _Im extends xt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.object)
      return we(r, {
        code: ce.invalid_type,
        expected: ge.object,
        received: r.parsedType
      }), Qe;
    const n = this.discriminator, o = r.data[n], i = this.optionsMap.get(o);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (we(r, {
      code: ce.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), Qe);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, r, n) {
    const o = /* @__PURE__ */ new Map();
    for (const i of r) {
      const s = b0(i.shape[t]);
      if (!s)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const a of s) {
        if (o.has(a))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(a)}`);
        o.set(a, i);
      }
    }
    return new _Im({
      typeName: je.ZodDiscriminatedUnion,
      discriminator: t,
      options: r,
      optionsMap: o,
      ...ct(n)
    });
  }
};
function R2(e, t) {
  const r = pc(e), n = pc(t);
  if (e === t)
    return { valid: true, data: e };
  if (r === ge.object && n === ge.object) {
    const o = Ct.objectKeys(t), i = Ct.objectKeys(e).filter((a) => o.indexOf(a) !== -1), s = { ...e, ...t };
    for (const a of i) {
      const c = R2(e[a], t[a]);
      if (!c.valid)
        return { valid: false };
      s[a] = c.data;
    }
    return { valid: true, data: s };
  } else if (r === ge.array && n === ge.array) {
    if (e.length !== t.length)
      return { valid: false };
    const o = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i], a = t[i], c = R2(s, a);
      if (!c.valid)
        return { valid: false };
      o.push(c.data);
    }
    return { valid: true, data: o };
  } else return r === ge.date && n === ge.date && +e == +t ? { valid: true, data: e } : { valid: false };
}
var hh = class extends xt {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = (i, s) => {
      if (U2(i) || U2(s))
        return Qe;
      const a = R2(i.value, s.value);
      return a.valid ? (($2(i) || $2(s)) && r.dirty(), { status: r.value, value: a.data }) : (we(n, {
        code: ce.invalid_intersection_types
      }), Qe);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, s]) => o(i, s)) : o(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
hh.create = (e, t, r) => new hh({
  left: e,
  right: t,
  typeName: je.ZodIntersection,
  ...ct(r)
});
var ts = class _ts extends xt {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.array)
      return we(n, {
        code: ce.invalid_type,
        expected: ge.array,
        received: n.parsedType
      }), Qe;
    if (n.data.length < this._def.items.length)
      return we(n, {
        code: ce.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), Qe;
    !this._def.rest && n.data.length > this._def.items.length && (we(n, {
      code: ce.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), r.dirty());
    const o = [...n.data].map((i, s) => {
      const a = this._def.items[s] || this._def.rest;
      return a ? a._parse(new es(n, i, n.path, s)) : null;
    }).filter((i) => !!i);
    return n.common.async ? Promise.all(o).then((i) => kn.mergeArray(r, i)) : kn.mergeArray(r, o);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new _ts({
      ...this._def,
      rest: t
    });
  }
};
ts.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ts({
    items: e,
    typeName: je.ZodTuple,
    rest: null,
    ...ct(t)
  });
};
var ph = class _ph extends xt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.object)
      return we(n, {
        code: ce.invalid_type,
        expected: ge.object,
        received: n.parsedType
      }), Qe;
    const o = [], i = this._def.keyType, s = this._def.valueType;
    for (const a in n.data)
      o.push({
        key: i._parse(new es(n, a, n.path, a)),
        value: s._parse(new es(n, n.data[a], n.path, a))
      });
    return n.common.async ? kn.mergeObjectAsync(r, o) : kn.mergeObjectSync(r, o);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, r, n) {
    return r instanceof xt ? new _ph({
      keyType: t,
      valueType: r,
      typeName: je.ZodRecord,
      ...ct(n)
    }) : new _ph({
      keyType: ri.create(),
      valueType: t,
      typeName: je.ZodRecord,
      ...ct(r)
    });
  }
};
var Mg = class extends xt {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.map)
      return we(n, {
        code: ce.invalid_type,
        expected: ge.map,
        received: n.parsedType
      }), Qe;
    const o = this._def.keyType, i = this._def.valueType, s = [...n.data.entries()].map(([a, c], u) => ({
      key: o._parse(new es(n, a, n.path, [u, "key"])),
      value: i._parse(new es(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of s) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return Qe;
          (u.status === "dirty" || l.status === "dirty") && r.dirty(), a.set(u.value, l.value);
        }
        return { status: r.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of s) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return Qe;
        (u.status === "dirty" || l.status === "dirty") && r.dirty(), a.set(u.value, l.value);
      }
      return { status: r.value, value: a };
    }
  }
};
Mg.create = (e, t, r) => new Mg({
  valueType: t,
  keyType: e,
  typeName: je.ZodMap,
  ...ct(r)
});
var Lu = class _Lu extends xt {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ge.set)
      return we(n, {
        code: ce.invalid_type,
        expected: ge.set,
        received: n.parsedType
      }), Qe;
    const o = this._def;
    o.minSize !== null && n.data.size < o.minSize.value && (we(n, {
      code: ce.too_small,
      minimum: o.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: o.minSize.message
    }), r.dirty()), o.maxSize !== null && n.data.size > o.maxSize.value && (we(n, {
      code: ce.too_big,
      maximum: o.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: o.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function s(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return Qe;
        l.status === "dirty" && r.dirty(), u.add(l.value);
      }
      return { status: r.value, value: u };
    }
    const a = [...n.data.values()].map((c, u) => i._parse(new es(n, c, n.path, u)));
    return n.common.async ? Promise.all(a).then((c) => s(c)) : s(a);
  }
  min(t, r) {
    return new _Lu({
      ...this._def,
      minSize: { value: t, message: Be.toString(r) }
    });
  }
  max(t, r) {
    return new _Lu({
      ...this._def,
      maxSize: { value: t, message: Be.toString(r) }
    });
  }
  size(t, r) {
    return this.min(t, r).max(t, r);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
Lu.create = (e, t) => new Lu({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: je.ZodSet,
  ...ct(t)
});
var jl = class _jl extends xt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.function)
      return we(r, {
        code: ce.invalid_type,
        expected: ge.function,
        received: r.parsedType
      }), Qe;
    function n(a, c) {
      return Lg({
        data: a,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Hg(),
          ch
        ].filter((u) => !!u),
        issueData: {
          code: ce.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function o(a, c) {
      return Lg({
        data: a,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Hg(),
          ch
        ].filter((u) => !!u),
        issueData: {
          code: ce.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, s = r.data;
    return this._def.returns instanceof mf ? Ln(async (...a) => {
      const c = new li([]), u = await this._def.args.parseAsync(a, i).catch((f) => {
        throw c.addIssue(n(a, f)), c;
      }), l = await s(...u);
      return await this._def.returns._def.type.parseAsync(l, i).catch((f) => {
        throw c.addIssue(o(l, f)), c;
      });
    }) : Ln((...a) => {
      const c = this._def.args.safeParse(a, i);
      if (!c.success)
        throw new li([n(a, c.error)]);
      const u = s(...c.data), l = this._def.returns.safeParse(u, i);
      if (!l.success)
        throw new li([o(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new _jl({
      ...this._def,
      args: ts.create(t).rest(ku.create())
    });
  }
  returns(t) {
    return new _jl({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, r, n) {
    return new _jl({
      args: t || ts.create([]).rest(ku.create()),
      returns: r || ku.create(),
      typeName: je.ZodFunction,
      ...ct(n)
    });
  }
};
var gh = class extends xt {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
gh.create = (e, t) => new gh({
  getter: e,
  typeName: je.ZodLazy,
  ...ct(t)
});
var mh = class extends xt {
  _parse(t) {
    if (t.data !== this._def.value) {
      const r = this._getOrReturnCtx(t);
      return we(r, {
        received: r.data,
        code: ce.invalid_literal,
        expected: this._def.value
      }), Qe;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
mh.create = (e, t) => new mh({
  value: e,
  typeName: je.ZodLiteral,
  ...ct(t)
});
function iO(e, t) {
  return new Bc({
    values: e,
    typeName: je.ZodEnum,
    ...ct(t)
  });
}
var Bc = class _Bc extends xt {
  _parse(t) {
    if (typeof t.data != "string") {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return we(r, {
        expected: Ct.joinValues(n),
        received: r.parsedType,
        code: ce.invalid_type
      }), Qe;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const r = this._getOrReturnCtx(t), n = this._def.values;
      return we(r, {
        received: r.data,
        code: ce.invalid_enum_value,
        options: n
      }), Qe;
    }
    return Ln(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Values() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  get Enum() {
    const t = {};
    for (const r of this._def.values)
      t[r] = r;
    return t;
  }
  extract(t) {
    return _Bc.create(t);
  }
  exclude(t) {
    return _Bc.create(this.options.filter((r) => !t.includes(r)));
  }
};
Bc.create = iO;
var bh = class extends xt {
  _parse(t) {
    const r = Ct.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(t);
    if (n.parsedType !== ge.string && n.parsedType !== ge.number) {
      const o = Ct.objectValues(r);
      return we(n, {
        expected: Ct.joinValues(o),
        received: n.parsedType,
        code: ce.invalid_type
      }), Qe;
    }
    if (r.indexOf(t.data) === -1) {
      const o = Ct.objectValues(r);
      return we(n, {
        received: n.data,
        code: ce.invalid_enum_value,
        options: o
      }), Qe;
    }
    return Ln(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
bh.create = (e, t) => new bh({
  values: e,
  typeName: je.ZodNativeEnum,
  ...ct(t)
});
var mf = class extends xt {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ge.promise && r.common.async === false)
      return we(r, {
        code: ce.invalid_type,
        expected: ge.promise,
        received: r.parsedType
      }), Qe;
    const n = r.parsedType === ge.promise ? r.data : Promise.resolve(r.data);
    return Ln(n.then((o) => this._def.type.parseAsync(o, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
mf.create = (e, t) => new mf({
  type: e,
  typeName: je.ZodPromise,
  ...ct(t)
});
var yi = class extends xt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === je.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t), o = this._def.effect || null;
    if (o.type === "preprocess") {
      const s = o.transform(n.data);
      return n.common.async ? Promise.resolve(s).then((a) => this._def.schema._parseAsync({
        data: a,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: s,
        path: n.path,
        parent: n
      });
    }
    const i = {
      addIssue: (s) => {
        we(n, s), s.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), o.type === "refinement") {
      const s = (a) => {
        const c = o.refinement(a, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (n.common.async === false) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return a.status === "aborted" ? Qe : (a.status === "dirty" && r.dirty(), s(a.value), { status: r.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => a.status === "aborted" ? Qe : (a.status === "dirty" && r.dirty(), s(a.value).then(() => ({ status: r.value, value: a.value }))));
    }
    if (o.type === "transform")
      if (n.common.async === false) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!jg(s))
          return s;
        const a = o.transform(s.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((s) => jg(s) ? Promise.resolve(o.transform(s.value, i)).then((a) => ({ status: r.value, value: a })) : s);
    Ct.assertNever(o);
  }
};
yi.create = (e, t, r) => new yi({
  schema: e,
  typeName: je.ZodEffects,
  effect: t,
  ...ct(r)
});
yi.createWithPreprocess = (e, t, r) => new yi({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: je.ZodEffects,
  ...ct(r)
});
var Fs = class extends xt {
  _parse(t) {
    return this._getType(t) === ge.undefined ? Ln(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Fs.create = (e, t) => new Fs({
  innerType: e,
  typeName: je.ZodOptional,
  ...ct(t)
});
var ju = class extends xt {
  _parse(t) {
    return this._getType(t) === ge.null ? Ln(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ju.create = (e, t) => new ju({
  innerType: e,
  typeName: je.ZodNullable,
  ...ct(t)
});
var yh = class extends xt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t);
    let n = r.data;
    return r.parsedType === ge.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
yh.create = (e, t) => new yh({
  innerType: e,
  typeName: je.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...ct(t)
});
var qg = class extends xt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, o = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Fg(o) ? o.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new li(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new li(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
qg.create = (e, t) => new qg({
  innerType: e,
  typeName: je.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...ct(t)
});
var Vg = class extends xt {
  _parse(t) {
    if (this._getType(t) !== ge.nan) {
      const r = this._getOrReturnCtx(t);
      return we(r, {
        code: ce.invalid_type,
        expected: ge.nan,
        received: r.parsedType
      }), Qe;
    }
    return { status: "valid", value: t.data };
  }
};
Vg.create = (e) => new Vg({
  typeName: je.ZodNaN,
  ...ct(e)
});
var Vde = Symbol("zod_brand");
var sO = class extends xt {
  _parse(t) {
    const { ctx: r } = this._processInputParams(t), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var np = class _np extends xt {
  _parse(t) {
    const { status: r, ctx: n } = this._processInputParams(t);
    if (n.common.async)
      return (async () => {
        const o = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? Qe : o.status === "dirty" ? (r.dirty(), oO(o.value)) : this._def.out._parseAsync({
          data: o.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const o = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return o.status === "aborted" ? Qe : o.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: o.value
      }) : this._def.out._parseSync({
        data: o.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(t, r) {
    return new _np({
      in: t,
      out: r,
      typeName: je.ZodPipeline
    });
  }
};
var aO = (e, t = {}, r) => e ? gf.create().superRefine((n, o) => {
  var i, s;
  if (!e(n)) {
    const a = typeof t == "function" ? t(n) : typeof t == "string" ? { message: t } : t, c = (s = (i = a.fatal) !== null && i !== void 0 ? i : r) !== null && s !== void 0 ? s : true, u = typeof a == "string" ? { message: a } : a;
    o.addIssue({ code: "custom", ...u, fatal: c });
  }
}) : gf.create();
var Gde = {
  object: rr.lazycreate
};
var je;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(je || (je = {}));
var Wde = (e, t = {
  message: `Input not instance of ${e.name}`
}) => aO((r) => r instanceof e, t);
var cO = ri.create;
var uO = Ic.create;
var Zde = Vg.create;
var Xde = Oc.create;
var lO = uh.create;
var Yde = Hu.create;
var Jde = Dg.create;
var Qde = lh.create;
var ehe = fh.create;
var the = gf.create;
var rhe = ku.create;
var nhe = Xs.create;
var ohe = Kg.create;
var ihe = fi.create;
var she = rr.create;
var ahe = rr.strictCreate;
var che = dh.create;
var uhe = Im.create;
var lhe = hh.create;
var fhe = ts.create;
var dhe = ph.create;
var hhe = Mg.create;
var phe = Lu.create;
var ghe = jl.create;
var mhe = gh.create;
var bhe = mh.create;
var yhe = Bc.create;
var whe = bh.create;
var vhe = mf.create;
var zE = yi.create;
var Ehe = Fs.create;
var xhe = ju.create;
var khe = yi.createWithPreprocess;
var Ahe = np.create;
var She = () => cO().optional();
var _he = () => uO().optional();
var The = () => lO().optional();
var Phe = {
  string: (e) => ri.create({ ...e, coerce: true }),
  number: (e) => Ic.create({ ...e, coerce: true }),
  boolean: (e) => uh.create({
    ...e,
    coerce: true
  }),
  bigint: (e) => Oc.create({ ...e, coerce: true }),
  date: (e) => Hu.create({ ...e, coerce: true })
};
var Ihe = Qe;
var $n = Object.freeze({
  __proto__: null,
  defaultErrorMap: ch,
  setErrorMap: Nde,
  getErrorMap: Hg,
  makeIssue: Lg,
  EMPTY_PATH: Ude,
  addIssueToContext: we,
  ParseStatus: kn,
  INVALID: Qe,
  DIRTY: oO,
  OK: Ln,
  isAborted: U2,
  isDirty: $2,
  isValid: jg,
  isAsync: Fg,
  get util() {
    return Ct;
  },
  get objectUtil() {
    return N2;
  },
  ZodParsedType: ge,
  getParsedType: pc,
  ZodType: xt,
  ZodString: ri,
  ZodNumber: Ic,
  ZodBigInt: Oc,
  ZodBoolean: uh,
  ZodDate: Hu,
  ZodSymbol: Dg,
  ZodUndefined: lh,
  ZodNull: fh,
  ZodAny: gf,
  ZodUnknown: ku,
  ZodNever: Xs,
  ZodVoid: Kg,
  ZodArray: fi,
  ZodObject: rr,
  ZodUnion: dh,
  ZodDiscriminatedUnion: Im,
  ZodIntersection: hh,
  ZodTuple: ts,
  ZodRecord: ph,
  ZodMap: Mg,
  ZodSet: Lu,
  ZodFunction: jl,
  ZodLazy: gh,
  ZodLiteral: mh,
  ZodEnum: Bc,
  ZodNativeEnum: bh,
  ZodPromise: mf,
  ZodEffects: yi,
  ZodTransformer: yi,
  ZodOptional: Fs,
  ZodNullable: ju,
  ZodDefault: yh,
  ZodCatch: qg,
  ZodNaN: Vg,
  BRAND: Vde,
  ZodBranded: sO,
  ZodPipeline: np,
  custom: aO,
  Schema: xt,
  ZodSchema: xt,
  late: Gde,
  get ZodFirstPartyTypeKind() {
    return je;
  },
  coerce: Phe,
  any: the,
  array: ihe,
  bigint: Xde,
  boolean: lO,
  date: Yde,
  discriminatedUnion: uhe,
  effect: zE,
  enum: yhe,
  function: ghe,
  instanceof: Wde,
  intersection: lhe,
  lazy: mhe,
  literal: bhe,
  map: hhe,
  nan: Zde,
  nativeEnum: whe,
  never: nhe,
  null: ehe,
  nullable: xhe,
  number: uO,
  object: she,
  oboolean: The,
  onumber: _he,
  optional: Ehe,
  ostring: She,
  pipeline: Ahe,
  preprocess: khe,
  promise: vhe,
  record: dhe,
  set: phe,
  strictObject: ahe,
  string: cO,
  symbol: Jde,
  transformer: zE,
  tuple: fhe,
  undefined: Qde,
  union: che,
  unknown: rhe,
  void: ohe,
  NEVER: Ihe,
  ZodIssueCode: ce,
  quotelessJson: Cde,
  ZodError: li
});
var fO = $n.string().regex(/^[a-fA-F0-9]$/);
var Ohe = $n.string().regex(/^[a-fA-F0-9]{64}$/);
var bf = $n.number().min(0).max(4294967295);
var Bhe = $n.bigint();
var dO = $n.instanceof(Uint8Array);
var Che = $n.union([fO, bf, $n.string(), dO]).array();
var V8 = $n.union([Che, fO, dO]);
var Nhe = $n.array(V8);
var hO = $n.object({
  value: $n.union([bf, Bhe]),
  scriptPubKey: V8
});
var Uhe = $n.object({
  txid: Ohe,
  vout: bf,
  scriptSig: V8,
  sequence: bf,
  prevout: hO.optional(),
  witness: Nhe
});
$n.object({
  version: bf,
  vin: $n.array(Uhe),
  vout: $n.array(hO),
  locktime: bf
});
var gr = {};
var G8 = {};
var $he = {};
var Rhe = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: $he
}, Symbol.toStringTag, { value: "Module" }));
var pO = Nee(Rhe);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.utils = e.schnorr = e.verify = e.signSync = e.sign = e.getSharedSecret = e.recoverPublicKey = e.getPublicKey = e.Signature = e.Point = e.CURVE = void 0;
  const t = pO, r = BigInt(0), n = BigInt(1), o = BigInt(2), i = BigInt(3), s = BigInt(8), a = Object.freeze({
    a: r,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  e.CURVE = a;
  const c = (T, E) => (T + E / o) / E, u = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(T) {
      const { n: E } = a, S = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), B = -n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), z = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), D = S, X = BigInt("0x100000000000000000000000000000000"), Y = c(D * T, E), se = c(-B * T, E);
      let oe = K(T - Y * S - se * z, E), ue = K(-Y * B - se * D, E);
      const he = oe > X, be = ue > X;
      if (he && (oe = E - oe), be && (ue = E - ue), oe > X || ue > X)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + T);
      return { k1neg: he, k1: oe, k2neg: be, k2: ue };
    }
  }, l = 32, f = 32, d = 32, m = l + 1, y = 2 * l + 1;
  function b(T) {
    const { a: E, b: S } = a, B = K(T * T), z = K(B * T);
    return K(z + E * T + S);
  }
  const w = a.a === r;
  class v extends Error {
    constructor(E) {
      super(E);
    }
  }
  function k(T) {
    if (!(T instanceof x))
      throw new TypeError("JacobianPoint expected");
  }
  class x {
    constructor(E, S, B) {
      this.x = E, this.y = S, this.z = B;
    }
    static fromAffine(E) {
      if (!(E instanceof P))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return E.equals(P.ZERO) ? x.ZERO : new x(E.x, E.y, n);
    }
    static toAffineBatch(E) {
      const S = St(E.map((B) => B.z));
      return E.map((B, z) => B.toAffine(S[z]));
    }
    static normalizeZ(E) {
      return x.toAffineBatch(E).map(x.fromAffine);
    }
    equals(E) {
      k(E);
      const { x: S, y: B, z } = this, { x: D, y: X, z: Y } = E, se = K(z * z), oe = K(Y * Y), ue = K(S * oe), he = K(D * se), be = K(K(B * Y) * oe), yt = K(K(X * z) * se);
      return ue === he && be === yt;
    }
    negate() {
      return new x(this.x, K(-this.y), this.z);
    }
    double() {
      const { x: E, y: S, z: B } = this, z = K(E * E), D = K(S * S), X = K(D * D), Y = E + D, se = K(o * (K(Y * Y) - z - X)), oe = K(i * z), ue = K(oe * oe), he = K(ue - o * se), be = K(oe * (se - he) - s * X), yt = K(o * S * B);
      return new x(he, be, yt);
    }
    add(E) {
      k(E);
      const { x: S, y: B, z } = this, { x: D, y: X, z: Y } = E;
      if (D === r || X === r)
        return this;
      if (S === r || B === r)
        return E;
      const se = K(z * z), oe = K(Y * Y), ue = K(S * oe), he = K(D * se), be = K(K(B * Y) * oe), yt = K(K(X * z) * se), lt = K(he - ue), vr = K(yt - be);
      if (lt === r)
        return vr === r ? this.double() : x.ZERO;
      const ao = K(lt * lt), co = K(lt * ao), uo = K(ue * ao), hs = K(vr * vr - co - o * uo), Fc = K(vr * (uo - hs) - be * co), Mo = K(z * Y * lt);
      return new x(hs, Fc, Mo);
    }
    subtract(E) {
      return this.add(E.negate());
    }
    multiplyUnsafe(E) {
      const S = x.ZERO;
      if (typeof E == "bigint" && E === r)
        return S;
      let B = le(E);
      if (B === n)
        return this;
      if (!w) {
        let he = S, be = this;
        for (; B > r; )
          B & n && (he = he.add(be)), be = be.double(), B >>= n;
        return he;
      }
      let { k1neg: z, k1: D, k2neg: X, k2: Y } = u.splitScalar(B), se = S, oe = S, ue = this;
      for (; D > r || Y > r; )
        D & n && (se = se.add(ue)), Y & n && (oe = oe.add(ue)), ue = ue.double(), D >>= n, Y >>= n;
      return z && (se = se.negate()), X && (oe = oe.negate()), oe = new x(K(oe.x * u.beta), oe.y, oe.z), se.add(oe);
    }
    precomputeWindow(E) {
      const S = w ? 128 / E + 1 : 256 / E + 1, B = [];
      let z = this, D = z;
      for (let X = 0; X < S; X++) {
        D = z, B.push(D);
        for (let Y = 1; Y < 2 ** (E - 1); Y++)
          D = D.add(z), B.push(D);
        z = D.double();
      }
      return B;
    }
    wNAF(E, S) {
      !S && this.equals(x.BASE) && (S = P.BASE);
      const B = S && S._WINDOW_SIZE || 1;
      if (256 % B)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let z = S && I.get(S);
      z || (z = this.precomputeWindow(B), S && B !== 1 && (z = x.normalizeZ(z), I.set(S, z)));
      let D = x.ZERO, X = x.BASE;
      const Y = 1 + (w ? 128 / B : 256 / B), se = 2 ** (B - 1), oe = BigInt(2 ** B - 1), ue = 2 ** B, he = BigInt(B);
      for (let be = 0; be < Y; be++) {
        const yt = be * se;
        let lt = Number(E & oe);
        E >>= he, lt > se && (lt -= ue, E += n);
        const vr = yt, ao = yt + Math.abs(lt) - 1, co = be % 2 !== 0, uo = lt < 0;
        lt === 0 ? X = X.add(_(co, z[vr])) : D = D.add(_(uo, z[ao]));
      }
      return { p: D, f: X };
    }
    multiply(E, S) {
      let B = le(E), z, D;
      if (w) {
        const { k1neg: X, k1: Y, k2neg: se, k2: oe } = u.splitScalar(B);
        let { p: ue, f: he } = this.wNAF(Y, S), { p: be, f: yt } = this.wNAF(oe, S);
        ue = _(X, ue), be = _(se, be), be = new x(K(be.x * u.beta), be.y, be.z), z = ue.add(be), D = he.add(yt);
      } else {
        const { p: X, f: Y } = this.wNAF(B, S);
        z = X, D = Y;
      }
      return x.normalizeZ([z, D])[0];
    }
    toAffine(E) {
      const { x: S, y: B, z } = this, D = this.equals(x.ZERO);
      E == null && (E = D ? s : ze(z));
      const X = E, Y = K(X * X), se = K(Y * X), oe = K(S * Y), ue = K(B * se), he = K(z * X);
      if (D)
        return P.ZERO;
      if (he !== n)
        throw new Error("invZ was invalid");
      return new P(oe, ue);
    }
  }
  x.BASE = new x(a.Gx, a.Gy, n), x.ZERO = new x(r, n, r);
  function _(T, E) {
    const S = E.negate();
    return T ? S : E;
  }
  const I = /* @__PURE__ */ new WeakMap();
  class P {
    constructor(E, S) {
      this.x = E, this.y = S;
    }
    _setWindowSize(E) {
      this._WINDOW_SIZE = E, I.delete(this);
    }
    hasEvenY() {
      return this.y % o === r;
    }
    static fromCompressedHex(E) {
      const S = E.length === 32, B = ie(S ? E : E.subarray(1));
      if (!bt(B))
        throw new Error("Point is not on curve");
      const z = b(B);
      let D = At(z);
      const X = (D & n) === n;
      S ? X && (D = K(-D)) : (E[0] & 1) === 1 !== X && (D = K(-D));
      const Y = new P(B, D);
      return Y.assertValidity(), Y;
    }
    static fromUncompressedHex(E) {
      const S = ie(E.subarray(1, l + 1)), B = ie(E.subarray(l + 1, l * 2 + 1)), z = new P(S, B);
      return z.assertValidity(), z;
    }
    static fromHex(E) {
      const S = ne(E), B = S.length, z = S[0];
      if (B === l)
        return this.fromCompressedHex(S);
      if (B === m && (z === 2 || z === 3))
        return this.fromCompressedHex(S);
      if (B === y && z === 4)
        return this.fromUncompressedHex(S);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${m} compressed bytes or ${y} uncompressed bytes, not ${B}`);
    }
    static fromPrivateKey(E) {
      return P.BASE.multiply(Gt(E));
    }
    static fromSignature(E, S, B) {
      const { r: z, s: D } = us(S);
      if (![0, 1, 2, 3].includes(B))
        throw new Error("Cannot recover: invalid recovery bit");
      const X = Ge(ne(E)), { n: Y } = a, se = B === 2 || B === 3 ? z + Y : z, oe = ze(se, Y), ue = K(-X * oe, Y), he = K(D * oe, Y), be = B & 1 ? "03" : "02", yt = P.fromHex(be + C(se)), lt = P.BASE.multiplyAndAddUnsafe(yt, ue, he);
      if (!lt)
        throw new Error("Cannot recover signature: point at infinify");
      return lt.assertValidity(), lt;
    }
    toRawBytes(E = false) {
      return te(this.toHex(E));
    }
    toHex(E = false) {
      const S = C(this.x);
      return E ? `${this.hasEvenY() ? "02" : "03"}${S}` : `04${S}${C(this.y)}`;
    }
    toHexX() {
      return this.toHex(true).slice(2);
    }
    toRawX() {
      return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
      const E = "Point is not on elliptic curve", { x: S, y: B } = this;
      if (!bt(S) || !bt(B))
        throw new Error(E);
      const z = K(B * B), D = b(S);
      if (K(z - D) !== r)
        throw new Error(E);
    }
    equals(E) {
      return this.x === E.x && this.y === E.y;
    }
    negate() {
      return new P(this.x, K(-this.y));
    }
    double() {
      return x.fromAffine(this).double().toAffine();
    }
    add(E) {
      return x.fromAffine(this).add(x.fromAffine(E)).toAffine();
    }
    subtract(E) {
      return this.add(E.negate());
    }
    multiply(E) {
      return x.fromAffine(this).multiply(E, this).toAffine();
    }
    multiplyAndAddUnsafe(E, S, B) {
      const z = x.fromAffine(this), D = S === r || S === n || this !== P.BASE ? z.multiplyUnsafe(S) : z.multiply(S), X = x.fromAffine(E).multiplyUnsafe(B), Y = D.add(X);
      return Y.equals(x.ZERO) ? void 0 : Y.toAffine();
    }
  }
  e.Point = P, P.BASE = new P(a.Gx, a.Gy), P.ZERO = new P(r, r);
  function $(T) {
    return Number.parseInt(T[0], 16) >= 8 ? "00" + T : T;
  }
  function L(T) {
    if (T.length < 2 || T[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${q(T)}`);
    const E = T[1], S = T.subarray(2, E + 2);
    if (!E || S.length !== E)
      throw new Error("Invalid signature integer: wrong length");
    if (S[0] === 0 && S[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ie(S), left: T.subarray(E + 2) };
  }
  function V(T) {
    if (T.length < 2 || T[0] != 48)
      throw new Error(`Invalid signature tag: ${q(T)}`);
    if (T[1] !== T.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: E, left: S } = L(T.subarray(2)), { data: B, left: z } = L(S);
    if (z.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${q(z)}`);
    return { r: E, s: B };
  }
  class ee {
    constructor(E, S) {
      this.r = E, this.s = S, this.assertValidity();
    }
    static fromCompact(E) {
      const S = E instanceof Uint8Array, B = "Signature.fromCompact";
      if (typeof E != "string" && !S)
        throw new TypeError(`${B}: Expected string or Uint8Array`);
      const z = S ? q(E) : E;
      if (z.length !== 128)
        throw new Error(`${B}: Expected 64-byte hex`);
      return new ee(re(z.slice(0, 64)), re(z.slice(64, 128)));
    }
    static fromDER(E) {
      const S = E instanceof Uint8Array;
      if (typeof E != "string" && !S)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: B, s: z } = V(S ? E : te(E));
      return new ee(B, z);
    }
    static fromHex(E) {
      return this.fromDER(E);
    }
    assertValidity() {
      const { r: E, s: S } = this;
      if (!Ae(E))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Ae(S))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const E = a.n >> n;
      return this.s > E;
    }
    normalizeS() {
      return this.hasHighS() ? new ee(this.r, K(-this.s, a.n)) : this;
    }
    toDERRawBytes() {
      return te(this.toDERHex());
    }
    toDERHex() {
      const E = $(M(this.s)), S = $(M(this.r)), B = E.length / 2, z = S.length / 2, D = M(B), X = M(z);
      return `30${M(z + B + 4)}02${X}${S}02${D}${E}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return te(this.toCompactHex());
    }
    toCompactHex() {
      return C(this.r) + C(this.s);
    }
  }
  e.Signature = ee;
  function G(...T) {
    if (!T.every((B) => B instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (T.length === 1)
      return T[0];
    const E = T.reduce((B, z) => B + z.length, 0), S = new Uint8Array(E);
    for (let B = 0, z = 0; B < T.length; B++) {
      const D = T[B];
      S.set(D, z), z += D.length;
    }
    return S;
  }
  const N = Array.from({ length: 256 }, (T, E) => E.toString(16).padStart(2, "0"));
  function q(T) {
    if (!(T instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let E = "";
    for (let S = 0; S < T.length; S++)
      E += N[T[S]];
    return E;
  }
  const j = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function C(T) {
    if (typeof T != "bigint")
      throw new Error("Expected bigint");
    if (!(r <= T && T < j))
      throw new Error("Expected number 0 <= n < 2^256");
    return T.toString(16).padStart(64, "0");
  }
  function U(T) {
    const E = te(C(T));
    if (E.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return E;
  }
  function M(T) {
    const E = T.toString(16);
    return E.length & 1 ? `0${E}` : E;
  }
  function re(T) {
    if (typeof T != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof T);
    return BigInt(`0x${T}`);
  }
  function te(T) {
    if (typeof T != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof T);
    if (T.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + T.length);
    const E = new Uint8Array(T.length / 2);
    for (let S = 0; S < E.length; S++) {
      const B = S * 2, z = T.slice(B, B + 2), D = Number.parseInt(z, 16);
      if (Number.isNaN(D) || D < 0)
        throw new Error("Invalid byte sequence");
      E[S] = D;
    }
    return E;
  }
  function ie(T) {
    return re(q(T));
  }
  function ne(T) {
    return T instanceof Uint8Array ? Uint8Array.from(T) : te(T);
  }
  function le(T) {
    if (typeof T == "number" && Number.isSafeInteger(T) && T > 0)
      return BigInt(T);
    if (typeof T == "bigint" && Ae(T))
      return T;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function K(T, E = a.P) {
    const S = T % E;
    return S >= r ? S : E + S;
  }
  function ve(T, E) {
    const { P: S } = a;
    let B = T;
    for (; E-- > r; )
      B *= B, B %= S;
    return B;
  }
  function At(T) {
    const { P: E } = a, S = BigInt(6), B = BigInt(11), z = BigInt(22), D = BigInt(23), X = BigInt(44), Y = BigInt(88), se = T * T * T % E, oe = se * se * T % E, ue = ve(oe, i) * oe % E, he = ve(ue, i) * oe % E, be = ve(he, o) * se % E, yt = ve(be, B) * be % E, lt = ve(yt, z) * yt % E, vr = ve(lt, X) * lt % E, ao = ve(vr, Y) * vr % E, co = ve(ao, X) * lt % E, uo = ve(co, i) * oe % E, hs = ve(uo, D) * yt % E, Fc = ve(hs, S) * se % E, Mo = ve(Fc, o);
    if (Mo * Mo % E !== T)
      throw new Error("Cannot find square root");
    return Mo;
  }
  function ze(T, E = a.P) {
    if (T === r || E <= r)
      throw new Error(`invert: expected positive integers, got n=${T} mod=${E}`);
    let S = K(T, E), B = E, z = r, D = n;
    for (; S !== r; ) {
      const X = B / S, Y = B % S, se = z - D * X;
      B = S, S = Y, z = D, D = se;
    }
    if (B !== n)
      throw new Error("invert: does not exist");
    return K(z, E);
  }
  function St(T, E = a.P) {
    const S = new Array(T.length), B = T.reduce((D, X, Y) => X === r ? D : (S[Y] = D, K(D * X, E)), n), z = ze(B, E);
    return T.reduceRight((D, X, Y) => X === r ? D : (S[Y] = K(D * S[Y], E), K(D * X, E)), z), S;
  }
  function et(T) {
    const E = T.length * 8 - f * 8, S = ie(T);
    return E > 0 ? S >> BigInt(E) : S;
  }
  function Ge(T, E = false) {
    const S = et(T);
    if (E)
      return S;
    const { n: B } = a;
    return S >= B ? S - B : S;
  }
  let ut, ot;
  class He {
    constructor(E, S) {
      if (this.hashLen = E, this.qByteLen = S, typeof E != "number" || E < 2)
        throw new Error("hashLen must be a number");
      if (typeof S != "number" || S < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(E).fill(1), this.k = new Uint8Array(E).fill(0), this.counter = 0;
    }
    hmac(...E) {
      return e.utils.hmacSha256(this.k, ...E);
    }
    hmacSync(...E) {
      return ot(this.k, ...E);
    }
    checkSync() {
      if (typeof ot != "function")
        throw new v("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(E = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), E), this.v = await this.hmac(this.v), E.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), E), this.v = await this.hmac(this.v));
    }
    reseedSync(E = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), E), this.v = this.hmacSync(this.v), E.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), E), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let E = 0;
      const S = [];
      for (; E < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const B = this.v.slice();
        S.push(B), E += this.v.length;
      }
      return G(...S);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let E = 0;
      const S = [];
      for (; E < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const B = this.v.slice();
        S.push(B), E += this.v.length;
      }
      return G(...S);
    }
  }
  function Ae(T) {
    return r < T && T < a.n;
  }
  function bt(T) {
    return r < T && T < a.P;
  }
  function wr(T, E, S, B = true) {
    const { n: z } = a, D = Ge(T, true);
    if (!Ae(D))
      return;
    const X = ze(D, z), Y = P.BASE.multiply(D), se = K(Y.x, z);
    if (se === r)
      return;
    const oe = K(X * K(E + S * se, z), z);
    if (oe === r)
      return;
    let ue = new ee(se, oe), he = (Y.x === ue.r ? 0 : 2) | Number(Y.y & n);
    return B && ue.hasHighS() && (ue = ue.normalizeS(), he ^= 1), { sig: ue, recovery: he };
  }
  function Gt(T) {
    let E;
    if (typeof T == "bigint")
      E = T;
    else if (typeof T == "number" && Number.isSafeInteger(T) && T > 0)
      E = BigInt(T);
    else if (typeof T == "string") {
      if (T.length !== 2 * f)
        throw new Error("Expected 32 bytes of private key");
      E = re(T);
    } else if (T instanceof Uint8Array) {
      if (T.length !== f)
        throw new Error("Expected 32 bytes of private key");
      E = ie(T);
    } else
      throw new TypeError("Expected valid private key");
    if (!Ae(E))
      throw new Error("Expected private key: 0 < key < n");
    return E;
  }
  function An(T) {
    return T instanceof P ? (T.assertValidity(), T) : P.fromHex(T);
  }
  function us(T) {
    if (T instanceof ee)
      return T.assertValidity(), T;
    try {
      return ee.fromDER(T);
    } catch {
      return ee.fromCompact(T);
    }
  }
  function Lc(T, E = false) {
    return P.fromPrivateKey(T).toRawBytes(E);
  }
  e.getPublicKey = Lc;
  function ls(T, E, S, B = false) {
    return P.fromSignature(T, E, S).toRawBytes(B);
  }
  e.recoverPublicKey = ls;
  function Sn(T) {
    const E = T instanceof Uint8Array, S = typeof T == "string", B = (E || S) && T.length;
    return E ? B === m || B === y : S ? B === m * 2 || B === y * 2 : T instanceof P;
  }
  function Wt(T, E, S = false) {
    if (Sn(T))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Sn(E))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const B = An(E);
    return B.assertValidity(), B.multiply(Gt(T)).toRawBytes(S);
  }
  e.getSharedSecret = Wt;
  function so(T) {
    const E = T.length > l ? T.slice(0, l) : T;
    return ie(E);
  }
  function jc(T) {
    const E = so(T), S = K(E, a.n);
    return Qt(S < r ? E : S);
  }
  function Qt(T) {
    return U(T);
  }
  function fs(T, E, S) {
    if (T == null)
      throw new Error(`sign: expected valid message hash, not "${T}"`);
    const B = ne(T), z = Gt(E), D = [Qt(z), jc(B)];
    if (S != null) {
      S === true && (S = e.utils.randomBytes(l));
      const se = ne(S);
      if (se.length !== l)
        throw new Error(`sign: Expected ${l} bytes of extra data`);
      D.push(se);
    }
    const X = G(...D), Y = so(B);
    return { seed: X, m: Y, d: z };
  }
  function p(T, E) {
    const { sig: S, recovery: B } = T, { der: z, recovered: D } = Object.assign({ canonical: true, der: true }, E), X = z ? S.toDERRawBytes() : S.toCompactRawBytes();
    return D ? [X, B] : X;
  }
  async function h(T, E, S = {}) {
    const { seed: B, m: z, d: D } = fs(T, E, S.extraEntropy), X = new He(d, f);
    await X.reseed(B);
    let Y;
    for (; !(Y = wr(await X.generate(), z, D, S.canonical)); )
      await X.reseed();
    return p(Y, S);
  }
  e.sign = h;
  function g(T, E, S = {}) {
    const { seed: B, m: z, d: D } = fs(T, E, S.extraEntropy), X = new He(d, f);
    X.reseedSync(B);
    let Y;
    for (; !(Y = wr(X.generateSync(), z, D, S.canonical)); )
      X.reseedSync();
    return p(Y, S);
  }
  e.signSync = g;
  const A = { strict: true };
  function O(T, E, S, B = A) {
    let z;
    try {
      z = us(T), E = ne(E);
    } catch {
      return false;
    }
    const { r: D, s: X } = z;
    if (B.strict && z.hasHighS())
      return false;
    const Y = Ge(E);
    let se;
    try {
      se = An(S);
    } catch {
      return false;
    }
    const { n: oe } = a, ue = ze(X, oe), he = K(Y * ue, oe), be = K(D * ue, oe), yt = P.BASE.multiplyAndAddUnsafe(se, he, be);
    return yt ? K(yt.x, oe) === D : false;
  }
  e.verify = O;
  function R(T) {
    return K(ie(T), a.n);
  }
  class F {
    constructor(E, S) {
      this.r = E, this.s = S, this.assertValidity();
    }
    static fromHex(E) {
      const S = ne(E);
      if (S.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${S.length}`);
      const B = ie(S.subarray(0, 32)), z = ie(S.subarray(32, 64));
      return new F(B, z);
    }
    assertValidity() {
      const { r: E, s: S } = this;
      if (!bt(E) || !Ae(S))
        throw new Error("Invalid signature");
    }
    toHex() {
      return C(this.r) + C(this.s);
    }
    toRawBytes() {
      return te(this.toHex());
    }
  }
  function me(T) {
    return P.fromPrivateKey(T).toRawX();
  }
  class Me {
    constructor(E, S, B = e.utils.randomBytes()) {
      if (E == null)
        throw new TypeError(`sign: Expected valid message, not "${E}"`);
      this.m = ne(E);
      const { x: z, scalar: D } = this.getScalar(Gt(S));
      if (this.px = z, this.d = D, this.rand = ne(B), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(E) {
      const S = P.fromPrivateKey(E), B = S.hasEvenY() ? E : a.n - E;
      return { point: S, scalar: B, x: S.toRawX() };
    }
    initNonce(E, S) {
      return U(E ^ ie(S));
    }
    finalizeNonce(E) {
      const S = K(ie(E), a.n);
      if (S === r)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: B, x: z, scalar: D } = this.getScalar(S);
      return { R: B, rx: z, k: D };
    }
    finalizeSig(E, S, B, z) {
      return new F(E.x, K(S + B * z, a.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: E, d: S, px: B, rand: z } = this, D = e.utils.taggedHash, X = this.initNonce(S, await D(an.aux, z)), { R: Y, rx: se, k: oe } = this.finalizeNonce(await D(an.nonce, X, B, E)), ue = R(await D(an.challenge, se, B, E)), he = this.finalizeSig(Y, oe, ue, S);
      return await Wf(he, E, B) || this.error(), he;
    }
    calcSync() {
      const { m: E, d: S, px: B, rand: z } = this, D = e.utils.taggedHashSync, X = this.initNonce(S, D(an.aux, z)), { R: Y, rx: se, k: oe } = this.finalizeNonce(D(an.nonce, X, B, E)), ue = R(D(an.challenge, se, B, E)), he = this.finalizeSig(Y, oe, ue, S);
      return Zf(he, E, B) || this.error(), he;
    }
  }
  async function Pe(T, E, S) {
    return new Me(T, E, S).calc();
  }
  function Ie(T, E, S) {
    return new Me(T, E, S).calcSync();
  }
  function Se(T, E, S) {
    const B = T instanceof F, z = B ? T : F.fromHex(T);
    return B && z.assertValidity(), {
      ...z,
      m: ne(E),
      P: An(S)
    };
  }
  function Gf(T, E, S, B) {
    const z = P.BASE.multiplyAndAddUnsafe(E, Gt(S), K(-B, a.n));
    return !(!z || !z.hasEvenY() || z.x !== T);
  }
  async function Wf(T, E, S) {
    try {
      const { r: B, s: z, m: D, P: X } = Se(T, E, S), Y = R(await e.utils.taggedHash(an.challenge, U(B), X.toRawX(), D));
      return Gf(B, X, z, Y);
    } catch {
      return false;
    }
  }
  function Zf(T, E, S) {
    try {
      const { r: B, s: z, m: D, P: X } = Se(T, E, S), Y = R(e.utils.taggedHashSync(an.challenge, U(B), X.toRawX(), D));
      return Gf(B, X, z, Y);
    } catch (B) {
      if (B instanceof v)
        throw B;
      return false;
    }
  }
  e.schnorr = {
    Signature: F,
    getPublicKey: me,
    sign: Pe,
    verify: Wf,
    signSync: Ie,
    verifySync: Zf
  }, P.BASE._setWindowSize(8);
  const Dt = {
    node: t,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, an = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, ds = {};
  e.utils = {
    bytesToHex: q,
    hexToBytes: te,
    concatBytes: G,
    mod: K,
    invert: ze,
    isValidPrivateKey(T) {
      try {
        return Gt(T), true;
      } catch {
        return false;
      }
    },
    _bigintTo32Bytes: U,
    _normalizePrivateKey: Gt,
    hashToPrivateKey: (T) => {
      T = ne(T);
      const E = f + 8;
      if (T.length < E || T.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const S = K(ie(T), a.n - n) + n;
      return U(S);
    },
    randomBytes: (T = 32) => {
      if (Dt.web)
        return Dt.web.getRandomValues(new Uint8Array(T));
      if (Dt.node) {
        const { randomBytes: E } = Dt.node;
        return Uint8Array.from(E(T));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => e.utils.hashToPrivateKey(e.utils.randomBytes(f + 8)),
    precompute(T = 8, E = P.BASE) {
      const S = E === P.BASE ? E : new P(E.x, E.y);
      return S._setWindowSize(T), S.multiply(i), S;
    },
    sha256: async (...T) => {
      if (Dt.web) {
        const E = await Dt.web.subtle.digest("SHA-256", G(...T));
        return new Uint8Array(E);
      } else if (Dt.node) {
        const { createHash: E } = Dt.node, S = E("sha256");
        return T.forEach((B) => S.update(B)), Uint8Array.from(S.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (T, ...E) => {
      if (Dt.web) {
        const S = await Dt.web.subtle.importKey("raw", T, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), B = G(...E), z = await Dt.web.subtle.sign("HMAC", S, B);
        return new Uint8Array(z);
      } else if (Dt.node) {
        const { createHmac: S } = Dt.node, B = S("sha256", T);
        return E.forEach((z) => B.update(z)), Uint8Array.from(B.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (T, ...E) => {
      let S = ds[T];
      if (S === void 0) {
        const B = await e.utils.sha256(Uint8Array.from(T, (z) => z.charCodeAt(0)));
        S = G(B, B), ds[T] = S;
      }
      return e.utils.sha256(S, ...E);
    },
    taggedHashSync: (T, ...E) => {
      if (typeof ut != "function")
        throw new v("sha256Sync is undefined, you need to set it");
      let S = ds[T];
      if (S === void 0) {
        const B = ut(Uint8Array.from(T, (z) => z.charCodeAt(0)));
        S = G(B, B), ds[T] = S;
      }
      return ut(S, ...E);
    },
    _JacobianPoint: x
  }, Object.defineProperties(e.utils, {
    sha256Sync: {
      configurable: false,
      get() {
        return ut;
      },
      set(T) {
        ut || (ut = T);
      }
    },
    hmacSha256Sync: {
      configurable: false,
      get() {
        return ot;
      },
      set(T) {
        ot || (ot = T);
      }
    }
  });
})(G8);
var Om = {};
var So = {};
Object.defineProperty(So, "__esModule", { value: true });
So.isBytes = mO;
So.number = Gg;
So.bool = gO;
So.bytes = W8;
So.hash = bO;
So.exists = yO;
So.output = wO;
function Gg(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function gO(e) {
  if (typeof e != "boolean")
    throw new Error(`boolean expected, not ${e}`);
}
function mO(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function W8(e, ...t) {
  if (!mO(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function bO(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Gg(e.outputLen), Gg(e.blockLen);
}
function yO(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function wO(e, t) {
  W8(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var zhe = { number: Gg, bool: gO, bytes: W8, hash: bO, exists: yO, output: wO };
So.default = zhe;
var Rc = {};
var Bm = {};
Object.defineProperty(Bm, "__esModule", { value: true });
Bm.crypto = void 0;
Bm.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.Hash = e.nextTick = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = void 0, e.isBytes = n, e.byteSwap32 = l, e.bytesToHex = d, e.hexToBytes = b, e.asyncLoop = v, e.utf8ToBytes = k, e.toBytes = x, e.concatBytes = _, e.checkOpts = $, e.wrapConstructor = L, e.wrapConstructorWithOpts = V, e.wrapXOFConstructorWithOpts = ee, e.randomBytes = G;
  const t = Bm, r = So;
  function n(N) {
    return N instanceof Uint8Array || N != null && typeof N == "object" && N.constructor.name === "Uint8Array";
  }
  const o = (N) => new Uint8Array(N.buffer, N.byteOffset, N.byteLength);
  e.u8 = o;
  const i = (N) => new Uint32Array(N.buffer, N.byteOffset, Math.floor(N.byteLength / 4));
  e.u32 = i;
  const s = (N) => new DataView(N.buffer, N.byteOffset, N.byteLength);
  e.createView = s;
  const a = (N, q) => N << 32 - q | N >>> q;
  e.rotr = a;
  const c = (N, q) => N << q | N >>> 32 - q >>> 0;
  e.rotl = c, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  const u = (N) => N << 24 & 4278190080 | N << 8 & 16711680 | N >>> 8 & 65280 | N >>> 24 & 255;
  e.byteSwap = u, e.byteSwapIfBE = e.isLE ? (N) => N : (N) => (0, e.byteSwap)(N);
  function l(N) {
    for (let q = 0; q < N.length; q++)
      N[q] = (0, e.byteSwap)(N[q]);
  }
  const f = Array.from({ length: 256 }, (N, q) => q.toString(16).padStart(2, "0"));
  function d(N) {
    (0, r.bytes)(N);
    let q = "";
    for (let j = 0; j < N.length; j++)
      q += f[N[j]];
    return q;
  }
  const m = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function y(N) {
    if (N >= m._0 && N <= m._9)
      return N - m._0;
    if (N >= m._A && N <= m._F)
      return N - (m._A - 10);
    if (N >= m._a && N <= m._f)
      return N - (m._a - 10);
  }
  function b(N) {
    if (typeof N != "string")
      throw new Error("hex string expected, got " + typeof N);
    const q = N.length, j = q / 2;
    if (q % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + q);
    const C = new Uint8Array(j);
    for (let U = 0, M = 0; U < j; U++, M += 2) {
      const re = y(N.charCodeAt(M)), te = y(N.charCodeAt(M + 1));
      if (re === void 0 || te === void 0) {
        const ie = N[M] + N[M + 1];
        throw new Error('hex string expected, got non-hex character "' + ie + '" at index ' + M);
      }
      C[U] = re * 16 + te;
    }
    return C;
  }
  const w = async () => {
  };
  e.nextTick = w;
  async function v(N, q, j) {
    let C = Date.now();
    for (let U = 0; U < N; U++) {
      j(U);
      const M = Date.now() - C;
      M >= 0 && M < q || (await (0, e.nextTick)(), C += M);
    }
  }
  function k(N) {
    if (typeof N != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof N}`);
    return new Uint8Array(new TextEncoder().encode(N));
  }
  function x(N) {
    return typeof N == "string" && (N = k(N)), (0, r.bytes)(N), N;
  }
  function _(...N) {
    let q = 0;
    for (let C = 0; C < N.length; C++) {
      const U = N[C];
      (0, r.bytes)(U), q += U.length;
    }
    const j = new Uint8Array(q);
    for (let C = 0, U = 0; C < N.length; C++) {
      const M = N[C];
      j.set(M, U), U += M.length;
    }
    return j;
  }
  class I {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = I;
  const P = {}.toString;
  function $(N, q) {
    if (q !== void 0 && P.call(q) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(N, q);
  }
  function L(N) {
    const q = (C) => N().update(x(C)).digest(), j = N();
    return q.outputLen = j.outputLen, q.blockLen = j.blockLen, q.create = () => N(), q;
  }
  function V(N) {
    const q = (C, U) => N(U).update(x(C)).digest(), j = N({});
    return q.outputLen = j.outputLen, q.blockLen = j.blockLen, q.create = (C) => N(C), q;
  }
  function ee(N) {
    const q = (C, U) => N(U).update(x(C)).digest(), j = N({});
    return q.outputLen = j.outputLen, q.blockLen = j.blockLen, q.create = (C) => N(C), q;
  }
  function G(N = 32) {
    if (t.crypto && typeof t.crypto.getRandomValues == "function")
      return t.crypto.getRandomValues(new Uint8Array(N));
    if (t.crypto && typeof t.crypto.randomBytes == "function")
      return t.crypto.randomBytes(N);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(Rc);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.hmac = e.HMAC = void 0;
  const t = So, r = Rc;
  class n extends r.Hash {
    constructor(s, a) {
      super(), this.finished = false, this.destroyed = false, (0, t.hash)(s);
      const c = (0, r.toBytes)(a);
      if (this.iHash = s.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const u = this.blockLen, l = new Uint8Array(u);
      l.set(c.length > u ? s.create().update(c).digest() : c);
      for (let f = 0; f < l.length; f++)
        l[f] ^= 54;
      this.iHash.update(l), this.oHash = s.create();
      for (let f = 0; f < l.length; f++)
        l[f] ^= 106;
      this.oHash.update(l), l.fill(0);
    }
    update(s) {
      return (0, t.exists)(this), this.iHash.update(s), this;
    }
    digestInto(s) {
      (0, t.exists)(this), (0, t.bytes)(s, this.outputLen), this.finished = true, this.iHash.digestInto(s), this.oHash.update(s), this.oHash.digestInto(s), this.destroy();
    }
    digest() {
      const s = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(s), s;
    }
    _cloneInto(s) {
      s || (s = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: a, iHash: c, finished: u, destroyed: l, blockLen: f, outputLen: d } = this;
      return s = s, s.finished = u, s.destroyed = l, s.blockLen = f, s.outputLen = d, s.oHash = a._cloneInto(s.oHash), s.iHash = c._cloneInto(s.iHash), s;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = n;
  const o = (i, s, a) => new n(i, s).update(a).digest();
  e.hmac = o, e.hmac.create = (i, s) => new n(i, s);
})(Om);
var di = {};
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: true });
Ds.HashMD = Ds.Maj = Ds.Chi = void 0;
var Ly = So;
var fd = Rc;
function Hhe(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 4 : 0, u = n ? 0 : 4;
  e.setUint32(t + c, s, n), e.setUint32(t + u, a, n);
}
var Lhe = (e, t, r) => e & t ^ ~e & r;
Ds.Chi = Lhe;
var jhe = (e, t, r) => e & t ^ e & r ^ t & r;
Ds.Maj = jhe;
var Fhe = class extends fd.Hash {
  constructor(t, r, n, o) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = (0, fd.createView)(this.buffer);
  }
  update(t) {
    (0, Ly.exists)(this);
    const { view: r, buffer: n, blockLen: o } = this;
    t = (0, fd.toBytes)(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const a = Math.min(o - this.pos, i - s);
      if (a === o) {
        const c = (0, fd.createView)(t);
        for (; o <= i - s; s += o)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + a), this.pos), this.pos += a, s += a, this.pos === o && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    (0, Ly.exists)(this), (0, Ly.output)(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: o, isLE: i } = this;
    let { pos: s } = this;
    r[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > o - s && (this.process(n, 0), s = 0);
    for (let f = s; f < o; f++)
      r[f] = 0;
    Hhe(n, o - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = (0, fd.createView)(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      a.setUint32(4 * f, l[f], i);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: o, finished: i, destroyed: s, pos: a } = this;
    return t.length = o, t.pos = a, t.finished = i, t.destroyed = s, o % r && t.buffer.set(n), t;
  }
};
Ds.HashMD = Fhe;
Object.defineProperty(di, "__esModule", { value: true });
di.sha224 = di.sha256 = di.SHA256 = void 0;
var jy = Ds;
var $o = Rc;
var Dhe = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Wa = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Za = new Uint32Array(64);
var Z8 = class extends jy.HashMD {
  constructor() {
    super(64, 32, 8, false), this.A = Wa[0] | 0, this.B = Wa[1] | 0, this.C = Wa[2] | 0, this.D = Wa[3] | 0, this.E = Wa[4] | 0, this.F = Wa[5] | 0, this.G = Wa[6] | 0, this.H = Wa[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: o, E: i, F: s, G: a, H: c } = this;
    return [t, r, n, o, i, s, a, c];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = o | 0, this.E = i | 0, this.F = s | 0, this.G = a | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let f = 0; f < 16; f++, r += 4)
      Za[f] = t.getUint32(r, false);
    for (let f = 16; f < 64; f++) {
      const d = Za[f - 15], m = Za[f - 2], y = (0, $o.rotr)(d, 7) ^ (0, $o.rotr)(d, 18) ^ d >>> 3, b = (0, $o.rotr)(m, 17) ^ (0, $o.rotr)(m, 19) ^ m >>> 10;
      Za[f] = b + Za[f - 7] + y + Za[f - 16] | 0;
    }
    let { A: n, B: o, C: i, D: s, E: a, F: c, G: u, H: l } = this;
    for (let f = 0; f < 64; f++) {
      const d = (0, $o.rotr)(a, 6) ^ (0, $o.rotr)(a, 11) ^ (0, $o.rotr)(a, 25), m = l + d + (0, jy.Chi)(a, c, u) + Dhe[f] + Za[f] | 0, y = ((0, $o.rotr)(n, 2) ^ (0, $o.rotr)(n, 13) ^ (0, $o.rotr)(n, 22)) + (0, jy.Maj)(n, o, i) | 0;
      l = u, u = c, c = a, a = s + m | 0, s = i, i = o, o = n, n = m + y | 0;
    }
    n = n + this.A | 0, o = o + this.B | 0, i = i + this.C | 0, s = s + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, o, i, s, a, c, u, l);
  }
  roundClean() {
    Za.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
di.SHA256 = Z8;
var Khe = class extends Z8 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
di.sha256 = (0, $o.wrapConstructor)(() => new Z8());
di.sha224 = (0, $o.wrapConstructor)(() => new Khe());
var Mhe = G8;
var qhe = Om;
var vO = di;
function Vhe(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(r) {
    if (r !== "default") {
      var n = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(t, r, n.get ? n : {
        enumerable: true,
        get: function() {
          return e[r];
        }
      });
    }
  }), t.default = e, Object.freeze(t);
}
var Ot = Vhe(Mhe);
var zc = "Expected Private";
var Hc = "Expected Point";
var op = "Expected Tweak";
var Ghe = "Expected Hash";
var Wg = "Expected Signature";
var X8 = "Expected Extra Data (32 bytes)";
var ip = "Expected Scalar";
var Whe = "Bad Recovery Id";
Ot.utils.hmacSha256Sync = (e, ...t) => qhe.hmac(vO.sha256, e, Ot.utils.concatBytes(...t));
Ot.utils.sha256Sync = (...e) => vO.sha256(Ot.utils.concatBytes(...e));
var Y8 = Ot.utils._normalizePrivateKey;
var Zhe = 32;
var Xhe = 32;
var z2 = new Uint8Array([
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65
]);
var Yhe = 32;
var Jhe = new Uint8Array(32);
var Qhe = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  69,
  81,
  35,
  25,
  80,
  183,
  95,
  196,
  64,
  45,
  161,
  114,
  47,
  201,
  186,
  238
]);
function epe(e) {
  return e instanceof Uint8Array;
}
function wh(e, t) {
  for (let r = 0; r < 32; ++r)
    if (e[r] !== t[r])
      return e[r] < t[r] ? -1 : 1;
  return 0;
}
function HE(e) {
  return wh(e, Jhe) === 0;
}
function sp(e) {
  return !(!(e instanceof Uint8Array) || e.length !== Xhe || wh(e, z2) >= 0);
}
function J8(e) {
  return e instanceof Uint8Array && e.length === 64 && wh(e.subarray(0, 32), z2) < 0 && wh(e.subarray(32, 64), z2) < 0;
}
function tpe(e) {
  return epe(e) && e.length === 64 && wh(e.subarray(0, 32), Qhe) < 0;
}
function rpe(e) {
  return !(HE(e.subarray(0, 32)) || HE(e.subarray(32, 64)));
}
function jf(e) {
  return e instanceof Uint8Array && e.length === Zhe;
}
function Q8(e) {
  return e === void 0 || e instanceof Uint8Array && e.length === Yhe;
}
function EO(e) {
  if (typeof e != "string")
    throw new TypeError("hexToNumber: expected string, got " + typeof e);
  return BigInt(`0x${e}`);
}
function npe(e) {
  return EO(Ot.utils.bytesToHex(e));
}
function e5(e) {
  let t;
  if (typeof e == "bigint")
    t = e;
  else if (typeof e == "number" && Number.isSafeInteger(e) && e >= 0)
    t = BigInt(e);
  else if (typeof e == "string") {
    if (e.length !== 64)
      throw new Error("Expected 32 bytes of private scalar");
    t = EO(e);
  } else if (e instanceof Uint8Array) {
    if (e.length !== 32)
      throw new Error("Expected 32 bytes of private scalar");
    t = npe(e);
  } else
    throw new TypeError("Expected valid private scalar");
  if (t < 0) throw new Error("Expected private scalar >= 0");
  return t;
}
var ope = (e, t) => {
  const r = Y8(e), n = e5(t), o = Ot.utils._bigintTo32Bytes(Ot.utils.mod(r + n, Ot.CURVE.n));
  return Ot.utils.isValidPrivateKey(o) ? o : null;
};
var ipe = (e, t) => {
  const r = Y8(e), n = e5(t), o = Ot.utils._bigintTo32Bytes(Ot.utils.mod(r - n, Ot.CURVE.n));
  return Ot.utils.isValidPrivateKey(o) ? o : null;
};
var spe = (e) => {
  const t = Y8(e), r = Ot.utils._bigintTo32Bytes(Ot.CURVE.n - t);
  return Ot.utils.isValidPrivateKey(r) ? r : null;
};
var xO = (e, t, r) => {
  const n = Ot.Point.fromHex(e), o = e5(t), i = Ot.Point.BASE.multiplyAndAddUnsafe(n, o, BigInt(1));
  if (!i) throw new Error("Tweaked point at infinity");
  return i.toRawBytes(r);
};
var ape = (e, t, r) => {
  const n = Ot.Point.fromHex(e), o = typeof t == "string" ? t : Ot.utils.bytesToHex(t), i = BigInt(`0x${o}`);
  return n.multiply(i).toRawBytes(r);
};
function Ff(e, t) {
  return e === void 0 ? t !== void 0 ? kO(t) : true : !!e;
}
function nl(e) {
  try {
    return e();
  } catch {
    return null;
  }
}
function t5(e, t) {
  if (e.length === 32 !== t) return false;
  try {
    return !!Ot.Point.fromHex(e);
  } catch {
    return false;
  }
}
function Cc(e) {
  return t5(e, false);
}
function kO(e) {
  return t5(e, false) && e.length === 33;
}
function oa(e) {
  return Ot.utils.isValidPrivateKey(e);
}
function Cm(e) {
  return t5(e, true);
}
function cpe(e, t) {
  if (!Cm(e))
    throw new Error(Hc);
  if (!sp(t))
    throw new Error(op);
  return nl(() => {
    const r = xO(e, t, true);
    return { parity: r[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: r.slice(1) };
  });
}
function AO(e) {
  if (!Cc(e))
    throw new Error(Hc);
  return e.slice(1, 33);
}
function SO(e, t) {
  if (!oa(e))
    throw new Error(zc);
  return nl(
    () => Ot.getPublicKey(e, Ff(t))
  );
}
function upe(e) {
  if (!oa(e))
    throw new Error(zc);
  return AO(SO(e));
}
function lpe(e, t) {
  if (!Cc(e))
    throw new Error(Hc);
  return Ot.Point.fromHex(e).toRawBytes(Ff(t, e));
}
function fpe(e, t, r) {
  if (!Cc(e))
    throw new Error(Hc);
  if (!sp(t))
    throw new Error(op);
  return nl(
    () => ape(e, t, Ff(r, e))
  );
}
function dpe(e, t, r) {
  if (!Cc(e) || !Cc(t))
    throw new Error(Hc);
  return nl(() => {
    const n = Ot.Point.fromHex(e), o = Ot.Point.fromHex(t);
    return n.equals(o.negate()) ? null : n.add(o).toRawBytes(Ff(r, e));
  });
}
function hpe(e, t, r) {
  if (!Cc(e))
    throw new Error(Hc);
  if (!sp(t))
    throw new Error(op);
  return nl(
    () => xO(e, t, Ff(r, e))
  );
}
function ppe(e, t) {
  if (oa(e) === false)
    throw new Error(zc);
  if (sp(t) === false)
    throw new Error(op);
  return nl(() => ope(e, t));
}
function gpe(e, t) {
  if (oa(e) === false)
    throw new Error(zc);
  if (sp(t) === false)
    throw new Error(op);
  return nl(() => ipe(e, t));
}
function mpe(e) {
  if (oa(e) === false)
    throw new Error(zc);
  return spe(e);
}
function bpe(e, t, r) {
  if (!oa(t))
    throw new Error(zc);
  if (!jf(e))
    throw new Error(ip);
  if (!Q8(r))
    throw new Error(X8);
  return Ot.signSync(e, t, { der: false, extraEntropy: r });
}
function ype(e, t, r) {
  if (!oa(t))
    throw new Error(zc);
  if (!jf(e))
    throw new Error(ip);
  if (!Q8(r))
    throw new Error(X8);
  const [n, o] = Ot.signSync(e, t, { der: false, extraEntropy: r, recovered: true });
  return { signature: n, recoveryId: o };
}
function wpe(e, t, r = Buffer.alloc(32, 0)) {
  if (!oa(t))
    throw new Error(zc);
  if (!jf(e))
    throw new Error(ip);
  if (!Q8(r))
    throw new Error(X8);
  return Ot.schnorr.signSync(e, t, r);
}
function vpe(e, t, r, n) {
  if (!jf(e))
    throw new Error(Ghe);
  if (!J8(t) || !rpe(t))
    throw new Error(Wg);
  if (r & 2 && !tpe(t))
    throw new Error(Whe);
  if (!Cm(t.subarray(0, 32)))
    throw new Error(Wg);
  return Ot.recoverPublicKey(e, t, r, Ff(n));
}
function Epe(e, t, r, n) {
  if (!Cc(t))
    throw new Error(Hc);
  if (!J8(r))
    throw new Error(Wg);
  if (!jf(e))
    throw new Error(ip);
  return Ot.verify(r, e, t, { strict: n });
}
function xpe(e, t, r) {
  if (!Cm(t))
    throw new Error(Hc);
  if (!J8(r))
    throw new Error(Wg);
  if (!jf(e))
    throw new Error(ip);
  return Ot.schnorr.verifySync(r, e, t);
}
var kpe = gr.isPoint = Cc;
var Ape = gr.isPointCompressed = kO;
var Spe = gr.isPrivate = oa;
var _pe = gr.isXOnlyPoint = Cm;
var Tpe = gr.pointAdd = dpe;
var Ppe = gr.pointAddScalar = hpe;
var Ipe = gr.pointCompress = lpe;
var Ope = gr.pointFromScalar = SO;
var Bpe = gr.pointMultiply = fpe;
var Cpe = gr.privateAdd = ppe;
var Npe = gr.privateNegate = mpe;
var Upe = gr.privateSub = gpe;
var $pe = gr.recover = vpe;
var Rpe = gr.sign = bpe;
var zpe = gr.signRecoverable = ype;
var Hpe = gr.signSchnorr = wpe;
var Lpe = gr.verify = Epe;
var jpe = gr.verifySchnorr = xpe;
var Fpe = gr.xOnlyPointAddTweak = cpe;
var Dpe = gr.xOnlyPointFromPoint = AO;
var Kpe = gr.xOnlyPointFromScalar = upe;
var r5 = xQ({
  __proto__: null,
  default: gr,
  isPoint: kpe,
  isPointCompressed: Ape,
  isPrivate: Spe,
  isXOnlyPoint: _pe,
  pointAdd: Tpe,
  pointAddScalar: Ppe,
  pointCompress: Ipe,
  pointFromScalar: Ope,
  pointMultiply: Bpe,
  privateAdd: Cpe,
  privateNegate: Npe,
  privateSub: Upe,
  recover: $pe,
  sign: Rpe,
  signRecoverable: zpe,
  signSchnorr: Hpe,
  verify: Lpe,
  verifySchnorr: jpe,
  xOnlyPointAddTweak: Fpe,
  xOnlyPointFromPoint: Dpe,
  xOnlyPointFromScalar: Kpe
}, [gr]);
var _O = {};
var Df = {};
Df.byteLength = Vpe;
Df.toByteArray = Wpe;
Df.fromByteArray = Ype;
var Gi = [];
var zo = [];
var Mpe = typeof Uint8Array < "u" ? Uint8Array : Array;
var Fy = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (pl = 0, qpe = Fy.length; pl < qpe; ++pl)
  Gi[pl] = Fy[pl], zo[Fy.charCodeAt(pl)] = pl;
var pl;
var qpe;
zo[45] = 62;
zo[95] = 63;
function TO(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function Vpe(e) {
  var t = TO(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function Gpe(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function Wpe(e) {
  var t, r = TO(e), n = r[0], o = r[1], i = new Mpe(Gpe(e, n, o)), s = 0, a = o > 0 ? n - 4 : n, c;
  for (c = 0; c < a; c += 4)
    t = zo[e.charCodeAt(c)] << 18 | zo[e.charCodeAt(c + 1)] << 12 | zo[e.charCodeAt(c + 2)] << 6 | zo[e.charCodeAt(c + 3)], i[s++] = t >> 16 & 255, i[s++] = t >> 8 & 255, i[s++] = t & 255;
  return o === 2 && (t = zo[e.charCodeAt(c)] << 2 | zo[e.charCodeAt(c + 1)] >> 4, i[s++] = t & 255), o === 1 && (t = zo[e.charCodeAt(c)] << 10 | zo[e.charCodeAt(c + 1)] << 4 | zo[e.charCodeAt(c + 2)] >> 2, i[s++] = t >> 8 & 255, i[s++] = t & 255), i;
}
function Zpe(e) {
  return Gi[e >> 18 & 63] + Gi[e >> 12 & 63] + Gi[e >> 6 & 63] + Gi[e & 63];
}
function Xpe(e, t, r) {
  for (var n, o = [], i = t; i < r; i += 3)
    n = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255), o.push(Zpe(n));
  return o.join("");
}
function Ype(e) {
  for (var t, r = e.length, n = r % 3, o = [], i = 16383, s = 0, a = r - n; s < a; s += i)
    o.push(Xpe(e, s, s + i > a ? a : s + i));
  return n === 1 ? (t = e[r - 1], o.push(
    Gi[t >> 2] + Gi[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    Gi[t >> 10] + Gi[t >> 4 & 63] + Gi[t << 2 & 63] + "="
  )), o.join("");
}
var n5 = {};
n5.read = function(e, t, r, n, o) {
  var i, s, a = o * 8 - n - 1, c = (1 << a) - 1, u = c >> 1, l = -7, f = r ? o - 1 : 0, d = r ? -1 : 1, m = e[t + f];
  for (f += d, i = m & (1 << -l) - 1, m >>= -l, l += a; l > 0; i = i * 256 + e[t + f], f += d, l -= 8)
    ;
  for (s = i & (1 << -l) - 1, i >>= -l, l += n; l > 0; s = s * 256 + e[t + f], f += d, l -= 8)
    ;
  if (i === 0)
    i = 1 - u;
  else {
    if (i === c)
      return s ? NaN : (m ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, n), i = i - u;
  }
  return (m ? -1 : 1) * s * Math.pow(2, i - n);
};
n5.write = function(e, t, r, n, o, i) {
  var s, a, c, u = i * 8 - o - 1, l = (1 << u) - 1, f = l >> 1, d = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = n ? 0 : i - 1, y = n ? 1 : -1, b = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), s + f >= 1 ? t += d / c : t += d * Math.pow(2, 1 - f), t * c >= 2 && (s++, c /= 2), s + f >= l ? (a = 0, s = l) : s + f >= 1 ? (a = (t * c - 1) * Math.pow(2, o), s = s + f) : (a = t * Math.pow(2, f - 1) * Math.pow(2, o), s = 0)); o >= 8; e[r + m] = a & 255, m += y, a /= 256, o -= 8)
    ;
  for (s = s << o | a, u += o; u > 0; e[r + m] = s & 255, m += y, s /= 256, u -= 8)
    ;
  e[r + m - y] |= b * 128;
};
(function(e) {
  const t = Df, r = n5, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = a, e.SlowBuffer = k, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o, a.TYPED_ARRAY_SUPPORT = i(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function i() {
    try {
      const p = new Uint8Array(1), h = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(h, Uint8Array.prototype), Object.setPrototypeOf(p, h), p.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s(p) {
    if (p > o)
      throw new RangeError('The value "' + p + '" is invalid for option "size"');
    const h = new Uint8Array(p);
    return Object.setPrototypeOf(h, a.prototype), h;
  }
  function a(p, h, g) {
    if (typeof p == "number") {
      if (typeof h == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return f(p);
    }
    return c(p, h, g);
  }
  a.poolSize = 8192;
  function c(p, h, g) {
    if (typeof p == "string")
      return d(p, h);
    if (ArrayBuffer.isView(p))
      return y(p);
    if (p == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p
      );
    if (Wt(p, ArrayBuffer) || p && Wt(p.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Wt(p, SharedArrayBuffer) || p && Wt(p.buffer, SharedArrayBuffer)))
      return b(p, h, g);
    if (typeof p == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const A = p.valueOf && p.valueOf();
    if (A != null && A !== p)
      return a.from(A, h, g);
    const O = w(p);
    if (O) return O;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof p[Symbol.toPrimitive] == "function")
      return a.from(p[Symbol.toPrimitive]("string"), h, g);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p
    );
  }
  a.from = function(p, h, g) {
    return c(p, h, g);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function u(p) {
    if (typeof p != "number")
      throw new TypeError('"size" argument must be of type number');
    if (p < 0)
      throw new RangeError('The value "' + p + '" is invalid for option "size"');
  }
  function l(p, h, g) {
    return u(p), p <= 0 ? s(p) : h !== void 0 ? typeof g == "string" ? s(p).fill(h, g) : s(p).fill(h) : s(p);
  }
  a.alloc = function(p, h, g) {
    return l(p, h, g);
  };
  function f(p) {
    return u(p), s(p < 0 ? 0 : v(p) | 0);
  }
  a.allocUnsafe = function(p) {
    return f(p);
  }, a.allocUnsafeSlow = function(p) {
    return f(p);
  };
  function d(p, h) {
    if ((typeof h != "string" || h === "") && (h = "utf8"), !a.isEncoding(h))
      throw new TypeError("Unknown encoding: " + h);
    const g = x(p, h) | 0;
    let A = s(g);
    const O = A.write(p, h);
    return O !== g && (A = A.slice(0, O)), A;
  }
  function m(p) {
    const h = p.length < 0 ? 0 : v(p.length) | 0, g = s(h);
    for (let A = 0; A < h; A += 1)
      g[A] = p[A] & 255;
    return g;
  }
  function y(p) {
    if (Wt(p, Uint8Array)) {
      const h = new Uint8Array(p);
      return b(h.buffer, h.byteOffset, h.byteLength);
    }
    return m(p);
  }
  function b(p, h, g) {
    if (h < 0 || p.byteLength < h)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (p.byteLength < h + (g || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let A;
    return h === void 0 && g === void 0 ? A = new Uint8Array(p) : g === void 0 ? A = new Uint8Array(p, h) : A = new Uint8Array(p, h, g), Object.setPrototypeOf(A, a.prototype), A;
  }
  function w(p) {
    if (a.isBuffer(p)) {
      const h = v(p.length) | 0, g = s(h);
      return g.length === 0 || p.copy(g, 0, 0, h), g;
    }
    if (p.length !== void 0)
      return typeof p.length != "number" || so(p.length) ? s(0) : m(p);
    if (p.type === "Buffer" && Array.isArray(p.data))
      return m(p.data);
  }
  function v(p) {
    if (p >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return p | 0;
  }
  function k(p) {
    return +p != p && (p = 0), a.alloc(+p);
  }
  a.isBuffer = function(p) {
    return p != null && p._isBuffer === true && p !== a.prototype;
  }, a.compare = function(p, h) {
    if (Wt(p, Uint8Array) && (p = a.from(p, p.offset, p.byteLength)), Wt(h, Uint8Array) && (h = a.from(h, h.offset, h.byteLength)), !a.isBuffer(p) || !a.isBuffer(h))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (p === h) return 0;
    let g = p.length, A = h.length;
    for (let O = 0, R = Math.min(g, A); O < R; ++O)
      if (p[O] !== h[O]) {
        g = p[O], A = h[O];
        break;
      }
    return g < A ? -1 : A < g ? 1 : 0;
  }, a.isEncoding = function(p) {
    switch (String(p).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, a.concat = function(p, h) {
    if (!Array.isArray(p))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (p.length === 0)
      return a.alloc(0);
    let g;
    if (h === void 0)
      for (h = 0, g = 0; g < p.length; ++g)
        h += p[g].length;
    const A = a.allocUnsafe(h);
    let O = 0;
    for (g = 0; g < p.length; ++g) {
      let R = p[g];
      if (Wt(R, Uint8Array))
        O + R.length > A.length ? (a.isBuffer(R) || (R = a.from(R)), R.copy(A, O)) : Uint8Array.prototype.set.call(
          A,
          R,
          O
        );
      else if (a.isBuffer(R))
        R.copy(A, O);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      O += R.length;
    }
    return A;
  };
  function x(p, h) {
    if (a.isBuffer(p))
      return p.length;
    if (ArrayBuffer.isView(p) || Wt(p, ArrayBuffer))
      return p.byteLength;
    if (typeof p != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof p
      );
    const g = p.length, A = arguments.length > 2 && arguments[2] === true;
    if (!A && g === 0) return 0;
    let O = false;
    for (; ; )
      switch (h) {
        case "ascii":
        case "latin1":
        case "binary":
          return g;
        case "utf8":
        case "utf-8":
          return An(p).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return g * 2;
        case "hex":
          return g >>> 1;
        case "base64":
          return ls(p).length;
        default:
          if (O)
            return A ? -1 : An(p).length;
          h = ("" + h).toLowerCase(), O = true;
      }
  }
  a.byteLength = x;
  function _(p, h, g) {
    let A = false;
    if ((h === void 0 || h < 0) && (h = 0), h > this.length || ((g === void 0 || g > this.length) && (g = this.length), g <= 0) || (g >>>= 0, h >>>= 0, g <= h))
      return "";
    for (p || (p = "utf8"); ; )
      switch (p) {
        case "hex":
          return te(this, h, g);
        case "utf8":
        case "utf-8":
          return j(this, h, g);
        case "ascii":
          return M(this, h, g);
        case "latin1":
        case "binary":
          return re(this, h, g);
        case "base64":
          return q(this, h, g);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, h, g);
        default:
          if (A) throw new TypeError("Unknown encoding: " + p);
          p = (p + "").toLowerCase(), A = true;
      }
  }
  a.prototype._isBuffer = true;
  function I(p, h, g) {
    const A = p[h];
    p[h] = p[g], p[g] = A;
  }
  a.prototype.swap16 = function() {
    const p = this.length;
    if (p % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let h = 0; h < p; h += 2)
      I(this, h, h + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const p = this.length;
    if (p % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let h = 0; h < p; h += 4)
      I(this, h, h + 3), I(this, h + 1, h + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const p = this.length;
    if (p % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let h = 0; h < p; h += 8)
      I(this, h, h + 7), I(this, h + 1, h + 6), I(this, h + 2, h + 5), I(this, h + 3, h + 4);
    return this;
  }, a.prototype.toString = function() {
    const p = this.length;
    return p === 0 ? "" : arguments.length === 0 ? j(this, 0, p) : _.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(p) {
    if (!a.isBuffer(p)) throw new TypeError("Argument must be a Buffer");
    return this === p ? true : a.compare(this, p) === 0;
  }, a.prototype.inspect = function() {
    let p = "";
    const h = e.INSPECT_MAX_BYTES;
    return p = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (p += " ... "), "<Buffer " + p + ">";
  }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(p, h, g, A, O) {
    if (Wt(p, Uint8Array) && (p = a.from(p, p.offset, p.byteLength)), !a.isBuffer(p))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof p
      );
    if (h === void 0 && (h = 0), g === void 0 && (g = p ? p.length : 0), A === void 0 && (A = 0), O === void 0 && (O = this.length), h < 0 || g > p.length || A < 0 || O > this.length)
      throw new RangeError("out of range index");
    if (A >= O && h >= g)
      return 0;
    if (A >= O)
      return -1;
    if (h >= g)
      return 1;
    if (h >>>= 0, g >>>= 0, A >>>= 0, O >>>= 0, this === p) return 0;
    let R = O - A, F = g - h;
    const me = Math.min(R, F), Me = this.slice(A, O), Pe = p.slice(h, g);
    for (let Ie = 0; Ie < me; ++Ie)
      if (Me[Ie] !== Pe[Ie]) {
        R = Me[Ie], F = Pe[Ie];
        break;
      }
    return R < F ? -1 : F < R ? 1 : 0;
  };
  function P(p, h, g, A, O) {
    if (p.length === 0) return -1;
    if (typeof g == "string" ? (A = g, g = 0) : g > 2147483647 ? g = 2147483647 : g < -2147483648 && (g = -2147483648), g = +g, so(g) && (g = O ? 0 : p.length - 1), g < 0 && (g = p.length + g), g >= p.length) {
      if (O) return -1;
      g = p.length - 1;
    } else if (g < 0)
      if (O) g = 0;
      else return -1;
    if (typeof h == "string" && (h = a.from(h, A)), a.isBuffer(h))
      return h.length === 0 ? -1 : $(p, h, g, A, O);
    if (typeof h == "number")
      return h = h & 255, typeof Uint8Array.prototype.indexOf == "function" ? O ? Uint8Array.prototype.indexOf.call(p, h, g) : Uint8Array.prototype.lastIndexOf.call(p, h, g) : $(p, [h], g, A, O);
    throw new TypeError("val must be string, number or Buffer");
  }
  function $(p, h, g, A, O) {
    let R = 1, F = p.length, me = h.length;
    if (A !== void 0 && (A = String(A).toLowerCase(), A === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
      if (p.length < 2 || h.length < 2)
        return -1;
      R = 2, F /= 2, me /= 2, g /= 2;
    }
    function Me(Ie, Se) {
      return R === 1 ? Ie[Se] : Ie.readUInt16BE(Se * R);
    }
    let Pe;
    if (O) {
      let Ie = -1;
      for (Pe = g; Pe < F; Pe++)
        if (Me(p, Pe) === Me(h, Ie === -1 ? 0 : Pe - Ie)) {
          if (Ie === -1 && (Ie = Pe), Pe - Ie + 1 === me) return Ie * R;
        } else
          Ie !== -1 && (Pe -= Pe - Ie), Ie = -1;
    } else
      for (g + me > F && (g = F - me), Pe = g; Pe >= 0; Pe--) {
        let Ie = true;
        for (let Se = 0; Se < me; Se++)
          if (Me(p, Pe + Se) !== Me(h, Se)) {
            Ie = false;
            break;
          }
        if (Ie) return Pe;
      }
    return -1;
  }
  a.prototype.includes = function(p, h, g) {
    return this.indexOf(p, h, g) !== -1;
  }, a.prototype.indexOf = function(p, h, g) {
    return P(this, p, h, g, true);
  }, a.prototype.lastIndexOf = function(p, h, g) {
    return P(this, p, h, g, false);
  };
  function L(p, h, g, A) {
    g = Number(g) || 0;
    const O = p.length - g;
    A ? (A = Number(A), A > O && (A = O)) : A = O;
    const R = h.length;
    A > R / 2 && (A = R / 2);
    let F;
    for (F = 0; F < A; ++F) {
      const me = parseInt(h.substr(F * 2, 2), 16);
      if (so(me)) return F;
      p[g + F] = me;
    }
    return F;
  }
  function V(p, h, g, A) {
    return Sn(An(h, p.length - g), p, g, A);
  }
  function ee(p, h, g, A) {
    return Sn(us(h), p, g, A);
  }
  function G(p, h, g, A) {
    return Sn(ls(h), p, g, A);
  }
  function N(p, h, g, A) {
    return Sn(Lc(h, p.length - g), p, g, A);
  }
  a.prototype.write = function(p, h, g, A) {
    if (h === void 0)
      A = "utf8", g = this.length, h = 0;
    else if (g === void 0 && typeof h == "string")
      A = h, g = this.length, h = 0;
    else if (isFinite(h))
      h = h >>> 0, isFinite(g) ? (g = g >>> 0, A === void 0 && (A = "utf8")) : (A = g, g = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const O = this.length - h;
    if ((g === void 0 || g > O) && (g = O), p.length > 0 && (g < 0 || h < 0) || h > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    A || (A = "utf8");
    let R = false;
    for (; ; )
      switch (A) {
        case "hex":
          return L(this, p, h, g);
        case "utf8":
        case "utf-8":
          return V(this, p, h, g);
        case "ascii":
        case "latin1":
        case "binary":
          return ee(this, p, h, g);
        case "base64":
          return G(this, p, h, g);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N(this, p, h, g);
        default:
          if (R) throw new TypeError("Unknown encoding: " + A);
          A = ("" + A).toLowerCase(), R = true;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function q(p, h, g) {
    return h === 0 && g === p.length ? t.fromByteArray(p) : t.fromByteArray(p.slice(h, g));
  }
  function j(p, h, g) {
    g = Math.min(p.length, g);
    const A = [];
    let O = h;
    for (; O < g; ) {
      const R = p[O];
      let F = null, me = R > 239 ? 4 : R > 223 ? 3 : R > 191 ? 2 : 1;
      if (O + me <= g) {
        let Me, Pe, Ie, Se;
        switch (me) {
          case 1:
            R < 128 && (F = R);
            break;
          case 2:
            Me = p[O + 1], (Me & 192) === 128 && (Se = (R & 31) << 6 | Me & 63, Se > 127 && (F = Se));
            break;
          case 3:
            Me = p[O + 1], Pe = p[O + 2], (Me & 192) === 128 && (Pe & 192) === 128 && (Se = (R & 15) << 12 | (Me & 63) << 6 | Pe & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (F = Se));
            break;
          case 4:
            Me = p[O + 1], Pe = p[O + 2], Ie = p[O + 3], (Me & 192) === 128 && (Pe & 192) === 128 && (Ie & 192) === 128 && (Se = (R & 15) << 18 | (Me & 63) << 12 | (Pe & 63) << 6 | Ie & 63, Se > 65535 && Se < 1114112 && (F = Se));
        }
      }
      F === null ? (F = 65533, me = 1) : F > 65535 && (F -= 65536, A.push(F >>> 10 & 1023 | 55296), F = 56320 | F & 1023), A.push(F), O += me;
    }
    return U(A);
  }
  const C = 4096;
  function U(p) {
    const h = p.length;
    if (h <= C)
      return String.fromCharCode.apply(String, p);
    let g = "", A = 0;
    for (; A < h; )
      g += String.fromCharCode.apply(
        String,
        p.slice(A, A += C)
      );
    return g;
  }
  function M(p, h, g) {
    let A = "";
    g = Math.min(p.length, g);
    for (let O = h; O < g; ++O)
      A += String.fromCharCode(p[O] & 127);
    return A;
  }
  function re(p, h, g) {
    let A = "";
    g = Math.min(p.length, g);
    for (let O = h; O < g; ++O)
      A += String.fromCharCode(p[O]);
    return A;
  }
  function te(p, h, g) {
    const A = p.length;
    (!h || h < 0) && (h = 0), (!g || g < 0 || g > A) && (g = A);
    let O = "";
    for (let R = h; R < g; ++R)
      O += jc[p[R]];
    return O;
  }
  function ie(p, h, g) {
    const A = p.slice(h, g);
    let O = "";
    for (let R = 0; R < A.length - 1; R += 2)
      O += String.fromCharCode(A[R] + A[R + 1] * 256);
    return O;
  }
  a.prototype.slice = function(p, h) {
    const g = this.length;
    p = ~~p, h = h === void 0 ? g : ~~h, p < 0 ? (p += g, p < 0 && (p = 0)) : p > g && (p = g), h < 0 ? (h += g, h < 0 && (h = 0)) : h > g && (h = g), h < p && (h = p);
    const A = this.subarray(p, h);
    return Object.setPrototypeOf(A, a.prototype), A;
  };
  function ne(p, h, g) {
    if (p % 1 !== 0 || p < 0) throw new RangeError("offset is not uint");
    if (p + h > g) throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(p, h, g) {
    p = p >>> 0, h = h >>> 0, g || ne(p, h, this.length);
    let A = this[p], O = 1, R = 0;
    for (; ++R < h && (O *= 256); )
      A += this[p + R] * O;
    return A;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(p, h, g) {
    p = p >>> 0, h = h >>> 0, g || ne(p, h, this.length);
    let A = this[p + --h], O = 1;
    for (; h > 0 && (O *= 256); )
      A += this[p + --h] * O;
    return A;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(p, h) {
    return p = p >>> 0, h || ne(p, 1, this.length), this[p];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(p, h) {
    return p = p >>> 0, h || ne(p, 2, this.length), this[p] | this[p + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(p, h) {
    return p = p >>> 0, h || ne(p, 2, this.length), this[p] << 8 | this[p + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(p, h) {
    return p = p >>> 0, h || ne(p, 4, this.length), (this[p] | this[p + 1] << 8 | this[p + 2] << 16) + this[p + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(p, h) {
    return p = p >>> 0, h || ne(p, 4, this.length), this[p] * 16777216 + (this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3]);
  }, a.prototype.readBigUInt64LE = Qt(function(p) {
    p = p >>> 0, Ae(p, "offset");
    const h = this[p], g = this[p + 7];
    (h === void 0 || g === void 0) && bt(p, this.length - 8);
    const A = h + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24, O = this[++p] + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + g * 2 ** 24;
    return BigInt(A) + (BigInt(O) << BigInt(32));
  }), a.prototype.readBigUInt64BE = Qt(function(p) {
    p = p >>> 0, Ae(p, "offset");
    const h = this[p], g = this[p + 7];
    (h === void 0 || g === void 0) && bt(p, this.length - 8);
    const A = h * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p], O = this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + g;
    return (BigInt(A) << BigInt(32)) + BigInt(O);
  }), a.prototype.readIntLE = function(p, h, g) {
    p = p >>> 0, h = h >>> 0, g || ne(p, h, this.length);
    let A = this[p], O = 1, R = 0;
    for (; ++R < h && (O *= 256); )
      A += this[p + R] * O;
    return O *= 128, A >= O && (A -= Math.pow(2, 8 * h)), A;
  }, a.prototype.readIntBE = function(p, h, g) {
    p = p >>> 0, h = h >>> 0, g || ne(p, h, this.length);
    let A = h, O = 1, R = this[p + --A];
    for (; A > 0 && (O *= 256); )
      R += this[p + --A] * O;
    return O *= 128, R >= O && (R -= Math.pow(2, 8 * h)), R;
  }, a.prototype.readInt8 = function(p, h) {
    return p = p >>> 0, h || ne(p, 1, this.length), this[p] & 128 ? (255 - this[p] + 1) * -1 : this[p];
  }, a.prototype.readInt16LE = function(p, h) {
    p = p >>> 0, h || ne(p, 2, this.length);
    const g = this[p] | this[p + 1] << 8;
    return g & 32768 ? g | 4294901760 : g;
  }, a.prototype.readInt16BE = function(p, h) {
    p = p >>> 0, h || ne(p, 2, this.length);
    const g = this[p + 1] | this[p] << 8;
    return g & 32768 ? g | 4294901760 : g;
  }, a.prototype.readInt32LE = function(p, h) {
    return p = p >>> 0, h || ne(p, 4, this.length), this[p] | this[p + 1] << 8 | this[p + 2] << 16 | this[p + 3] << 24;
  }, a.prototype.readInt32BE = function(p, h) {
    return p = p >>> 0, h || ne(p, 4, this.length), this[p] << 24 | this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3];
  }, a.prototype.readBigInt64LE = Qt(function(p) {
    p = p >>> 0, Ae(p, "offset");
    const h = this[p], g = this[p + 7];
    (h === void 0 || g === void 0) && bt(p, this.length - 8);
    const A = this[p + 4] + this[p + 5] * 2 ** 8 + this[p + 6] * 2 ** 16 + (g << 24);
    return (BigInt(A) << BigInt(32)) + BigInt(h + this[++p] * 2 ** 8 + this[++p] * 2 ** 16 + this[++p] * 2 ** 24);
  }), a.prototype.readBigInt64BE = Qt(function(p) {
    p = p >>> 0, Ae(p, "offset");
    const h = this[p], g = this[p + 7];
    (h === void 0 || g === void 0) && bt(p, this.length - 8);
    const A = (h << 24) + // Overflow
    this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + this[++p];
    return (BigInt(A) << BigInt(32)) + BigInt(this[++p] * 2 ** 24 + this[++p] * 2 ** 16 + this[++p] * 2 ** 8 + g);
  }), a.prototype.readFloatLE = function(p, h) {
    return p = p >>> 0, h || ne(p, 4, this.length), r.read(this, p, true, 23, 4);
  }, a.prototype.readFloatBE = function(p, h) {
    return p = p >>> 0, h || ne(p, 4, this.length), r.read(this, p, false, 23, 4);
  }, a.prototype.readDoubleLE = function(p, h) {
    return p = p >>> 0, h || ne(p, 8, this.length), r.read(this, p, true, 52, 8);
  }, a.prototype.readDoubleBE = function(p, h) {
    return p = p >>> 0, h || ne(p, 8, this.length), r.read(this, p, false, 52, 8);
  };
  function le(p, h, g, A, O, R) {
    if (!a.isBuffer(p)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (h > O || h < R) throw new RangeError('"value" argument is out of bounds');
    if (g + A > p.length) throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(p, h, g, A) {
    if (p = +p, h = h >>> 0, g = g >>> 0, !A) {
      const F = Math.pow(2, 8 * g) - 1;
      le(this, p, h, g, F, 0);
    }
    let O = 1, R = 0;
    for (this[h] = p & 255; ++R < g && (O *= 256); )
      this[h + R] = p / O & 255;
    return h + g;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(p, h, g, A) {
    if (p = +p, h = h >>> 0, g = g >>> 0, !A) {
      const F = Math.pow(2, 8 * g) - 1;
      le(this, p, h, g, F, 0);
    }
    let O = g - 1, R = 1;
    for (this[h + O] = p & 255; --O >= 0 && (R *= 256); )
      this[h + O] = p / R & 255;
    return h + g;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 1, 255, 0), this[h] = p & 255, h + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 2, 65535, 0), this[h] = p & 255, this[h + 1] = p >>> 8, h + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 2, 65535, 0), this[h] = p >>> 8, this[h + 1] = p & 255, h + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 4, 4294967295, 0), this[h + 3] = p >>> 24, this[h + 2] = p >>> 16, this[h + 1] = p >>> 8, this[h] = p & 255, h + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 4, 4294967295, 0), this[h] = p >>> 24, this[h + 1] = p >>> 16, this[h + 2] = p >>> 8, this[h + 3] = p & 255, h + 4;
  };
  function K(p, h, g, A, O) {
    He(h, A, O, p, g, 7);
    let R = Number(h & BigInt(4294967295));
    p[g++] = R, R = R >> 8, p[g++] = R, R = R >> 8, p[g++] = R, R = R >> 8, p[g++] = R;
    let F = Number(h >> BigInt(32) & BigInt(4294967295));
    return p[g++] = F, F = F >> 8, p[g++] = F, F = F >> 8, p[g++] = F, F = F >> 8, p[g++] = F, g;
  }
  function ve(p, h, g, A, O) {
    He(h, A, O, p, g, 7);
    let R = Number(h & BigInt(4294967295));
    p[g + 7] = R, R = R >> 8, p[g + 6] = R, R = R >> 8, p[g + 5] = R, R = R >> 8, p[g + 4] = R;
    let F = Number(h >> BigInt(32) & BigInt(4294967295));
    return p[g + 3] = F, F = F >> 8, p[g + 2] = F, F = F >> 8, p[g + 1] = F, F = F >> 8, p[g] = F, g + 8;
  }
  a.prototype.writeBigUInt64LE = Qt(function(p, h = 0) {
    return K(this, p, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = Qt(function(p, h = 0) {
    return ve(this, p, h, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(p, h, g, A) {
    if (p = +p, h = h >>> 0, !A) {
      const me = Math.pow(2, 8 * g - 1);
      le(this, p, h, g, me - 1, -me);
    }
    let O = 0, R = 1, F = 0;
    for (this[h] = p & 255; ++O < g && (R *= 256); )
      p < 0 && F === 0 && this[h + O - 1] !== 0 && (F = 1), this[h + O] = (p / R >> 0) - F & 255;
    return h + g;
  }, a.prototype.writeIntBE = function(p, h, g, A) {
    if (p = +p, h = h >>> 0, !A) {
      const me = Math.pow(2, 8 * g - 1);
      le(this, p, h, g, me - 1, -me);
    }
    let O = g - 1, R = 1, F = 0;
    for (this[h + O] = p & 255; --O >= 0 && (R *= 256); )
      p < 0 && F === 0 && this[h + O + 1] !== 0 && (F = 1), this[h + O] = (p / R >> 0) - F & 255;
    return h + g;
  }, a.prototype.writeInt8 = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 1, 127, -128), p < 0 && (p = 255 + p + 1), this[h] = p & 255, h + 1;
  }, a.prototype.writeInt16LE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 2, 32767, -32768), this[h] = p & 255, this[h + 1] = p >>> 8, h + 2;
  }, a.prototype.writeInt16BE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 2, 32767, -32768), this[h] = p >>> 8, this[h + 1] = p & 255, h + 2;
  }, a.prototype.writeInt32LE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 4, 2147483647, -2147483648), this[h] = p & 255, this[h + 1] = p >>> 8, this[h + 2] = p >>> 16, this[h + 3] = p >>> 24, h + 4;
  }, a.prototype.writeInt32BE = function(p, h, g) {
    return p = +p, h = h >>> 0, g || le(this, p, h, 4, 2147483647, -2147483648), p < 0 && (p = 4294967295 + p + 1), this[h] = p >>> 24, this[h + 1] = p >>> 16, this[h + 2] = p >>> 8, this[h + 3] = p & 255, h + 4;
  }, a.prototype.writeBigInt64LE = Qt(function(p, h = 0) {
    return K(this, p, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = Qt(function(p, h = 0) {
    return ve(this, p, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function At(p, h, g, A, O, R) {
    if (g + A > p.length) throw new RangeError("Index out of range");
    if (g < 0) throw new RangeError("Index out of range");
  }
  function ze(p, h, g, A, O) {
    return h = +h, g = g >>> 0, O || At(p, h, g, 4), r.write(p, h, g, A, 23, 4), g + 4;
  }
  a.prototype.writeFloatLE = function(p, h, g) {
    return ze(this, p, h, true, g);
  }, a.prototype.writeFloatBE = function(p, h, g) {
    return ze(this, p, h, false, g);
  };
  function St(p, h, g, A, O) {
    return h = +h, g = g >>> 0, O || At(p, h, g, 8), r.write(p, h, g, A, 52, 8), g + 8;
  }
  a.prototype.writeDoubleLE = function(p, h, g) {
    return St(this, p, h, true, g);
  }, a.prototype.writeDoubleBE = function(p, h, g) {
    return St(this, p, h, false, g);
  }, a.prototype.copy = function(p, h, g, A) {
    if (!a.isBuffer(p)) throw new TypeError("argument should be a Buffer");
    if (g || (g = 0), !A && A !== 0 && (A = this.length), h >= p.length && (h = p.length), h || (h = 0), A > 0 && A < g && (A = g), A === g || p.length === 0 || this.length === 0) return 0;
    if (h < 0)
      throw new RangeError("targetStart out of bounds");
    if (g < 0 || g >= this.length) throw new RangeError("Index out of range");
    if (A < 0) throw new RangeError("sourceEnd out of bounds");
    A > this.length && (A = this.length), p.length - h < A - g && (A = p.length - h + g);
    const O = A - g;
    return this === p && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(h, g, A) : Uint8Array.prototype.set.call(
      p,
      this.subarray(g, A),
      h
    ), O;
  }, a.prototype.fill = function(p, h, g, A) {
    if (typeof p == "string") {
      if (typeof h == "string" ? (A = h, h = 0, g = this.length) : typeof g == "string" && (A = g, g = this.length), A !== void 0 && typeof A != "string")
        throw new TypeError("encoding must be a string");
      if (typeof A == "string" && !a.isEncoding(A))
        throw new TypeError("Unknown encoding: " + A);
      if (p.length === 1) {
        const R = p.charCodeAt(0);
        (A === "utf8" && R < 128 || A === "latin1") && (p = R);
      }
    } else typeof p == "number" ? p = p & 255 : typeof p == "boolean" && (p = Number(p));
    if (h < 0 || this.length < h || this.length < g)
      throw new RangeError("Out of range index");
    if (g <= h)
      return this;
    h = h >>> 0, g = g === void 0 ? this.length : g >>> 0, p || (p = 0);
    let O;
    if (typeof p == "number")
      for (O = h; O < g; ++O)
        this[O] = p;
    else {
      const R = a.isBuffer(p) ? p : a.from(p, A), F = R.length;
      if (F === 0)
        throw new TypeError('The value "' + p + '" is invalid for argument "value"');
      for (O = 0; O < g - h; ++O)
        this[O + h] = R[O % F];
    }
    return this;
  };
  const et = {};
  function Ge(p, h, g) {
    et[p] = class extends g {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: h.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${p}]`, this.stack, delete this.name;
      }
      get code() {
        return p;
      }
      set code(A) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: A,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${p}]: ${this.message}`;
      }
    };
  }
  Ge(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(p) {
      return p ? `${p} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Ge(
    "ERR_INVALID_ARG_TYPE",
    function(p, h) {
      return `The "${p}" argument must be of type number. Received type ${typeof h}`;
    },
    TypeError
  ), Ge(
    "ERR_OUT_OF_RANGE",
    function(p, h, g) {
      let A = `The value of "${p}" is out of range.`, O = g;
      return Number.isInteger(g) && Math.abs(g) > 2 ** 32 ? O = ut(String(g)) : typeof g == "bigint" && (O = String(g), (g > BigInt(2) ** BigInt(32) || g < -(BigInt(2) ** BigInt(32))) && (O = ut(O)), O += "n"), A += ` It must be ${h}. Received ${O}`, A;
    },
    RangeError
  );
  function ut(p) {
    let h = "", g = p.length;
    const A = p[0] === "-" ? 1 : 0;
    for (; g >= A + 4; g -= 3)
      h = `_${p.slice(g - 3, g)}${h}`;
    return `${p.slice(0, g)}${h}`;
  }
  function ot(p, h, g) {
    Ae(h, "offset"), (p[h] === void 0 || p[h + g] === void 0) && bt(h, p.length - (g + 1));
  }
  function He(p, h, g, A, O, R) {
    if (p > g || p < h) {
      const F = typeof h == "bigint" ? "n" : "";
      let me;
      throw h === 0 || h === BigInt(0) ? me = `>= 0${F} and < 2${F} ** ${(R + 1) * 8}${F}` : me = `>= -(2${F} ** ${(R + 1) * 8 - 1}${F}) and < 2 ** ${(R + 1) * 8 - 1}${F}`, new et.ERR_OUT_OF_RANGE("value", me, p);
    }
    ot(A, O, R);
  }
  function Ae(p, h) {
    if (typeof p != "number")
      throw new et.ERR_INVALID_ARG_TYPE(h, "number", p);
  }
  function bt(p, h, g) {
    throw Math.floor(p) !== p ? (Ae(p, g), new et.ERR_OUT_OF_RANGE("offset", "an integer", p)) : h < 0 ? new et.ERR_BUFFER_OUT_OF_BOUNDS() : new et.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${h}`,
      p
    );
  }
  const wr = /[^+/0-9A-Za-z-_]/g;
  function Gt(p) {
    if (p = p.split("=")[0], p = p.trim().replace(wr, ""), p.length < 2) return "";
    for (; p.length % 4 !== 0; )
      p = p + "=";
    return p;
  }
  function An(p, h) {
    h = h || 1 / 0;
    let g;
    const A = p.length;
    let O = null;
    const R = [];
    for (let F = 0; F < A; ++F) {
      if (g = p.charCodeAt(F), g > 55295 && g < 57344) {
        if (!O) {
          if (g > 56319) {
            (h -= 3) > -1 && R.push(239, 191, 189);
            continue;
          } else if (F + 1 === A) {
            (h -= 3) > -1 && R.push(239, 191, 189);
            continue;
          }
          O = g;
          continue;
        }
        if (g < 56320) {
          (h -= 3) > -1 && R.push(239, 191, 189), O = g;
          continue;
        }
        g = (O - 55296 << 10 | g - 56320) + 65536;
      } else O && (h -= 3) > -1 && R.push(239, 191, 189);
      if (O = null, g < 128) {
        if ((h -= 1) < 0) break;
        R.push(g);
      } else if (g < 2048) {
        if ((h -= 2) < 0) break;
        R.push(
          g >> 6 | 192,
          g & 63 | 128
        );
      } else if (g < 65536) {
        if ((h -= 3) < 0) break;
        R.push(
          g >> 12 | 224,
          g >> 6 & 63 | 128,
          g & 63 | 128
        );
      } else if (g < 1114112) {
        if ((h -= 4) < 0) break;
        R.push(
          g >> 18 | 240,
          g >> 12 & 63 | 128,
          g >> 6 & 63 | 128,
          g & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return R;
  }
  function us(p) {
    const h = [];
    for (let g = 0; g < p.length; ++g)
      h.push(p.charCodeAt(g) & 255);
    return h;
  }
  function Lc(p, h) {
    let g, A, O;
    const R = [];
    for (let F = 0; F < p.length && !((h -= 2) < 0); ++F)
      g = p.charCodeAt(F), A = g >> 8, O = g % 256, R.push(O), R.push(A);
    return R;
  }
  function ls(p) {
    return t.toByteArray(Gt(p));
  }
  function Sn(p, h, g, A) {
    let O;
    for (O = 0; O < A && !(O + g >= h.length || O >= p.length); ++O)
      h[O + g] = p[O];
    return O;
  }
  function Wt(p, h) {
    return p instanceof h || p != null && p.constructor != null && p.constructor.name != null && p.constructor.name === h.name;
  }
  function so(p) {
    return p !== p;
  }
  const jc = function() {
    const p = "0123456789abcdef", h = new Array(256);
    for (let g = 0; g < 16; ++g) {
      const A = g * 16;
      for (let O = 0; O < 16; ++O)
        h[A + O] = p[g] + p[O];
    }
    return h;
  }();
  function Qt(p) {
    return typeof BigInt > "u" ? fs : p;
  }
  function fs() {
    throw new Error("BigInt not supported");
  }
})(_O);
var yf = "BITCOIN_MAINNET";
var Nm = "BITCOIN_TESTNET";
var Um = "BITCOIN_TESTNET4";
var $m = "BITCOIN_SIGNET";
var Rm = "FRACTAL_BITCOIN_MAINNET";
var zm = "FRACTAL_BITCOIN_TESTNET";
var PO = "GLITTR_DEVNET";
var LE = "Mainnet";
var Jpe = "Testnet";
var Qpe = "Signet";
var e0e = "livenet";
var t0e = "testnet";
var IO = "livenet";
var r0e = "testnet";
var n0e = "testnet4";
var o0e = "signet";
var jE = "Mainnet";
var i0e = "Testnet";
var FE = "main";
var s0e = "testnet";
var a0e = "signet";
var Ft = "mainnet";
var sn = "signet";
var sr = "testnet";
var qr = "testnet4";
var ia = "fractal mainnet";
var wn = "fractal testnet";
var OO = "glittr devnet";
var y0 = (e) => e === Ft ? LE : e === sr || e === qr ? Jpe : e === sn ? Qpe : LE;
var BO = (e) => e === Ft ? yf : e === sr ? Nm : e === qr ? Um : e === sn ? $m : e === ia ? Rm : e === wn ? zm : yf;
var c0e = (e) => e === Ft ? yf : e === sr ? Nm : e === qr ? Um : e === sn ? $m : e === ia ? Rm : e === wn ? zm : e === OO ? PO : yf;
var Dy = (e) => e === Ft ? jE : e === sr || e === qr || e === sn ? i0e : jE;
var u0e = (e) => e === Ft ? FE : e === qr || e === sr ? s0e : e === sn ? a0e : FE;
var Zg = (e) => e === yf ? Ft : e === Nm ? sr : e === Um ? qr : e === $m ? sn : e === Rm ? ia : e === zm ? wn : Ft;
var DE = (e) => e === yf ? Ft : e === Nm ? sr : e === Um ? qr : e === $m ? sn : e === Rm ? ia : e === zm ? wn : e === PO ? OO : Ft;
var l0e = (e) => e === e0e ? Ft : e === t0e ? sr : Ft;
var KE = (e) => e === IO ? Ft : e === r0e ? sr : e === n0e ? qr : e === o0e ? sn : e === wn ? sr : Ft;
function CO(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
var { toString: f0e } = Object.prototype;
var { getPrototypeOf: o5 } = Object;
var Hm = /* @__PURE__ */ ((e) => (t) => {
  const r = f0e.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var Si = (e) => (e = e.toLowerCase(), (t) => Hm(t) === e);
var Lm = (e) => (t) => typeof t === e;
var { isArray: Kf } = Array;
var vh = Lm("undefined");
function d0e(e) {
  return e !== null && !vh(e) && e.constructor !== null && !vh(e.constructor) && yo(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
var NO = Si("ArrayBuffer");
function h0e(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && NO(e.buffer), t;
}
var p0e = Lm("string");
var yo = Lm("function");
var UO = Lm("number");
var jm = (e) => e !== null && typeof e == "object";
var g0e = (e) => e === true || e === false;
var w0 = (e) => {
  if (Hm(e) !== "object")
    return false;
  const t = o5(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
};
var m0e = Si("Date");
var b0e = Si("File");
var y0e = Si("Blob");
var w0e = Si("FileList");
var v0e = (e) => jm(e) && yo(e.pipe);
var E0e = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || yo(e.append) && ((t = Hm(e)) === "formdata" || // detect form-data instance
  t === "object" && yo(e.toString) && e.toString() === "[object FormData]"));
};
var x0e = Si("URLSearchParams");
var [k0e, A0e, S0e, _0e] = ["ReadableStream", "Request", "Response", "Headers"].map(Si);
var T0e = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ap(e, t, { allOwnKeys: r = false } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, o;
  if (typeof e != "object" && (e = [e]), Kf(e))
    for (n = 0, o = e.length; n < o; n++)
      t.call(null, e[n], n, e);
  else {
    const i = r ? Object.getOwnPropertyNames(e) : Object.keys(e), s = i.length;
    let a;
    for (n = 0; n < s; n++)
      a = i[n], t.call(null, e[a], a, e);
  }
}
function $O(e, t) {
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, o;
  for (; n-- > 0; )
    if (o = r[n], t === o.toLowerCase())
      return o;
  return null;
}
var gu = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global;
var RO = (e) => !vh(e) && e !== gu;
function H2() {
  const { caseless: e } = RO(this) && this || {}, t = {}, r = (n, o) => {
    const i = e && $O(t, o) || o;
    w0(t[i]) && w0(n) ? t[i] = H2(t[i], n) : w0(n) ? t[i] = H2({}, n) : Kf(n) ? t[i] = n.slice() : t[i] = n;
  };
  for (let n = 0, o = arguments.length; n < o; n++)
    arguments[n] && ap(arguments[n], r);
  return t;
}
var P0e = (e, t, r, { allOwnKeys: n } = {}) => (ap(t, (o, i) => {
  r && yo(o) ? e[i] = CO(o, r) : e[i] = o;
}, { allOwnKeys: n }), e);
var I0e = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e);
var O0e = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
};
var B0e = (e, t, r, n) => {
  let o, i, s;
  const a = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), i = o.length; i-- > 0; )
      s = o[i], (!n || n(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = true);
    e = r !== false && o5(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
};
var C0e = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
};
var N0e = (e) => {
  if (!e) return null;
  if (Kf(e)) return e;
  let t = e.length;
  if (!UO(t)) return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
};
var U0e = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && o5(Uint8Array));
var $0e = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let n;
  for (; (n = r.next()) && !n.done; ) {
    const o = n.value;
    t.call(e, o[0], o[1]);
  }
};
var R0e = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
};
var z0e = Si("HTMLFormElement");
var H0e = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(t, r, n) {
    return r.toUpperCase() + n;
  }
);
var ME = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype);
var L0e = Si("RegExp");
var zO = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  ap(r, (o, i) => {
    let s;
    (s = t(o, i, e)) !== false && (n[i] = s || o);
  }), Object.defineProperties(e, n);
};
var j0e = (e) => {
  zO(e, (t, r) => {
    if (yo(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return false;
    const n = e[r];
    if (yo(n)) {
      if (t.enumerable = false, "writable" in t) {
        t.writable = false;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
};
var F0e = (e, t) => {
  const r = {}, n = (o) => {
    o.forEach((i) => {
      r[i] = true;
    });
  };
  return Kf(e) ? n(e) : n(String(e).split(t)), r;
};
var D0e = () => {
};
var K0e = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
var Ky = "abcdefghijklmnopqrstuvwxyz";
var qE = "0123456789";
var HO = {
  DIGIT: qE,
  ALPHA: Ky,
  ALPHA_DIGIT: Ky + Ky.toUpperCase() + qE
};
var M0e = (e = 16, t = HO.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = t;
  for (; e--; )
    r += t[Math.random() * n | 0];
  return r;
};
function q0e(e) {
  return !!(e && yo(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
var V0e = (e) => {
  const t = new Array(10), r = (n, o) => {
    if (jm(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        t[o] = n;
        const i = Kf(n) ? [] : {};
        return ap(n, (s, a) => {
          const c = r(s, o + 1);
          !vh(c) && (i[a] = c);
        }), t[o] = void 0, i;
      }
    }
    return n;
  };
  return r(e, 0);
};
var G0e = Si("AsyncFunction");
var W0e = (e) => e && (jm(e) || yo(e)) && yo(e.then) && yo(e.catch);
var LO = ((e, t) => e ? setImmediate : t ? ((r, n) => (gu.addEventListener("message", ({ source: o, data: i }) => {
  o === gu && i === r && n.length && n.shift()();
}, false), (o) => {
  n.push(o), gu.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  yo(gu.postMessage)
);
var Z0e = typeof queueMicrotask < "u" ? queueMicrotask.bind(gu) : typeof process < "u" && process.nextTick || LO;
var Q = {
  isArray: Kf,
  isArrayBuffer: NO,
  isBuffer: d0e,
  isFormData: E0e,
  isArrayBufferView: h0e,
  isString: p0e,
  isNumber: UO,
  isBoolean: g0e,
  isObject: jm,
  isPlainObject: w0,
  isReadableStream: k0e,
  isRequest: A0e,
  isResponse: S0e,
  isHeaders: _0e,
  isUndefined: vh,
  isDate: m0e,
  isFile: b0e,
  isBlob: y0e,
  isRegExp: L0e,
  isFunction: yo,
  isStream: v0e,
  isURLSearchParams: x0e,
  isTypedArray: U0e,
  isFileList: w0e,
  forEach: ap,
  merge: H2,
  extend: P0e,
  trim: T0e,
  stripBOM: I0e,
  inherits: O0e,
  toFlatObject: B0e,
  kindOf: Hm,
  kindOfTest: Si,
  endsWith: C0e,
  toArray: N0e,
  forEachEntry: $0e,
  matchAll: R0e,
  isHTMLForm: z0e,
  hasOwnProperty: ME,
  hasOwnProp: ME,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: zO,
  freezeMethods: j0e,
  toObjectSet: F0e,
  toCamelCase: H0e,
  noop: D0e,
  toFiniteNumber: K0e,
  findKey: $O,
  global: gu,
  isContextDefined: RO,
  ALPHABET: HO,
  generateString: M0e,
  isSpecCompliantForm: q0e,
  toJSONObject: V0e,
  isAsyncFn: G0e,
  isThenable: W0e,
  setImmediate: LO,
  asap: Z0e
};
function nt(e, t, r, n, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), o && (this.response = o, this.status = o.status ? o.status : null);
}
Q.inherits(nt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Q.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var jO = nt.prototype;
var FO = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  FO[e] = { value: e };
});
Object.defineProperties(nt, FO);
Object.defineProperty(jO, "isAxiosError", { value: true });
nt.from = (e, t, r, n, o, i) => {
  const s = Object.create(jO);
  return Q.toFlatObject(e, s, function(a) {
    return a !== Error.prototype;
  }, (a) => a !== "isAxiosError"), nt.call(s, e.message, t, r, n, o), s.cause = e, s.name = e.name, i && Object.assign(s, i), s;
};
var X0e = null;
function L2(e) {
  return Q.isPlainObject(e) || Q.isArray(e);
}
function DO(e) {
  return Q.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function VE(e, t, r) {
  return e ? e.concat(t).map(function(n, o) {
    return n = DO(n), !r && o ? "[" + n + "]" : n;
  }).join(r ? "." : "") : t;
}
function Y0e(e) {
  return Q.isArray(e) && !e.some(L2);
}
var J0e = Q.toFlatObject(Q, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Fm(e, t, r) {
  if (!Q.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = Q.toFlatObject(r, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function(m, y) {
    return !Q.isUndefined(y[m]);
  });
  const n = r.metaTokens, o = r.visitor || u, i = r.dots, s = r.indexes, a = (r.Blob || typeof Blob < "u" && Blob) && Q.isSpecCompliantForm(t);
  if (!Q.isFunction(o))
    throw new TypeError("visitor must be a function");
  function c(m) {
    if (m === null) return "";
    if (Q.isDate(m))
      return m.toISOString();
    if (!a && Q.isBlob(m))
      throw new nt("Blob is not supported. Use a Buffer instead.");
    return Q.isArrayBuffer(m) || Q.isTypedArray(m) ? a && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function u(m, y, b) {
    let w = m;
    if (m && !b && typeof m == "object") {
      if (Q.endsWith(y, "{}"))
        y = n ? y : y.slice(0, -2), m = JSON.stringify(m);
      else if (Q.isArray(m) && Y0e(m) || (Q.isFileList(m) || Q.endsWith(y, "[]")) && (w = Q.toArray(m)))
        return y = DO(y), w.forEach(function(v, k) {
          !(Q.isUndefined(v) || v === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === true ? VE([y], k, i) : s === null ? y : y + "[]",
            c(v)
          );
        }), false;
    }
    return L2(m) ? true : (t.append(VE(b, y, i), c(m)), false);
  }
  const l = [], f = Object.assign(J0e, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: L2
  });
  function d(m, y) {
    if (!Q.isUndefined(m)) {
      if (l.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      l.push(m), Q.forEach(m, function(b, w) {
        (!(Q.isUndefined(b) || b === null) && o.call(
          t,
          b,
          Q.isString(w) ? w.trim() : w,
          y,
          f
        )) === true && d(b, y ? y.concat(w) : [w]);
      }), l.pop();
    }
  }
  if (!Q.isObject(e))
    throw new TypeError("data must be an object");
  return d(e), t;
}
function GE(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function i5(e, t) {
  this._pairs = [], e && Fm(e, this, t);
}
var KO = i5.prototype;
KO.append = function(e, t) {
  this._pairs.push([e, t]);
};
KO.toString = function(e) {
  const t = e ? function(r) {
    return e.call(this, r, GE);
  } : GE;
  return this._pairs.map(function(r) {
    return t(r[0]) + "=" + t(r[1]);
  }, "").join("&");
};
function Q0e(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function MO(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || Q0e, o = r && r.serialize;
  let i;
  if (o ? i = o(t, r) : i = Q.isURLSearchParams(t) ? t.toString() : new i5(t, r).toString(n), i) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
  }
  return e;
}
var WE = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : false,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Q.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
};
var qO = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var ege = typeof URLSearchParams < "u" ? URLSearchParams : i5;
var tge = typeof FormData < "u" ? FormData : null;
var rge = typeof Blob < "u" ? Blob : null;
var nge = {
  isBrowser: true,
  classes: {
    URLSearchParams: ege,
    FormData: tge,
    Blob: rge
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
var s5 = typeof window < "u" && typeof document < "u";
var j2 = typeof navigator == "object" && navigator || void 0;
var oge = s5 && (!j2 || ["ReactNative", "NativeScript", "NS"].indexOf(j2.product) < 0);
var ige = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function";
var sge = s5 && window.location.href || "http://localhost";
var age = Object.freeze(Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: s5,
  hasStandardBrowserEnv: oge,
  hasStandardBrowserWebWorkerEnv: ige,
  navigator: j2,
  origin: sge
}, Symbol.toStringTag, { value: "Module" }));
var Yn = {
  ...age,
  ...nge
};
function cge(e, t) {
  return Fm(e, new Yn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, o, i) {
      return Yn.isNode && Q.isBuffer(r) ? (this.append(n, r.toString("base64")), false) : i.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function uge(e) {
  return Q.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function lge(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const o = r.length;
  let i;
  for (n = 0; n < o; n++)
    i = r[n], t[i] = e[i];
  return t;
}
function VO(e) {
  function t(r, n, o, i) {
    let s = r[i++];
    if (s === "__proto__") return true;
    const a = Number.isFinite(+s), c = i >= r.length;
    return s = !s && Q.isArray(o) ? o.length : s, c ? (Q.hasOwnProp(o, s) ? o[s] = [o[s], n] : o[s] = n, !a) : ((!o[s] || !Q.isObject(o[s])) && (o[s] = []), t(r, n, o[s], i) && Q.isArray(o[s]) && (o[s] = lge(o[s])), !a);
  }
  if (Q.isFormData(e) && Q.isFunction(e.entries)) {
    const r = {};
    return Q.forEachEntry(e, (n, o) => {
      t(uge(n), o, r, 0);
    }), r;
  }
  return null;
}
function fge(e, t, r) {
  if (Q.isString(e))
    try {
      return (t || JSON.parse)(e), Q.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (0, JSON.stringify)(e);
}
var cp = {
  transitional: qO,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const r = t.getContentType() || "", n = r.indexOf("application/json") > -1, o = Q.isObject(e);
    if (o && Q.isHTMLForm(e) && (e = new FormData(e)), Q.isFormData(e))
      return n ? JSON.stringify(VO(e)) : e;
    if (Q.isArrayBuffer(e) || Q.isBuffer(e) || Q.isStream(e) || Q.isFile(e) || Q.isBlob(e) || Q.isReadableStream(e))
      return e;
    if (Q.isArrayBufferView(e))
      return e.buffer;
    if (Q.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e.toString();
    let i;
    if (o) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return cge(e, this.formSerializer).toString();
      if ((i = Q.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const s = this.env && this.env.FormData;
        return Fm(
          i ? { "files[]": e } : e,
          s && new s(),
          this.formSerializer
        );
      }
    }
    return o || n ? (t.setContentType("application/json", false), fge(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || cp.transitional, r = t && t.forcedJSONParsing, n = this.responseType === "json";
    if (Q.isResponse(e) || Q.isReadableStream(e))
      return e;
    if (e && Q.isString(e) && (r && !this.responseType || n)) {
      const o = !(t && t.silentJSONParsing) && n;
      try {
        return JSON.parse(e);
      } catch (i) {
        if (o)
          throw i.name === "SyntaxError" ? nt.from(i, nt.ERR_BAD_RESPONSE, this, null, this.response) : i;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Yn.classes.FormData,
    Blob: Yn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Q.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  cp.headers[e] = {};
});
var dge = Q.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var hge = (e) => {
  const t = {};
  let r, n, o;
  return e && e.split(`
`).forEach(function(i) {
    o = i.indexOf(":"), r = i.substring(0, o).trim().toLowerCase(), n = i.substring(o + 1).trim(), !(!r || t[r] && dge[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
};
var ZE = Symbol("internals");
function dd(e) {
  return e && String(e).trim().toLowerCase();
}
function v0(e) {
  return e === false || e == null ? e : Q.isArray(e) ? e.map(v0) : String(e);
}
function pge(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
var gge = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function My(e, t, r, n, o) {
  if (Q.isFunction(n))
    return n.call(this, t, r);
  if (o && (t = r), !!Q.isString(t)) {
    if (Q.isString(n))
      return t.indexOf(n) !== -1;
    if (Q.isRegExp(n))
      return n.test(t);
  }
}
function mge(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function bge(e, t) {
  const r = Q.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(o, i, s) {
        return this[n].call(this, t, o, i, s);
      },
      configurable: true
    });
  });
}
var Jn = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const o = this;
    function i(a, c, u) {
      const l = dd(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const f = Q.findKey(o, l);
      (!f || o[f] === void 0 || u === true || u === void 0 && o[f] !== false) && (o[f || c] = v0(a));
    }
    const s = (a, c) => Q.forEach(a, (u, l) => i(u, l, c));
    if (Q.isPlainObject(t) || t instanceof this.constructor)
      s(t, r);
    else if (Q.isString(t) && (t = t.trim()) && !gge(t))
      s(hge(t), r);
    else if (Q.isHeaders(t))
      for (const [a, c] of t.entries())
        i(c, a, n);
    else
      t != null && i(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = dd(t), t) {
      const n = Q.findKey(this, t);
      if (n) {
        const o = this[n];
        if (!r)
          return o;
        if (r === true)
          return pge(o);
        if (Q.isFunction(r))
          return r.call(this, o, n);
        if (Q.isRegExp(r))
          return r.exec(o);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = dd(t), t) {
      const n = Q.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || My(this, this[n], n, r)));
    }
    return false;
  }
  delete(t, r) {
    const n = this;
    let o = false;
    function i(s) {
      if (s = dd(s), s) {
        const a = Q.findKey(n, s);
        a && (!r || My(n, n[a], a, r)) && (delete n[a], o = true);
      }
    }
    return Q.isArray(t) ? t.forEach(i) : i(t), o;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, o = false;
    for (; n--; ) {
      const i = r[n];
      (!t || My(this, this[i], i, t, true)) && (delete this[i], o = true);
    }
    return o;
  }
  normalize(t) {
    const r = this, n = {};
    return Q.forEach(this, (o, i) => {
      const s = Q.findKey(n, i);
      if (s) {
        r[s] = v0(o), delete r[i];
        return;
      }
      const a = t ? mge(i) : String(i).trim();
      a !== i && delete r[i], r[a] = v0(o), n[a] = true;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return Q.forEach(this, (n, o) => {
      n != null && n !== false && (r[o] = t && Q.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((o) => n.set(o)), n;
  }
  static accessor(t) {
    const r = (this[ZE] = this[ZE] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function o(i) {
      const s = dd(i);
      r[s] || (bge(n, i), r[s] = true);
    }
    return Q.isArray(t) ? t.forEach(o) : o(t), this;
  }
};
Jn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Q.reduceDescriptors(Jn.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
Q.freezeMethods(Jn);
function qy(e, t) {
  const r = this || cp, n = t || r, o = Jn.from(n.headers);
  let i = n.data;
  return Q.forEach(e, function(s) {
    i = s.call(r, i, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), i;
}
function GO(e) {
  return !!(e && e.__CANCEL__);
}
function Mf(e, t, r) {
  nt.call(this, e ?? "canceled", nt.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Q.inherits(Mf, nt, {
  __CANCEL__: true
});
function WO(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new nt(
    "Request failed with status code " + r.status,
    [nt.ERR_BAD_REQUEST, nt.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function yge(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function wge(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let o = 0, i = 0, s;
  return t = t !== void 0 ? t : 1e3, function(a) {
    const c = Date.now(), u = n[i];
    s || (s = c), r[o] = a, n[o] = c;
    let l = i, f = 0;
    for (; l !== o; )
      f += r[l++], l = l % e;
    if (o = (o + 1) % e, o === i && (i = (i + 1) % e), c - s < t)
      return;
    const d = u && c - u;
    return d ? Math.round(f * 1e3 / d) : void 0;
  };
}
function vge(e, t) {
  let r = 0, n = 1e3 / t, o, i;
  const s = (a, c = Date.now()) => {
    r = c, o = null, i && (clearTimeout(i), i = null), e.apply(null, a);
  };
  return [(...a) => {
    const c = Date.now(), u = c - r;
    u >= n ? s(a, c) : (o = a, i || (i = setTimeout(() => {
      i = null, s(o);
    }, n - u)));
  }, () => o && s(o)];
}
var Xg = (e, t, r = 3) => {
  let n = 0;
  const o = wge(50, 250);
  return vge((i) => {
    const s = i.loaded, a = i.lengthComputable ? i.total : void 0, c = s - n, u = o(c), l = s <= a;
    n = s;
    const f = {
      loaded: s,
      total: a,
      progress: a ? s / a : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && a && l ? (a - s) / u : void 0,
      event: i,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: true
    };
    e(f);
  }, r);
};
var XE = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
};
var YE = (e) => (...t) => Q.asap(() => e(...t));
var Ege = Yn.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = Yn.navigator && /(msie|trident)/i.test(Yn.navigator.userAgent), t = document.createElement("a");
    let r;
    function n(o) {
      let i = o;
      return e && (t.setAttribute("href", i), i = t.href), t.setAttribute("href", i), {
        href: t.href,
        protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
        host: t.host,
        search: t.search ? t.search.replace(/^\?/, "") : "",
        hash: t.hash ? t.hash.replace(/^#/, "") : "",
        hostname: t.hostname,
        port: t.port,
        pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
      };
    }
    return r = n(window.location.href), function(o) {
      const i = Q.isString(o) ? n(o) : o;
      return i.protocol === r.protocol && i.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return true;
    };
  }()
);
var xge = Yn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, o, i) {
      const s = [e + "=" + encodeURIComponent(t)];
      Q.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), Q.isString(n) && s.push("path=" + n), Q.isString(o) && s.push("domain=" + o), i === true && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function kge(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function Age(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function ZO(e, t) {
  return e && !kge(t) ? Age(e, t) : t;
}
var JE = (e) => e instanceof Jn ? { ...e } : e;
function Fu(e, t) {
  t = t || {};
  const r = {};
  function n(u, l, f) {
    return Q.isPlainObject(u) && Q.isPlainObject(l) ? Q.merge.call({ caseless: f }, u, l) : Q.isPlainObject(l) ? Q.merge({}, l) : Q.isArray(l) ? l.slice() : l;
  }
  function o(u, l, f) {
    if (Q.isUndefined(l)) {
      if (!Q.isUndefined(u))
        return n(void 0, u, f);
    } else return n(u, l, f);
  }
  function i(u, l) {
    if (!Q.isUndefined(l))
      return n(void 0, l);
  }
  function s(u, l) {
    if (Q.isUndefined(l)) {
      if (!Q.isUndefined(u))
        return n(void 0, u);
    } else return n(void 0, l);
  }
  function a(u, l, f) {
    if (f in t)
      return n(u, l);
    if (f in e)
      return n(void 0, u);
  }
  const c = {
    url: i,
    method: i,
    data: i,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: a,
    headers: (u, l) => o(JE(u), JE(l), true)
  };
  return Q.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const l = c[u] || o, f = l(e[u], t[u], u);
    Q.isUndefined(f) && l !== a || (r[u] = f);
  }), r;
}
var XO = (e) => {
  const t = Fu({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: o, xsrfCookieName: i, headers: s, auth: a } = t;
  t.headers = s = Jn.from(s), t.url = MO(ZO(t.baseURL, t.url), e.params, e.paramsSerializer), a && s.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (Q.isFormData(r)) {
    if (Yn.hasStandardBrowserEnv || Yn.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((c = s.getContentType()) !== false) {
      const [u, ...l] = c ? c.split(";").map((f) => f.trim()).filter(Boolean) : [];
      s.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (Yn.hasStandardBrowserEnv && (n && Q.isFunction(n) && (n = n(t)), n || n !== false && Ege(t.url))) {
    const u = o && i && xge.read(i);
    u && s.set(o, u);
  }
  return t;
};
var Sge = typeof XMLHttpRequest < "u";
var _ge = Sge && function(e) {
  return new Promise(function(t, r) {
    const n = XO(e);
    let o = n.data;
    const i = Jn.from(n.headers).normalize();
    let { responseType: s, onUploadProgress: a, onDownloadProgress: c } = n, u, l, f, d, m;
    function y() {
      d && d(), m && m(), n.cancelToken && n.cancelToken.unsubscribe(u), n.signal && n.signal.removeEventListener("abort", u);
    }
    let b = new XMLHttpRequest();
    b.open(n.method.toUpperCase(), n.url, true), b.timeout = n.timeout;
    function w() {
      if (!b)
        return;
      const k = Jn.from(
        "getAllResponseHeaders" in b && b.getAllResponseHeaders()
      ), x = {
        data: !s || s === "text" || s === "json" ? b.responseText : b.response,
        status: b.status,
        statusText: b.statusText,
        headers: k,
        config: e,
        request: b
      };
      WO(function(_) {
        t(_), y();
      }, function(_) {
        r(_), y();
      }, x), b = null;
    }
    "onloadend" in b ? b.onloadend = w : b.onreadystatechange = function() {
      !b || b.readyState !== 4 || b.status === 0 && !(b.responseURL && b.responseURL.indexOf("file:") === 0) || setTimeout(w);
    }, b.onabort = function() {
      b && (r(new nt("Request aborted", nt.ECONNABORTED, e, b)), b = null);
    }, b.onerror = function() {
      r(new nt("Network Error", nt.ERR_NETWORK, e, b)), b = null;
    }, b.ontimeout = function() {
      let k = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
      const x = n.transitional || qO;
      n.timeoutErrorMessage && (k = n.timeoutErrorMessage), r(new nt(
        k,
        x.clarifyTimeoutError ? nt.ETIMEDOUT : nt.ECONNABORTED,
        e,
        b
      )), b = null;
    }, o === void 0 && i.setContentType(null), "setRequestHeader" in b && Q.forEach(i.toJSON(), function(k, x) {
      b.setRequestHeader(x, k);
    }), Q.isUndefined(n.withCredentials) || (b.withCredentials = !!n.withCredentials), s && s !== "json" && (b.responseType = n.responseType), c && ([f, m] = Xg(c, true), b.addEventListener("progress", f)), a && b.upload && ([l, d] = Xg(a), b.upload.addEventListener("progress", l), b.upload.addEventListener("loadend", d)), (n.cancelToken || n.signal) && (u = (k) => {
      b && (r(!k || k.type ? new Mf(null, e, b) : k), b.abort(), b = null);
    }, n.cancelToken && n.cancelToken.subscribe(u), n.signal && (n.signal.aborted ? u() : n.signal.addEventListener("abort", u)));
    const v = yge(n.url);
    if (v && Yn.protocols.indexOf(v) === -1) {
      r(new nt("Unsupported protocol " + v + ":", nt.ERR_BAD_REQUEST, e));
      return;
    }
    b.send(o || null);
  });
};
var Tge = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), o;
    const i = function(u) {
      if (!o) {
        o = true, a();
        const l = u instanceof Error ? u : this.reason;
        n.abort(l instanceof nt ? l : new Mf(l instanceof Error ? l.message : l));
      }
    };
    let s = t && setTimeout(() => {
      s = null, i(new nt(`timeout ${t} of ms exceeded`, nt.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(i) : u.removeEventListener("abort", i);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", i));
    const { signal: c } = n;
    return c.unsubscribe = () => Q.asap(a), c;
  }
};
var Pge = function* (e, t) {
  let r = e.byteLength;
  if (r < t) {
    yield e;
    return;
  }
  let n = 0, o;
  for (; n < r; )
    o = n + t, yield e.slice(n, o), n = o;
};
var Ige = async function* (e, t) {
  for await (const r of Oge(e))
    yield* Pge(r, t);
};
var Oge = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
};
var QE = (e, t, r, n) => {
  const o = Ige(e, t);
  let i = 0, s, a = (c) => {
    s || (s = true, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await o.next();
        if (u) {
          a(), c.close();
          return;
        }
        let f = l.byteLength;
        if (r) {
          let d = i += f;
          r(d);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw a(u), u;
      }
    },
    cancel(c) {
      return a(c), o.return();
    }
  }, {
    highWaterMark: 2
  });
};
var Dm = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function";
var YO = Dm && typeof ReadableStream == "function";
var Bge = Dm && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer()));
var JO = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return false;
  }
};
var Cge = YO && JO(() => {
  let e = false;
  const t = new Request(Yn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = true, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
});
var ex = 64 * 1024;
var F2 = YO && JO(() => Q.isReadableStream(new Response("").body));
var Yg = {
  stream: F2 && ((e) => e.body)
};
Dm && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Yg[t] && (Yg[t] = Q.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new nt(`Response type '${t}' is not supported`, nt.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
var Nge = async (e) => {
  if (e == null)
    return 0;
  if (Q.isBlob(e))
    return e.size;
  if (Q.isSpecCompliantForm(e))
    return (await new Request(Yn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (Q.isArrayBufferView(e) || Q.isArrayBuffer(e))
    return e.byteLength;
  if (Q.isURLSearchParams(e) && (e = e + ""), Q.isString(e))
    return (await Bge(e)).byteLength;
};
var Uge = async (e, t) => Q.toFiniteNumber(e.getContentLength()) ?? Nge(t);
var $ge = Dm && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: o,
    cancelToken: i,
    timeout: s,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: f = "same-origin",
    fetchOptions: d
  } = XO(e);
  u = u ? (u + "").toLowerCase() : "text";
  let m = Tge([o, i && i.toAbortSignal()], s), y;
  const b = m && m.unsubscribe && (() => {
    m.unsubscribe();
  });
  let w;
  try {
    if (c && Cge && r !== "get" && r !== "head" && (w = await Uge(l, n)) !== 0) {
      let I = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), P;
      if (Q.isFormData(n) && (P = I.headers.get("content-type")) && l.setContentType(P), I.body) {
        const [$, L] = XE(
          w,
          Xg(YE(c))
        );
        n = QE(I.body, ex, $, L);
      }
    }
    Q.isString(f) || (f = f ? "include" : "omit");
    const v = "credentials" in Request.prototype;
    y = new Request(t, {
      ...d,
      signal: m,
      method: r.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: v ? f : void 0
    });
    let k = await fetch(y);
    const x = F2 && (u === "stream" || u === "response");
    if (F2 && (a || x && b)) {
      const I = {};
      ["status", "statusText", "headers"].forEach((V) => {
        I[V] = k[V];
      });
      const P = Q.toFiniteNumber(k.headers.get("content-length")), [$, L] = a && XE(
        P,
        Xg(YE(a), true)
      ) || [];
      k = new Response(
        QE(k.body, ex, $, () => {
          L && L(), b && b();
        }),
        I
      );
    }
    u = u || "text";
    let _ = await Yg[Q.findKey(Yg, u) || "text"](k, e);
    return !x && b && b(), await new Promise((I, P) => {
      WO(I, P, {
        data: _,
        headers: Jn.from(k.headers),
        status: k.status,
        statusText: k.statusText,
        config: e,
        request: y
      });
    });
  } catch (v) {
    throw b && b(), v && v.name === "TypeError" && /fetch/i.test(v.message) ? Object.assign(
      new nt("Network Error", nt.ERR_NETWORK, e, y),
      {
        cause: v.cause || v
      }
    ) : nt.from(v, v && v.code, e, y);
  }
});
var D2 = {
  http: X0e,
  xhr: _ge,
  fetch: $ge
};
Q.forEach(D2, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
var tx = (e) => `- ${e}`;
var Rge = (e) => Q.isFunction(e) || e === null || e === false;
var QO = {
  getAdapter: (e) => {
    e = Q.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const o = {};
    for (let i = 0; i < t; i++) {
      r = e[i];
      let s;
      if (n = r, !Rge(r) && (n = D2[(s = String(r)).toLowerCase()], n === void 0))
        throw new nt(`Unknown adapter '${s}'`);
      if (n)
        break;
      o[s || "#" + i] = n;
    }
    if (!n) {
      const i = Object.entries(o).map(
        ([a, c]) => `adapter ${a} ` + (c === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? i.length > 1 ? `since :
` + i.map(tx).join(`
`) : " " + tx(i[0]) : "as no adapter specified";
      throw new nt(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: D2
};
function Vy(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Mf(null, e);
}
function rx(e) {
  return Vy(e), e.headers = Jn.from(e.headers), e.data = qy.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", false), QO.getAdapter(e.adapter || cp.adapter)(e).then(function(t) {
    return Vy(e), t.data = qy.call(
      e,
      e.transformResponse,
      t
    ), t.headers = Jn.from(t.headers), t;
  }, function(t) {
    return GO(t) || (Vy(e), t && t.response && (t.response.data = qy.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = Jn.from(t.response.headers))), Promise.reject(t);
  });
}
var eB = "1.7.7";
var a5 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  a5[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
var nx = {};
a5.transitional = function(e, t, r) {
  function n(o, i) {
    return "[Axios v" + eB + "] Transitional option '" + o + "'" + i + (r ? ". " + r : "");
  }
  return (o, i, s) => {
    if (e === false)
      throw new nt(
        n(i, " has been removed" + (t ? " in " + t : "")),
        nt.ERR_DEPRECATED
      );
    return t && !nx[i] && (nx[i] = true, console.warn(
      n(
        i,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(o, i, s) : true;
  };
};
function zge(e, t, r) {
  if (typeof e != "object")
    throw new nt("options must be an object", nt.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let o = n.length;
  for (; o-- > 0; ) {
    const i = n[o], s = t[i];
    if (s) {
      const a = e[i], c = a === void 0 || s(a, i, e);
      if (c !== true)
        throw new nt("option " + i + " must be " + c, nt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== true)
      throw new nt("Unknown option " + i, nt.ERR_BAD_OPTION);
  }
}
var K2 = {
  assertOptions: zge,
  validators: a5
};
var Xa = K2.validators;
var Au = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new WE(),
      response: new WE()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let o;
        Error.captureStackTrace ? Error.captureStackTrace(o = {}) : o = new Error();
        const i = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? i && !String(n.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + i) : n.stack = i;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = Fu(this.defaults, r);
    const { transitional: n, paramsSerializer: o, headers: i } = r;
    n !== void 0 && K2.assertOptions(n, {
      silentJSONParsing: Xa.transitional(Xa.boolean),
      forcedJSONParsing: Xa.transitional(Xa.boolean),
      clarifyTimeoutError: Xa.transitional(Xa.boolean)
    }, false), o != null && (Q.isFunction(o) ? r.paramsSerializer = {
      serialize: o
    } : K2.assertOptions(o, {
      encode: Xa.function,
      serialize: Xa.function
    }, true)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let s = i && Q.merge(
      i.common,
      i[r.method]
    );
    i && Q.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (y) => {
        delete i[y];
      }
    ), r.headers = Jn.concat(s, i);
    const a = [];
    let c = true;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(r) === false || (c = c && y.synchronous, a.unshift(y.fulfilled, y.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(y) {
      u.push(y.fulfilled, y.rejected);
    });
    let l, f = 0, d;
    if (!c) {
      const y = [rx.bind(this), void 0];
      for (y.unshift.apply(y, a), y.push.apply(y, u), d = y.length, l = Promise.resolve(r); f < d; )
        l = l.then(y[f++], y[f++]);
      return l;
    }
    d = a.length;
    let m = r;
    for (f = 0; f < d; ) {
      const y = a[f++], b = a[f++];
      try {
        m = y(m);
      } catch (w) {
        b.call(this, w);
        break;
      }
    }
    try {
      l = rx.call(this, m);
    } catch (y) {
      return Promise.reject(y);
    }
    for (f = 0, d = u.length; f < d; )
      l = l.then(u[f++], u[f++]);
    return l;
  }
  getUri(t) {
    t = Fu(this.defaults, t);
    const r = ZO(t.baseURL, t.url);
    return MO(r, t.params, t.paramsSerializer);
  }
};
Q.forEach(["delete", "get", "head", "options"], function(e) {
  Au.prototype[e] = function(t, r) {
    return this.request(Fu(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
Q.forEach(["post", "put", "patch"], function(e) {
  function t(r) {
    return function(n, o, i) {
      return this.request(Fu(i || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: n,
        data: o
      }));
    };
  }
  Au.prototype[e] = t(), Au.prototype[e + "Form"] = t(true);
});
var c5 = class _c5 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((o) => {
      if (!n._listeners) return;
      let i = n._listeners.length;
      for (; i-- > 0; )
        n._listeners[i](o);
      n._listeners = null;
    }), this.promise.then = (o) => {
      let i;
      const s = new Promise((a) => {
        n.subscribe(a), i = a;
      }).then(o);
      return s.cancel = function() {
        n.unsubscribe(i);
      }, s;
    }, t(function(o, i, s) {
      n.reason || (n.reason = new Mf(o, i, s), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new _c5(function(r) {
        t = r;
      }),
      cancel: t
    };
  }
};
function Hge(e) {
  return function(t) {
    return e.apply(null, t);
  };
}
function Lge(e) {
  return Q.isObject(e) && e.isAxiosError === true;
}
var M2 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(M2).forEach(([e, t]) => {
  M2[t] = e;
});
function tB(e) {
  const t = new Au(e), r = CO(Au.prototype.request, t);
  return Q.extend(r, Au.prototype, t, { allOwnKeys: true }), Q.extend(r, t, null, { allOwnKeys: true }), r.create = function(n) {
    return tB(Fu(e, n));
  }, r;
}
var mr = tB(cp);
mr.Axios = Au;
mr.CanceledError = Mf;
mr.CancelToken = c5;
mr.isCancel = GO;
mr.VERSION = eB;
mr.toFormData = Fm;
mr.AxiosError = nt;
mr.Cancel = mr.CanceledError;
mr.all = function(e) {
  return Promise.all(e);
};
mr.spread = Hge;
mr.isAxiosError = Lge;
mr.mergeConfig = Fu;
mr.AxiosHeaders = Jn;
mr.formToJSON = (e) => VO(Q.isHTMLForm(e) ? new FormData(e) : e);
mr.getAdapter = QO.getAdapter;
mr.HttpStatusCode = M2;
mr.default = mr;
var jge = "https://mempool.space";
var Fge = "https://mempool.space/testnet";
var Dge = "https://mempool.space/testnet4";
var Kge = "https://mempool.space/signet";
var Mge = "https://mempool.fractalbitcoin.io";
var qge = "https://mempool-testnet.fractalbitcoin.io";
var Km = (e) => e === sr ? Fge : e === qr ? Dge : e === sn ? Kge : e === ia ? Mge : e === wn ? qge : jge;
var Vge = "text/plain";
eT(r5);
var Wr = (e) => e === sr || e === qr || e === sn ? BQ : Ai;
var u5 = (e) => e.find(
  ({ purpose: t }) => t === "ordinals"
);
var l5 = (e) => e.find(
  ({ purpose: t }) => t === "payment"
);
var qf = async (e, t) => {
  try {
    const r = await f5(
      e,
      t
    );
    return r ? r.reduce((n, o) => n + BigInt(o.value), 0n) : 0n;
  } catch (r) {
    throw console.error("Error fetching BTC balance:", r), new Error("Failed to fetch BTC balance");
  }
};
function Gge(e, t, r) {
  const n = e * 57 + t * 41, o = r * 34;
  return 10 + n + o;
}
async function f5(e, t) {
  if (e.startsWith("t")) {
    if (t === Ft)
      return [];
    if (t === ia)
      return [];
    if (t === wn)
      return [];
  }
  return await mr.get(`${Km(t)}/api/address/${e}/utxo`).then((r) => r.data);
}
async function d5(e, t, r, n, o, i, s = 7) {
  const a = e === t, c = await f5(
    t,
    i
  );
  if (!c)
    throw new Error("No UTXOs found");
  const u = c.sort(
    (b, w) => w.value - b.value
  ), l = new Xt({ network: Wr(i) }), f = Gge(1, 0, 2), d = Math.floor(f * s) + n;
  let m = 0, y = 0;
  for await (let b of u) {
    const { txid: w, vout: v, value: k } = b, x = J3(
      t,
      Wr(i)
    );
    if (l.addInput({
      hash: w,
      index: v,
      witnessUtxo: {
        script: x,
        value: BigInt(k)
      }
    }), !a) {
      const _ = rB(o, i);
      l.updateInput(y, { redeemScript: _ });
    }
    if (m += k, m >= d)
      break;
  }
  if (m < d)
    throw new Error("Insufficient funds");
  return l.addOutput({
    address: r,
    value: BigInt(n)
  }), m > d && l.addOutput({
    address: t,
    value: BigInt(m - d)
  }), {
    psbtBase64: l.toBase64(),
    psbtHex: l.toHex()
  };
}
function rB(e, t) {
  var r;
  const n = Gh({
    pubkey: _O.Buffer.from(e, "hex"),
    network: Wr(t)
  }), o = Rf({
    redeem: n,
    network: Wr(t)
  });
  return (r = o == null ? void 0 : o.redeem) == null ? void 0 : r.output;
}
function Wge(e) {
  return e == null ? void 0 : e.reduce((t, r) => t + r.value, 0);
}
async function h5(e, t) {
  return (await mr.post(
    `${Km(t)}/api/tx`,
    e,
    {
      headers: {
        "Content-Type": "text/plain"
      }
    }
  )).data;
}
var Zge = (e, t) => {
  try {
    const r = Wr(t), n = fT(e);
    if (n.version === r.pubKeyHash) return PQ;
    if (n.version === r.scriptHash) {
      const o = cr(n.hash);
      return o && o.length === 2 && o[0] === zt.OP_0 ? IQ : __;
    }
  } catch {
    try {
      const r = Y3(e);
      if (r.version === 0 && r.data.length === 20) return e2;
      if (r.version === 0 && r.data.length === 32) return OQ;
      if (r.version === 1 && r.data.length === 32) return Ad;
    } catch {
      return "unknown";
    }
  }
  return "unknown";
};
var p5 = (e) => e === sr || e === qr || e === sn;
var g5 = (e) => e === Ft || e === ia || e === wn;
var as = {};
var Jr = {};
var Ze = {};
Object.defineProperty(Ze, "__esModule", { value: true });
Ze.add5L = Ze.add5H = Ze.add4H = Ze.add4L = Ze.add3H = Ze.add3L = Ze.rotlBL = Ze.rotlBH = Ze.rotlSL = Ze.rotlSH = Ze.rotr32L = Ze.rotr32H = Ze.rotrBL = Ze.rotrBH = Ze.rotrSL = Ze.rotrSH = Ze.shrSL = Ze.shrSH = Ze.toBig = void 0;
Ze.fromBig = m5;
Ze.split = nB;
Ze.add = bB;
var Yp = BigInt(2 ** 32 - 1);
var q2 = BigInt(32);
function m5(e, t = false) {
  return t ? { h: Number(e & Yp), l: Number(e >> q2 & Yp) } : { h: Number(e >> q2 & Yp) | 0, l: Number(e & Yp) | 0 };
}
function nB(e, t = false) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let o = 0; o < e.length; o++) {
    const { h: i, l: s } = m5(e[o], t);
    [r[o], n[o]] = [i, s];
  }
  return [r, n];
}
var oB = (e, t) => BigInt(e >>> 0) << q2 | BigInt(t >>> 0);
Ze.toBig = oB;
var iB = (e, t, r) => e >>> r;
Ze.shrSH = iB;
var sB = (e, t, r) => e << 32 - r | t >>> r;
Ze.shrSL = sB;
var aB = (e, t, r) => e >>> r | t << 32 - r;
Ze.rotrSH = aB;
var cB = (e, t, r) => e << 32 - r | t >>> r;
Ze.rotrSL = cB;
var uB = (e, t, r) => e << 64 - r | t >>> r - 32;
Ze.rotrBH = uB;
var lB = (e, t, r) => e >>> r - 32 | t << 64 - r;
Ze.rotrBL = lB;
var fB = (e, t) => t;
Ze.rotr32H = fB;
var dB = (e, t) => e;
Ze.rotr32L = dB;
var hB = (e, t, r) => e << r | t >>> 32 - r;
Ze.rotlSH = hB;
var pB = (e, t, r) => t << r | e >>> 32 - r;
Ze.rotlSL = pB;
var gB = (e, t, r) => t << r - 32 | e >>> 64 - r;
Ze.rotlBH = gB;
var mB = (e, t, r) => e << r - 32 | t >>> 64 - r;
Ze.rotlBL = mB;
function bB(e, t, r, n) {
  const o = (t >>> 0) + (n >>> 0);
  return { h: e + r + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
var yB = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0);
Ze.add3L = yB;
var wB = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0;
Ze.add3H = wB;
var vB = (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0);
Ze.add4L = vB;
var EB = (e, t, r, n, o) => t + r + n + o + (e / 2 ** 32 | 0) | 0;
Ze.add4H = EB;
var xB = (e, t, r, n, o) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (o >>> 0);
Ze.add5L = xB;
var kB = (e, t, r, n, o, i) => t + r + n + o + i + (e / 2 ** 32 | 0) | 0;
Ze.add5H = kB;
var Xge = {
  fromBig: m5,
  split: nB,
  toBig: oB,
  shrSH: iB,
  shrSL: sB,
  rotrSH: aB,
  rotrSL: cB,
  rotrBH: uB,
  rotrBL: lB,
  rotr32H: fB,
  rotr32L: dB,
  rotlSH: hB,
  rotlSL: pB,
  rotlBH: gB,
  rotlBL: mB,
  add: bB,
  add3L: yB,
  add3H: wB,
  add4L: vB,
  add4H: EB,
  add5H: kB,
  add5L: xB
};
Ze.default = Xge;
Object.defineProperty(Jr, "__esModule", { value: true });
Jr.sha384 = Jr.sha512_256 = Jr.sha512_224 = Jr.sha512 = Jr.SHA384 = Jr.SHA512_256 = Jr.SHA512_224 = Jr.SHA512 = void 0;
var Yge = Ds;
var mt = Ze;
var Mm = Rc;
var [Jge, Qge] = mt.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e)));
var Ya = new Uint32Array(80);
var Ja = new Uint32Array(80);
var up = class extends Yge.HashMD {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: r, Bh: n, Bl: o, Ch: i, Cl: s, Dh: a, Dl: c, Eh: u, El: l, Fh: f, Fl: d, Gh: m, Gl: y, Hh: b, Hl: w } = this;
    return [t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w];
  }
  // prettier-ignore
  set(t, r, n, o, i, s, a, c, u, l, f, d, m, y, b, w) {
    this.Ah = t | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = o | 0, this.Ch = i | 0, this.Cl = s | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = f | 0, this.Fl = d | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = b | 0, this.Hl = w | 0;
  }
  process(t, r) {
    for (let x = 0; x < 16; x++, r += 4)
      Ya[x] = t.getUint32(r), Ja[x] = t.getUint32(r += 4);
    for (let x = 16; x < 80; x++) {
      const _ = Ya[x - 15] | 0, I = Ja[x - 15] | 0, P = mt.default.rotrSH(_, I, 1) ^ mt.default.rotrSH(_, I, 8) ^ mt.default.shrSH(_, I, 7), $ = mt.default.rotrSL(_, I, 1) ^ mt.default.rotrSL(_, I, 8) ^ mt.default.shrSL(_, I, 7), L = Ya[x - 2] | 0, V = Ja[x - 2] | 0, ee = mt.default.rotrSH(L, V, 19) ^ mt.default.rotrBH(L, V, 61) ^ mt.default.shrSH(L, V, 6), G = mt.default.rotrSL(L, V, 19) ^ mt.default.rotrBL(L, V, 61) ^ mt.default.shrSL(L, V, 6), N = mt.default.add4L($, G, Ja[x - 7], Ja[x - 16]), q = mt.default.add4H(N, P, ee, Ya[x - 7], Ya[x - 16]);
      Ya[x] = q | 0, Ja[x] = N | 0;
    }
    let { Ah: n, Al: o, Bh: i, Bl: s, Ch: a, Cl: c, Dh: u, Dl: l, Eh: f, El: d, Fh: m, Fl: y, Gh: b, Gl: w, Hh: v, Hl: k } = this;
    for (let x = 0; x < 80; x++) {
      const _ = mt.default.rotrSH(f, d, 14) ^ mt.default.rotrSH(f, d, 18) ^ mt.default.rotrBH(f, d, 41), I = mt.default.rotrSL(f, d, 14) ^ mt.default.rotrSL(f, d, 18) ^ mt.default.rotrBL(f, d, 41), P = f & m ^ ~f & b, $ = d & y ^ ~d & w, L = mt.default.add5L(k, I, $, Qge[x], Ja[x]), V = mt.default.add5H(L, v, _, P, Jge[x], Ya[x]), ee = L | 0, G = mt.default.rotrSH(n, o, 28) ^ mt.default.rotrBH(n, o, 34) ^ mt.default.rotrBH(n, o, 39), N = mt.default.rotrSL(n, o, 28) ^ mt.default.rotrBL(n, o, 34) ^ mt.default.rotrBL(n, o, 39), q = n & i ^ n & a ^ i & a, j = o & s ^ o & c ^ s & c;
      v = b | 0, k = w | 0, b = m | 0, w = y | 0, m = f | 0, y = d | 0, { h: f, l: d } = mt.default.add(u | 0, l | 0, V | 0, ee | 0), u = a | 0, l = c | 0, a = i | 0, c = s | 0, i = n | 0, s = o | 0;
      const C = mt.default.add3L(ee, N, j);
      n = mt.default.add3H(C, V, G, q), o = C | 0;
    }
    ({ h: n, l: o } = mt.default.add(this.Ah | 0, this.Al | 0, n | 0, o | 0)), { h: i, l: s } = mt.default.add(this.Bh | 0, this.Bl | 0, i | 0, s | 0), { h: a, l: c } = mt.default.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l } = mt.default.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h: f, l: d } = mt.default.add(this.Eh | 0, this.El | 0, f | 0, d | 0), { h: m, l: y } = mt.default.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: b, l: w } = mt.default.add(this.Gh | 0, this.Gl | 0, b | 0, w | 0), { h: v, l: k } = mt.default.add(this.Hh | 0, this.Hl | 0, v | 0, k | 0), this.set(n, o, i, s, a, c, u, l, f, d, m, y, b, w, v, k);
  }
  roundClean() {
    Ya.fill(0), Ja.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Jr.SHA512 = up;
var AB = class extends up {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Jr.SHA512_224 = AB;
var SB = class extends up {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Jr.SHA512_256 = SB;
var _B = class extends up {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Jr.SHA384 = _B;
Jr.sha512 = (0, Mm.wrapConstructor)(() => new up());
Jr.sha512_224 = (0, Mm.wrapConstructor)(() => new AB());
Jr.sha512_256 = (0, Mm.wrapConstructor)(() => new SB());
Jr.sha384 = (0, Mm.wrapConstructor)(() => new _B());
var qm = {};
Object.defineProperty(qm, "__esModule", { value: true });
qm.pbkdf2 = t1e;
qm.pbkdf2Async = r1e;
var Jp = So;
var e1e = Om;
var Fl = Rc;
function TB(e, t, r, n) {
  (0, Jp.hash)(e);
  const o = (0, Fl.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: i, dkLen: s, asyncTick: a } = o;
  if ((0, Jp.number)(i), (0, Jp.number)(s), (0, Jp.number)(a), i < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const c = (0, Fl.toBytes)(t), u = (0, Fl.toBytes)(r), l = new Uint8Array(s), f = e1e.hmac.create(e, c), d = f._cloneInto().update(u);
  return { c: i, dkLen: s, asyncTick: a, DK: l, PRF: f, PRFSalt: d };
}
function PB(e, t, r, n, o) {
  return e.destroy(), t.destroy(), n && n.destroy(), o.fill(0), r;
}
function t1e(e, t, r, n) {
  const { c: o, dkLen: i, DK: s, PRF: a, PRFSalt: c } = TB(e, t, r, n);
  let u;
  const l = new Uint8Array(4), f = (0, Fl.createView)(l), d = new Uint8Array(a.outputLen);
  for (let m = 1, y = 0; y < i; m++, y += a.outputLen) {
    const b = s.subarray(y, y + a.outputLen);
    f.setInt32(0, m, false), (u = c._cloneInto(u)).update(l).digestInto(d), b.set(d.subarray(0, b.length));
    for (let w = 1; w < o; w++) {
      a._cloneInto(u).update(d).digestInto(d);
      for (let v = 0; v < b.length; v++)
        b[v] ^= d[v];
    }
  }
  return PB(a, c, s, u, d);
}
async function r1e(e, t, r, n) {
  const { c: o, dkLen: i, asyncTick: s, DK: a, PRF: c, PRFSalt: u } = TB(e, t, r, n);
  let l;
  const f = new Uint8Array(4), d = (0, Fl.createView)(f), m = new Uint8Array(c.outputLen);
  for (let y = 1, b = 0; b < i; y++, b += c.outputLen) {
    const w = a.subarray(b, b + c.outputLen);
    d.setInt32(0, y, false), (l = u._cloneInto(l)).update(f).digestInto(m), w.set(m.subarray(0, w.length)), await (0, Fl.asyncLoop)(o - 1, s, () => {
      c._cloneInto(l).update(m).digestInto(m);
      for (let v = 0; v < w.length; v++)
        w[v] ^= m[v];
    });
  }
  return PB(c, u, a, l, m);
}
var Fn = {};
var n1e = [
  "abdikace",
  "abeceda",
  "adresa",
  "agrese",
  "akce",
  "aktovka",
  "alej",
  "alkohol",
  "amputace",
  "ananas",
  "andulka",
  "anekdota",
  "anketa",
  "antika",
  "anulovat",
  "archa",
  "arogance",
  "asfalt",
  "asistent",
  "aspirace",
  "astma",
  "astronom",
  "atlas",
  "atletika",
  "atol",
  "autobus",
  "azyl",
  "babka",
  "bachor",
  "bacil",
  "baculka",
  "badatel",
  "bageta",
  "bagr",
  "bahno",
  "bakterie",
  "balada",
  "baletka",
  "balkon",
  "balonek",
  "balvan",
  "balza",
  "bambus",
  "bankomat",
  "barbar",
  "baret",
  "barman",
  "baroko",
  "barva",
  "baterka",
  "batoh",
  "bavlna",
  "bazalka",
  "bazilika",
  "bazuka",
  "bedna",
  "beran",
  "beseda",
  "bestie",
  "beton",
  "bezinka",
  "bezmoc",
  "beztak",
  "bicykl",
  "bidlo",
  "biftek",
  "bikiny",
  "bilance",
  "biograf",
  "biolog",
  "bitva",
  "bizon",
  "blahobyt",
  "blatouch",
  "blecha",
  "bledule",
  "blesk",
  "blikat",
  "blizna",
  "blokovat",
  "bloudit",
  "blud",
  "bobek",
  "bobr",
  "bodlina",
  "bodnout",
  "bohatost",
  "bojkot",
  "bojovat",
  "bokorys",
  "bolest",
  "borec",
  "borovice",
  "bota",
  "boubel",
  "bouchat",
  "bouda",
  "boule",
  "bourat",
  "boxer",
  "bradavka",
  "brambora",
  "branka",
  "bratr",
  "brepta",
  "briketa",
  "brko",
  "brloh",
  "bronz",
  "broskev",
  "brunetka",
  "brusinka",
  "brzda",
  "brzy",
  "bublina",
  "bubnovat",
  "buchta",
  "buditel",
  "budka",
  "budova",
  "bufet",
  "bujarost",
  "bukvice",
  "buldok",
  "bulva",
  "bunda",
  "bunkr",
  "burza",
  "butik",
  "buvol",
  "buzola",
  "bydlet",
  "bylina",
  "bytovka",
  "bzukot",
  "capart",
  "carevna",
  "cedr",
  "cedule",
  "cejch",
  "cejn",
  "cela",
  "celer",
  "celkem",
  "celnice",
  "cenina",
  "cennost",
  "cenovka",
  "centrum",
  "cenzor",
  "cestopis",
  "cetka",
  "chalupa",
  "chapadlo",
  "charita",
  "chata",
  "chechtat",
  "chemie",
  "chichot",
  "chirurg",
  "chlad",
  "chleba",
  "chlubit",
  "chmel",
  "chmura",
  "chobot",
  "chochol",
  "chodba",
  "cholera",
  "chomout",
  "chopit",
  "choroba",
  "chov",
  "chrapot",
  "chrlit",
  "chrt",
  "chrup",
  "chtivost",
  "chudina",
  "chutnat",
  "chvat",
  "chvilka",
  "chvost",
  "chyba",
  "chystat",
  "chytit",
  "cibule",
  "cigareta",
  "cihelna",
  "cihla",
  "cinkot",
  "cirkus",
  "cisterna",
  "citace",
  "citrus",
  "cizinec",
  "cizost",
  "clona",
  "cokoliv",
  "couvat",
  "ctitel",
  "ctnost",
  "cudnost",
  "cuketa",
  "cukr",
  "cupot",
  "cvaknout",
  "cval",
  "cvik",
  "cvrkot",
  "cyklista",
  "daleko",
  "dareba",
  "datel",
  "datum",
  "dcera",
  "debata",
  "dechovka",
  "decibel",
  "deficit",
  "deflace",
  "dekl",
  "dekret",
  "demokrat",
  "deprese",
  "derby",
  "deska",
  "detektiv",
  "dikobraz",
  "diktovat",
  "dioda",
  "diplom",
  "disk",
  "displej",
  "divadlo",
  "divoch",
  "dlaha",
  "dlouho",
  "dluhopis",
  "dnes",
  "dobro",
  "dobytek",
  "docent",
  "dochutit",
  "dodnes",
  "dohled",
  "dohoda",
  "dohra",
  "dojem",
  "dojnice",
  "doklad",
  "dokola",
  "doktor",
  "dokument",
  "dolar",
  "doleva",
  "dolina",
  "doma",
  "dominant",
  "domluvit",
  "domov",
  "donutit",
  "dopad",
  "dopis",
  "doplnit",
  "doposud",
  "doprovod",
  "dopustit",
  "dorazit",
  "dorost",
  "dort",
  "dosah",
  "doslov",
  "dostatek",
  "dosud",
  "dosyta",
  "dotaz",
  "dotek",
  "dotknout",
  "doufat",
  "doutnat",
  "dovozce",
  "dozadu",
  "doznat",
  "dozorce",
  "drahota",
  "drak",
  "dramatik",
  "dravec",
  "draze",
  "drdol",
  "drobnost",
  "drogerie",
  "drozd",
  "drsnost",
  "drtit",
  "drzost",
  "duben",
  "duchovno",
  "dudek",
  "duha",
  "duhovka",
  "dusit",
  "dusno",
  "dutost",
  "dvojice",
  "dvorec",
  "dynamit",
  "ekolog",
  "ekonomie",
  "elektron",
  "elipsa",
  "email",
  "emise",
  "emoce",
  "empatie",
  "epizoda",
  "epocha",
  "epopej",
  "epos",
  "esej",
  "esence",
  "eskorta",
  "eskymo",
  "etiketa",
  "euforie",
  "evoluce",
  "exekuce",
  "exkurze",
  "expedice",
  "exploze",
  "export",
  "extrakt",
  "facka",
  "fajfka",
  "fakulta",
  "fanatik",
  "fantazie",
  "farmacie",
  "favorit",
  "fazole",
  "federace",
  "fejeton",
  "fenka",
  "fialka",
  "figurant",
  "filozof",
  "filtr",
  "finance",
  "finta",
  "fixace",
  "fjord",
  "flanel",
  "flirt",
  "flotila",
  "fond",
  "fosfor",
  "fotbal",
  "fotka",
  "foton",
  "frakce",
  "freska",
  "fronta",
  "fukar",
  "funkce",
  "fyzika",
  "galeje",
  "garant",
  "genetika",
  "geolog",
  "gilotina",
  "glazura",
  "glejt",
  "golem",
  "golfista",
  "gotika",
  "graf",
  "gramofon",
  "granule",
  "grep",
  "gril",
  "grog",
  "groteska",
  "guma",
  "hadice",
  "hadr",
  "hala",
  "halenka",
  "hanba",
  "hanopis",
  "harfa",
  "harpuna",
  "havran",
  "hebkost",
  "hejkal",
  "hejno",
  "hejtman",
  "hektar",
  "helma",
  "hematom",
  "herec",
  "herna",
  "heslo",
  "hezky",
  "historik",
  "hladovka",
  "hlasivky",
  "hlava",
  "hledat",
  "hlen",
  "hlodavec",
  "hloh",
  "hloupost",
  "hltat",
  "hlubina",
  "hluchota",
  "hmat",
  "hmota",
  "hmyz",
  "hnis",
  "hnojivo",
  "hnout",
  "hoblina",
  "hoboj",
  "hoch",
  "hodiny",
  "hodlat",
  "hodnota",
  "hodovat",
  "hojnost",
  "hokej",
  "holinka",
  "holka",
  "holub",
  "homole",
  "honitba",
  "honorace",
  "horal",
  "horda",
  "horizont",
  "horko",
  "horlivec",
  "hormon",
  "hornina",
  "horoskop",
  "horstvo",
  "hospoda",
  "hostina",
  "hotovost",
  "houba",
  "houf",
  "houpat",
  "houska",
  "hovor",
  "hradba",
  "hranice",
  "hravost",
  "hrazda",
  "hrbolek",
  "hrdina",
  "hrdlo",
  "hrdost",
  "hrnek",
  "hrobka",
  "hromada",
  "hrot",
  "hrouda",
  "hrozen",
  "hrstka",
  "hrubost",
  "hryzat",
  "hubenost",
  "hubnout",
  "hudba",
  "hukot",
  "humr",
  "husita",
  "hustota",
  "hvozd",
  "hybnost",
  "hydrant",
  "hygiena",
  "hymna",
  "hysterik",
  "idylka",
  "ihned",
  "ikona",
  "iluze",
  "imunita",
  "infekce",
  "inflace",
  "inkaso",
  "inovace",
  "inspekce",
  "internet",
  "invalida",
  "investor",
  "inzerce",
  "ironie",
  "jablko",
  "jachta",
  "jahoda",
  "jakmile",
  "jakost",
  "jalovec",
  "jantar",
  "jarmark",
  "jaro",
  "jasan",
  "jasno",
  "jatka",
  "javor",
  "jazyk",
  "jedinec",
  "jedle",
  "jednatel",
  "jehlan",
  "jekot",
  "jelen",
  "jelito",
  "jemnost",
  "jenom",
  "jepice",
  "jeseter",
  "jevit",
  "jezdec",
  "jezero",
  "jinak",
  "jindy",
  "jinoch",
  "jiskra",
  "jistota",
  "jitrnice",
  "jizva",
  "jmenovat",
  "jogurt",
  "jurta",
  "kabaret",
  "kabel",
  "kabinet",
  "kachna",
  "kadet",
  "kadidlo",
  "kahan",
  "kajak",
  "kajuta",
  "kakao",
  "kaktus",
  "kalamita",
  "kalhoty",
  "kalibr",
  "kalnost",
  "kamera",
  "kamkoliv",
  "kamna",
  "kanibal",
  "kanoe",
  "kantor",
  "kapalina",
  "kapela",
  "kapitola",
  "kapka",
  "kaple",
  "kapota",
  "kapr",
  "kapusta",
  "kapybara",
  "karamel",
  "karotka",
  "karton",
  "kasa",
  "katalog",
  "katedra",
  "kauce",
  "kauza",
  "kavalec",
  "kazajka",
  "kazeta",
  "kazivost",
  "kdekoliv",
  "kdesi",
  "kedluben",
  "kemp",
  "keramika",
  "kino",
  "klacek",
  "kladivo",
  "klam",
  "klapot",
  "klasika",
  "klaun",
  "klec",
  "klenba",
  "klepat",
  "klesnout",
  "klid",
  "klima",
  "klisna",
  "klobouk",
  "klokan",
  "klopa",
  "kloub",
  "klubovna",
  "klusat",
  "kluzkost",
  "kmen",
  "kmitat",
  "kmotr",
  "kniha",
  "knot",
  "koalice",
  "koberec",
  "kobka",
  "kobliha",
  "kobyla",
  "kocour",
  "kohout",
  "kojenec",
  "kokos",
  "koktejl",
  "kolaps",
  "koleda",
  "kolize",
  "kolo",
  "komando",
  "kometa",
  "komik",
  "komnata",
  "komora",
  "kompas",
  "komunita",
  "konat",
  "koncept",
  "kondice",
  "konec",
  "konfese",
  "kongres",
  "konina",
  "konkurs",
  "kontakt",
  "konzerva",
  "kopanec",
  "kopie",
  "kopnout",
  "koprovka",
  "korbel",
  "korektor",
  "kormidlo",
  "koroptev",
  "korpus",
  "koruna",
  "koryto",
  "korzet",
  "kosatec",
  "kostka",
  "kotel",
  "kotleta",
  "kotoul",
  "koukat",
  "koupelna",
  "kousek",
  "kouzlo",
  "kovboj",
  "koza",
  "kozoroh",
  "krabice",
  "krach",
  "krajina",
  "kralovat",
  "krasopis",
  "kravata",
  "kredit",
  "krejcar",
  "kresba",
  "kreveta",
  "kriket",
  "kritik",
  "krize",
  "krkavec",
  "krmelec",
  "krmivo",
  "krocan",
  "krok",
  "kronika",
  "kropit",
  "kroupa",
  "krovka",
  "krtek",
  "kruhadlo",
  "krupice",
  "krutost",
  "krvinka",
  "krychle",
  "krypta",
  "krystal",
  "kryt",
  "kudlanka",
  "kufr",
  "kujnost",
  "kukla",
  "kulajda",
  "kulich",
  "kulka",
  "kulomet",
  "kultura",
  "kuna",
  "kupodivu",
  "kurt",
  "kurzor",
  "kutil",
  "kvalita",
  "kvasinka",
  "kvestor",
  "kynolog",
  "kyselina",
  "kytara",
  "kytice",
  "kytka",
  "kytovec",
  "kyvadlo",
  "labrador",
  "lachtan",
  "ladnost",
  "laik",
  "lakomec",
  "lamela",
  "lampa",
  "lanovka",
  "lasice",
  "laso",
  "lastura",
  "latinka",
  "lavina",
  "lebka",
  "leckdy",
  "leden",
  "lednice",
  "ledovka",
  "ledvina",
  "legenda",
  "legie",
  "legrace",
  "lehce",
  "lehkost",
  "lehnout",
  "lektvar",
  "lenochod",
  "lentilka",
  "lepenka",
  "lepidlo",
  "letadlo",
  "letec",
  "letmo",
  "letokruh",
  "levhart",
  "levitace",
  "levobok",
  "libra",
  "lichotka",
  "lidojed",
  "lidskost",
  "lihovina",
  "lijavec",
  "lilek",
  "limetka",
  "linie",
  "linka",
  "linoleum",
  "listopad",
  "litina",
  "litovat",
  "lobista",
  "lodivod",
  "logika",
  "logoped",
  "lokalita",
  "loket",
  "lomcovat",
  "lopata",
  "lopuch",
  "lord",
  "losos",
  "lotr",
  "loudal",
  "louh",
  "louka",
  "louskat",
  "lovec",
  "lstivost",
  "lucerna",
  "lucifer",
  "lump",
  "lusk",
  "lustrace",
  "lvice",
  "lyra",
  "lyrika",
  "lysina",
  "madam",
  "madlo",
  "magistr",
  "mahagon",
  "majetek",
  "majitel",
  "majorita",
  "makak",
  "makovice",
  "makrela",
  "malba",
  "malina",
  "malovat",
  "malvice",
  "maminka",
  "mandle",
  "manko",
  "marnost",
  "masakr",
  "maskot",
  "masopust",
  "matice",
  "matrika",
  "maturita",
  "mazanec",
  "mazivo",
  "mazlit",
  "mazurka",
  "mdloba",
  "mechanik",
  "meditace",
  "medovina",
  "melasa",
  "meloun",
  "mentolka",
  "metla",
  "metoda",
  "metr",
  "mezera",
  "migrace",
  "mihnout",
  "mihule",
  "mikina",
  "mikrofon",
  "milenec",
  "milimetr",
  "milost",
  "mimika",
  "mincovna",
  "minibar",
  "minomet",
  "minulost",
  "miska",
  "mistr",
  "mixovat",
  "mladost",
  "mlha",
  "mlhovina",
  "mlok",
  "mlsat",
  "mluvit",
  "mnich",
  "mnohem",
  "mobil",
  "mocnost",
  "modelka",
  "modlitba",
  "mohyla",
  "mokro",
  "molekula",
  "momentka",
  "monarcha",
  "monokl",
  "monstrum",
  "montovat",
  "monzun",
  "mosaz",
  "moskyt",
  "most",
  "motivace",
  "motorka",
  "motyka",
  "moucha",
  "moudrost",
  "mozaika",
  "mozek",
  "mozol",
  "mramor",
  "mravenec",
  "mrkev",
  "mrtvola",
  "mrzet",
  "mrzutost",
  "mstitel",
  "mudrc",
  "muflon",
  "mulat",
  "mumie",
  "munice",
  "muset",
  "mutace",
  "muzeum",
  "muzikant",
  "myslivec",
  "mzda",
  "nabourat",
  "nachytat",
  "nadace",
  "nadbytek",
  "nadhoz",
  "nadobro",
  "nadpis",
  "nahlas",
  "nahnat",
  "nahodile",
  "nahradit",
  "naivita",
  "najednou",
  "najisto",
  "najmout",
  "naklonit",
  "nakonec",
  "nakrmit",
  "nalevo",
  "namazat",
  "namluvit",
  "nanometr",
  "naoko",
  "naopak",
  "naostro",
  "napadat",
  "napevno",
  "naplnit",
  "napnout",
  "naposled",
  "naprosto",
  "narodit",
  "naruby",
  "narychlo",
  "nasadit",
  "nasekat",
  "naslepo",
  "nastat",
  "natolik",
  "navenek",
  "navrch",
  "navzdory",
  "nazvat",
  "nebe",
  "nechat",
  "necky",
  "nedaleko",
  "nedbat",
  "neduh",
  "negace",
  "nehet",
  "nehoda",
  "nejen",
  "nejprve",
  "neklid",
  "nelibost",
  "nemilost",
  "nemoc",
  "neochota",
  "neonka",
  "nepokoj",
  "nerost",
  "nerv",
  "nesmysl",
  "nesoulad",
  "netvor",
  "neuron",
  "nevina",
  "nezvykle",
  "nicota",
  "nijak",
  "nikam",
  "nikdy",
  "nikl",
  "nikterak",
  "nitro",
  "nocleh",
  "nohavice",
  "nominace",
  "nora",
  "norek",
  "nositel",
  "nosnost",
  "nouze",
  "noviny",
  "novota",
  "nozdra",
  "nuda",
  "nudle",
  "nuget",
  "nutit",
  "nutnost",
  "nutrie",
  "nymfa",
  "obal",
  "obarvit",
  "obava",
  "obdiv",
  "obec",
  "obehnat",
  "obejmout",
  "obezita",
  "obhajoba",
  "obilnice",
  "objasnit",
  "objekt",
  "obklopit",
  "oblast",
  "oblek",
  "obliba",
  "obloha",
  "obluda",
  "obnos",
  "obohatit",
  "obojek",
  "obout",
  "obrazec",
  "obrna",
  "obruba",
  "obrys",
  "obsah",
  "obsluha",
  "obstarat",
  "obuv",
  "obvaz",
  "obvinit",
  "obvod",
  "obvykle",
  "obyvatel",
  "obzor",
  "ocas",
  "ocel",
  "ocenit",
  "ochladit",
  "ochota",
  "ochrana",
  "ocitnout",
  "odboj",
  "odbyt",
  "odchod",
  "odcizit",
  "odebrat",
  "odeslat",
  "odevzdat",
  "odezva",
  "odhadce",
  "odhodit",
  "odjet",
  "odjinud",
  "odkaz",
  "odkoupit",
  "odliv",
  "odluka",
  "odmlka",
  "odolnost",
  "odpad",
  "odpis",
  "odplout",
  "odpor",
  "odpustit",
  "odpykat",
  "odrazka",
  "odsoudit",
  "odstup",
  "odsun",
  "odtok",
  "odtud",
  "odvaha",
  "odveta",
  "odvolat",
  "odvracet",
  "odznak",
  "ofina",
  "ofsajd",
  "ohlas",
  "ohnisko",
  "ohrada",
  "ohrozit",
  "ohryzek",
  "okap",
  "okenice",
  "oklika",
  "okno",
  "okouzlit",
  "okovy",
  "okrasa",
  "okres",
  "okrsek",
  "okruh",
  "okupant",
  "okurka",
  "okusit",
  "olejnina",
  "olizovat",
  "omak",
  "omeleta",
  "omezit",
  "omladina",
  "omlouvat",
  "omluva",
  "omyl",
  "onehdy",
  "opakovat",
  "opasek",
  "operace",
  "opice",
  "opilost",
  "opisovat",
  "opora",
  "opozice",
  "opravdu",
  "oproti",
  "orbital",
  "orchestr",
  "orgie",
  "orlice",
  "orloj",
  "ortel",
  "osada",
  "oschnout",
  "osika",
  "osivo",
  "oslava",
  "oslepit",
  "oslnit",
  "oslovit",
  "osnova",
  "osoba",
  "osolit",
  "ospalec",
  "osten",
  "ostraha",
  "ostuda",
  "ostych",
  "osvojit",
  "oteplit",
  "otisk",
  "otop",
  "otrhat",
  "otrlost",
  "otrok",
  "otruby",
  "otvor",
  "ovanout",
  "ovar",
  "oves",
  "ovlivnit",
  "ovoce",
  "oxid",
  "ozdoba",
  "pachatel",
  "pacient",
  "padouch",
  "pahorek",
  "pakt",
  "palanda",
  "palec",
  "palivo",
  "paluba",
  "pamflet",
  "pamlsek",
  "panenka",
  "panika",
  "panna",
  "panovat",
  "panstvo",
  "pantofle",
  "paprika",
  "parketa",
  "parodie",
  "parta",
  "paruka",
  "paryba",
  "paseka",
  "pasivita",
  "pastelka",
  "patent",
  "patrona",
  "pavouk",
  "pazneht",
  "pazourek",
  "pecka",
  "pedagog",
  "pejsek",
  "peklo",
  "peloton",
  "penalta",
  "pendrek",
  "penze",
  "periskop",
  "pero",
  "pestrost",
  "petarda",
  "petice",
  "petrolej",
  "pevnina",
  "pexeso",
  "pianista",
  "piha",
  "pijavice",
  "pikle",
  "piknik",
  "pilina",
  "pilnost",
  "pilulka",
  "pinzeta",
  "pipeta",
  "pisatel",
  "pistole",
  "pitevna",
  "pivnice",
  "pivovar",
  "placenta",
  "plakat",
  "plamen",
  "planeta",
  "plastika",
  "platit",
  "plavidlo",
  "plaz",
  "plech",
  "plemeno",
  "plenta",
  "ples",
  "pletivo",
  "plevel",
  "plivat",
  "plnit",
  "plno",
  "plocha",
  "plodina",
  "plomba",
  "plout",
  "pluk",
  "plyn",
  "pobavit",
  "pobyt",
  "pochod",
  "pocit",
  "poctivec",
  "podat",
  "podcenit",
  "podepsat",
  "podhled",
  "podivit",
  "podklad",
  "podmanit",
  "podnik",
  "podoba",
  "podpora",
  "podraz",
  "podstata",
  "podvod",
  "podzim",
  "poezie",
  "pohanka",
  "pohnutka",
  "pohovor",
  "pohroma",
  "pohyb",
  "pointa",
  "pojistka",
  "pojmout",
  "pokazit",
  "pokles",
  "pokoj",
  "pokrok",
  "pokuta",
  "pokyn",
  "poledne",
  "polibek",
  "polknout",
  "poloha",
  "polynom",
  "pomalu",
  "pominout",
  "pomlka",
  "pomoc",
  "pomsta",
  "pomyslet",
  "ponechat",
  "ponorka",
  "ponurost",
  "popadat",
  "popel",
  "popisek",
  "poplach",
  "poprosit",
  "popsat",
  "popud",
  "poradce",
  "porce",
  "porod",
  "porucha",
  "poryv",
  "posadit",
  "posed",
  "posila",
  "poskok",
  "poslanec",
  "posoudit",
  "pospolu",
  "postava",
  "posudek",
  "posyp",
  "potah",
  "potkan",
  "potlesk",
  "potomek",
  "potrava",
  "potupa",
  "potvora",
  "poukaz",
  "pouto",
  "pouzdro",
  "povaha",
  "povidla",
  "povlak",
  "povoz",
  "povrch",
  "povstat",
  "povyk",
  "povzdech",
  "pozdrav",
  "pozemek",
  "poznatek",
  "pozor",
  "pozvat",
  "pracovat",
  "prahory",
  "praktika",
  "prales",
  "praotec",
  "praporek",
  "prase",
  "pravda",
  "princip",
  "prkno",
  "probudit",
  "procento",
  "prodej",
  "profese",
  "prohra",
  "projekt",
  "prolomit",
  "promile",
  "pronikat",
  "propad",
  "prorok",
  "prosba",
  "proton",
  "proutek",
  "provaz",
  "prskavka",
  "prsten",
  "prudkost",
  "prut",
  "prvek",
  "prvohory",
  "psanec",
  "psovod",
  "pstruh",
  "ptactvo",
  "puberta",
  "puch",
  "pudl",
  "pukavec",
  "puklina",
  "pukrle",
  "pult",
  "pumpa",
  "punc",
  "pupen",
  "pusa",
  "pusinka",
  "pustina",
  "putovat",
  "putyka",
  "pyramida",
  "pysk",
  "pytel",
  "racek",
  "rachot",
  "radiace",
  "radnice",
  "radon",
  "raft",
  "ragby",
  "raketa",
  "rakovina",
  "rameno",
  "rampouch",
  "rande",
  "rarach",
  "rarita",
  "rasovna",
  "rastr",
  "ratolest",
  "razance",
  "razidlo",
  "reagovat",
  "reakce",
  "recept",
  "redaktor",
  "referent",
  "reflex",
  "rejnok",
  "reklama",
  "rekord",
  "rekrut",
  "rektor",
  "reputace",
  "revize",
  "revma",
  "revolver",
  "rezerva",
  "riskovat",
  "riziko",
  "robotika",
  "rodokmen",
  "rohovka",
  "rokle",
  "rokoko",
  "romaneto",
  "ropovod",
  "ropucha",
  "rorejs",
  "rosol",
  "rostlina",
  "rotmistr",
  "rotoped",
  "rotunda",
  "roubenka",
  "roucho",
  "roup",
  "roura",
  "rovina",
  "rovnice",
  "rozbor",
  "rozchod",
  "rozdat",
  "rozeznat",
  "rozhodce",
  "rozinka",
  "rozjezd",
  "rozkaz",
  "rozloha",
  "rozmar",
  "rozpad",
  "rozruch",
  "rozsah",
  "roztok",
  "rozum",
  "rozvod",
  "rubrika",
  "ruchadlo",
  "rukavice",
  "rukopis",
  "ryba",
  "rybolov",
  "rychlost",
  "rydlo",
  "rypadlo",
  "rytina",
  "ryzost",
  "sadista",
  "sahat",
  "sako",
  "samec",
  "samizdat",
  "samota",
  "sanitka",
  "sardinka",
  "sasanka",
  "satelit",
  "sazba",
  "sazenice",
  "sbor",
  "schovat",
  "sebranka",
  "secese",
  "sedadlo",
  "sediment",
  "sedlo",
  "sehnat",
  "sejmout",
  "sekera",
  "sekta",
  "sekunda",
  "sekvoje",
  "semeno",
  "seno",
  "servis",
  "sesadit",
  "seshora",
  "seskok",
  "seslat",
  "sestra",
  "sesuv",
  "sesypat",
  "setba",
  "setina",
  "setkat",
  "setnout",
  "setrvat",
  "sever",
  "seznam",
  "shoda",
  "shrnout",
  "sifon",
  "silnice",
  "sirka",
  "sirotek",
  "sirup",
  "situace",
  "skafandr",
  "skalisko",
  "skanzen",
  "skaut",
  "skeptik",
  "skica",
  "skladba",
  "sklenice",
  "sklo",
  "skluz",
  "skoba",
  "skokan",
  "skoro",
  "skripta",
  "skrz",
  "skupina",
  "skvost",
  "skvrna",
  "slabika",
  "sladidlo",
  "slanina",
  "slast",
  "slavnost",
  "sledovat",
  "slepec",
  "sleva",
  "slezina",
  "slib",
  "slina",
  "sliznice",
  "slon",
  "sloupek",
  "slovo",
  "sluch",
  "sluha",
  "slunce",
  "slupka",
  "slza",
  "smaragd",
  "smetana",
  "smilstvo",
  "smlouva",
  "smog",
  "smrad",
  "smrk",
  "smrtka",
  "smutek",
  "smysl",
  "snad",
  "snaha",
  "snob",
  "sobota",
  "socha",
  "sodovka",
  "sokol",
  "sopka",
  "sotva",
  "souboj",
  "soucit",
  "soudce",
  "souhlas",
  "soulad",
  "soumrak",
  "souprava",
  "soused",
  "soutok",
  "souviset",
  "spalovna",
  "spasitel",
  "spis",
  "splav",
  "spodek",
  "spojenec",
  "spolu",
  "sponzor",
  "spornost",
  "spousta",
  "sprcha",
  "spustit",
  "sranda",
  "sraz",
  "srdce",
  "srna",
  "srnec",
  "srovnat",
  "srpen",
  "srst",
  "srub",
  "stanice",
  "starosta",
  "statika",
  "stavba",
  "stehno",
  "stezka",
  "stodola",
  "stolek",
  "stopa",
  "storno",
  "stoupat",
  "strach",
  "stres",
  "strhnout",
  "strom",
  "struna",
  "studna",
  "stupnice",
  "stvol",
  "styk",
  "subjekt",
  "subtropy",
  "suchar",
  "sudost",
  "sukno",
  "sundat",
  "sunout",
  "surikata",
  "surovina",
  "svah",
  "svalstvo",
  "svetr",
  "svatba",
  "svazek",
  "svisle",
  "svitek",
  "svoboda",
  "svodidlo",
  "svorka",
  "svrab",
  "sykavka",
  "sykot",
  "synek",
  "synovec",
  "sypat",
  "sypkost",
  "syrovost",
  "sysel",
  "sytost",
  "tabletka",
  "tabule",
  "tahoun",
  "tajemno",
  "tajfun",
  "tajga",
  "tajit",
  "tajnost",
  "taktika",
  "tamhle",
  "tampon",
  "tancovat",
  "tanec",
  "tanker",
  "tapeta",
  "tavenina",
  "tazatel",
  "technika",
  "tehdy",
  "tekutina",
  "telefon",
  "temnota",
  "tendence",
  "tenista",
  "tenor",
  "teplota",
  "tepna",
  "teprve",
  "terapie",
  "termoska",
  "textil",
  "ticho",
  "tiskopis",
  "titulek",
  "tkadlec",
  "tkanina",
  "tlapka",
  "tleskat",
  "tlukot",
  "tlupa",
  "tmel",
  "toaleta",
  "topinka",
  "topol",
  "torzo",
  "touha",
  "toulec",
  "tradice",
  "traktor",
  "tramp",
  "trasa",
  "traverza",
  "trefit",
  "trest",
  "trezor",
  "trhavina",
  "trhlina",
  "trochu",
  "trojice",
  "troska",
  "trouba",
  "trpce",
  "trpitel",
  "trpkost",
  "trubec",
  "truchlit",
  "truhlice",
  "trus",
  "trvat",
  "tudy",
  "tuhnout",
  "tuhost",
  "tundra",
  "turista",
  "turnaj",
  "tuzemsko",
  "tvaroh",
  "tvorba",
  "tvrdost",
  "tvrz",
  "tygr",
  "tykev",
  "ubohost",
  "uboze",
  "ubrat",
  "ubrousek",
  "ubrus",
  "ubytovna",
  "ucho",
  "uctivost",
  "udivit",
  "uhradit",
  "ujednat",
  "ujistit",
  "ujmout",
  "ukazatel",
  "uklidnit",
  "uklonit",
  "ukotvit",
  "ukrojit",
  "ulice",
  "ulita",
  "ulovit",
  "umyvadlo",
  "unavit",
  "uniforma",
  "uniknout",
  "upadnout",
  "uplatnit",
  "uplynout",
  "upoutat",
  "upravit",
  "uran",
  "urazit",
  "usednout",
  "usilovat",
  "usmrtit",
  "usnadnit",
  "usnout",
  "usoudit",
  "ustlat",
  "ustrnout",
  "utahovat",
  "utkat",
  "utlumit",
  "utonout",
  "utopenec",
  "utrousit",
  "uvalit",
  "uvolnit",
  "uvozovka",
  "uzdravit",
  "uzel",
  "uzenina",
  "uzlina",
  "uznat",
  "vagon",
  "valcha",
  "valoun",
  "vana",
  "vandal",
  "vanilka",
  "varan",
  "varhany",
  "varovat",
  "vcelku",
  "vchod",
  "vdova",
  "vedro",
  "vegetace",
  "vejce",
  "velbloud",
  "veletrh",
  "velitel",
  "velmoc",
  "velryba",
  "venkov",
  "veranda",
  "verze",
  "veselka",
  "veskrze",
  "vesnice",
  "vespodu",
  "vesta",
  "veterina",
  "veverka",
  "vibrace",
  "vichr",
  "videohra",
  "vidina",
  "vidle",
  "vila",
  "vinice",
  "viset",
  "vitalita",
  "vize",
  "vizitka",
  "vjezd",
  "vklad",
  "vkus",
  "vlajka",
  "vlak",
  "vlasec",
  "vlevo",
  "vlhkost",
  "vliv",
  "vlnovka",
  "vloupat",
  "vnucovat",
  "vnuk",
  "voda",
  "vodivost",
  "vodoznak",
  "vodstvo",
  "vojensky",
  "vojna",
  "vojsko",
  "volant",
  "volba",
  "volit",
  "volno",
  "voskovka",
  "vozidlo",
  "vozovna",
  "vpravo",
  "vrabec",
  "vracet",
  "vrah",
  "vrata",
  "vrba",
  "vrcholek",
  "vrhat",
  "vrstva",
  "vrtule",
  "vsadit",
  "vstoupit",
  "vstup",
  "vtip",
  "vybavit",
  "vybrat",
  "vychovat",
  "vydat",
  "vydra",
  "vyfotit",
  "vyhledat",
  "vyhnout",
  "vyhodit",
  "vyhradit",
  "vyhubit",
  "vyjasnit",
  "vyjet",
  "vyjmout",
  "vyklopit",
  "vykonat",
  "vylekat",
  "vymazat",
  "vymezit",
  "vymizet",
  "vymyslet",
  "vynechat",
  "vynikat",
  "vynutit",
  "vypadat",
  "vyplatit",
  "vypravit",
  "vypustit",
  "vyrazit",
  "vyrovnat",
  "vyrvat",
  "vyslovit",
  "vysoko",
  "vystavit",
  "vysunout",
  "vysypat",
  "vytasit",
  "vytesat",
  "vytratit",
  "vyvinout",
  "vyvolat",
  "vyvrhel",
  "vyzdobit",
  "vyznat",
  "vzadu",
  "vzbudit",
  "vzchopit",
  "vzdor",
  "vzduch",
  "vzdychat",
  "vzestup",
  "vzhledem",
  "vzkaz",
  "vzlykat",
  "vznik",
  "vzorek",
  "vzpoura",
  "vztah",
  "vztek",
  "xylofon",
  "zabrat",
  "zabydlet",
  "zachovat",
  "zadarmo",
  "zadusit",
  "zafoukat",
  "zahltit",
  "zahodit",
  "zahrada",
  "zahynout",
  "zajatec",
  "zajet",
  "zajistit",
  "zaklepat",
  "zakoupit",
  "zalepit",
  "zamezit",
  "zamotat",
  "zamyslet",
  "zanechat",
  "zanikat",
  "zaplatit",
  "zapojit",
  "zapsat",
  "zarazit",
  "zastavit",
  "zasunout",
  "zatajit",
  "zatemnit",
  "zatknout",
  "zaujmout",
  "zavalit",
  "zavelet",
  "zavinit",
  "zavolat",
  "zavrtat",
  "zazvonit",
  "zbavit",
  "zbrusu",
  "zbudovat",
  "zbytek",
  "zdaleka",
  "zdarma",
  "zdatnost",
  "zdivo",
  "zdobit",
  "zdroj",
  "zdvih",
  "zdymadlo",
  "zelenina",
  "zeman",
  "zemina",
  "zeptat",
  "zezadu",
  "zezdola",
  "zhatit",
  "zhltnout",
  "zhluboka",
  "zhotovit",
  "zhruba",
  "zima",
  "zimnice",
  "zjemnit",
  "zklamat",
  "zkoumat",
  "zkratka",
  "zkumavka",
  "zlato",
  "zlehka",
  "zloba",
  "zlom",
  "zlost",
  "zlozvyk",
  "zmapovat",
  "zmar",
  "zmatek",
  "zmije",
  "zmizet",
  "zmocnit",
  "zmodrat",
  "zmrzlina",
  "zmutovat",
  "znak",
  "znalost",
  "znamenat",
  "znovu",
  "zobrazit",
  "zotavit",
  "zoubek",
  "zoufale",
  "zplodit",
  "zpomalit",
  "zprava",
  "zprostit",
  "zprudka",
  "zprvu",
  "zrada",
  "zranit",
  "zrcadlo",
  "zrnitost",
  "zrno",
  "zrovna",
  "zrychlit",
  "zrzavost",
  "zticha",
  "ztratit",
  "zubovina",
  "zubr",
  "zvednout",
  "zvenku",
  "zvesela",
  "zvon",
  "zvrat",
  "zvukovod",
  "zvyk"
];
var o1e = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var i1e = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var s1e = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var a1e = [
  "abaisser",
  "abandon",
  "abdiquer",
  "abeille",
  "abolir",
  "aborder",
  "aboutir",
  "aboyer",
  "abrasif",
  "abreuver",
  "abriter",
  "abroger",
  "abrupt",
  "absence",
  "absolu",
  "absurde",
  "abusif",
  "abyssal",
  "academie",
  "acajou",
  "acarien",
  "accabler",
  "accepter",
  "acclamer",
  "accolade",
  "accroche",
  "accuser",
  "acerbe",
  "achat",
  "acheter",
  "aciduler",
  "acier",
  "acompte",
  "acquerir",
  "acronyme",
  "acteur",
  "actif",
  "actuel",
  "adepte",
  "adequat",
  "adhesif",
  "adjectif",
  "adjuger",
  "admettre",
  "admirer",
  "adopter",
  "adorer",
  "adoucir",
  "adresse",
  "adroit",
  "adulte",
  "adverbe",
  "aerer",
  "aeronef",
  "affaire",
  "affecter",
  "affiche",
  "affreux",
  "affubler",
  "agacer",
  "agencer",
  "agile",
  "agiter",
  "agrafer",
  "agreable",
  "agrume",
  "aider",
  "aiguille",
  "ailier",
  "aimable",
  "aisance",
  "ajouter",
  "ajuster",
  "alarmer",
  "alchimie",
  "alerte",
  "algebre",
  "algue",
  "aliener",
  "aliment",
  "alleger",
  "alliage",
  "allouer",
  "allumer",
  "alourdir",
  "alpaga",
  "altesse",
  "alveole",
  "amateur",
  "ambigu",
  "ambre",
  "amenager",
  "amertume",
  "amidon",
  "amiral",
  "amorcer",
  "amour",
  "amovible",
  "amphibie",
  "ampleur",
  "amusant",
  "analyse",
  "anaphore",
  "anarchie",
  "anatomie",
  "ancien",
  "aneantir",
  "angle",
  "angoisse",
  "anguleux",
  "animal",
  "annexer",
  "annonce",
  "annuel",
  "anodin",
  "anomalie",
  "anonyme",
  "anormal",
  "antenne",
  "antidote",
  "anxieux",
  "apaiser",
  "aperitif",
  "aplanir",
  "apologie",
  "appareil",
  "appeler",
  "apporter",
  "appuyer",
  "aquarium",
  "aqueduc",
  "arbitre",
  "arbuste",
  "ardeur",
  "ardoise",
  "argent",
  "arlequin",
  "armature",
  "armement",
  "armoire",
  "armure",
  "arpenter",
  "arracher",
  "arriver",
  "arroser",
  "arsenic",
  "arteriel",
  "article",
  "aspect",
  "asphalte",
  "aspirer",
  "assaut",
  "asservir",
  "assiette",
  "associer",
  "assurer",
  "asticot",
  "astre",
  "astuce",
  "atelier",
  "atome",
  "atrium",
  "atroce",
  "attaque",
  "attentif",
  "attirer",
  "attraper",
  "aubaine",
  "auberge",
  "audace",
  "audible",
  "augurer",
  "aurore",
  "automne",
  "autruche",
  "avaler",
  "avancer",
  "avarice",
  "avenir",
  "averse",
  "aveugle",
  "aviateur",
  "avide",
  "avion",
  "aviser",
  "avoine",
  "avouer",
  "avril",
  "axial",
  "axiome",
  "badge",
  "bafouer",
  "bagage",
  "baguette",
  "baignade",
  "balancer",
  "balcon",
  "baleine",
  "balisage",
  "bambin",
  "bancaire",
  "bandage",
  "banlieue",
  "banniere",
  "banquier",
  "barbier",
  "baril",
  "baron",
  "barque",
  "barrage",
  "bassin",
  "bastion",
  "bataille",
  "bateau",
  "batterie",
  "baudrier",
  "bavarder",
  "belette",
  "belier",
  "belote",
  "benefice",
  "berceau",
  "berger",
  "berline",
  "bermuda",
  "besace",
  "besogne",
  "betail",
  "beurre",
  "biberon",
  "bicycle",
  "bidule",
  "bijou",
  "bilan",
  "bilingue",
  "billard",
  "binaire",
  "biologie",
  "biopsie",
  "biotype",
  "biscuit",
  "bison",
  "bistouri",
  "bitume",
  "bizarre",
  "blafard",
  "blague",
  "blanchir",
  "blessant",
  "blinder",
  "blond",
  "bloquer",
  "blouson",
  "bobard",
  "bobine",
  "boire",
  "boiser",
  "bolide",
  "bonbon",
  "bondir",
  "bonheur",
  "bonifier",
  "bonus",
  "bordure",
  "borne",
  "botte",
  "boucle",
  "boueux",
  "bougie",
  "boulon",
  "bouquin",
  "bourse",
  "boussole",
  "boutique",
  "boxeur",
  "branche",
  "brasier",
  "brave",
  "brebis",
  "breche",
  "breuvage",
  "bricoler",
  "brigade",
  "brillant",
  "brioche",
  "brique",
  "brochure",
  "broder",
  "bronzer",
  "brousse",
  "broyeur",
  "brume",
  "brusque",
  "brutal",
  "bruyant",
  "buffle",
  "buisson",
  "bulletin",
  "bureau",
  "burin",
  "bustier",
  "butiner",
  "butoir",
  "buvable",
  "buvette",
  "cabanon",
  "cabine",
  "cachette",
  "cadeau",
  "cadre",
  "cafeine",
  "caillou",
  "caisson",
  "calculer",
  "calepin",
  "calibre",
  "calmer",
  "calomnie",
  "calvaire",
  "camarade",
  "camera",
  "camion",
  "campagne",
  "canal",
  "caneton",
  "canon",
  "cantine",
  "canular",
  "capable",
  "caporal",
  "caprice",
  "capsule",
  "capter",
  "capuche",
  "carabine",
  "carbone",
  "caresser",
  "caribou",
  "carnage",
  "carotte",
  "carreau",
  "carton",
  "cascade",
  "casier",
  "casque",
  "cassure",
  "causer",
  "caution",
  "cavalier",
  "caverne",
  "caviar",
  "cedille",
  "ceinture",
  "celeste",
  "cellule",
  "cendrier",
  "censurer",
  "central",
  "cercle",
  "cerebral",
  "cerise",
  "cerner",
  "cerveau",
  "cesser",
  "chagrin",
  "chaise",
  "chaleur",
  "chambre",
  "chance",
  "chapitre",
  "charbon",
  "chasseur",
  "chaton",
  "chausson",
  "chavirer",
  "chemise",
  "chenille",
  "chequier",
  "chercher",
  "cheval",
  "chien",
  "chiffre",
  "chignon",
  "chimere",
  "chiot",
  "chlorure",
  "chocolat",
  "choisir",
  "chose",
  "chouette",
  "chrome",
  "chute",
  "cigare",
  "cigogne",
  "cimenter",
  "cinema",
  "cintrer",
  "circuler",
  "cirer",
  "cirque",
  "citerne",
  "citoyen",
  "citron",
  "civil",
  "clairon",
  "clameur",
  "claquer",
  "classe",
  "clavier",
  "client",
  "cligner",
  "climat",
  "clivage",
  "cloche",
  "clonage",
  "cloporte",
  "cobalt",
  "cobra",
  "cocasse",
  "cocotier",
  "coder",
  "codifier",
  "coffre",
  "cogner",
  "cohesion",
  "coiffer",
  "coincer",
  "colere",
  "colibri",
  "colline",
  "colmater",
  "colonel",
  "combat",
  "comedie",
  "commande",
  "compact",
  "concert",
  "conduire",
  "confier",
  "congeler",
  "connoter",
  "consonne",
  "contact",
  "convexe",
  "copain",
  "copie",
  "corail",
  "corbeau",
  "cordage",
  "corniche",
  "corpus",
  "correct",
  "cortege",
  "cosmique",
  "costume",
  "coton",
  "coude",
  "coupure",
  "courage",
  "couteau",
  "couvrir",
  "coyote",
  "crabe",
  "crainte",
  "cravate",
  "crayon",
  "creature",
  "crediter",
  "cremeux",
  "creuser",
  "crevette",
  "cribler",
  "crier",
  "cristal",
  "critere",
  "croire",
  "croquer",
  "crotale",
  "crucial",
  "cruel",
  "crypter",
  "cubique",
  "cueillir",
  "cuillere",
  "cuisine",
  "cuivre",
  "culminer",
  "cultiver",
  "cumuler",
  "cupide",
  "curatif",
  "curseur",
  "cyanure",
  "cycle",
  "cylindre",
  "cynique",
  "daigner",
  "damier",
  "danger",
  "danseur",
  "dauphin",
  "debattre",
  "debiter",
  "deborder",
  "debrider",
  "debutant",
  "decaler",
  "decembre",
  "dechirer",
  "decider",
  "declarer",
  "decorer",
  "decrire",
  "decupler",
  "dedale",
  "deductif",
  "deesse",
  "defensif",
  "defiler",
  "defrayer",
  "degager",
  "degivrer",
  "deglutir",
  "degrafer",
  "dejeuner",
  "delice",
  "deloger",
  "demander",
  "demeurer",
  "demolir",
  "denicher",
  "denouer",
  "dentelle",
  "denuder",
  "depart",
  "depenser",
  "dephaser",
  "deplacer",
  "deposer",
  "deranger",
  "derober",
  "desastre",
  "descente",
  "desert",
  "designer",
  "desobeir",
  "dessiner",
  "destrier",
  "detacher",
  "detester",
  "detourer",
  "detresse",
  "devancer",
  "devenir",
  "deviner",
  "devoir",
  "diable",
  "dialogue",
  "diamant",
  "dicter",
  "differer",
  "digerer",
  "digital",
  "digne",
  "diluer",
  "dimanche",
  "diminuer",
  "dioxyde",
  "directif",
  "diriger",
  "discuter",
  "disposer",
  "dissiper",
  "distance",
  "divertir",
  "diviser",
  "docile",
  "docteur",
  "dogme",
  "doigt",
  "domaine",
  "domicile",
  "dompter",
  "donateur",
  "donjon",
  "donner",
  "dopamine",
  "dortoir",
  "dorure",
  "dosage",
  "doseur",
  "dossier",
  "dotation",
  "douanier",
  "double",
  "douceur",
  "douter",
  "doyen",
  "dragon",
  "draper",
  "dresser",
  "dribbler",
  "droiture",
  "duperie",
  "duplexe",
  "durable",
  "durcir",
  "dynastie",
  "eblouir",
  "ecarter",
  "echarpe",
  "echelle",
  "eclairer",
  "eclipse",
  "eclore",
  "ecluse",
  "ecole",
  "economie",
  "ecorce",
  "ecouter",
  "ecraser",
  "ecremer",
  "ecrivain",
  "ecrou",
  "ecume",
  "ecureuil",
  "edifier",
  "eduquer",
  "effacer",
  "effectif",
  "effigie",
  "effort",
  "effrayer",
  "effusion",
  "egaliser",
  "egarer",
  "ejecter",
  "elaborer",
  "elargir",
  "electron",
  "elegant",
  "elephant",
  "eleve",
  "eligible",
  "elitisme",
  "eloge",
  "elucider",
  "eluder",
  "emballer",
  "embellir",
  "embryon",
  "emeraude",
  "emission",
  "emmener",
  "emotion",
  "emouvoir",
  "empereur",
  "employer",
  "emporter",
  "emprise",
  "emulsion",
  "encadrer",
  "enchere",
  "enclave",
  "encoche",
  "endiguer",
  "endosser",
  "endroit",
  "enduire",
  "energie",
  "enfance",
  "enfermer",
  "enfouir",
  "engager",
  "engin",
  "englober",
  "enigme",
  "enjamber",
  "enjeu",
  "enlever",
  "ennemi",
  "ennuyeux",
  "enrichir",
  "enrobage",
  "enseigne",
  "entasser",
  "entendre",
  "entier",
  "entourer",
  "entraver",
  "enumerer",
  "envahir",
  "enviable",
  "envoyer",
  "enzyme",
  "eolien",
  "epaissir",
  "epargne",
  "epatant",
  "epaule",
  "epicerie",
  "epidemie",
  "epier",
  "epilogue",
  "epine",
  "episode",
  "epitaphe",
  "epoque",
  "epreuve",
  "eprouver",
  "epuisant",
  "equerre",
  "equipe",
  "eriger",
  "erosion",
  "erreur",
  "eruption",
  "escalier",
  "espadon",
  "espece",
  "espiegle",
  "espoir",
  "esprit",
  "esquiver",
  "essayer",
  "essence",
  "essieu",
  "essorer",
  "estime",
  "estomac",
  "estrade",
  "etagere",
  "etaler",
  "etanche",
  "etatique",
  "eteindre",
  "etendoir",
  "eternel",
  "ethanol",
  "ethique",
  "ethnie",
  "etirer",
  "etoffer",
  "etoile",
  "etonnant",
  "etourdir",
  "etrange",
  "etroit",
  "etude",
  "euphorie",
  "evaluer",
  "evasion",
  "eventail",
  "evidence",
  "eviter",
  "evolutif",
  "evoquer",
  "exact",
  "exagerer",
  "exaucer",
  "exceller",
  "excitant",
  "exclusif",
  "excuse",
  "executer",
  "exemple",
  "exercer",
  "exhaler",
  "exhorter",
  "exigence",
  "exiler",
  "exister",
  "exotique",
  "expedier",
  "explorer",
  "exposer",
  "exprimer",
  "exquis",
  "extensif",
  "extraire",
  "exulter",
  "fable",
  "fabuleux",
  "facette",
  "facile",
  "facture",
  "faiblir",
  "falaise",
  "fameux",
  "famille",
  "farceur",
  "farfelu",
  "farine",
  "farouche",
  "fasciner",
  "fatal",
  "fatigue",
  "faucon",
  "fautif",
  "faveur",
  "favori",
  "febrile",
  "feconder",
  "federer",
  "felin",
  "femme",
  "femur",
  "fendoir",
  "feodal",
  "fermer",
  "feroce",
  "ferveur",
  "festival",
  "feuille",
  "feutre",
  "fevrier",
  "fiasco",
  "ficeler",
  "fictif",
  "fidele",
  "figure",
  "filature",
  "filetage",
  "filiere",
  "filleul",
  "filmer",
  "filou",
  "filtrer",
  "financer",
  "finir",
  "fiole",
  "firme",
  "fissure",
  "fixer",
  "flairer",
  "flamme",
  "flasque",
  "flatteur",
  "fleau",
  "fleche",
  "fleur",
  "flexion",
  "flocon",
  "flore",
  "fluctuer",
  "fluide",
  "fluvial",
  "folie",
  "fonderie",
  "fongible",
  "fontaine",
  "forcer",
  "forgeron",
  "formuler",
  "fortune",
  "fossile",
  "foudre",
  "fougere",
  "fouiller",
  "foulure",
  "fourmi",
  "fragile",
  "fraise",
  "franchir",
  "frapper",
  "frayeur",
  "fregate",
  "freiner",
  "frelon",
  "fremir",
  "frenesie",
  "frere",
  "friable",
  "friction",
  "frisson",
  "frivole",
  "froid",
  "fromage",
  "frontal",
  "frotter",
  "fruit",
  "fugitif",
  "fuite",
  "fureur",
  "furieux",
  "furtif",
  "fusion",
  "futur",
  "gagner",
  "galaxie",
  "galerie",
  "gambader",
  "garantir",
  "gardien",
  "garnir",
  "garrigue",
  "gazelle",
  "gazon",
  "geant",
  "gelatine",
  "gelule",
  "gendarme",
  "general",
  "genie",
  "genou",
  "gentil",
  "geologie",
  "geometre",
  "geranium",
  "germe",
  "gestuel",
  "geyser",
  "gibier",
  "gicler",
  "girafe",
  "givre",
  "glace",
  "glaive",
  "glisser",
  "globe",
  "gloire",
  "glorieux",
  "golfeur",
  "gomme",
  "gonfler",
  "gorge",
  "gorille",
  "goudron",
  "gouffre",
  "goulot",
  "goupille",
  "gourmand",
  "goutte",
  "graduel",
  "graffiti",
  "graine",
  "grand",
  "grappin",
  "gratuit",
  "gravir",
  "grenat",
  "griffure",
  "griller",
  "grimper",
  "grogner",
  "gronder",
  "grotte",
  "groupe",
  "gruger",
  "grutier",
  "gruyere",
  "guepard",
  "guerrier",
  "guide",
  "guimauve",
  "guitare",
  "gustatif",
  "gymnaste",
  "gyrostat",
  "habitude",
  "hachoir",
  "halte",
  "hameau",
  "hangar",
  "hanneton",
  "haricot",
  "harmonie",
  "harpon",
  "hasard",
  "helium",
  "hematome",
  "herbe",
  "herisson",
  "hermine",
  "heron",
  "hesiter",
  "heureux",
  "hiberner",
  "hibou",
  "hilarant",
  "histoire",
  "hiver",
  "homard",
  "hommage",
  "homogene",
  "honneur",
  "honorer",
  "honteux",
  "horde",
  "horizon",
  "horloge",
  "hormone",
  "horrible",
  "houleux",
  "housse",
  "hublot",
  "huileux",
  "humain",
  "humble",
  "humide",
  "humour",
  "hurler",
  "hydromel",
  "hygiene",
  "hymne",
  "hypnose",
  "idylle",
  "ignorer",
  "iguane",
  "illicite",
  "illusion",
  "image",
  "imbiber",
  "imiter",
  "immense",
  "immobile",
  "immuable",
  "impact",
  "imperial",
  "implorer",
  "imposer",
  "imprimer",
  "imputer",
  "incarner",
  "incendie",
  "incident",
  "incliner",
  "incolore",
  "indexer",
  "indice",
  "inductif",
  "inedit",
  "ineptie",
  "inexact",
  "infini",
  "infliger",
  "informer",
  "infusion",
  "ingerer",
  "inhaler",
  "inhiber",
  "injecter",
  "injure",
  "innocent",
  "inoculer",
  "inonder",
  "inscrire",
  "insecte",
  "insigne",
  "insolite",
  "inspirer",
  "instinct",
  "insulter",
  "intact",
  "intense",
  "intime",
  "intrigue",
  "intuitif",
  "inutile",
  "invasion",
  "inventer",
  "inviter",
  "invoquer",
  "ironique",
  "irradier",
  "irreel",
  "irriter",
  "isoler",
  "ivoire",
  "ivresse",
  "jaguar",
  "jaillir",
  "jambe",
  "janvier",
  "jardin",
  "jauger",
  "jaune",
  "javelot",
  "jetable",
  "jeton",
  "jeudi",
  "jeunesse",
  "joindre",
  "joncher",
  "jongler",
  "joueur",
  "jouissif",
  "journal",
  "jovial",
  "joyau",
  "joyeux",
  "jubiler",
  "jugement",
  "junior",
  "jupon",
  "juriste",
  "justice",
  "juteux",
  "juvenile",
  "kayak",
  "kimono",
  "kiosque",
  "label",
  "labial",
  "labourer",
  "lacerer",
  "lactose",
  "lagune",
  "laine",
  "laisser",
  "laitier",
  "lambeau",
  "lamelle",
  "lampe",
  "lanceur",
  "langage",
  "lanterne",
  "lapin",
  "largeur",
  "larme",
  "laurier",
  "lavabo",
  "lavoir",
  "lecture",
  "legal",
  "leger",
  "legume",
  "lessive",
  "lettre",
  "levier",
  "lexique",
  "lezard",
  "liasse",
  "liberer",
  "libre",
  "licence",
  "licorne",
  "liege",
  "lievre",
  "ligature",
  "ligoter",
  "ligue",
  "limer",
  "limite",
  "limonade",
  "limpide",
  "lineaire",
  "lingot",
  "lionceau",
  "liquide",
  "lisiere",
  "lister",
  "lithium",
  "litige",
  "littoral",
  "livreur",
  "logique",
  "lointain",
  "loisir",
  "lombric",
  "loterie",
  "louer",
  "lourd",
  "loutre",
  "louve",
  "loyal",
  "lubie",
  "lucide",
  "lucratif",
  "lueur",
  "lugubre",
  "luisant",
  "lumiere",
  "lunaire",
  "lundi",
  "luron",
  "lutter",
  "luxueux",
  "machine",
  "magasin",
  "magenta",
  "magique",
  "maigre",
  "maillon",
  "maintien",
  "mairie",
  "maison",
  "majorer",
  "malaxer",
  "malefice",
  "malheur",
  "malice",
  "mallette",
  "mammouth",
  "mandater",
  "maniable",
  "manquant",
  "manteau",
  "manuel",
  "marathon",
  "marbre",
  "marchand",
  "mardi",
  "maritime",
  "marqueur",
  "marron",
  "marteler",
  "mascotte",
  "massif",
  "materiel",
  "matiere",
  "matraque",
  "maudire",
  "maussade",
  "mauve",
  "maximal",
  "mechant",
  "meconnu",
  "medaille",
  "medecin",
  "mediter",
  "meduse",
  "meilleur",
  "melange",
  "melodie",
  "membre",
  "memoire",
  "menacer",
  "mener",
  "menhir",
  "mensonge",
  "mentor",
  "mercredi",
  "merite",
  "merle",
  "messager",
  "mesure",
  "metal",
  "meteore",
  "methode",
  "metier",
  "meuble",
  "miauler",
  "microbe",
  "miette",
  "mignon",
  "migrer",
  "milieu",
  "million",
  "mimique",
  "mince",
  "mineral",
  "minimal",
  "minorer",
  "minute",
  "miracle",
  "miroiter",
  "missile",
  "mixte",
  "mobile",
  "moderne",
  "moelleux",
  "mondial",
  "moniteur",
  "monnaie",
  "monotone",
  "monstre",
  "montagne",
  "monument",
  "moqueur",
  "morceau",
  "morsure",
  "mortier",
  "moteur",
  "motif",
  "mouche",
  "moufle",
  "moulin",
  "mousson",
  "mouton",
  "mouvant",
  "multiple",
  "munition",
  "muraille",
  "murene",
  "murmure",
  "muscle",
  "museum",
  "musicien",
  "mutation",
  "muter",
  "mutuel",
  "myriade",
  "myrtille",
  "mystere",
  "mythique",
  "nageur",
  "nappe",
  "narquois",
  "narrer",
  "natation",
  "nation",
  "nature",
  "naufrage",
  "nautique",
  "navire",
  "nebuleux",
  "nectar",
  "nefaste",
  "negation",
  "negliger",
  "negocier",
  "neige",
  "nerveux",
  "nettoyer",
  "neurone",
  "neutron",
  "neveu",
  "niche",
  "nickel",
  "nitrate",
  "niveau",
  "noble",
  "nocif",
  "nocturne",
  "noirceur",
  "noisette",
  "nomade",
  "nombreux",
  "nommer",
  "normatif",
  "notable",
  "notifier",
  "notoire",
  "nourrir",
  "nouveau",
  "novateur",
  "novembre",
  "novice",
  "nuage",
  "nuancer",
  "nuire",
  "nuisible",
  "numero",
  "nuptial",
  "nuque",
  "nutritif",
  "obeir",
  "objectif",
  "obliger",
  "obscur",
  "observer",
  "obstacle",
  "obtenir",
  "obturer",
  "occasion",
  "occuper",
  "ocean",
  "octobre",
  "octroyer",
  "octupler",
  "oculaire",
  "odeur",
  "odorant",
  "offenser",
  "officier",
  "offrir",
  "ogive",
  "oiseau",
  "oisillon",
  "olfactif",
  "olivier",
  "ombrage",
  "omettre",
  "onctueux",
  "onduler",
  "onereux",
  "onirique",
  "opale",
  "opaque",
  "operer",
  "opinion",
  "opportun",
  "opprimer",
  "opter",
  "optique",
  "orageux",
  "orange",
  "orbite",
  "ordonner",
  "oreille",
  "organe",
  "orgueil",
  "orifice",
  "ornement",
  "orque",
  "ortie",
  "osciller",
  "osmose",
  "ossature",
  "otarie",
  "ouragan",
  "ourson",
  "outil",
  "outrager",
  "ouvrage",
  "ovation",
  "oxyde",
  "oxygene",
  "ozone",
  "paisible",
  "palace",
  "palmares",
  "palourde",
  "palper",
  "panache",
  "panda",
  "pangolin",
  "paniquer",
  "panneau",
  "panorama",
  "pantalon",
  "papaye",
  "papier",
  "papoter",
  "papyrus",
  "paradoxe",
  "parcelle",
  "paresse",
  "parfumer",
  "parler",
  "parole",
  "parrain",
  "parsemer",
  "partager",
  "parure",
  "parvenir",
  "passion",
  "pasteque",
  "paternel",
  "patience",
  "patron",
  "pavillon",
  "pavoiser",
  "payer",
  "paysage",
  "peigne",
  "peintre",
  "pelage",
  "pelican",
  "pelle",
  "pelouse",
  "peluche",
  "pendule",
  "penetrer",
  "penible",
  "pensif",
  "penurie",
  "pepite",
  "peplum",
  "perdrix",
  "perforer",
  "periode",
  "permuter",
  "perplexe",
  "persil",
  "perte",
  "peser",
  "petale",
  "petit",
  "petrir",
  "peuple",
  "pharaon",
  "phobie",
  "phoque",
  "photon",
  "phrase",
  "physique",
  "piano",
  "pictural",
  "piece",
  "pierre",
  "pieuvre",
  "pilote",
  "pinceau",
  "pipette",
  "piquer",
  "pirogue",
  "piscine",
  "piston",
  "pivoter",
  "pixel",
  "pizza",
  "placard",
  "plafond",
  "plaisir",
  "planer",
  "plaque",
  "plastron",
  "plateau",
  "pleurer",
  "plexus",
  "pliage",
  "plomb",
  "plonger",
  "pluie",
  "plumage",
  "pochette",
  "poesie",
  "poete",
  "pointe",
  "poirier",
  "poisson",
  "poivre",
  "polaire",
  "policier",
  "pollen",
  "polygone",
  "pommade",
  "pompier",
  "ponctuel",
  "ponderer",
  "poney",
  "portique",
  "position",
  "posseder",
  "posture",
  "potager",
  "poteau",
  "potion",
  "pouce",
  "poulain",
  "poumon",
  "pourpre",
  "poussin",
  "pouvoir",
  "prairie",
  "pratique",
  "precieux",
  "predire",
  "prefixe",
  "prelude",
  "prenom",
  "presence",
  "pretexte",
  "prevoir",
  "primitif",
  "prince",
  "prison",
  "priver",
  "probleme",
  "proceder",
  "prodige",
  "profond",
  "progres",
  "proie",
  "projeter",
  "prologue",
  "promener",
  "propre",
  "prospere",
  "proteger",
  "prouesse",
  "proverbe",
  "prudence",
  "pruneau",
  "psychose",
  "public",
  "puceron",
  "puiser",
  "pulpe",
  "pulsar",
  "punaise",
  "punitif",
  "pupitre",
  "purifier",
  "puzzle",
  "pyramide",
  "quasar",
  "querelle",
  "question",
  "quietude",
  "quitter",
  "quotient",
  "racine",
  "raconter",
  "radieux",
  "ragondin",
  "raideur",
  "raisin",
  "ralentir",
  "rallonge",
  "ramasser",
  "rapide",
  "rasage",
  "ratisser",
  "ravager",
  "ravin",
  "rayonner",
  "reactif",
  "reagir",
  "realiser",
  "reanimer",
  "recevoir",
  "reciter",
  "reclamer",
  "recolter",
  "recruter",
  "reculer",
  "recycler",
  "rediger",
  "redouter",
  "refaire",
  "reflexe",
  "reformer",
  "refrain",
  "refuge",
  "regalien",
  "region",
  "reglage",
  "regulier",
  "reiterer",
  "rejeter",
  "rejouer",
  "relatif",
  "relever",
  "relief",
  "remarque",
  "remede",
  "remise",
  "remonter",
  "remplir",
  "remuer",
  "renard",
  "renfort",
  "renifler",
  "renoncer",
  "rentrer",
  "renvoi",
  "replier",
  "reporter",
  "reprise",
  "reptile",
  "requin",
  "reserve",
  "resineux",
  "resoudre",
  "respect",
  "rester",
  "resultat",
  "retablir",
  "retenir",
  "reticule",
  "retomber",
  "retracer",
  "reunion",
  "reussir",
  "revanche",
  "revivre",
  "revolte",
  "revulsif",
  "richesse",
  "rideau",
  "rieur",
  "rigide",
  "rigoler",
  "rincer",
  "riposter",
  "risible",
  "risque",
  "rituel",
  "rival",
  "riviere",
  "rocheux",
  "romance",
  "rompre",
  "ronce",
  "rondin",
  "roseau",
  "rosier",
  "rotatif",
  "rotor",
  "rotule",
  "rouge",
  "rouille",
  "rouleau",
  "routine",
  "royaume",
  "ruban",
  "rubis",
  "ruche",
  "ruelle",
  "rugueux",
  "ruiner",
  "ruisseau",
  "ruser",
  "rustique",
  "rythme",
  "sabler",
  "saboter",
  "sabre",
  "sacoche",
  "safari",
  "sagesse",
  "saisir",
  "salade",
  "salive",
  "salon",
  "saluer",
  "samedi",
  "sanction",
  "sanglier",
  "sarcasme",
  "sardine",
  "saturer",
  "saugrenu",
  "saumon",
  "sauter",
  "sauvage",
  "savant",
  "savonner",
  "scalpel",
  "scandale",
  "scelerat",
  "scenario",
  "sceptre",
  "schema",
  "science",
  "scinder",
  "score",
  "scrutin",
  "sculpter",
  "seance",
  "secable",
  "secher",
  "secouer",
  "secreter",
  "sedatif",
  "seduire",
  "seigneur",
  "sejour",
  "selectif",
  "semaine",
  "sembler",
  "semence",
  "seminal",
  "senateur",
  "sensible",
  "sentence",
  "separer",
  "sequence",
  "serein",
  "sergent",
  "serieux",
  "serrure",
  "serum",
  "service",
  "sesame",
  "sevir",
  "sevrage",
  "sextuple",
  "sideral",
  "siecle",
  "sieger",
  "siffler",
  "sigle",
  "signal",
  "silence",
  "silicium",
  "simple",
  "sincere",
  "sinistre",
  "siphon",
  "sirop",
  "sismique",
  "situer",
  "skier",
  "social",
  "socle",
  "sodium",
  "soigneux",
  "soldat",
  "soleil",
  "solitude",
  "soluble",
  "sombre",
  "sommeil",
  "somnoler",
  "sonde",
  "songeur",
  "sonnette",
  "sonore",
  "sorcier",
  "sortir",
  "sosie",
  "sottise",
  "soucieux",
  "soudure",
  "souffle",
  "soulever",
  "soupape",
  "source",
  "soutirer",
  "souvenir",
  "spacieux",
  "spatial",
  "special",
  "sphere",
  "spiral",
  "stable",
  "station",
  "sternum",
  "stimulus",
  "stipuler",
  "strict",
  "studieux",
  "stupeur",
  "styliste",
  "sublime",
  "substrat",
  "subtil",
  "subvenir",
  "succes",
  "sucre",
  "suffixe",
  "suggerer",
  "suiveur",
  "sulfate",
  "superbe",
  "supplier",
  "surface",
  "suricate",
  "surmener",
  "surprise",
  "sursaut",
  "survie",
  "suspect",
  "syllabe",
  "symbole",
  "symetrie",
  "synapse",
  "syntaxe",
  "systeme",
  "tabac",
  "tablier",
  "tactile",
  "tailler",
  "talent",
  "talisman",
  "talonner",
  "tambour",
  "tamiser",
  "tangible",
  "tapis",
  "taquiner",
  "tarder",
  "tarif",
  "tartine",
  "tasse",
  "tatami",
  "tatouage",
  "taupe",
  "taureau",
  "taxer",
  "temoin",
  "temporel",
  "tenaille",
  "tendre",
  "teneur",
  "tenir",
  "tension",
  "terminer",
  "terne",
  "terrible",
  "tetine",
  "texte",
  "theme",
  "theorie",
  "therapie",
  "thorax",
  "tibia",
  "tiede",
  "timide",
  "tirelire",
  "tiroir",
  "tissu",
  "titane",
  "titre",
  "tituber",
  "toboggan",
  "tolerant",
  "tomate",
  "tonique",
  "tonneau",
  "toponyme",
  "torche",
  "tordre",
  "tornade",
  "torpille",
  "torrent",
  "torse",
  "tortue",
  "totem",
  "toucher",
  "tournage",
  "tousser",
  "toxine",
  "traction",
  "trafic",
  "tragique",
  "trahir",
  "train",
  "trancher",
  "travail",
  "trefle",
  "tremper",
  "tresor",
  "treuil",
  "triage",
  "tribunal",
  "tricoter",
  "trilogie",
  "triomphe",
  "tripler",
  "triturer",
  "trivial",
  "trombone",
  "tronc",
  "tropical",
  "troupeau",
  "tuile",
  "tulipe",
  "tumulte",
  "tunnel",
  "turbine",
  "tuteur",
  "tutoyer",
  "tuyau",
  "tympan",
  "typhon",
  "typique",
  "tyran",
  "ubuesque",
  "ultime",
  "ultrason",
  "unanime",
  "unifier",
  "union",
  "unique",
  "unitaire",
  "univers",
  "uranium",
  "urbain",
  "urticant",
  "usage",
  "usine",
  "usuel",
  "usure",
  "utile",
  "utopie",
  "vacarme",
  "vaccin",
  "vagabond",
  "vague",
  "vaillant",
  "vaincre",
  "vaisseau",
  "valable",
  "valise",
  "vallon",
  "valve",
  "vampire",
  "vanille",
  "vapeur",
  "varier",
  "vaseux",
  "vassal",
  "vaste",
  "vecteur",
  "vedette",
  "vegetal",
  "vehicule",
  "veinard",
  "veloce",
  "vendredi",
  "venerer",
  "venger",
  "venimeux",
  "ventouse",
  "verdure",
  "verin",
  "vernir",
  "verrou",
  "verser",
  "vertu",
  "veston",
  "veteran",
  "vetuste",
  "vexant",
  "vexer",
  "viaduc",
  "viande",
  "victoire",
  "vidange",
  "video",
  "vignette",
  "vigueur",
  "vilain",
  "village",
  "vinaigre",
  "violon",
  "vipere",
  "virement",
  "virtuose",
  "virus",
  "visage",
  "viseur",
  "vision",
  "visqueux",
  "visuel",
  "vital",
  "vitesse",
  "viticole",
  "vitrine",
  "vivace",
  "vivipare",
  "vocation",
  "voguer",
  "voile",
  "voisin",
  "voiture",
  "volaille",
  "volcan",
  "voltiger",
  "volume",
  "vorace",
  "vortex",
  "voter",
  "vouloir",
  "voyage",
  "voyelle",
  "wagon",
  "xenon",
  "yacht",
  "zebre",
  "zenith",
  "zeste",
  "zoologie"
];
var c1e = [
  "abaco",
  "abbaglio",
  "abbinato",
  "abete",
  "abisso",
  "abolire",
  "abrasivo",
  "abrogato",
  "accadere",
  "accenno",
  "accusato",
  "acetone",
  "achille",
  "acido",
  "acqua",
  "acre",
  "acrilico",
  "acrobata",
  "acuto",
  "adagio",
  "addebito",
  "addome",
  "adeguato",
  "aderire",
  "adipe",
  "adottare",
  "adulare",
  "affabile",
  "affetto",
  "affisso",
  "affranto",
  "aforisma",
  "afoso",
  "africano",
  "agave",
  "agente",
  "agevole",
  "aggancio",
  "agire",
  "agitare",
  "agonismo",
  "agricolo",
  "agrumeto",
  "aguzzo",
  "alabarda",
  "alato",
  "albatro",
  "alberato",
  "albo",
  "albume",
  "alce",
  "alcolico",
  "alettone",
  "alfa",
  "algebra",
  "aliante",
  "alibi",
  "alimento",
  "allagato",
  "allegro",
  "allievo",
  "allodola",
  "allusivo",
  "almeno",
  "alogeno",
  "alpaca",
  "alpestre",
  "altalena",
  "alterno",
  "alticcio",
  "altrove",
  "alunno",
  "alveolo",
  "alzare",
  "amalgama",
  "amanita",
  "amarena",
  "ambito",
  "ambrato",
  "ameba",
  "america",
  "ametista",
  "amico",
  "ammasso",
  "ammenda",
  "ammirare",
  "ammonito",
  "amore",
  "ampio",
  "ampliare",
  "amuleto",
  "anacardo",
  "anagrafe",
  "analista",
  "anarchia",
  "anatra",
  "anca",
  "ancella",
  "ancora",
  "andare",
  "andrea",
  "anello",
  "angelo",
  "angolare",
  "angusto",
  "anima",
  "annegare",
  "annidato",
  "anno",
  "annuncio",
  "anonimo",
  "anticipo",
  "anzi",
  "apatico",
  "apertura",
  "apode",
  "apparire",
  "appetito",
  "appoggio",
  "approdo",
  "appunto",
  "aprile",
  "arabica",
  "arachide",
  "aragosta",
  "araldica",
  "arancio",
  "aratura",
  "arazzo",
  "arbitro",
  "archivio",
  "ardito",
  "arenile",
  "argento",
  "argine",
  "arguto",
  "aria",
  "armonia",
  "arnese",
  "arredato",
  "arringa",
  "arrosto",
  "arsenico",
  "arso",
  "artefice",
  "arzillo",
  "asciutto",
  "ascolto",
  "asepsi",
  "asettico",
  "asfalto",
  "asino",
  "asola",
  "aspirato",
  "aspro",
  "assaggio",
  "asse",
  "assoluto",
  "assurdo",
  "asta",
  "astenuto",
  "astice",
  "astratto",
  "atavico",
  "ateismo",
  "atomico",
  "atono",
  "attesa",
  "attivare",
  "attorno",
  "attrito",
  "attuale",
  "ausilio",
  "austria",
  "autista",
  "autonomo",
  "autunno",
  "avanzato",
  "avere",
  "avvenire",
  "avviso",
  "avvolgere",
  "azione",
  "azoto",
  "azzimo",
  "azzurro",
  "babele",
  "baccano",
  "bacino",
  "baco",
  "badessa",
  "badilata",
  "bagnato",
  "baita",
  "balcone",
  "baldo",
  "balena",
  "ballata",
  "balzano",
  "bambino",
  "bandire",
  "baraonda",
  "barbaro",
  "barca",
  "baritono",
  "barlume",
  "barocco",
  "basilico",
  "basso",
  "batosta",
  "battuto",
  "baule",
  "bava",
  "bavosa",
  "becco",
  "beffa",
  "belgio",
  "belva",
  "benda",
  "benevole",
  "benigno",
  "benzina",
  "bere",
  "berlina",
  "beta",
  "bibita",
  "bici",
  "bidone",
  "bifido",
  "biga",
  "bilancia",
  "bimbo",
  "binocolo",
  "biologo",
  "bipede",
  "bipolare",
  "birbante",
  "birra",
  "biscotto",
  "bisesto",
  "bisnonno",
  "bisonte",
  "bisturi",
  "bizzarro",
  "blando",
  "blatta",
  "bollito",
  "bonifico",
  "bordo",
  "bosco",
  "botanico",
  "bottino",
  "bozzolo",
  "braccio",
  "bradipo",
  "brama",
  "branca",
  "bravura",
  "bretella",
  "brevetto",
  "brezza",
  "briglia",
  "brillante",
  "brindare",
  "broccolo",
  "brodo",
  "bronzina",
  "brullo",
  "bruno",
  "bubbone",
  "buca",
  "budino",
  "buffone",
  "buio",
  "bulbo",
  "buono",
  "burlone",
  "burrasca",
  "bussola",
  "busta",
  "cadetto",
  "caduco",
  "calamaro",
  "calcolo",
  "calesse",
  "calibro",
  "calmo",
  "caloria",
  "cambusa",
  "camerata",
  "camicia",
  "cammino",
  "camola",
  "campale",
  "canapa",
  "candela",
  "cane",
  "canino",
  "canotto",
  "cantina",
  "capace",
  "capello",
  "capitolo",
  "capogiro",
  "cappero",
  "capra",
  "capsula",
  "carapace",
  "carcassa",
  "cardo",
  "carisma",
  "carovana",
  "carretto",
  "cartolina",
  "casaccio",
  "cascata",
  "caserma",
  "caso",
  "cassone",
  "castello",
  "casuale",
  "catasta",
  "catena",
  "catrame",
  "cauto",
  "cavillo",
  "cedibile",
  "cedrata",
  "cefalo",
  "celebre",
  "cellulare",
  "cena",
  "cenone",
  "centesimo",
  "ceramica",
  "cercare",
  "certo",
  "cerume",
  "cervello",
  "cesoia",
  "cespo",
  "ceto",
  "chela",
  "chiaro",
  "chicca",
  "chiedere",
  "chimera",
  "china",
  "chirurgo",
  "chitarra",
  "ciao",
  "ciclismo",
  "cifrare",
  "cigno",
  "cilindro",
  "ciottolo",
  "circa",
  "cirrosi",
  "citrico",
  "cittadino",
  "ciuffo",
  "civetta",
  "civile",
  "classico",
  "clinica",
  "cloro",
  "cocco",
  "codardo",
  "codice",
  "coerente",
  "cognome",
  "collare",
  "colmato",
  "colore",
  "colposo",
  "coltivato",
  "colza",
  "coma",
  "cometa",
  "commando",
  "comodo",
  "computer",
  "comune",
  "conciso",
  "condurre",
  "conferma",
  "congelare",
  "coniuge",
  "connesso",
  "conoscere",
  "consumo",
  "continuo",
  "convegno",
  "coperto",
  "copione",
  "coppia",
  "copricapo",
  "corazza",
  "cordata",
  "coricato",
  "cornice",
  "corolla",
  "corpo",
  "corredo",
  "corsia",
  "cortese",
  "cosmico",
  "costante",
  "cottura",
  "covato",
  "cratere",
  "cravatta",
  "creato",
  "credere",
  "cremoso",
  "crescita",
  "creta",
  "criceto",
  "crinale",
  "crisi",
  "critico",
  "croce",
  "cronaca",
  "crostata",
  "cruciale",
  "crusca",
  "cucire",
  "cuculo",
  "cugino",
  "cullato",
  "cupola",
  "curatore",
  "cursore",
  "curvo",
  "cuscino",
  "custode",
  "dado",
  "daino",
  "dalmata",
  "damerino",
  "daniela",
  "dannoso",
  "danzare",
  "datato",
  "davanti",
  "davvero",
  "debutto",
  "decennio",
  "deciso",
  "declino",
  "decollo",
  "decreto",
  "dedicato",
  "definito",
  "deforme",
  "degno",
  "delegare",
  "delfino",
  "delirio",
  "delta",
  "demenza",
  "denotato",
  "dentro",
  "deposito",
  "derapata",
  "derivare",
  "deroga",
  "descritto",
  "deserto",
  "desiderio",
  "desumere",
  "detersivo",
  "devoto",
  "diametro",
  "dicembre",
  "diedro",
  "difeso",
  "diffuso",
  "digerire",
  "digitale",
  "diluvio",
  "dinamico",
  "dinnanzi",
  "dipinto",
  "diploma",
  "dipolo",
  "diradare",
  "dire",
  "dirotto",
  "dirupo",
  "disagio",
  "discreto",
  "disfare",
  "disgelo",
  "disposto",
  "distanza",
  "disumano",
  "dito",
  "divano",
  "divelto",
  "dividere",
  "divorato",
  "doblone",
  "docente",
  "doganale",
  "dogma",
  "dolce",
  "domato",
  "domenica",
  "dominare",
  "dondolo",
  "dono",
  "dormire",
  "dote",
  "dottore",
  "dovuto",
  "dozzina",
  "drago",
  "druido",
  "dubbio",
  "dubitare",
  "ducale",
  "duna",
  "duomo",
  "duplice",
  "duraturo",
  "ebano",
  "eccesso",
  "ecco",
  "eclissi",
  "economia",
  "edera",
  "edicola",
  "edile",
  "editoria",
  "educare",
  "egemonia",
  "egli",
  "egoismo",
  "egregio",
  "elaborato",
  "elargire",
  "elegante",
  "elencato",
  "eletto",
  "elevare",
  "elfico",
  "elica",
  "elmo",
  "elsa",
  "eluso",
  "emanato",
  "emblema",
  "emesso",
  "emiro",
  "emotivo",
  "emozione",
  "empirico",
  "emulo",
  "endemico",
  "enduro",
  "energia",
  "enfasi",
  "enoteca",
  "entrare",
  "enzima",
  "epatite",
  "epilogo",
  "episodio",
  "epocale",
  "eppure",
  "equatore",
  "erario",
  "erba",
  "erboso",
  "erede",
  "eremita",
  "erigere",
  "ermetico",
  "eroe",
  "erosivo",
  "errante",
  "esagono",
  "esame",
  "esanime",
  "esaudire",
  "esca",
  "esempio",
  "esercito",
  "esibito",
  "esigente",
  "esistere",
  "esito",
  "esofago",
  "esortato",
  "esoso",
  "espanso",
  "espresso",
  "essenza",
  "esso",
  "esteso",
  "estimare",
  "estonia",
  "estroso",
  "esultare",
  "etilico",
  "etnico",
  "etrusco",
  "etto",
  "euclideo",
  "europa",
  "evaso",
  "evidenza",
  "evitato",
  "evoluto",
  "evviva",
  "fabbrica",
  "faccenda",
  "fachiro",
  "falco",
  "famiglia",
  "fanale",
  "fanfara",
  "fango",
  "fantasma",
  "fare",
  "farfalla",
  "farinoso",
  "farmaco",
  "fascia",
  "fastoso",
  "fasullo",
  "faticare",
  "fato",
  "favoloso",
  "febbre",
  "fecola",
  "fede",
  "fegato",
  "felpa",
  "feltro",
  "femmina",
  "fendere",
  "fenomeno",
  "fermento",
  "ferro",
  "fertile",
  "fessura",
  "festivo",
  "fetta",
  "feudo",
  "fiaba",
  "fiducia",
  "fifa",
  "figurato",
  "filo",
  "finanza",
  "finestra",
  "finire",
  "fiore",
  "fiscale",
  "fisico",
  "fiume",
  "flacone",
  "flamenco",
  "flebo",
  "flemma",
  "florido",
  "fluente",
  "fluoro",
  "fobico",
  "focaccia",
  "focoso",
  "foderato",
  "foglio",
  "folata",
  "folclore",
  "folgore",
  "fondente",
  "fonetico",
  "fonia",
  "fontana",
  "forbito",
  "forchetta",
  "foresta",
  "formica",
  "fornaio",
  "foro",
  "fortezza",
  "forzare",
  "fosfato",
  "fosso",
  "fracasso",
  "frana",
  "frassino",
  "fratello",
  "freccetta",
  "frenata",
  "fresco",
  "frigo",
  "frollino",
  "fronde",
  "frugale",
  "frutta",
  "fucilata",
  "fucsia",
  "fuggente",
  "fulmine",
  "fulvo",
  "fumante",
  "fumetto",
  "fumoso",
  "fune",
  "funzione",
  "fuoco",
  "furbo",
  "furgone",
  "furore",
  "fuso",
  "futile",
  "gabbiano",
  "gaffe",
  "galateo",
  "gallina",
  "galoppo",
  "gambero",
  "gamma",
  "garanzia",
  "garbo",
  "garofano",
  "garzone",
  "gasdotto",
  "gasolio",
  "gastrico",
  "gatto",
  "gaudio",
  "gazebo",
  "gazzella",
  "geco",
  "gelatina",
  "gelso",
  "gemello",
  "gemmato",
  "gene",
  "genitore",
  "gennaio",
  "genotipo",
  "gergo",
  "ghepardo",
  "ghiaccio",
  "ghisa",
  "giallo",
  "gilda",
  "ginepro",
  "giocare",
  "gioiello",
  "giorno",
  "giove",
  "girato",
  "girone",
  "gittata",
  "giudizio",
  "giurato",
  "giusto",
  "globulo",
  "glutine",
  "gnomo",
  "gobba",
  "golf",
  "gomito",
  "gommone",
  "gonfio",
  "gonna",
  "governo",
  "gracile",
  "grado",
  "grafico",
  "grammo",
  "grande",
  "grattare",
  "gravoso",
  "grazia",
  "greca",
  "gregge",
  "grifone",
  "grigio",
  "grinza",
  "grotta",
  "gruppo",
  "guadagno",
  "guaio",
  "guanto",
  "guardare",
  "gufo",
  "guidare",
  "ibernato",
  "icona",
  "identico",
  "idillio",
  "idolo",
  "idra",
  "idrico",
  "idrogeno",
  "igiene",
  "ignaro",
  "ignorato",
  "ilare",
  "illeso",
  "illogico",
  "illudere",
  "imballo",
  "imbevuto",
  "imbocco",
  "imbuto",
  "immane",
  "immerso",
  "immolato",
  "impacco",
  "impeto",
  "impiego",
  "importo",
  "impronta",
  "inalare",
  "inarcare",
  "inattivo",
  "incanto",
  "incendio",
  "inchino",
  "incisivo",
  "incluso",
  "incontro",
  "incrocio",
  "incubo",
  "indagine",
  "india",
  "indole",
  "inedito",
  "infatti",
  "infilare",
  "inflitto",
  "ingaggio",
  "ingegno",
  "inglese",
  "ingordo",
  "ingrosso",
  "innesco",
  "inodore",
  "inoltrare",
  "inondato",
  "insano",
  "insetto",
  "insieme",
  "insonnia",
  "insulina",
  "intasato",
  "intero",
  "intonaco",
  "intuito",
  "inumidire",
  "invalido",
  "invece",
  "invito",
  "iperbole",
  "ipnotico",
  "ipotesi",
  "ippica",
  "iride",
  "irlanda",
  "ironico",
  "irrigato",
  "irrorare",
  "isolato",
  "isotopo",
  "isterico",
  "istituto",
  "istrice",
  "italia",
  "iterare",
  "labbro",
  "labirinto",
  "lacca",
  "lacerato",
  "lacrima",
  "lacuna",
  "laddove",
  "lago",
  "lampo",
  "lancetta",
  "lanterna",
  "lardoso",
  "larga",
  "laringe",
  "lastra",
  "latenza",
  "latino",
  "lattuga",
  "lavagna",
  "lavoro",
  "legale",
  "leggero",
  "lembo",
  "lentezza",
  "lenza",
  "leone",
  "lepre",
  "lesivo",
  "lessato",
  "lesto",
  "letterale",
  "leva",
  "levigato",
  "libero",
  "lido",
  "lievito",
  "lilla",
  "limatura",
  "limitare",
  "limpido",
  "lineare",
  "lingua",
  "liquido",
  "lira",
  "lirica",
  "lisca",
  "lite",
  "litigio",
  "livrea",
  "locanda",
  "lode",
  "logica",
  "lombare",
  "londra",
  "longevo",
  "loquace",
  "lorenzo",
  "loto",
  "lotteria",
  "luce",
  "lucidato",
  "lumaca",
  "luminoso",
  "lungo",
  "lupo",
  "luppolo",
  "lusinga",
  "lusso",
  "lutto",
  "macabro",
  "macchina",
  "macero",
  "macinato",
  "madama",
  "magico",
  "maglia",
  "magnete",
  "magro",
  "maiolica",
  "malafede",
  "malgrado",
  "malinteso",
  "malsano",
  "malto",
  "malumore",
  "mana",
  "mancia",
  "mandorla",
  "mangiare",
  "manifesto",
  "mannaro",
  "manovra",
  "mansarda",
  "mantide",
  "manubrio",
  "mappa",
  "maratona",
  "marcire",
  "maretta",
  "marmo",
  "marsupio",
  "maschera",
  "massaia",
  "mastino",
  "materasso",
  "matricola",
  "mattone",
  "maturo",
  "mazurca",
  "meandro",
  "meccanico",
  "mecenate",
  "medesimo",
  "meditare",
  "mega",
  "melassa",
  "melis",
  "melodia",
  "meninge",
  "meno",
  "mensola",
  "mercurio",
  "merenda",
  "merlo",
  "meschino",
  "mese",
  "messere",
  "mestolo",
  "metallo",
  "metodo",
  "mettere",
  "miagolare",
  "mica",
  "micelio",
  "michele",
  "microbo",
  "midollo",
  "miele",
  "migliore",
  "milano",
  "milite",
  "mimosa",
  "minerale",
  "mini",
  "minore",
  "mirino",
  "mirtillo",
  "miscela",
  "missiva",
  "misto",
  "misurare",
  "mitezza",
  "mitigare",
  "mitra",
  "mittente",
  "mnemonico",
  "modello",
  "modifica",
  "modulo",
  "mogano",
  "mogio",
  "mole",
  "molosso",
  "monastero",
  "monco",
  "mondina",
  "monetario",
  "monile",
  "monotono",
  "monsone",
  "montato",
  "monviso",
  "mora",
  "mordere",
  "morsicato",
  "mostro",
  "motivato",
  "motosega",
  "motto",
  "movenza",
  "movimento",
  "mozzo",
  "mucca",
  "mucosa",
  "muffa",
  "mughetto",
  "mugnaio",
  "mulatto",
  "mulinello",
  "multiplo",
  "mummia",
  "munto",
  "muovere",
  "murale",
  "musa",
  "muscolo",
  "musica",
  "mutevole",
  "muto",
  "nababbo",
  "nafta",
  "nanometro",
  "narciso",
  "narice",
  "narrato",
  "nascere",
  "nastrare",
  "naturale",
  "nautica",
  "naviglio",
  "nebulosa",
  "necrosi",
  "negativo",
  "negozio",
  "nemmeno",
  "neofita",
  "neretto",
  "nervo",
  "nessuno",
  "nettuno",
  "neutrale",
  "neve",
  "nevrotico",
  "nicchia",
  "ninfa",
  "nitido",
  "nobile",
  "nocivo",
  "nodo",
  "nome",
  "nomina",
  "nordico",
  "normale",
  "norvegese",
  "nostrano",
  "notare",
  "notizia",
  "notturno",
  "novella",
  "nucleo",
  "nulla",
  "numero",
  "nuovo",
  "nutrire",
  "nuvola",
  "nuziale",
  "oasi",
  "obbedire",
  "obbligo",
  "obelisco",
  "oblio",
  "obolo",
  "obsoleto",
  "occasione",
  "occhio",
  "occidente",
  "occorrere",
  "occultare",
  "ocra",
  "oculato",
  "odierno",
  "odorare",
  "offerta",
  "offrire",
  "offuscato",
  "oggetto",
  "oggi",
  "ognuno",
  "olandese",
  "olfatto",
  "oliato",
  "oliva",
  "ologramma",
  "oltre",
  "omaggio",
  "ombelico",
  "ombra",
  "omega",
  "omissione",
  "ondoso",
  "onere",
  "onice",
  "onnivoro",
  "onorevole",
  "onta",
  "operato",
  "opinione",
  "opposto",
  "oracolo",
  "orafo",
  "ordine",
  "orecchino",
  "orefice",
  "orfano",
  "organico",
  "origine",
  "orizzonte",
  "orma",
  "ormeggio",
  "ornativo",
  "orologio",
  "orrendo",
  "orribile",
  "ortensia",
  "ortica",
  "orzata",
  "orzo",
  "osare",
  "oscurare",
  "osmosi",
  "ospedale",
  "ospite",
  "ossa",
  "ossidare",
  "ostacolo",
  "oste",
  "otite",
  "otre",
  "ottagono",
  "ottimo",
  "ottobre",
  "ovale",
  "ovest",
  "ovino",
  "oviparo",
  "ovocito",
  "ovunque",
  "ovviare",
  "ozio",
  "pacchetto",
  "pace",
  "pacifico",
  "padella",
  "padrone",
  "paese",
  "paga",
  "pagina",
  "palazzina",
  "palesare",
  "pallido",
  "palo",
  "palude",
  "pandoro",
  "pannello",
  "paolo",
  "paonazzo",
  "paprica",
  "parabola",
  "parcella",
  "parere",
  "pargolo",
  "pari",
  "parlato",
  "parola",
  "partire",
  "parvenza",
  "parziale",
  "passivo",
  "pasticca",
  "patacca",
  "patologia",
  "pattume",
  "pavone",
  "peccato",
  "pedalare",
  "pedonale",
  "peggio",
  "peloso",
  "penare",
  "pendice",
  "penisola",
  "pennuto",
  "penombra",
  "pensare",
  "pentola",
  "pepe",
  "pepita",
  "perbene",
  "percorso",
  "perdonato",
  "perforare",
  "pergamena",
  "periodo",
  "permesso",
  "perno",
  "perplesso",
  "persuaso",
  "pertugio",
  "pervaso",
  "pesatore",
  "pesista",
  "peso",
  "pestifero",
  "petalo",
  "pettine",
  "petulante",
  "pezzo",
  "piacere",
  "pianta",
  "piattino",
  "piccino",
  "picozza",
  "piega",
  "pietra",
  "piffero",
  "pigiama",
  "pigolio",
  "pigro",
  "pila",
  "pilifero",
  "pillola",
  "pilota",
  "pimpante",
  "pineta",
  "pinna",
  "pinolo",
  "pioggia",
  "piombo",
  "piramide",
  "piretico",
  "pirite",
  "pirolisi",
  "pitone",
  "pizzico",
  "placebo",
  "planare",
  "plasma",
  "platano",
  "plenario",
  "pochezza",
  "poderoso",
  "podismo",
  "poesia",
  "poggiare",
  "polenta",
  "poligono",
  "pollice",
  "polmonite",
  "polpetta",
  "polso",
  "poltrona",
  "polvere",
  "pomice",
  "pomodoro",
  "ponte",
  "popoloso",
  "porfido",
  "poroso",
  "porpora",
  "porre",
  "portata",
  "posa",
  "positivo",
  "possesso",
  "postulato",
  "potassio",
  "potere",
  "pranzo",
  "prassi",
  "pratica",
  "precluso",
  "predica",
  "prefisso",
  "pregiato",
  "prelievo",
  "premere",
  "prenotare",
  "preparato",
  "presenza",
  "pretesto",
  "prevalso",
  "prima",
  "principe",
  "privato",
  "problema",
  "procura",
  "produrre",
  "profumo",
  "progetto",
  "prolunga",
  "promessa",
  "pronome",
  "proposta",
  "proroga",
  "proteso",
  "prova",
  "prudente",
  "prugna",
  "prurito",
  "psiche",
  "pubblico",
  "pudica",
  "pugilato",
  "pugno",
  "pulce",
  "pulito",
  "pulsante",
  "puntare",
  "pupazzo",
  "pupilla",
  "puro",
  "quadro",
  "qualcosa",
  "quasi",
  "querela",
  "quota",
  "raccolto",
  "raddoppio",
  "radicale",
  "radunato",
  "raffica",
  "ragazzo",
  "ragione",
  "ragno",
  "ramarro",
  "ramingo",
  "ramo",
  "randagio",
  "rantolare",
  "rapato",
  "rapina",
  "rappreso",
  "rasatura",
  "raschiato",
  "rasente",
  "rassegna",
  "rastrello",
  "rata",
  "ravveduto",
  "reale",
  "recepire",
  "recinto",
  "recluta",
  "recondito",
  "recupero",
  "reddito",
  "redimere",
  "regalato",
  "registro",
  "regola",
  "regresso",
  "relazione",
  "remare",
  "remoto",
  "renna",
  "replica",
  "reprimere",
  "reputare",
  "resa",
  "residente",
  "responso",
  "restauro",
  "rete",
  "retina",
  "retorica",
  "rettifica",
  "revocato",
  "riassunto",
  "ribadire",
  "ribelle",
  "ribrezzo",
  "ricarica",
  "ricco",
  "ricevere",
  "riciclato",
  "ricordo",
  "ricreduto",
  "ridicolo",
  "ridurre",
  "rifasare",
  "riflesso",
  "riforma",
  "rifugio",
  "rigare",
  "rigettato",
  "righello",
  "rilassato",
  "rilevato",
  "rimanere",
  "rimbalzo",
  "rimedio",
  "rimorchio",
  "rinascita",
  "rincaro",
  "rinforzo",
  "rinnovo",
  "rinomato",
  "rinsavito",
  "rintocco",
  "rinuncia",
  "rinvenire",
  "riparato",
  "ripetuto",
  "ripieno",
  "riportare",
  "ripresa",
  "ripulire",
  "risata",
  "rischio",
  "riserva",
  "risibile",
  "riso",
  "rispetto",
  "ristoro",
  "risultato",
  "risvolto",
  "ritardo",
  "ritegno",
  "ritmico",
  "ritrovo",
  "riunione",
  "riva",
  "riverso",
  "rivincita",
  "rivolto",
  "rizoma",
  "roba",
  "robotico",
  "robusto",
  "roccia",
  "roco",
  "rodaggio",
  "rodere",
  "roditore",
  "rogito",
  "rollio",
  "romantico",
  "rompere",
  "ronzio",
  "rosolare",
  "rospo",
  "rotante",
  "rotondo",
  "rotula",
  "rovescio",
  "rubizzo",
  "rubrica",
  "ruga",
  "rullino",
  "rumine",
  "rumoroso",
  "ruolo",
  "rupe",
  "russare",
  "rustico",
  "sabato",
  "sabbiare",
  "sabotato",
  "sagoma",
  "salasso",
  "saldatura",
  "salgemma",
  "salivare",
  "salmone",
  "salone",
  "saltare",
  "saluto",
  "salvo",
  "sapere",
  "sapido",
  "saporito",
  "saraceno",
  "sarcasmo",
  "sarto",
  "sassoso",
  "satellite",
  "satira",
  "satollo",
  "saturno",
  "savana",
  "savio",
  "saziato",
  "sbadiglio",
  "sbalzo",
  "sbancato",
  "sbarra",
  "sbattere",
  "sbavare",
  "sbendare",
  "sbirciare",
  "sbloccato",
  "sbocciato",
  "sbrinare",
  "sbruffone",
  "sbuffare",
  "scabroso",
  "scadenza",
  "scala",
  "scambiare",
  "scandalo",
  "scapola",
  "scarso",
  "scatenare",
  "scavato",
  "scelto",
  "scenico",
  "scettro",
  "scheda",
  "schiena",
  "sciarpa",
  "scienza",
  "scindere",
  "scippo",
  "sciroppo",
  "scivolo",
  "sclerare",
  "scodella",
  "scolpito",
  "scomparto",
  "sconforto",
  "scoprire",
  "scorta",
  "scossone",
  "scozzese",
  "scriba",
  "scrollare",
  "scrutinio",
  "scuderia",
  "scultore",
  "scuola",
  "scuro",
  "scusare",
  "sdebitare",
  "sdoganare",
  "seccatura",
  "secondo",
  "sedano",
  "seggiola",
  "segnalato",
  "segregato",
  "seguito",
  "selciato",
  "selettivo",
  "sella",
  "selvaggio",
  "semaforo",
  "sembrare",
  "seme",
  "seminato",
  "sempre",
  "senso",
  "sentire",
  "sepolto",
  "sequenza",
  "serata",
  "serbato",
  "sereno",
  "serio",
  "serpente",
  "serraglio",
  "servire",
  "sestina",
  "setola",
  "settimana",
  "sfacelo",
  "sfaldare",
  "sfamato",
  "sfarzoso",
  "sfaticato",
  "sfera",
  "sfida",
  "sfilato",
  "sfinge",
  "sfocato",
  "sfoderare",
  "sfogo",
  "sfoltire",
  "sforzato",
  "sfratto",
  "sfruttato",
  "sfuggito",
  "sfumare",
  "sfuso",
  "sgabello",
  "sgarbato",
  "sgonfiare",
  "sgorbio",
  "sgrassato",
  "sguardo",
  "sibilo",
  "siccome",
  "sierra",
  "sigla",
  "signore",
  "silenzio",
  "sillaba",
  "simbolo",
  "simpatico",
  "simulato",
  "sinfonia",
  "singolo",
  "sinistro",
  "sino",
  "sintesi",
  "sinusoide",
  "sipario",
  "sisma",
  "sistole",
  "situato",
  "slitta",
  "slogatura",
  "sloveno",
  "smarrito",
  "smemorato",
  "smentito",
  "smeraldo",
  "smilzo",
  "smontare",
  "smottato",
  "smussato",
  "snellire",
  "snervato",
  "snodo",
  "sobbalzo",
  "sobrio",
  "soccorso",
  "sociale",
  "sodale",
  "soffitto",
  "sogno",
  "soldato",
  "solenne",
  "solido",
  "sollazzo",
  "solo",
  "solubile",
  "solvente",
  "somatico",
  "somma",
  "sonda",
  "sonetto",
  "sonnifero",
  "sopire",
  "soppeso",
  "sopra",
  "sorgere",
  "sorpasso",
  "sorriso",
  "sorso",
  "sorteggio",
  "sorvolato",
  "sospiro",
  "sosta",
  "sottile",
  "spada",
  "spalla",
  "spargere",
  "spatola",
  "spavento",
  "spazzola",
  "specie",
  "spedire",
  "spegnere",
  "spelatura",
  "speranza",
  "spessore",
  "spettrale",
  "spezzato",
  "spia",
  "spigoloso",
  "spillato",
  "spinoso",
  "spirale",
  "splendido",
  "sportivo",
  "sposo",
  "spranga",
  "sprecare",
  "spronato",
  "spruzzo",
  "spuntino",
  "squillo",
  "sradicare",
  "srotolato",
  "stabile",
  "stacco",
  "staffa",
  "stagnare",
  "stampato",
  "stantio",
  "starnuto",
  "stasera",
  "statuto",
  "stelo",
  "steppa",
  "sterzo",
  "stiletto",
  "stima",
  "stirpe",
  "stivale",
  "stizzoso",
  "stonato",
  "storico",
  "strappo",
  "stregato",
  "stridulo",
  "strozzare",
  "strutto",
  "stuccare",
  "stufo",
  "stupendo",
  "subentro",
  "succoso",
  "sudore",
  "suggerito",
  "sugo",
  "sultano",
  "suonare",
  "superbo",
  "supporto",
  "surgelato",
  "surrogato",
  "sussurro",
  "sutura",
  "svagare",
  "svedese",
  "sveglio",
  "svelare",
  "svenuto",
  "svezia",
  "sviluppo",
  "svista",
  "svizzera",
  "svolta",
  "svuotare",
  "tabacco",
  "tabulato",
  "tacciare",
  "taciturno",
  "tale",
  "talismano",
  "tampone",
  "tannino",
  "tara",
  "tardivo",
  "targato",
  "tariffa",
  "tarpare",
  "tartaruga",
  "tasto",
  "tattico",
  "taverna",
  "tavolata",
  "tazza",
  "teca",
  "tecnico",
  "telefono",
  "temerario",
  "tempo",
  "temuto",
  "tendone",
  "tenero",
  "tensione",
  "tentacolo",
  "teorema",
  "terme",
  "terrazzo",
  "terzetto",
  "tesi",
  "tesserato",
  "testato",
  "tetro",
  "tettoia",
  "tifare",
  "tigella",
  "timbro",
  "tinto",
  "tipico",
  "tipografo",
  "tiraggio",
  "tiro",
  "titanio",
  "titolo",
  "titubante",
  "tizio",
  "tizzone",
  "toccare",
  "tollerare",
  "tolto",
  "tombola",
  "tomo",
  "tonfo",
  "tonsilla",
  "topazio",
  "topologia",
  "toppa",
  "torba",
  "tornare",
  "torrone",
  "tortora",
  "toscano",
  "tossire",
  "tostatura",
  "totano",
  "trabocco",
  "trachea",
  "trafila",
  "tragedia",
  "tralcio",
  "tramonto",
  "transito",
  "trapano",
  "trarre",
  "trasloco",
  "trattato",
  "trave",
  "treccia",
  "tremolio",
  "trespolo",
  "tributo",
  "tricheco",
  "trifoglio",
  "trillo",
  "trincea",
  "trio",
  "tristezza",
  "triturato",
  "trivella",
  "tromba",
  "trono",
  "troppo",
  "trottola",
  "trovare",
  "truccato",
  "tubatura",
  "tuffato",
  "tulipano",
  "tumulto",
  "tunisia",
  "turbare",
  "turchino",
  "tuta",
  "tutela",
  "ubicato",
  "uccello",
  "uccisore",
  "udire",
  "uditivo",
  "uffa",
  "ufficio",
  "uguale",
  "ulisse",
  "ultimato",
  "umano",
  "umile",
  "umorismo",
  "uncinetto",
  "ungere",
  "ungherese",
  "unicorno",
  "unificato",
  "unisono",
  "unitario",
  "unte",
  "uovo",
  "upupa",
  "uragano",
  "urgenza",
  "urlo",
  "usanza",
  "usato",
  "uscito",
  "usignolo",
  "usuraio",
  "utensile",
  "utilizzo",
  "utopia",
  "vacante",
  "vaccinato",
  "vagabondo",
  "vagliato",
  "valanga",
  "valgo",
  "valico",
  "valletta",
  "valoroso",
  "valutare",
  "valvola",
  "vampata",
  "vangare",
  "vanitoso",
  "vano",
  "vantaggio",
  "vanvera",
  "vapore",
  "varano",
  "varcato",
  "variante",
  "vasca",
  "vedetta",
  "vedova",
  "veduto",
  "vegetale",
  "veicolo",
  "velcro",
  "velina",
  "velluto",
  "veloce",
  "venato",
  "vendemmia",
  "vento",
  "verace",
  "verbale",
  "vergogna",
  "verifica",
  "vero",
  "verruca",
  "verticale",
  "vescica",
  "vessillo",
  "vestale",
  "veterano",
  "vetrina",
  "vetusto",
  "viandante",
  "vibrante",
  "vicenda",
  "vichingo",
  "vicinanza",
  "vidimare",
  "vigilia",
  "vigneto",
  "vigore",
  "vile",
  "villano",
  "vimini",
  "vincitore",
  "viola",
  "vipera",
  "virgola",
  "virologo",
  "virulento",
  "viscoso",
  "visione",
  "vispo",
  "vissuto",
  "visura",
  "vita",
  "vitello",
  "vittima",
  "vivanda",
  "vivido",
  "viziare",
  "voce",
  "voga",
  "volatile",
  "volere",
  "volpe",
  "voragine",
  "vulcano",
  "zampogna",
  "zanna",
  "zappato",
  "zattera",
  "zavorra",
  "zefiro",
  "zelante",
  "zelo",
  "zenzero",
  "zerbino",
  "zibetto",
  "zinco",
  "zircone",
  "zitto",
  "zolla",
  "zotico",
  "zucchero",
  "zufolo",
  "zulu",
  "zuppa"
];
var u1e = [
  "abaco",
  "abdomen",
  "abeja",
  "abierto",
  "abogado",
  "abono",
  "aborto",
  "abrazo",
  "abrir",
  "abuelo",
  "abuso",
  "acabar",
  "academia",
  "acceso",
  "accion",
  "aceite",
  "acelga",
  "acento",
  "aceptar",
  "acido",
  "aclarar",
  "acne",
  "acoger",
  "acoso",
  "activo",
  "acto",
  "actriz",
  "actuar",
  "acudir",
  "acuerdo",
  "acusar",
  "adicto",
  "admitir",
  "adoptar",
  "adorno",
  "aduana",
  "adulto",
  "aereo",
  "afectar",
  "aficion",
  "afinar",
  "afirmar",
  "agil",
  "agitar",
  "agonia",
  "agosto",
  "agotar",
  "agregar",
  "agrio",
  "agua",
  "agudo",
  "aguila",
  "aguja",
  "ahogo",
  "ahorro",
  "aire",
  "aislar",
  "ajedrez",
  "ajeno",
  "ajuste",
  "alacran",
  "alambre",
  "alarma",
  "alba",
  "album",
  "alcalde",
  "aldea",
  "alegre",
  "alejar",
  "alerta",
  "aleta",
  "alfiler",
  "alga",
  "algodon",
  "aliado",
  "aliento",
  "alivio",
  "alma",
  "almeja",
  "almibar",
  "altar",
  "alteza",
  "altivo",
  "alto",
  "altura",
  "alumno",
  "alzar",
  "amable",
  "amante",
  "amapola",
  "amargo",
  "amasar",
  "ambar",
  "ambito",
  "ameno",
  "amigo",
  "amistad",
  "amor",
  "amparo",
  "amplio",
  "ancho",
  "anciano",
  "ancla",
  "andar",
  "anden",
  "anemia",
  "angulo",
  "anillo",
  "animo",
  "anis",
  "anotar",
  "antena",
  "antiguo",
  "antojo",
  "anual",
  "anular",
  "anuncio",
  "anadir",
  "anejo",
  "ano",
  "apagar",
  "aparato",
  "apetito",
  "apio",
  "aplicar",
  "apodo",
  "aporte",
  "apoyo",
  "aprender",
  "aprobar",
  "apuesta",
  "apuro",
  "arado",
  "arana",
  "arar",
  "arbitro",
  "arbol",
  "arbusto",
  "archivo",
  "arco",
  "arder",
  "ardilla",
  "arduo",
  "area",
  "arido",
  "aries",
  "armonia",
  "arnes",
  "aroma",
  "arpa",
  "arpon",
  "arreglo",
  "arroz",
  "arruga",
  "arte",
  "artista",
  "asa",
  "asado",
  "asalto",
  "ascenso",
  "asegurar",
  "aseo",
  "asesor",
  "asiento",
  "asilo",
  "asistir",
  "asno",
  "asombro",
  "aspero",
  "astilla",
  "astro",
  "astuto",
  "asumir",
  "asunto",
  "atajo",
  "ataque",
  "atar",
  "atento",
  "ateo",
  "atico",
  "atleta",
  "atomo",
  "atraer",
  "atroz",
  "atun",
  "audaz",
  "audio",
  "auge",
  "aula",
  "aumento",
  "ausente",
  "autor",
  "aval",
  "avance",
  "avaro",
  "ave",
  "avellana",
  "avena",
  "avestruz",
  "avion",
  "aviso",
  "ayer",
  "ayuda",
  "ayuno",
  "azafran",
  "azar",
  "azote",
  "azucar",
  "azufre",
  "azul",
  "baba",
  "babor",
  "bache",
  "bahia",
  "baile",
  "bajar",
  "balanza",
  "balcon",
  "balde",
  "bambu",
  "banco",
  "banda",
  "bano",
  "barba",
  "barco",
  "barniz",
  "barro",
  "bascula",
  "baston",
  "basura",
  "batalla",
  "bateria",
  "batir",
  "batuta",
  "baul",
  "bazar",
  "bebe",
  "bebida",
  "bello",
  "besar",
  "beso",
  "bestia",
  "bicho",
  "bien",
  "bingo",
  "blanco",
  "bloque",
  "blusa",
  "boa",
  "bobina",
  "bobo",
  "boca",
  "bocina",
  "boda",
  "bodega",
  "boina",
  "bola",
  "bolero",
  "bolsa",
  "bomba",
  "bondad",
  "bonito",
  "bono",
  "bonsai",
  "borde",
  "borrar",
  "bosque",
  "bote",
  "botin",
  "boveda",
  "bozal",
  "bravo",
  "brazo",
  "brecha",
  "breve",
  "brillo",
  "brinco",
  "brisa",
  "broca",
  "broma",
  "bronce",
  "brote",
  "bruja",
  "brusco",
  "bruto",
  "buceo",
  "bucle",
  "bueno",
  "buey",
  "bufanda",
  "bufon",
  "buho",
  "buitre",
  "bulto",
  "burbuja",
  "burla",
  "burro",
  "buscar",
  "butaca",
  "buzon",
  "caballo",
  "cabeza",
  "cabina",
  "cabra",
  "cacao",
  "cadaver",
  "cadena",
  "caer",
  "cafe",
  "caida",
  "caiman",
  "caja",
  "cajon",
  "cal",
  "calamar",
  "calcio",
  "caldo",
  "calidad",
  "calle",
  "calma",
  "calor",
  "calvo",
  "cama",
  "cambio",
  "camello",
  "camino",
  "campo",
  "cancer",
  "candil",
  "canela",
  "canguro",
  "canica",
  "canto",
  "cana",
  "canon",
  "caoba",
  "caos",
  "capaz",
  "capitan",
  "capote",
  "captar",
  "capucha",
  "cara",
  "carbon",
  "carcel",
  "careta",
  "carga",
  "carino",
  "carne",
  "carpeta",
  "carro",
  "carta",
  "casa",
  "casco",
  "casero",
  "caspa",
  "castor",
  "catorce",
  "catre",
  "caudal",
  "causa",
  "cazo",
  "cebolla",
  "ceder",
  "cedro",
  "celda",
  "celebre",
  "celoso",
  "celula",
  "cemento",
  "ceniza",
  "centro",
  "cerca",
  "cerdo",
  "cereza",
  "cero",
  "cerrar",
  "certeza",
  "cesped",
  "cetro",
  "chacal",
  "chaleco",
  "champu",
  "chancla",
  "chapa",
  "charla",
  "chico",
  "chiste",
  "chivo",
  "choque",
  "choza",
  "chuleta",
  "chupar",
  "ciclon",
  "ciego",
  "cielo",
  "cien",
  "cierto",
  "cifra",
  "cigarro",
  "cima",
  "cinco",
  "cine",
  "cinta",
  "cipres",
  "circo",
  "ciruela",
  "cisne",
  "cita",
  "ciudad",
  "clamor",
  "clan",
  "claro",
  "clase",
  "clave",
  "cliente",
  "clima",
  "clinica",
  "cobre",
  "coccion",
  "cochino",
  "cocina",
  "coco",
  "codigo",
  "codo",
  "cofre",
  "coger",
  "cohete",
  "cojin",
  "cojo",
  "cola",
  "colcha",
  "colegio",
  "colgar",
  "colina",
  "collar",
  "colmo",
  "columna",
  "combate",
  "comer",
  "comida",
  "comodo",
  "compra",
  "conde",
  "conejo",
  "conga",
  "conocer",
  "consejo",
  "contar",
  "copa",
  "copia",
  "corazon",
  "corbata",
  "corcho",
  "cordon",
  "corona",
  "correr",
  "coser",
  "cosmos",
  "costa",
  "craneo",
  "crater",
  "crear",
  "crecer",
  "creido",
  "crema",
  "cria",
  "crimen",
  "cripta",
  "crisis",
  "cromo",
  "cronica",
  "croqueta",
  "crudo",
  "cruz",
  "cuadro",
  "cuarto",
  "cuatro",
  "cubo",
  "cubrir",
  "cuchara",
  "cuello",
  "cuento",
  "cuerda",
  "cuesta",
  "cueva",
  "cuidar",
  "culebra",
  "culpa",
  "culto",
  "cumbre",
  "cumplir",
  "cuna",
  "cuneta",
  "cuota",
  "cupon",
  "cupula",
  "curar",
  "curioso",
  "curso",
  "curva",
  "cutis",
  "dama",
  "danza",
  "dar",
  "dardo",
  "datil",
  "deber",
  "debil",
  "decada",
  "decir",
  "dedo",
  "defensa",
  "definir",
  "dejar",
  "delfin",
  "delgado",
  "delito",
  "demora",
  "denso",
  "dental",
  "deporte",
  "derecho",
  "derrota",
  "desayuno",
  "deseo",
  "desfile",
  "desnudo",
  "destino",
  "desvio",
  "detalle",
  "detener",
  "deuda",
  "dia",
  "diablo",
  "diadema",
  "diamante",
  "diana",
  "diario",
  "dibujo",
  "dictar",
  "diente",
  "dieta",
  "diez",
  "dificil",
  "digno",
  "dilema",
  "diluir",
  "dinero",
  "directo",
  "dirigir",
  "disco",
  "diseno",
  "disfraz",
  "diva",
  "divino",
  "doble",
  "doce",
  "dolor",
  "domingo",
  "don",
  "donar",
  "dorado",
  "dormir",
  "dorso",
  "dos",
  "dosis",
  "dragon",
  "droga",
  "ducha",
  "duda",
  "duelo",
  "dueno",
  "dulce",
  "duo",
  "duque",
  "durar",
  "dureza",
  "duro",
  "ebano",
  "ebrio",
  "echar",
  "eco",
  "ecuador",
  "edad",
  "edicion",
  "edificio",
  "editor",
  "educar",
  "efecto",
  "eficaz",
  "eje",
  "ejemplo",
  "elefante",
  "elegir",
  "elemento",
  "elevar",
  "elipse",
  "elite",
  "elixir",
  "elogio",
  "eludir",
  "embudo",
  "emitir",
  "emocion",
  "empate",
  "empeno",
  "empleo",
  "empresa",
  "enano",
  "encargo",
  "enchufe",
  "encia",
  "enemigo",
  "enero",
  "enfado",
  "enfermo",
  "engano",
  "enigma",
  "enlace",
  "enorme",
  "enredo",
  "ensayo",
  "ensenar",
  "entero",
  "entrar",
  "envase",
  "envio",
  "epoca",
  "equipo",
  "erizo",
  "escala",
  "escena",
  "escolar",
  "escribir",
  "escudo",
  "esencia",
  "esfera",
  "esfuerzo",
  "espada",
  "espejo",
  "espia",
  "esposa",
  "espuma",
  "esqui",
  "estar",
  "este",
  "estilo",
  "estufa",
  "etapa",
  "eterno",
  "etica",
  "etnia",
  "evadir",
  "evaluar",
  "evento",
  "evitar",
  "exacto",
  "examen",
  "exceso",
  "excusa",
  "exento",
  "exigir",
  "exilio",
  "existir",
  "exito",
  "experto",
  "explicar",
  "exponer",
  "extremo",
  "fabrica",
  "fabula",
  "fachada",
  "facil",
  "factor",
  "faena",
  "faja",
  "falda",
  "fallo",
  "falso",
  "faltar",
  "fama",
  "familia",
  "famoso",
  "faraon",
  "farmacia",
  "farol",
  "farsa",
  "fase",
  "fatiga",
  "fauna",
  "favor",
  "fax",
  "febrero",
  "fecha",
  "feliz",
  "feo",
  "feria",
  "feroz",
  "fertil",
  "fervor",
  "festin",
  "fiable",
  "fianza",
  "fiar",
  "fibra",
  "ficcion",
  "ficha",
  "fideo",
  "fiebre",
  "fiel",
  "fiera",
  "fiesta",
  "figura",
  "fijar",
  "fijo",
  "fila",
  "filete",
  "filial",
  "filtro",
  "fin",
  "finca",
  "fingir",
  "finito",
  "firma",
  "flaco",
  "flauta",
  "flecha",
  "flor",
  "flota",
  "fluir",
  "flujo",
  "fluor",
  "fobia",
  "foca",
  "fogata",
  "fogon",
  "folio",
  "folleto",
  "fondo",
  "forma",
  "forro",
  "fortuna",
  "forzar",
  "fosa",
  "foto",
  "fracaso",
  "fragil",
  "franja",
  "frase",
  "fraude",
  "freir",
  "freno",
  "fresa",
  "frio",
  "frito",
  "fruta",
  "fuego",
  "fuente",
  "fuerza",
  "fuga",
  "fumar",
  "funcion",
  "funda",
  "furgon",
  "furia",
  "fusil",
  "futbol",
  "futuro",
  "gacela",
  "gafas",
  "gaita",
  "gajo",
  "gala",
  "galeria",
  "gallo",
  "gamba",
  "ganar",
  "gancho",
  "ganga",
  "ganso",
  "garaje",
  "garza",
  "gasolina",
  "gastar",
  "gato",
  "gavilan",
  "gemelo",
  "gemir",
  "gen",
  "genero",
  "genio",
  "gente",
  "geranio",
  "gerente",
  "germen",
  "gesto",
  "gigante",
  "gimnasio",
  "girar",
  "giro",
  "glaciar",
  "globo",
  "gloria",
  "gol",
  "golfo",
  "goloso",
  "golpe",
  "goma",
  "gordo",
  "gorila",
  "gorra",
  "gota",
  "goteo",
  "gozar",
  "grada",
  "grafico",
  "grano",
  "grasa",
  "gratis",
  "grave",
  "grieta",
  "grillo",
  "gripe",
  "gris",
  "grito",
  "grosor",
  "grua",
  "grueso",
  "grumo",
  "grupo",
  "guante",
  "guapo",
  "guardia",
  "guerra",
  "guia",
  "guino",
  "guion",
  "guiso",
  "guitarra",
  "gusano",
  "gustar",
  "haber",
  "habil",
  "hablar",
  "hacer",
  "hacha",
  "hada",
  "hallar",
  "hamaca",
  "harina",
  "haz",
  "hazana",
  "hebilla",
  "hebra",
  "hecho",
  "helado",
  "helio",
  "hembra",
  "herir",
  "hermano",
  "heroe",
  "hervir",
  "hielo",
  "hierro",
  "higado",
  "higiene",
  "hijo",
  "himno",
  "historia",
  "hocico",
  "hogar",
  "hoguera",
  "hoja",
  "hombre",
  "hongo",
  "honor",
  "honra",
  "hora",
  "hormiga",
  "horno",
  "hostil",
  "hoyo",
  "hueco",
  "huelga",
  "huerta",
  "hueso",
  "huevo",
  "huida",
  "huir",
  "humano",
  "humedo",
  "humilde",
  "humo",
  "hundir",
  "huracan",
  "hurto",
  "icono",
  "ideal",
  "idioma",
  "idolo",
  "iglesia",
  "iglu",
  "igual",
  "ilegal",
  "ilusion",
  "imagen",
  "iman",
  "imitar",
  "impar",
  "imperio",
  "imponer",
  "impulso",
  "incapaz",
  "indice",
  "inerte",
  "infiel",
  "informe",
  "ingenio",
  "inicio",
  "inmenso",
  "inmune",
  "innato",
  "insecto",
  "instante",
  "interes",
  "intimo",
  "intuir",
  "inutil",
  "invierno",
  "ira",
  "iris",
  "ironia",
  "isla",
  "islote",
  "jabali",
  "jabon",
  "jamon",
  "jarabe",
  "jardin",
  "jarra",
  "jaula",
  "jazmin",
  "jefe",
  "jeringa",
  "jinete",
  "jornada",
  "joroba",
  "joven",
  "joya",
  "juerga",
  "jueves",
  "juez",
  "jugador",
  "jugo",
  "juguete",
  "juicio",
  "junco",
  "jungla",
  "junio",
  "juntar",
  "jupiter",
  "jurar",
  "justo",
  "juvenil",
  "juzgar",
  "kilo",
  "koala",
  "labio",
  "lacio",
  "lacra",
  "lado",
  "ladron",
  "lagarto",
  "lagrima",
  "laguna",
  "laico",
  "lamer",
  "lamina",
  "lampara",
  "lana",
  "lancha",
  "langosta",
  "lanza",
  "lapiz",
  "largo",
  "larva",
  "lastima",
  "lata",
  "latex",
  "latir",
  "laurel",
  "lavar",
  "lazo",
  "leal",
  "leccion",
  "leche",
  "lector",
  "leer",
  "legion",
  "legumbre",
  "lejano",
  "lengua",
  "lento",
  "lena",
  "leon",
  "leopardo",
  "lesion",
  "letal",
  "letra",
  "leve",
  "leyenda",
  "libertad",
  "libro",
  "licor",
  "lider",
  "lidiar",
  "lienzo",
  "liga",
  "ligero",
  "lima",
  "limite",
  "limon",
  "limpio",
  "lince",
  "lindo",
  "linea",
  "lingote",
  "lino",
  "linterna",
  "liquido",
  "liso",
  "lista",
  "litera",
  "litio",
  "litro",
  "llaga",
  "llama",
  "llanto",
  "llave",
  "llegar",
  "llenar",
  "llevar",
  "llorar",
  "llover",
  "lluvia",
  "lobo",
  "locion",
  "loco",
  "locura",
  "logica",
  "logro",
  "lombriz",
  "lomo",
  "lonja",
  "lote",
  "lucha",
  "lucir",
  "lugar",
  "lujo",
  "luna",
  "lunes",
  "lupa",
  "lustro",
  "luto",
  "luz",
  "maceta",
  "macho",
  "madera",
  "madre",
  "maduro",
  "maestro",
  "mafia",
  "magia",
  "mago",
  "maiz",
  "maldad",
  "maleta",
  "malla",
  "malo",
  "mama",
  "mambo",
  "mamut",
  "manco",
  "mando",
  "manejar",
  "manga",
  "maniqui",
  "manjar",
  "mano",
  "manso",
  "manta",
  "manana",
  "mapa",
  "maquina",
  "mar",
  "marco",
  "marea",
  "marfil",
  "margen",
  "marido",
  "marmol",
  "marron",
  "martes",
  "marzo",
  "masa",
  "mascara",
  "masivo",
  "matar",
  "materia",
  "matiz",
  "matriz",
  "maximo",
  "mayor",
  "mazorca",
  "mecha",
  "medalla",
  "medio",
  "medula",
  "mejilla",
  "mejor",
  "melena",
  "melon",
  "memoria",
  "menor",
  "mensaje",
  "mente",
  "menu",
  "mercado",
  "merengue",
  "merito",
  "mes",
  "meson",
  "meta",
  "meter",
  "metodo",
  "metro",
  "mezcla",
  "miedo",
  "miel",
  "miembro",
  "miga",
  "mil",
  "milagro",
  "militar",
  "millon",
  "mimo",
  "mina",
  "minero",
  "minimo",
  "minuto",
  "miope",
  "mirar",
  "misa",
  "miseria",
  "misil",
  "mismo",
  "mitad",
  "mito",
  "mochila",
  "mocion",
  "moda",
  "modelo",
  "moho",
  "mojar",
  "molde",
  "moler",
  "molino",
  "momento",
  "momia",
  "monarca",
  "moneda",
  "monja",
  "monto",
  "mono",
  "morada",
  "morder",
  "moreno",
  "morir",
  "morro",
  "morsa",
  "mortal",
  "mosca",
  "mostrar",
  "motivo",
  "mover",
  "movil",
  "mozo",
  "mucho",
  "mudar",
  "mueble",
  "muela",
  "muerte",
  "muestra",
  "mugre",
  "mujer",
  "mula",
  "muleta",
  "multa",
  "mundo",
  "muneca",
  "mural",
  "muro",
  "musculo",
  "museo",
  "musgo",
  "musica",
  "muslo",
  "nacar",
  "nacion",
  "nadar",
  "naipe",
  "naranja",
  "nariz",
  "narrar",
  "nasal",
  "natal",
  "nativo",
  "natural",
  "nausea",
  "naval",
  "nave",
  "navidad",
  "necio",
  "nectar",
  "negar",
  "negocio",
  "negro",
  "neon",
  "nervio",
  "neto",
  "neutro",
  "nevar",
  "nevera",
  "nicho",
  "nido",
  "niebla",
  "nieto",
  "ninez",
  "nino",
  "nitido",
  "nivel",
  "nobleza",
  "noche",
  "nomina",
  "noria",
  "norma",
  "norte",
  "nota",
  "noticia",
  "novato",
  "novela",
  "novio",
  "nube",
  "nuca",
  "nucleo",
  "nudillo",
  "nudo",
  "nuera",
  "nueve",
  "nuez",
  "nulo",
  "numero",
  "nutria",
  "oasis",
  "obeso",
  "obispo",
  "objeto",
  "obra",
  "obrero",
  "observar",
  "obtener",
  "obvio",
  "oca",
  "ocaso",
  "oceano",
  "ochenta",
  "ocho",
  "ocio",
  "ocre",
  "octavo",
  "octubre",
  "oculto",
  "ocupar",
  "ocurrir",
  "odiar",
  "odio",
  "odisea",
  "oeste",
  "ofensa",
  "oferta",
  "oficio",
  "ofrecer",
  "ogro",
  "oido",
  "oir",
  "ojo",
  "ola",
  "oleada",
  "olfato",
  "olivo",
  "olla",
  "olmo",
  "olor",
  "olvido",
  "ombligo",
  "onda",
  "onza",
  "opaco",
  "opcion",
  "opera",
  "opinar",
  "oponer",
  "optar",
  "optica",
  "opuesto",
  "oracion",
  "orador",
  "oral",
  "orbita",
  "orca",
  "orden",
  "oreja",
  "organo",
  "orgia",
  "orgullo",
  "oriente",
  "origen",
  "orilla",
  "oro",
  "orquesta",
  "oruga",
  "osadia",
  "oscuro",
  "osezno",
  "oso",
  "ostra",
  "otono",
  "otro",
  "oveja",
  "ovulo",
  "oxido",
  "oxigeno",
  "oyente",
  "ozono",
  "pacto",
  "padre",
  "paella",
  "pagina",
  "pago",
  "pais",
  "pajaro",
  "palabra",
  "palco",
  "paleta",
  "palido",
  "palma",
  "paloma",
  "palpar",
  "pan",
  "panal",
  "panico",
  "pantera",
  "panuelo",
  "papa",
  "papel",
  "papilla",
  "paquete",
  "parar",
  "parcela",
  "pared",
  "parir",
  "paro",
  "parpado",
  "parque",
  "parrafo",
  "parte",
  "pasar",
  "paseo",
  "pasion",
  "paso",
  "pasta",
  "pata",
  "patio",
  "patria",
  "pausa",
  "pauta",
  "pavo",
  "payaso",
  "peaton",
  "pecado",
  "pecera",
  "pecho",
  "pedal",
  "pedir",
  "pegar",
  "peine",
  "pelar",
  "peldano",
  "pelea",
  "peligro",
  "pellejo",
  "pelo",
  "peluca",
  "pena",
  "pensar",
  "penon",
  "peon",
  "peor",
  "pepino",
  "pequeno",
  "pera",
  "percha",
  "perder",
  "pereza",
  "perfil",
  "perico",
  "perla",
  "permiso",
  "perro",
  "persona",
  "pesa",
  "pesca",
  "pesimo",
  "pestana",
  "petalo",
  "petroleo",
  "pez",
  "pezuna",
  "picar",
  "pichon",
  "pie",
  "piedra",
  "pierna",
  "pieza",
  "pijama",
  "pilar",
  "piloto",
  "pimienta",
  "pino",
  "pintor",
  "pinza",
  "pina",
  "piojo",
  "pipa",
  "pirata",
  "pisar",
  "piscina",
  "piso",
  "pista",
  "piton",
  "pizca",
  "placa",
  "plan",
  "plata",
  "playa",
  "plaza",
  "pleito",
  "pleno",
  "plomo",
  "pluma",
  "plural",
  "pobre",
  "poco",
  "poder",
  "podio",
  "poema",
  "poesia",
  "poeta",
  "polen",
  "policia",
  "pollo",
  "polvo",
  "pomada",
  "pomelo",
  "pomo",
  "pompa",
  "poner",
  "porcion",
  "portal",
  "posada",
  "poseer",
  "posible",
  "poste",
  "potencia",
  "potro",
  "pozo",
  "prado",
  "precoz",
  "pregunta",
  "premio",
  "prensa",
  "preso",
  "previo",
  "primo",
  "principe",
  "prision",
  "privar",
  "proa",
  "probar",
  "proceso",
  "producto",
  "proeza",
  "profesor",
  "programa",
  "prole",
  "promesa",
  "pronto",
  "propio",
  "proximo",
  "prueba",
  "publico",
  "puchero",
  "pudor",
  "pueblo",
  "puerta",
  "puesto",
  "pulga",
  "pulir",
  "pulmon",
  "pulpo",
  "pulso",
  "puma",
  "punto",
  "punal",
  "puno",
  "pupa",
  "pupila",
  "pure",
  "quedar",
  "queja",
  "quemar",
  "querer",
  "queso",
  "quieto",
  "quimica",
  "quince",
  "quitar",
  "rabano",
  "rabia",
  "rabo",
  "racion",
  "radical",
  "raiz",
  "rama",
  "rampa",
  "rancho",
  "rango",
  "rapaz",
  "rapido",
  "rapto",
  "rasgo",
  "raspa",
  "rato",
  "rayo",
  "raza",
  "razon",
  "reaccion",
  "realidad",
  "rebano",
  "rebote",
  "recaer",
  "receta",
  "rechazo",
  "recoger",
  "recreo",
  "recto",
  "recurso",
  "red",
  "redondo",
  "reducir",
  "reflejo",
  "reforma",
  "refran",
  "refugio",
  "regalo",
  "regir",
  "regla",
  "regreso",
  "rehen",
  "reino",
  "reir",
  "reja",
  "relato",
  "relevo",
  "relieve",
  "relleno",
  "reloj",
  "remar",
  "remedio",
  "remo",
  "rencor",
  "rendir",
  "renta",
  "reparto",
  "repetir",
  "reposo",
  "reptil",
  "res",
  "rescate",
  "resina",
  "respeto",
  "resto",
  "resumen",
  "retiro",
  "retorno",
  "retrato",
  "reunir",
  "reves",
  "revista",
  "rey",
  "rezar",
  "rico",
  "riego",
  "rienda",
  "riesgo",
  "rifa",
  "rigido",
  "rigor",
  "rincon",
  "rinon",
  "rio",
  "riqueza",
  "risa",
  "ritmo",
  "rito",
  "rizo",
  "roble",
  "roce",
  "rociar",
  "rodar",
  "rodeo",
  "rodilla",
  "roer",
  "rojizo",
  "rojo",
  "romero",
  "romper",
  "ron",
  "ronco",
  "ronda",
  "ropa",
  "ropero",
  "rosa",
  "rosca",
  "rostro",
  "rotar",
  "rubi",
  "rubor",
  "rudo",
  "rueda",
  "rugir",
  "ruido",
  "ruina",
  "ruleta",
  "rulo",
  "rumbo",
  "rumor",
  "ruptura",
  "ruta",
  "rutina",
  "sabado",
  "saber",
  "sabio",
  "sable",
  "sacar",
  "sagaz",
  "sagrado",
  "sala",
  "saldo",
  "salero",
  "salir",
  "salmon",
  "salon",
  "salsa",
  "salto",
  "salud",
  "salvar",
  "samba",
  "sancion",
  "sandia",
  "sanear",
  "sangre",
  "sanidad",
  "sano",
  "santo",
  "sapo",
  "saque",
  "sardina",
  "sarten",
  "sastre",
  "satan",
  "sauna",
  "saxofon",
  "seccion",
  "seco",
  "secreto",
  "secta",
  "sed",
  "seguir",
  "seis",
  "sello",
  "selva",
  "semana",
  "semilla",
  "senda",
  "sensor",
  "senal",
  "senor",
  "separar",
  "sepia",
  "sequia",
  "ser",
  "serie",
  "sermon",
  "servir",
  "sesenta",
  "sesion",
  "seta",
  "setenta",
  "severo",
  "sexo",
  "sexto",
  "sidra",
  "siesta",
  "siete",
  "siglo",
  "signo",
  "silaba",
  "silbar",
  "silencio",
  "silla",
  "simbolo",
  "simio",
  "sirena",
  "sistema",
  "sitio",
  "situar",
  "sobre",
  "socio",
  "sodio",
  "sol",
  "solapa",
  "soldado",
  "soledad",
  "solido",
  "soltar",
  "solucion",
  "sombra",
  "sondeo",
  "sonido",
  "sonoro",
  "sonrisa",
  "sopa",
  "soplar",
  "soporte",
  "sordo",
  "sorpresa",
  "sorteo",
  "sosten",
  "sotano",
  "suave",
  "subir",
  "suceso",
  "sudor",
  "suegra",
  "suelo",
  "sueno",
  "suerte",
  "sufrir",
  "sujeto",
  "sultan",
  "sumar",
  "superar",
  "suplir",
  "suponer",
  "supremo",
  "sur",
  "surco",
  "sureno",
  "surgir",
  "susto",
  "sutil",
  "tabaco",
  "tabique",
  "tabla",
  "tabu",
  "taco",
  "tacto",
  "tajo",
  "talar",
  "talco",
  "talento",
  "talla",
  "talon",
  "tamano",
  "tambor",
  "tango",
  "tanque",
  "tapa",
  "tapete",
  "tapia",
  "tapon",
  "taquilla",
  "tarde",
  "tarea",
  "tarifa",
  "tarjeta",
  "tarot",
  "tarro",
  "tarta",
  "tatuaje",
  "tauro",
  "taza",
  "tazon",
  "teatro",
  "techo",
  "tecla",
  "tecnica",
  "tejado",
  "tejer",
  "tejido",
  "tela",
  "telefono",
  "tema",
  "temor",
  "templo",
  "tenaz",
  "tender",
  "tener",
  "tenis",
  "tenso",
  "teoria",
  "terapia",
  "terco",
  "termino",
  "ternura",
  "terror",
  "tesis",
  "tesoro",
  "testigo",
  "tetera",
  "texto",
  "tez",
  "tibio",
  "tiburon",
  "tiempo",
  "tienda",
  "tierra",
  "tieso",
  "tigre",
  "tijera",
  "tilde",
  "timbre",
  "timido",
  "timo",
  "tinta",
  "tio",
  "tipico",
  "tipo",
  "tira",
  "tiron",
  "titan",
  "titere",
  "titulo",
  "tiza",
  "toalla",
  "tobillo",
  "tocar",
  "tocino",
  "todo",
  "toga",
  "toldo",
  "tomar",
  "tono",
  "tonto",
  "topar",
  "tope",
  "toque",
  "torax",
  "torero",
  "tormenta",
  "torneo",
  "toro",
  "torpedo",
  "torre",
  "torso",
  "tortuga",
  "tos",
  "tosco",
  "toser",
  "toxico",
  "trabajo",
  "tractor",
  "traer",
  "trafico",
  "trago",
  "traje",
  "tramo",
  "trance",
  "trato",
  "trauma",
  "trazar",
  "trebol",
  "tregua",
  "treinta",
  "tren",
  "trepar",
  "tres",
  "tribu",
  "trigo",
  "tripa",
  "triste",
  "triunfo",
  "trofeo",
  "trompa",
  "tronco",
  "tropa",
  "trote",
  "trozo",
  "truco",
  "trueno",
  "trufa",
  "tuberia",
  "tubo",
  "tuerto",
  "tumba",
  "tumor",
  "tunel",
  "tunica",
  "turbina",
  "turismo",
  "turno",
  "tutor",
  "ubicar",
  "ulcera",
  "umbral",
  "unidad",
  "unir",
  "universo",
  "uno",
  "untar",
  "una",
  "urbano",
  "urbe",
  "urgente",
  "urna",
  "usar",
  "usuario",
  "util",
  "utopia",
  "uva",
  "vaca",
  "vacio",
  "vacuna",
  "vagar",
  "vago",
  "vaina",
  "vajilla",
  "vale",
  "valido",
  "valle",
  "valor",
  "valvula",
  "vampiro",
  "vara",
  "variar",
  "varon",
  "vaso",
  "vecino",
  "vector",
  "vehiculo",
  "veinte",
  "vejez",
  "vela",
  "velero",
  "veloz",
  "vena",
  "vencer",
  "venda",
  "veneno",
  "vengar",
  "venir",
  "venta",
  "venus",
  "ver",
  "verano",
  "verbo",
  "verde",
  "vereda",
  "verja",
  "verso",
  "verter",
  "via",
  "viaje",
  "vibrar",
  "vicio",
  "victima",
  "vida",
  "video",
  "vidrio",
  "viejo",
  "viernes",
  "vigor",
  "vil",
  "villa",
  "vinagre",
  "vino",
  "vinedo",
  "violin",
  "viral",
  "virgo",
  "virtud",
  "visor",
  "vispera",
  "vista",
  "vitamina",
  "viudo",
  "vivaz",
  "vivero",
  "vivir",
  "vivo",
  "volcan",
  "volumen",
  "volver",
  "voraz",
  "votar",
  "voto",
  "voz",
  "vuelo",
  "vulgar",
  "yacer",
  "yate",
  "yegua",
  "yema",
  "yerno",
  "yeso",
  "yodo",
  "yoga",
  "yogur",
  "zafiro",
  "zanja",
  "zapato",
  "zarza",
  "zona",
  "zorro",
  "zumo",
  "zurdo"
];
var l1e = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var f1e = [
  "abacate",
  "abaixo",
  "abalar",
  "abater",
  "abduzir",
  "abelha",
  "aberto",
  "abismo",
  "abotoar",
  "abranger",
  "abreviar",
  "abrigar",
  "abrupto",
  "absinto",
  "absoluto",
  "absurdo",
  "abutre",
  "acabado",
  "acalmar",
  "acampar",
  "acanhar",
  "acaso",
  "aceitar",
  "acelerar",
  "acenar",
  "acervo",
  "acessar",
  "acetona",
  "achatar",
  "acidez",
  "acima",
  "acionado",
  "acirrar",
  "aclamar",
  "aclive",
  "acolhida",
  "acomodar",
  "acoplar",
  "acordar",
  "acumular",
  "acusador",
  "adaptar",
  "adega",
  "adentro",
  "adepto",
  "adequar",
  "aderente",
  "adesivo",
  "adeus",
  "adiante",
  "aditivo",
  "adjetivo",
  "adjunto",
  "admirar",
  "adorar",
  "adquirir",
  "adubo",
  "adverso",
  "advogado",
  "aeronave",
  "afastar",
  "aferir",
  "afetivo",
  "afinador",
  "afivelar",
  "aflito",
  "afluente",
  "afrontar",
  "agachar",
  "agarrar",
  "agasalho",
  "agenciar",
  "agilizar",
  "agiota",
  "agitado",
  "agora",
  "agradar",
  "agreste",
  "agrupar",
  "aguardar",
  "agulha",
  "ajoelhar",
  "ajudar",
  "ajustar",
  "alameda",
  "alarme",
  "alastrar",
  "alavanca",
  "albergue",
  "albino",
  "alcatra",
  "aldeia",
  "alecrim",
  "alegria",
  "alertar",
  "alface",
  "alfinete",
  "algum",
  "alheio",
  "aliar",
  "alicate",
  "alienar",
  "alinhar",
  "aliviar",
  "almofada",
  "alocar",
  "alpiste",
  "alterar",
  "altitude",
  "alucinar",
  "alugar",
  "aluno",
  "alusivo",
  "alvo",
  "amaciar",
  "amador",
  "amarelo",
  "amassar",
  "ambas",
  "ambiente",
  "ameixa",
  "amenizar",
  "amido",
  "amistoso",
  "amizade",
  "amolador",
  "amontoar",
  "amoroso",
  "amostra",
  "amparar",
  "ampliar",
  "ampola",
  "anagrama",
  "analisar",
  "anarquia",
  "anatomia",
  "andaime",
  "anel",
  "anexo",
  "angular",
  "animar",
  "anjo",
  "anomalia",
  "anotado",
  "ansioso",
  "anterior",
  "anuidade",
  "anunciar",
  "anzol",
  "apagador",
  "apalpar",
  "apanhado",
  "apego",
  "apelido",
  "apertada",
  "apesar",
  "apetite",
  "apito",
  "aplauso",
  "aplicada",
  "apoio",
  "apontar",
  "aposta",
  "aprendiz",
  "aprovar",
  "aquecer",
  "arame",
  "aranha",
  "arara",
  "arcada",
  "ardente",
  "areia",
  "arejar",
  "arenito",
  "aresta",
  "argiloso",
  "argola",
  "arma",
  "arquivo",
  "arraial",
  "arrebate",
  "arriscar",
  "arroba",
  "arrumar",
  "arsenal",
  "arterial",
  "artigo",
  "arvoredo",
  "asfaltar",
  "asilado",
  "aspirar",
  "assador",
  "assinar",
  "assoalho",
  "assunto",
  "astral",
  "atacado",
  "atadura",
  "atalho",
  "atarefar",
  "atear",
  "atender",
  "aterro",
  "ateu",
  "atingir",
  "atirador",
  "ativo",
  "atoleiro",
  "atracar",
  "atrevido",
  "atriz",
  "atual",
  "atum",
  "auditor",
  "aumentar",
  "aura",
  "aurora",
  "autismo",
  "autoria",
  "autuar",
  "avaliar",
  "avante",
  "avaria",
  "avental",
  "avesso",
  "aviador",
  "avisar",
  "avulso",
  "axila",
  "azarar",
  "azedo",
  "azeite",
  "azulejo",
  "babar",
  "babosa",
  "bacalhau",
  "bacharel",
  "bacia",
  "bagagem",
  "baiano",
  "bailar",
  "baioneta",
  "bairro",
  "baixista",
  "bajular",
  "baleia",
  "baliza",
  "balsa",
  "banal",
  "bandeira",
  "banho",
  "banir",
  "banquete",
  "barato",
  "barbado",
  "baronesa",
  "barraca",
  "barulho",
  "baseado",
  "bastante",
  "batata",
  "batedor",
  "batida",
  "batom",
  "batucar",
  "baunilha",
  "beber",
  "beijo",
  "beirada",
  "beisebol",
  "beldade",
  "beleza",
  "belga",
  "beliscar",
  "bendito",
  "bengala",
  "benzer",
  "berimbau",
  "berlinda",
  "berro",
  "besouro",
  "bexiga",
  "bezerro",
  "bico",
  "bicudo",
  "bienal",
  "bifocal",
  "bifurcar",
  "bigorna",
  "bilhete",
  "bimestre",
  "bimotor",
  "biologia",
  "biombo",
  "biosfera",
  "bipolar",
  "birrento",
  "biscoito",
  "bisneto",
  "bispo",
  "bissexto",
  "bitola",
  "bizarro",
  "blindado",
  "bloco",
  "bloquear",
  "boato",
  "bobagem",
  "bocado",
  "bocejo",
  "bochecha",
  "boicotar",
  "bolada",
  "boletim",
  "bolha",
  "bolo",
  "bombeiro",
  "bonde",
  "boneco",
  "bonita",
  "borbulha",
  "borda",
  "boreal",
  "borracha",
  "bovino",
  "boxeador",
  "branco",
  "brasa",
  "braveza",
  "breu",
  "briga",
  "brilho",
  "brincar",
  "broa",
  "brochura",
  "bronzear",
  "broto",
  "bruxo",
  "bucha",
  "budismo",
  "bufar",
  "bule",
  "buraco",
  "busca",
  "busto",
  "buzina",
  "cabana",
  "cabelo",
  "cabide",
  "cabo",
  "cabrito",
  "cacau",
  "cacetada",
  "cachorro",
  "cacique",
  "cadastro",
  "cadeado",
  "cafezal",
  "caiaque",
  "caipira",
  "caixote",
  "cajado",
  "caju",
  "calafrio",
  "calcular",
  "caldeira",
  "calibrar",
  "calmante",
  "calota",
  "camada",
  "cambista",
  "camisa",
  "camomila",
  "campanha",
  "camuflar",
  "canavial",
  "cancelar",
  "caneta",
  "canguru",
  "canhoto",
  "canivete",
  "canoa",
  "cansado",
  "cantar",
  "canudo",
  "capacho",
  "capela",
  "capinar",
  "capotar",
  "capricho",
  "captador",
  "capuz",
  "caracol",
  "carbono",
  "cardeal",
  "careca",
  "carimbar",
  "carneiro",
  "carpete",
  "carreira",
  "cartaz",
  "carvalho",
  "casaco",
  "casca",
  "casebre",
  "castelo",
  "casulo",
  "catarata",
  "cativar",
  "caule",
  "causador",
  "cautelar",
  "cavalo",
  "caverna",
  "cebola",
  "cedilha",
  "cegonha",
  "celebrar",
  "celular",
  "cenoura",
  "censo",
  "centeio",
  "cercar",
  "cerrado",
  "certeiro",
  "cerveja",
  "cetim",
  "cevada",
  "chacota",
  "chaleira",
  "chamado",
  "chapada",
  "charme",
  "chatice",
  "chave",
  "chefe",
  "chegada",
  "cheiro",
  "cheque",
  "chicote",
  "chifre",
  "chinelo",
  "chocalho",
  "chover",
  "chumbo",
  "chutar",
  "chuva",
  "cicatriz",
  "ciclone",
  "cidade",
  "cidreira",
  "ciente",
  "cigana",
  "cimento",
  "cinto",
  "cinza",
  "ciranda",
  "circuito",
  "cirurgia",
  "citar",
  "clareza",
  "clero",
  "clicar",
  "clone",
  "clube",
  "coado",
  "coagir",
  "cobaia",
  "cobertor",
  "cobrar",
  "cocada",
  "coelho",
  "coentro",
  "coeso",
  "cogumelo",
  "coibir",
  "coifa",
  "coiote",
  "colar",
  "coleira",
  "colher",
  "colidir",
  "colmeia",
  "colono",
  "coluna",
  "comando",
  "combinar",
  "comentar",
  "comitiva",
  "comover",
  "complexo",
  "comum",
  "concha",
  "condor",
  "conectar",
  "confuso",
  "congelar",
  "conhecer",
  "conjugar",
  "consumir",
  "contrato",
  "convite",
  "cooperar",
  "copeiro",
  "copiador",
  "copo",
  "coquetel",
  "coragem",
  "cordial",
  "corneta",
  "coronha",
  "corporal",
  "correio",
  "cortejo",
  "coruja",
  "corvo",
  "cosseno",
  "costela",
  "cotonete",
  "couro",
  "couve",
  "covil",
  "cozinha",
  "cratera",
  "cravo",
  "creche",
  "credor",
  "creme",
  "crer",
  "crespo",
  "criada",
  "criminal",
  "crioulo",
  "crise",
  "criticar",
  "crosta",
  "crua",
  "cruzeiro",
  "cubano",
  "cueca",
  "cuidado",
  "cujo",
  "culatra",
  "culminar",
  "culpar",
  "cultura",
  "cumprir",
  "cunhado",
  "cupido",
  "curativo",
  "curral",
  "cursar",
  "curto",
  "cuspir",
  "custear",
  "cutelo",
  "damasco",
  "datar",
  "debater",
  "debitar",
  "deboche",
  "debulhar",
  "decalque",
  "decimal",
  "declive",
  "decote",
  "decretar",
  "dedal",
  "dedicado",
  "deduzir",
  "defesa",
  "defumar",
  "degelo",
  "degrau",
  "degustar",
  "deitado",
  "deixar",
  "delator",
  "delegado",
  "delinear",
  "delonga",
  "demanda",
  "demitir",
  "demolido",
  "dentista",
  "depenado",
  "depilar",
  "depois",
  "depressa",
  "depurar",
  "deriva",
  "derramar",
  "desafio",
  "desbotar",
  "descanso",
  "desenho",
  "desfiado",
  "desgaste",
  "desigual",
  "deslize",
  "desmamar",
  "desova",
  "despesa",
  "destaque",
  "desviar",
  "detalhar",
  "detentor",
  "detonar",
  "detrito",
  "deusa",
  "dever",
  "devido",
  "devotado",
  "dezena",
  "diagrama",
  "dialeto",
  "didata",
  "difuso",
  "digitar",
  "dilatado",
  "diluente",
  "diminuir",
  "dinastia",
  "dinheiro",
  "diocese",
  "direto",
  "discreta",
  "disfarce",
  "disparo",
  "disquete",
  "dissipar",
  "distante",
  "ditador",
  "diurno",
  "diverso",
  "divisor",
  "divulgar",
  "dizer",
  "dobrador",
  "dolorido",
  "domador",
  "dominado",
  "donativo",
  "donzela",
  "dormente",
  "dorsal",
  "dosagem",
  "dourado",
  "doutor",
  "drenagem",
  "drible",
  "drogaria",
  "duelar",
  "duende",
  "dueto",
  "duplo",
  "duquesa",
  "durante",
  "duvidoso",
  "eclodir",
  "ecoar",
  "ecologia",
  "edificar",
  "edital",
  "educado",
  "efeito",
  "efetivar",
  "ejetar",
  "elaborar",
  "eleger",
  "eleitor",
  "elenco",
  "elevador",
  "eliminar",
  "elogiar",
  "embargo",
  "embolado",
  "embrulho",
  "embutido",
  "emenda",
  "emergir",
  "emissor",
  "empatia",
  "empenho",
  "empinado",
  "empolgar",
  "emprego",
  "empurrar",
  "emulador",
  "encaixe",
  "encenado",
  "enchente",
  "encontro",
  "endeusar",
  "endossar",
  "enfaixar",
  "enfeite",
  "enfim",
  "engajado",
  "engenho",
  "englobar",
  "engomado",
  "engraxar",
  "enguia",
  "enjoar",
  "enlatar",
  "enquanto",
  "enraizar",
  "enrolado",
  "enrugar",
  "ensaio",
  "enseada",
  "ensino",
  "ensopado",
  "entanto",
  "enteado",
  "entidade",
  "entortar",
  "entrada",
  "entulho",
  "envergar",
  "enviado",
  "envolver",
  "enxame",
  "enxerto",
  "enxofre",
  "enxuto",
  "epiderme",
  "equipar",
  "ereto",
  "erguido",
  "errata",
  "erva",
  "ervilha",
  "esbanjar",
  "esbelto",
  "escama",
  "escola",
  "escrita",
  "escuta",
  "esfinge",
  "esfolar",
  "esfregar",
  "esfumado",
  "esgrima",
  "esmalte",
  "espanto",
  "espelho",
  "espiga",
  "esponja",
  "espreita",
  "espumar",
  "esquerda",
  "estaca",
  "esteira",
  "esticar",
  "estofado",
  "estrela",
  "estudo",
  "esvaziar",
  "etanol",
  "etiqueta",
  "euforia",
  "europeu",
  "evacuar",
  "evaporar",
  "evasivo",
  "eventual",
  "evidente",
  "evoluir",
  "exagero",
  "exalar",
  "examinar",
  "exato",
  "exausto",
  "excesso",
  "excitar",
  "exclamar",
  "executar",
  "exemplo",
  "exibir",
  "exigente",
  "exonerar",
  "expandir",
  "expelir",
  "expirar",
  "explanar",
  "exposto",
  "expresso",
  "expulsar",
  "externo",
  "extinto",
  "extrato",
  "fabricar",
  "fabuloso",
  "faceta",
  "facial",
  "fada",
  "fadiga",
  "faixa",
  "falar",
  "falta",
  "familiar",
  "fandango",
  "fanfarra",
  "fantoche",
  "fardado",
  "farelo",
  "farinha",
  "farofa",
  "farpa",
  "fartura",
  "fatia",
  "fator",
  "favorita",
  "faxina",
  "fazenda",
  "fechado",
  "feijoada",
  "feirante",
  "felino",
  "feminino",
  "fenda",
  "feno",
  "fera",
  "feriado",
  "ferrugem",
  "ferver",
  "festejar",
  "fetal",
  "feudal",
  "fiapo",
  "fibrose",
  "ficar",
  "ficheiro",
  "figurado",
  "fileira",
  "filho",
  "filme",
  "filtrar",
  "firmeza",
  "fisgada",
  "fissura",
  "fita",
  "fivela",
  "fixador",
  "fixo",
  "flacidez",
  "flamingo",
  "flanela",
  "flechada",
  "flora",
  "flutuar",
  "fluxo",
  "focal",
  "focinho",
  "fofocar",
  "fogo",
  "foguete",
  "foice",
  "folgado",
  "folheto",
  "forjar",
  "formiga",
  "forno",
  "forte",
  "fosco",
  "fossa",
  "fragata",
  "fralda",
  "frango",
  "frasco",
  "fraterno",
  "freira",
  "frente",
  "fretar",
  "frieza",
  "friso",
  "fritura",
  "fronha",
  "frustrar",
  "fruteira",
  "fugir",
  "fulano",
  "fuligem",
  "fundar",
  "fungo",
  "funil",
  "furador",
  "furioso",
  "futebol",
  "gabarito",
  "gabinete",
  "gado",
  "gaiato",
  "gaiola",
  "gaivota",
  "galega",
  "galho",
  "galinha",
  "galocha",
  "ganhar",
  "garagem",
  "garfo",
  "gargalo",
  "garimpo",
  "garoupa",
  "garrafa",
  "gasoduto",
  "gasto",
  "gata",
  "gatilho",
  "gaveta",
  "gazela",
  "gelado",
  "geleia",
  "gelo",
  "gemada",
  "gemer",
  "gemido",
  "generoso",
  "gengiva",
  "genial",
  "genoma",
  "genro",
  "geologia",
  "gerador",
  "germinar",
  "gesso",
  "gestor",
  "ginasta",
  "gincana",
  "gingado",
  "girafa",
  "girino",
  "glacial",
  "glicose",
  "global",
  "glorioso",
  "goela",
  "goiaba",
  "golfe",
  "golpear",
  "gordura",
  "gorjeta",
  "gorro",
  "gostoso",
  "goteira",
  "governar",
  "gracejo",
  "gradual",
  "grafite",
  "gralha",
  "grampo",
  "granada",
  "gratuito",
  "graveto",
  "graxa",
  "grego",
  "grelhar",
  "greve",
  "grilo",
  "grisalho",
  "gritaria",
  "grosso",
  "grotesco",
  "grudado",
  "grunhido",
  "gruta",
  "guache",
  "guarani",
  "guaxinim",
  "guerrear",
  "guiar",
  "guincho",
  "guisado",
  "gula",
  "guloso",
  "guru",
  "habitar",
  "harmonia",
  "haste",
  "haver",
  "hectare",
  "herdar",
  "heresia",
  "hesitar",
  "hiato",
  "hibernar",
  "hidratar",
  "hiena",
  "hino",
  "hipismo",
  "hipnose",
  "hipoteca",
  "hoje",
  "holofote",
  "homem",
  "honesto",
  "honrado",
  "hormonal",
  "hospedar",
  "humorado",
  "iate",
  "ideia",
  "idoso",
  "ignorado",
  "igreja",
  "iguana",
  "ileso",
  "ilha",
  "iludido",
  "iluminar",
  "ilustrar",
  "imagem",
  "imediato",
  "imenso",
  "imersivo",
  "iminente",
  "imitador",
  "imortal",
  "impacto",
  "impedir",
  "implante",
  "impor",
  "imprensa",
  "impune",
  "imunizar",
  "inalador",
  "inapto",
  "inativo",
  "incenso",
  "inchar",
  "incidir",
  "incluir",
  "incolor",
  "indeciso",
  "indireto",
  "indutor",
  "ineficaz",
  "inerente",
  "infantil",
  "infestar",
  "infinito",
  "inflamar",
  "informal",
  "infrator",
  "ingerir",
  "inibido",
  "inicial",
  "inimigo",
  "injetar",
  "inocente",
  "inodoro",
  "inovador",
  "inox",
  "inquieto",
  "inscrito",
  "inseto",
  "insistir",
  "inspetor",
  "instalar",
  "insulto",
  "intacto",
  "integral",
  "intimar",
  "intocado",
  "intriga",
  "invasor",
  "inverno",
  "invicto",
  "invocar",
  "iogurte",
  "iraniano",
  "ironizar",
  "irreal",
  "irritado",
  "isca",
  "isento",
  "isolado",
  "isqueiro",
  "italiano",
  "janeiro",
  "jangada",
  "janta",
  "jararaca",
  "jardim",
  "jarro",
  "jasmim",
  "jato",
  "javali",
  "jazida",
  "jejum",
  "joaninha",
  "joelhada",
  "jogador",
  "joia",
  "jornal",
  "jorrar",
  "jovem",
  "juba",
  "judeu",
  "judoca",
  "juiz",
  "julgador",
  "julho",
  "jurado",
  "jurista",
  "juro",
  "justa",
  "labareda",
  "laboral",
  "lacre",
  "lactante",
  "ladrilho",
  "lagarta",
  "lagoa",
  "laje",
  "lamber",
  "lamentar",
  "laminar",
  "lampejo",
  "lanche",
  "lapidar",
  "lapso",
  "laranja",
  "lareira",
  "largura",
  "lasanha",
  "lastro",
  "lateral",
  "latido",
  "lavanda",
  "lavoura",
  "lavrador",
  "laxante",
  "lazer",
  "lealdade",
  "lebre",
  "legado",
  "legendar",
  "legista",
  "leigo",
  "leiloar",
  "leitura",
  "lembrete",
  "leme",
  "lenhador",
  "lentilha",
  "leoa",
  "lesma",
  "leste",
  "letivo",
  "letreiro",
  "levar",
  "leveza",
  "levitar",
  "liberal",
  "libido",
  "liderar",
  "ligar",
  "ligeiro",
  "limitar",
  "limoeiro",
  "limpador",
  "linda",
  "linear",
  "linhagem",
  "liquidez",
  "listagem",
  "lisura",
  "litoral",
  "livro",
  "lixa",
  "lixeira",
  "locador",
  "locutor",
  "lojista",
  "lombo",
  "lona",
  "longe",
  "lontra",
  "lorde",
  "lotado",
  "loteria",
  "loucura",
  "lousa",
  "louvar",
  "luar",
  "lucidez",
  "lucro",
  "luneta",
  "lustre",
  "lutador",
  "luva",
  "macaco",
  "macete",
  "machado",
  "macio",
  "madeira",
  "madrinha",
  "magnata",
  "magreza",
  "maior",
  "mais",
  "malandro",
  "malha",
  "malote",
  "maluco",
  "mamilo",
  "mamoeiro",
  "mamute",
  "manada",
  "mancha",
  "mandato",
  "manequim",
  "manhoso",
  "manivela",
  "manobrar",
  "mansa",
  "manter",
  "manusear",
  "mapeado",
  "maquinar",
  "marcador",
  "maresia",
  "marfim",
  "margem",
  "marinho",
  "marmita",
  "maroto",
  "marquise",
  "marreco",
  "martelo",
  "marujo",
  "mascote",
  "masmorra",
  "massagem",
  "mastigar",
  "matagal",
  "materno",
  "matinal",
  "matutar",
  "maxilar",
  "medalha",
  "medida",
  "medusa",
  "megafone",
  "meiga",
  "melancia",
  "melhor",
  "membro",
  "memorial",
  "menino",
  "menos",
  "mensagem",
  "mental",
  "merecer",
  "mergulho",
  "mesada",
  "mesclar",
  "mesmo",
  "mesquita",
  "mestre",
  "metade",
  "meteoro",
  "metragem",
  "mexer",
  "mexicano",
  "micro",
  "migalha",
  "migrar",
  "milagre",
  "milenar",
  "milhar",
  "mimado",
  "minerar",
  "minhoca",
  "ministro",
  "minoria",
  "miolo",
  "mirante",
  "mirtilo",
  "misturar",
  "mocidade",
  "moderno",
  "modular",
  "moeda",
  "moer",
  "moinho",
  "moita",
  "moldura",
  "moleza",
  "molho",
  "molinete",
  "molusco",
  "montanha",
  "moqueca",
  "morango",
  "morcego",
  "mordomo",
  "morena",
  "mosaico",
  "mosquete",
  "mostarda",
  "motel",
  "motim",
  "moto",
  "motriz",
  "muda",
  "muito",
  "mulata",
  "mulher",
  "multar",
  "mundial",
  "munido",
  "muralha",
  "murcho",
  "muscular",
  "museu",
  "musical",
  "nacional",
  "nadador",
  "naja",
  "namoro",
  "narina",
  "narrado",
  "nascer",
  "nativa",
  "natureza",
  "navalha",
  "navegar",
  "navio",
  "neblina",
  "nebuloso",
  "negativa",
  "negociar",
  "negrito",
  "nervoso",
  "neta",
  "neural",
  "nevasca",
  "nevoeiro",
  "ninar",
  "ninho",
  "nitidez",
  "nivelar",
  "nobreza",
  "noite",
  "noiva",
  "nomear",
  "nominal",
  "nordeste",
  "nortear",
  "notar",
  "noticiar",
  "noturno",
  "novelo",
  "novilho",
  "novo",
  "nublado",
  "nudez",
  "numeral",
  "nupcial",
  "nutrir",
  "nuvem",
  "obcecado",
  "obedecer",
  "objetivo",
  "obrigado",
  "obscuro",
  "obstetra",
  "obter",
  "obturar",
  "ocidente",
  "ocioso",
  "ocorrer",
  "oculista",
  "ocupado",
  "ofegante",
  "ofensiva",
  "oferenda",
  "oficina",
  "ofuscado",
  "ogiva",
  "olaria",
  "oleoso",
  "olhar",
  "oliveira",
  "ombro",
  "omelete",
  "omisso",
  "omitir",
  "ondulado",
  "oneroso",
  "ontem",
  "opcional",
  "operador",
  "oponente",
  "oportuno",
  "oposto",
  "orar",
  "orbitar",
  "ordem",
  "ordinal",
  "orfanato",
  "orgasmo",
  "orgulho",
  "oriental",
  "origem",
  "oriundo",
  "orla",
  "ortodoxo",
  "orvalho",
  "oscilar",
  "ossada",
  "osso",
  "ostentar",
  "otimismo",
  "ousadia",
  "outono",
  "outubro",
  "ouvido",
  "ovelha",
  "ovular",
  "oxidar",
  "oxigenar",
  "pacato",
  "paciente",
  "pacote",
  "pactuar",
  "padaria",
  "padrinho",
  "pagar",
  "pagode",
  "painel",
  "pairar",
  "paisagem",
  "palavra",
  "palestra",
  "palheta",
  "palito",
  "palmada",
  "palpitar",
  "pancada",
  "panela",
  "panfleto",
  "panqueca",
  "pantanal",
  "papagaio",
  "papelada",
  "papiro",
  "parafina",
  "parcial",
  "pardal",
  "parede",
  "partida",
  "pasmo",
  "passado",
  "pastel",
  "patamar",
  "patente",
  "patinar",
  "patrono",
  "paulada",
  "pausar",
  "peculiar",
  "pedalar",
  "pedestre",
  "pediatra",
  "pedra",
  "pegada",
  "peitoral",
  "peixe",
  "pele",
  "pelicano",
  "penca",
  "pendurar",
  "peneira",
  "penhasco",
  "pensador",
  "pente",
  "perceber",
  "perfeito",
  "pergunta",
  "perito",
  "permitir",
  "perna",
  "perplexo",
  "persiana",
  "pertence",
  "peruca",
  "pescado",
  "pesquisa",
  "pessoa",
  "petiscar",
  "piada",
  "picado",
  "piedade",
  "pigmento",
  "pilastra",
  "pilhado",
  "pilotar",
  "pimenta",
  "pincel",
  "pinguim",
  "pinha",
  "pinote",
  "pintar",
  "pioneiro",
  "pipoca",
  "piquete",
  "piranha",
  "pires",
  "pirueta",
  "piscar",
  "pistola",
  "pitanga",
  "pivete",
  "planta",
  "plaqueta",
  "platina",
  "plebeu",
  "plumagem",
  "pluvial",
  "pneu",
  "poda",
  "poeira",
  "poetisa",
  "polegada",
  "policiar",
  "poluente",
  "polvilho",
  "pomar",
  "pomba",
  "ponderar",
  "pontaria",
  "populoso",
  "porta",
  "possuir",
  "postal",
  "pote",
  "poupar",
  "pouso",
  "povoar",
  "praia",
  "prancha",
  "prato",
  "praxe",
  "prece",
  "predador",
  "prefeito",
  "premiar",
  "prensar",
  "preparar",
  "presilha",
  "pretexto",
  "prevenir",
  "prezar",
  "primata",
  "princesa",
  "prisma",
  "privado",
  "processo",
  "produto",
  "profeta",
  "proibido",
  "projeto",
  "prometer",
  "propagar",
  "prosa",
  "protetor",
  "provador",
  "publicar",
  "pudim",
  "pular",
  "pulmonar",
  "pulseira",
  "punhal",
  "punir",
  "pupilo",
  "pureza",
  "puxador",
  "quadra",
  "quantia",
  "quarto",
  "quase",
  "quebrar",
  "queda",
  "queijo",
  "quente",
  "querido",
  "quimono",
  "quina",
  "quiosque",
  "rabanada",
  "rabisco",
  "rachar",
  "racionar",
  "radial",
  "raiar",
  "rainha",
  "raio",
  "raiva",
  "rajada",
  "ralado",
  "ramal",
  "ranger",
  "ranhura",
  "rapadura",
  "rapel",
  "rapidez",
  "raposa",
  "raquete",
  "raridade",
  "rasante",
  "rascunho",
  "rasgar",
  "raspador",
  "rasteira",
  "rasurar",
  "ratazana",
  "ratoeira",
  "realeza",
  "reanimar",
  "reaver",
  "rebaixar",
  "rebelde",
  "rebolar",
  "recado",
  "recente",
  "recheio",
  "recibo",
  "recordar",
  "recrutar",
  "recuar",
  "rede",
  "redimir",
  "redonda",
  "reduzida",
  "reenvio",
  "refinar",
  "refletir",
  "refogar",
  "refresco",
  "refugiar",
  "regalia",
  "regime",
  "regra",
  "reinado",
  "reitor",
  "rejeitar",
  "relativo",
  "remador",
  "remendo",
  "remorso",
  "renovado",
  "reparo",
  "repelir",
  "repleto",
  "repolho",
  "represa",
  "repudiar",
  "requerer",
  "resenha",
  "resfriar",
  "resgatar",
  "residir",
  "resolver",
  "respeito",
  "ressaca",
  "restante",
  "resumir",
  "retalho",
  "reter",
  "retirar",
  "retomada",
  "retratar",
  "revelar",
  "revisor",
  "revolta",
  "riacho",
  "rica",
  "rigidez",
  "rigoroso",
  "rimar",
  "ringue",
  "risada",
  "risco",
  "risonho",
  "robalo",
  "rochedo",
  "rodada",
  "rodeio",
  "rodovia",
  "roedor",
  "roleta",
  "romano",
  "roncar",
  "rosado",
  "roseira",
  "rosto",
  "rota",
  "roteiro",
  "rotina",
  "rotular",
  "rouco",
  "roupa",
  "roxo",
  "rubro",
  "rugido",
  "rugoso",
  "ruivo",
  "rumo",
  "rupestre",
  "russo",
  "sabor",
  "saciar",
  "sacola",
  "sacudir",
  "sadio",
  "safira",
  "saga",
  "sagrada",
  "saibro",
  "salada",
  "saleiro",
  "salgado",
  "saliva",
  "salpicar",
  "salsicha",
  "saltar",
  "salvador",
  "sambar",
  "samurai",
  "sanar",
  "sanfona",
  "sangue",
  "sanidade",
  "sapato",
  "sarda",
  "sargento",
  "sarjeta",
  "saturar",
  "saudade",
  "saxofone",
  "sazonal",
  "secar",
  "secular",
  "seda",
  "sedento",
  "sediado",
  "sedoso",
  "sedutor",
  "segmento",
  "segredo",
  "segundo",
  "seiva",
  "seleto",
  "selvagem",
  "semanal",
  "semente",
  "senador",
  "senhor",
  "sensual",
  "sentado",
  "separado",
  "sereia",
  "seringa",
  "serra",
  "servo",
  "setembro",
  "setor",
  "sigilo",
  "silhueta",
  "silicone",
  "simetria",
  "simpatia",
  "simular",
  "sinal",
  "sincero",
  "singular",
  "sinopse",
  "sintonia",
  "sirene",
  "siri",
  "situado",
  "soberano",
  "sobra",
  "socorro",
  "sogro",
  "soja",
  "solda",
  "soletrar",
  "solteiro",
  "sombrio",
  "sonata",
  "sondar",
  "sonegar",
  "sonhador",
  "sono",
  "soprano",
  "soquete",
  "sorrir",
  "sorteio",
  "sossego",
  "sotaque",
  "soterrar",
  "sovado",
  "sozinho",
  "suavizar",
  "subida",
  "submerso",
  "subsolo",
  "subtrair",
  "sucata",
  "sucesso",
  "suco",
  "sudeste",
  "sufixo",
  "sugador",
  "sugerir",
  "sujeito",
  "sulfato",
  "sumir",
  "suor",
  "superior",
  "suplicar",
  "suposto",
  "suprimir",
  "surdina",
  "surfista",
  "surpresa",
  "surreal",
  "surtir",
  "suspiro",
  "sustento",
  "tabela",
  "tablete",
  "tabuada",
  "tacho",
  "tagarela",
  "talher",
  "talo",
  "talvez",
  "tamanho",
  "tamborim",
  "tampa",
  "tangente",
  "tanto",
  "tapar",
  "tapioca",
  "tardio",
  "tarefa",
  "tarja",
  "tarraxa",
  "tatuagem",
  "taurino",
  "taxativo",
  "taxista",
  "teatral",
  "tecer",
  "tecido",
  "teclado",
  "tedioso",
  "teia",
  "teimar",
  "telefone",
  "telhado",
  "tempero",
  "tenente",
  "tensor",
  "tentar",
  "termal",
  "terno",
  "terreno",
  "tese",
  "tesoura",
  "testado",
  "teto",
  "textura",
  "texugo",
  "tiara",
  "tigela",
  "tijolo",
  "timbrar",
  "timidez",
  "tingido",
  "tinteiro",
  "tiragem",
  "titular",
  "toalha",
  "tocha",
  "tolerar",
  "tolice",
  "tomada",
  "tomilho",
  "tonel",
  "tontura",
  "topete",
  "tora",
  "torcido",
  "torneio",
  "torque",
  "torrada",
  "torto",
  "tostar",
  "touca",
  "toupeira",
  "toxina",
  "trabalho",
  "tracejar",
  "tradutor",
  "trafegar",
  "trajeto",
  "trama",
  "trancar",
  "trapo",
  "traseiro",
  "tratador",
  "travar",
  "treino",
  "tremer",
  "trepidar",
  "trevo",
  "triagem",
  "tribo",
  "triciclo",
  "tridente",
  "trilogia",
  "trindade",
  "triplo",
  "triturar",
  "triunfal",
  "trocar",
  "trombeta",
  "trova",
  "trunfo",
  "truque",
  "tubular",
  "tucano",
  "tudo",
  "tulipa",
  "tupi",
  "turbo",
  "turma",
  "turquesa",
  "tutelar",
  "tutorial",
  "uivar",
  "umbigo",
  "unha",
  "unidade",
  "uniforme",
  "urologia",
  "urso",
  "urtiga",
  "urubu",
  "usado",
  "usina",
  "usufruir",
  "vacina",
  "vadiar",
  "vagaroso",
  "vaidoso",
  "vala",
  "valente",
  "validade",
  "valores",
  "vantagem",
  "vaqueiro",
  "varanda",
  "vareta",
  "varrer",
  "vascular",
  "vasilha",
  "vassoura",
  "vazar",
  "vazio",
  "veado",
  "vedar",
  "vegetar",
  "veicular",
  "veleiro",
  "velhice",
  "veludo",
  "vencedor",
  "vendaval",
  "venerar",
  "ventre",
  "verbal",
  "verdade",
  "vereador",
  "vergonha",
  "vermelho",
  "verniz",
  "versar",
  "vertente",
  "vespa",
  "vestido",
  "vetorial",
  "viaduto",
  "viagem",
  "viajar",
  "viatura",
  "vibrador",
  "videira",
  "vidraria",
  "viela",
  "viga",
  "vigente",
  "vigiar",
  "vigorar",
  "vilarejo",
  "vinco",
  "vinheta",
  "vinil",
  "violeta",
  "virada",
  "virtude",
  "visitar",
  "visto",
  "vitral",
  "viveiro",
  "vizinho",
  "voador",
  "voar",
  "vogal",
  "volante",
  "voleibol",
  "voltagem",
  "volumoso",
  "vontade",
  "vulto",
  "vuvuzela",
  "xadrez",
  "xarope",
  "xeque",
  "xeretar",
  "xerife",
  "xingar",
  "zangado",
  "zarpar",
  "zebu",
  "zelador",
  "zombar",
  "zoologia",
  "zumbido"
];
var d1e = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
Object.defineProperty(Fn, "__esModule", { value: true });
var vo = {};
Fn.wordlists = vo;
var lr;
var cs = Fn._default = lr;
try {
  cs = Fn._default = lr = n1e, vo.czech = lr;
} catch {
}
try {
  cs = Fn._default = lr = o1e, vo.chinese_simplified = lr;
} catch {
}
try {
  cs = Fn._default = lr = i1e, vo.chinese_traditional = lr;
} catch {
}
try {
  cs = Fn._default = lr = s1e, vo.korean = lr;
} catch {
}
try {
  cs = Fn._default = lr = a1e, vo.french = lr;
} catch {
}
try {
  cs = Fn._default = lr = c1e, vo.italian = lr;
} catch {
}
try {
  cs = Fn._default = lr = u1e, vo.spanish = lr;
} catch {
}
try {
  cs = Fn._default = lr = l1e, vo.japanese = lr, vo.JA = lr;
} catch {
}
try {
  cs = Fn._default = lr = f1e, vo.portuguese = lr;
} catch {
}
try {
  cs = Fn._default = lr = d1e, vo.english = lr, vo.EN = lr;
} catch {
}
Object.defineProperty(as, "__esModule", { value: true });
var h1e = di;
var IB = Jr;
var OB = qm;
var p1e = Rc;
var Jg = Fn;
var Eh = Jg._default;
var ox = "Invalid mnemonic";
var Su = "Invalid entropy";
var g1e = "Invalid mnemonic checksum";
var BB = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function xh(e) {
  return (e || "").normalize("NFKD");
}
function CB(e, t, r) {
  for (; e.length < r; )
    e = t + e;
  return e;
}
function NB(e) {
  return parseInt(e, 2);
}
function UB(e) {
  return e.map((t) => CB(t.toString(2), "0", 8)).join("");
}
function $B(e) {
  const t = e.length * 8 / 32, r = h1e.sha256(Uint8Array.from(e));
  return UB(Array.from(r)).slice(0, t);
}
function RB(e) {
  return "mnemonic" + (e || "");
}
function m1e(e, t) {
  const r = Uint8Array.from(Buffer.from(xh(e), "utf8")), n = Uint8Array.from(Buffer.from(RB(xh(t)), "utf8")), o = OB.pbkdf2(IB.sha512, r, n, {
    c: 2048,
    dkLen: 64
  });
  return Buffer.from(o);
}
as.mnemonicToSeedSync = m1e;
function b1e(e, t) {
  const r = Uint8Array.from(Buffer.from(xh(e), "utf8")), n = Uint8Array.from(Buffer.from(RB(xh(t)), "utf8"));
  return OB.pbkdf2Async(IB.sha512, r, n, {
    c: 2048,
    dkLen: 64
  }).then((o) => Buffer.from(o));
}
var y1e = as.mnemonicToSeed = b1e;
function zB(e, t) {
  if (t = t || Eh, !t)
    throw new Error(BB);
  const r = xh(e).split(" ");
  if (r.length % 3 !== 0)
    throw new Error(ox);
  const n = r.map((u) => {
    const l = t.indexOf(u);
    if (l === -1)
      throw new Error(ox);
    return CB(l.toString(2), "0", 11);
  }).join(""), o = Math.floor(n.length / 33) * 32, i = n.slice(0, o), s = n.slice(o), a = i.match(/(.{1,8})/g).map(NB);
  if (a.length < 16)
    throw new Error(Su);
  if (a.length > 32)
    throw new Error(Su);
  if (a.length % 4 !== 0)
    throw new Error(Su);
  const c = Buffer.from(a);
  if ($B(c) !== s)
    throw new Error(g1e);
  return c.toString("hex");
}
as.mnemonicToEntropy = zB;
function HB(e, t) {
  if (Buffer.isBuffer(e) || (e = Buffer.from(e, "hex")), t = t || Eh, !t)
    throw new Error(BB);
  if (e.length < 16)
    throw new TypeError(Su);
  if (e.length > 32)
    throw new TypeError(Su);
  if (e.length % 4 !== 0)
    throw new TypeError(Su);
  const r = UB(Array.from(e)), n = $B(e), o = (r + n).match(/(.{1,11})/g).map((i) => {
    const s = NB(i);
    return t[s];
  });
  return t[0] === "" ? o.join("") : o.join(" ");
}
var w1e = as.entropyToMnemonic = HB;
function v1e(e, t, r) {
  if (e = e || 128, e % 32 !== 0)
    throw new TypeError(Su);
  return t = t || ((n) => Buffer.from(p1e.randomBytes(n))), HB(t(e / 8), r);
}
as.generateMnemonic = v1e;
function E1e(e, t) {
  try {
    zB(e, t);
  } catch {
    return false;
  }
  return true;
}
as.validateMnemonic = E1e;
function x1e(e) {
  const t = Jg.wordlists[e];
  if (t)
    Eh = t;
  else
    throw new Error('Could not find wordlist for language "' + e + '"');
}
as.setDefaultWordlist = x1e;
function k1e() {
  if (!Eh)
    throw new Error("No Default Wordlist set");
  return Object.keys(Jg.wordlists).filter((e) => e === "JA" || e === "EN" ? false : Jg.wordlists[e].every((t, r) => t === Eh[r]))[0];
}
as.getDefaultWordlist = k1e;
var A1e = Fn;
as.wordlists = A1e.wordlists;
function S1e(e) {
  return Y_(en(e));
}
function ix(e, t) {
  return o8(Gie, e, t);
}
var st = (e) => Dee(e);
function _1e(e) {
  if ($r(e.isPoint(st("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), $r(!e.isPoint(st("030000000000000000000000000000000000000000000000000000000000000005"))), $r(e.isPrivate(st("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), $r(e.isPrivate(st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), $r(!e.isPrivate(st("0000000000000000000000000000000000000000000000000000000000000000"))), $r(!e.isPrivate(st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), $r(!e.isPrivate(st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), $r(xs(e.pointFromScalar(st("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), st("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), e.xOnlyPointAddTweak) {
    $r(e.xOnlyPointAddTweak(st("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
    let t = e.xOnlyPointAddTweak(st("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), st("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
    $r(xs(t.xOnlyPubkey, st("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && t.parity === 1), t = e.xOnlyPointAddTweak(st("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), st("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
  }
  $r(xs(e.pointAddScalar(st("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), st("0000000000000000000000000000000000000000000000000000000000000003")), st("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), $r(xs(e.privateAdd(st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), st("0000000000000000000000000000000000000000000000000000000000000002")), st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), e.privateNegate && ($r(xs(e.privateNegate(st("0000000000000000000000000000000000000000000000000000000000000001")), st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), $r(xs(e.privateNegate(st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), st("0000000000000000000000000000000000000000000000000000000000000003")) === 0), $r(xs(e.privateNegate(st("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), st("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), $r(xs(e.sign(st("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), st("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), st("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), $r(e.verify(st("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), st("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), st("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), e.signSchnorr && $r(xs(e.signSchnorr(st("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), st("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), st("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), st("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), e.verifySchnorr && $r(e.verifySchnorr(st("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), st("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), st("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
}
function $r(e) {
  if (!e)
    throw new Error("ecc library invalid");
}
function V2(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function LB(...e) {
  const t = (i) => i, r = (i, s) => (a) => i(s(a)), n = e.map((i) => i.encode).reduceRight(r, t), o = e.map((i) => i.decode).reduce(r, t);
  return { encode: n, decode: o };
}
function T1e(e) {
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return t.map((r) => {
        if (r < 0 || r >= e.length)
          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${e.length})`);
        return e[r];
      });
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("alphabet.decode input should be array of strings");
      return t.map((r) => {
        if (typeof r != "string")
          throw new Error(`alphabet.decode: not string element=${r}`);
        const n = e.indexOf(r);
        if (n === -1)
          throw new Error(`Unknown letter: "${r}". Allowed: ${e}`);
        return n;
      });
    }
  };
}
function P1e(e = "") {
  if (typeof e != "string")
    throw new Error("join separator should be string");
  return {
    encode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "string")
        throw new Error("join.encode input should be array of strings");
      for (let r of t)
        if (typeof r != "string")
          throw new Error(`join.encode: non-string input=${r}`);
      return t.join(e);
    },
    decode: (t) => {
      if (typeof t != "string")
        throw new Error("join.decode input should be string");
      return t.split(e);
    }
  };
}
function sx(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
  if (!Array.isArray(e))
    throw new Error("convertRadix: data should be array");
  if (!e.length)
    return [];
  let n = 0;
  const o = [], i = Array.from(e);
  for (i.forEach((s) => {
    if (s < 0 || s >= t)
      throw new Error(`Wrong integer: ${s}`);
  }); ; ) {
    let s = 0, a = true;
    for (let c = n; c < i.length; c++) {
      const u = i[c], l = t * s + u;
      if (!Number.isSafeInteger(l) || t * s / t !== s || l - u !== t * s)
        throw new Error("convertRadix: carry overflow");
      s = l % r;
      const f = Math.floor(l / r);
      if (i[c] = f, !Number.isSafeInteger(f) || f * r + s !== l)
        throw new Error("convertRadix: carry overflow");
      if (a)
        f ? a = false : n = c;
      else continue;
    }
    if (o.push(s), a)
      break;
  }
  for (let s = 0; s < e.length - 1 && e[s] === 0; s++)
    o.push(0);
  return o.reverse();
}
function I1e(e) {
  return {
    encode: (t) => {
      if (!V2(t))
        throw new Error("radix.encode input should be Uint8Array");
      return sx(Array.from(t), 2 ** 8, e);
    },
    decode: (t) => {
      if (!Array.isArray(t) || t.length && typeof t[0] != "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(sx(t, e, 2 ** 8));
    }
  };
}
function O1e(e, t) {
  if (typeof t != "function")
    throw new Error("checksum fn should be function");
  return {
    encode(r) {
      if (!V2(r))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!V2(r))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = t(n).slice(0, e), i = r.slice(-e);
      for (let s = 0; s < e; s++)
        if (o[s] !== i[s])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
var B1e = (e) => LB(I1e(58), T1e(e), P1e(""));
var C1e = B1e("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var N1e = (e) => LB(O1e(4, (t) => e(e(t))), C1e);
var U1e = N1e;
function $1e(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? void 0,
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? void 0,
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? void 0
  };
}
function R1e(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function kh(e) {
  var t, r;
  const n = typeof e;
  return n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n === "object" || n === "function" ? (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null" : n;
}
function sa(e, t, r, n, o) {
  const i = o && "input" in o ? o.input : r.value, s = (o == null ? void 0 : o.expected) ?? e.expects ?? null, a = (o == null ? void 0 : o.received) ?? kh(i), c = {
    kind: e.kind,
    type: e.type,
    input: i,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", l = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? R1e(e.reference, c.lang) ?? (u ? (c.lang, void 0) : null) ?? n.message ?? (c.lang, void 0);
  l && (c.message = typeof l == "function" ? l(c) : l), u && (r.typed = false), r.issues ? r.issues.push(c) : r.issues = [c];
}
var z1e = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e) {
    super(e[0].message), Ee(this, "issues"), this.name = "ValiError", this.issues = e;
  }
};
function Vm(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: Vm,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && sa(this, "integer", t, r), t;
    }
  };
}
function b5(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: b5,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && sa(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function Gm(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: Gm,
    async: false,
    expects: `<=${e instanceof Date ? e.toJSON() : kh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && sa(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : kh(r.value)
      }), r;
    }
  };
}
function Wm(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: Wm,
    async: false,
    expects: `>=${e instanceof Date ? e.toJSON() : kh(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && sa(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : kh(r.value)
      }), r;
    }
  };
}
function jB(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: jB,
    async: false,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && sa(this, "format", r, n), r;
    }
  };
}
function Zm(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: Zm,
    expects: e.name,
    async: false,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = true : sa(this, "type", r, n), r;
    }
  };
}
function Xm(e) {
  return {
    kind: "schema",
    type: "number",
    reference: Xm,
    expects: "number",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : sa(this, "type", t, r), t;
    }
  };
}
function G2(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: G2,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (o = r.issues) == null || o.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
      } else
        sa(this, "type", r, n);
      return r;
    }
  };
}
function FB(e) {
  return {
    kind: "schema",
    type: "string",
    reference: FB,
    expects: "string",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = true : sa(this, "type", t, r), t;
    }
  };
}
function Ss(e, t, r) {
  const n = e._run(
    { typed: false, value: t },
    $1e(r)
  );
  if (n.issues)
    throw new z1e(n.issues);
  return n.value;
}
function Vf(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (const n of e)
        if (n.kind !== "metadata") {
          if (t.issues && (n.kind === "schema" || n.kind === "transformation")) {
            t.typed = false;
            break;
          }
          (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = n._run(t, r));
        }
      return t;
    }
  };
}
var W2 = Vf(Xm(), Vm(), Wm(0), Gm(4294967295));
var H1e = Vf(Xm(), Vm(), Wm(0), Gm(2147483647));
var L1e = Vf(Xm(), Vm(), Wm(0), Gm(255));
var Gy = Vf(Zm(Uint8Array), b5(32));
var j1e = Vf(Zm(Uint8Array), b5(33));
var F1e = G2({
  wif: L1e,
  bip32: G2({
    public: W2,
    private: W2
  })
});
var D1e = Vf(FB(), jB(/^(m\/)?(\d+'?\/)*\d+'?$/));
function K1e(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  var n = new Uint8Array(34), o = new DataView(n.buffer);
  return o.setUint8(0, e), n.set(t, 1), n[33] = 1, n;
}
function M1e(e) {
  return of.encode(K1e(e.version, e.privateKey));
}
var ax = U1e(en);
var cx = {
  encode: (e) => ax.encode(e),
  decode: (e) => ax.decode(e)
};
function q1e(e) {
  _1e(e);
  const t = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, r = 2147483648;
  function n(d) {
    return d.length === 32 ? d : d.slice(1, 33);
  }
  class o {
    constructor(m, y) {
      Ee(this, "__D"), Ee(this, "__Q"), Ee(this, "lowR", false), this.__D = m, this.__Q = y;
    }
    get publicKey() {
      return this.__Q === void 0 && (this.__Q = e.pointFromScalar(this.__D, true)), this.__Q;
    }
    get privateKey() {
      return this.__D;
    }
    sign(m, y) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (y === void 0 && (y = this.lowR), y === false)
        return e.sign(m, this.privateKey);
      {
        let b = e.sign(m, this.privateKey);
        const w = new Uint8Array(32);
        let v = 0;
        for (; b[0] > 127; )
          v++, qc(w, 0, v, "LE"), b = e.sign(m, this.privateKey, w);
        return b;
      }
    }
    signSchnorr(m) {
      if (!this.privateKey)
        throw new Error("Missing private key");
      if (!e.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return e.signSchnorr(m, this.privateKey);
    }
    verify(m, y) {
      return e.verify(m, this.publicKey, y);
    }
    verifySchnorr(m, y) {
      if (!e.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e.verifySchnorr(m, this.publicKey.subarray(1, 33), y);
    }
  }
  class i extends o {
    constructor(m, y, b, w, v = 0, k = 0, x = 0) {
      super(m, y), Ee(this, "chainCode"), Ee(this, "network"), Ee(this, "__DEPTH"), Ee(this, "__INDEX"), Ee(this, "__PARENT_FINGERPRINT"), this.chainCode = b, this.network = w, this.__DEPTH = v, this.__INDEX = k, this.__PARENT_FINGERPRINT = x, Ss(F1e, w);
    }
    get depth() {
      return this.__DEPTH;
    }
    get index() {
      return this.__INDEX;
    }
    get parentFingerprint() {
      return this.__PARENT_FINGERPRINT;
    }
    get identifier() {
      return S1e(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get compressed() {
      return true;
    }
    // Private === not neutered
    // Public === neutered
    isNeutered() {
      return this.__D === void 0;
    }
    neutered() {
      return l(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const m = this.network, y = this.isNeutered() ? m.bip32.public : m.bip32.private, b = new Uint8Array(78);
      return qc(b, 0, y, "BE"), R6(b, 4, this.depth), qc(b, 5, this.parentFingerprint, "BE"), qc(b, 9, this.index, "BE"), b.set(this.chainCode, 13), this.isNeutered() ? b.set(this.publicKey, 45) : (R6(b, 45, 0), b.set(this.privateKey, 46)), cx.encode(b);
    }
    toWIF() {
      if (!this.privateKey)
        throw new TypeError("Missing private key");
      return M1e({
        version: this.network.wif,
        privateKey: this.privateKey,
        compressed: true
      });
    }
    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
    derive(m) {
      Ss(W2, m);
      const y = m >= r, b = new Uint8Array(37);
      if (y) {
        if (this.isNeutered())
          throw new TypeError("Missing private key for hardened child key");
        b[0] = 0, b.set(this.privateKey, 1), qc(b, 33, m, "BE");
      } else
        b.set(this.publicKey, 0), qc(b, 33, m, "BE");
      const w = ix(this.chainCode, b), v = w.slice(0, 32), k = w.slice(32);
      if (!e.isPrivate(v))
        return this.derive(m + 1);
      let x;
      if (this.isNeutered()) {
        const _ = e.pointAddScalar(this.publicKey, v, true);
        if (_ === null)
          return this.derive(m + 1);
        x = l(_, k, this.network, this.depth + 1, m, vl(this.fingerprint, 0, "BE"));
      } else {
        const _ = e.privateAdd(this.privateKey, v);
        if (_ == null)
          return this.derive(m + 1);
        x = c(_, k, this.network, this.depth + 1, m, vl(this.fingerprint, 0, "BE"));
      }
      return x;
    }
    deriveHardened(m) {
      if (typeof Ss(H1e, m) == "number")
        return this.derive(m + r);
      throw new TypeError("Expected UInt31, got " + m);
    }
    derivePath(m) {
      Ss(D1e, m);
      let y = m.split("/");
      if (y[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        y = y.slice(1);
      }
      return y.reduce((b, w) => {
        let v;
        return w.slice(-1) === "'" ? (v = parseInt(w.slice(0, -1), 10), b.deriveHardened(v)) : (v = parseInt(w, 10), b.derive(v));
      }, this);
    }
    tweak(m) {
      return this.privateKey ? this.tweakFromPrivateKey(m) : this.tweakFromPublicKey(m);
    }
    tweakFromPublicKey(m) {
      const y = n(this.publicKey);
      if (!e.xOnlyPointAddTweak)
        throw new Error("xOnlyPointAddTweak not supported by ecc library");
      const b = e.xOnlyPointAddTweak(y, m);
      if (!b || b.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const w = Uint8Array.from([
        b.parity === 0 ? 2 : 3
      ]), v = Fee([
        w,
        b.xOnlyPubkey
      ]);
      return new o(void 0, v);
    }
    tweakFromPrivateKey(m) {
      const y = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, b = (() => {
        if (y) {
          if (e.privateNegate)
            return e.privateNegate(this.privateKey);
          throw new Error("privateNegate not supported by ecc library");
        } else return this.privateKey;
      })(), w = e.privateAdd(b, m);
      if (!w)
        throw new Error("Invalid tweaked private key!");
      return new o(w, void 0);
    }
  }
  function s(d, m) {
    const y = cx.decode(d);
    if (y.length !== 78)
      throw new TypeError("Invalid buffer length");
    m = m || t;
    const b = vl(y, 0, "BE");
    if (b !== m.bip32.private && b !== m.bip32.public)
      throw new TypeError("Invalid network version");
    const w = y[4], v = vl(y, 5, "BE");
    if (w === 0 && v !== 0)
      throw new TypeError("Invalid parent fingerprint");
    const k = vl(y, 9, "BE");
    if (w === 0 && k !== 0)
      throw new TypeError("Invalid index");
    const x = y.slice(13, 45);
    let _;
    if (b === m.bip32.private) {
      if (y[45] !== 0)
        throw new TypeError("Invalid private key");
      const I = y.slice(46, 78);
      _ = c(I, x, m, w, k, v);
    } else {
      const I = y.slice(45, 78);
      _ = l(I, x, m, w, k, v);
    }
    return _;
  }
  function a(d, m, y) {
    return c(d, m, y);
  }
  function c(d, m, y, b, w, v) {
    if (Ss(Gy, d), Ss(Gy, m), y = y || t, !e.isPrivate(d))
      throw new TypeError("Private key not in range [1, n)");
    return new i(d, void 0, m, y, b, w, v);
  }
  function u(d, m, y) {
    return l(d, m, y);
  }
  function l(d, m, y, b, w, v) {
    if (Ss(j1e, d), Ss(Gy, m), y = y || t, !e.isPoint(d))
      throw new TypeError("Point is not on the curve");
    return new i(void 0, d, m, y, b, w, v);
  }
  function f(d, m) {
    if (Ss(Zm(Uint8Array), d), d.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (d.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    m = m || t;
    const y = ix(jee("Bitcoin seed"), d), b = y.slice(0, 32), w = y.slice(32);
    return a(b, w, m);
  }
  return {
    fromSeed: f,
    fromBase58: s,
    fromPublicKey: u,
    fromPrivateKey: a
  };
}
var V1e = q1e(r5);
eT(r5);
var G1e = async ({
  contentBase64: e,
  mimeType: t,
  quantity: r = 1,
  inscriptions: n,
  ordinalAddress: o,
  paymentAddress: i,
  paymentPublicKey: s,
  signPsbt: a,
  network: c = Ft
}) => {
  try {
    if (!e && !n)
      throw new Error("contentBase64 or inscriptions is required");
    const u = await X1e(c), l = Buffer.from(u).toString("hex"), f = n || Array(r).fill({
      content: e,
      mimeType: t
    }), d = await W1e({
      inscriptions: f,
      paymentAddress: i,
      paymentPublicKey: s,
      privKey: l,
      network: c
    });
    if (!d || !(d != null && d.psbtHex))
      throw new Error("couldn't get commit tx");
    const m = String(d == null ? void 0 : d.psbtHex), y = String(d == null ? void 0 : d.psbtBase64), b = await a(
      "",
      m,
      y,
      true,
      false,
      c
    );
    if (!b) throw new Error("sign psbt failed");
    const w = Xt.fromHex((b == null ? void 0 : b.signedPsbtHex) || "").extractTransaction(), v = await h5(w.toHex(), c);
    if (!v) throw new Error("commit tx failed");
    return await Z1e({
      inscriptions: f,
      ordinalAddress: o,
      privKey: l,
      commitTxId: v,
      network: c
    });
  } catch (u) {
    throw u;
  }
};
var W1e = async ({
  inscriptions: e,
  paymentAddress: t,
  paymentPublicKey: r,
  privKey: n,
  network: o
}) => {
  try {
    const i = e.length, s = e.reduce(
      (I, P) => I + Buffer.from(P.content).length,
      0
    );
    if (s > 39e4)
      throw new Error("Content size is too large, must be less than 390kb");
    const { fastestFee: a } = await Q1e(o), c = rP(String(n), true), u = new Xt({
      network: Wr(o)
    }), { inscriberAddress: l } = Y1e(
      c,
      e,
      o
    ), f = 5 * 34 * i, d = Math.floor(f * a * i), m = Math.floor(s * a / 3) + 1e3 + 546 * i, y = Math.floor(d + m), b = (await f5(
      t,
      o
    )).filter((I) => I.value > 3e3).sort((I, P) => P.value - I.value), w = Wge(b);
    if (w === 0)
      throw new Error("insufficient funds");
    if (w < y)
      throw new Error("insufficient funds");
    let v = 0;
    const k = await J3(
      t,
      Wr(o)
    );
    let x = 0;
    for await (const I of b) {
      const P = Zge(t, o);
      if (console.log({ paymentAddressType: P }), u.addInput({
        hash: I.txid,
        index: I.vout,
        witnessUtxo: { value: BigInt(I.value), script: k }
      }), P === Ad && u.updateInput(x, {
        tapInternalKey: Td(Buffer.from(r, "hex"))
      }), P === __) {
        let $ = rB(r, o);
        u.updateInput(x, { redeemScript: $ });
      }
      if (x++, v += I.value, v > y)
        break;
    }
    const _ = v - y;
    return u.addOutput({
      value: BigInt(m),
      address: l
    }), _ > 546 && u.addOutput({
      value: BigInt(_),
      address: t
    }), {
      psbtHex: u.toHex(),
      psbtBase64: u.toBase64()
    };
  } catch (i) {
    throw i;
  }
};
var Z1e = async ({
  inscriptions: e,
  ordinalAddress: t,
  commitTxId: r,
  privKey: n,
  network: o,
  isDry: i
}) => {
  try {
    const s = Wie(n), a = rP(n, true), c = DB(a, e), u = zg.encodeScript(c), [l, f] = zg.getPubKey(a, { target: u });
    if (!await J1e(String(r), o))
      throw new Error("ERROR WAITING FOR COMMIT TX");
    const d = await eme(
      r,
      0,
      o
    );
    if (d === 0 || !d)
      throw new Error("ERROR GETTING FIRST INPUT VALUE");
    const m = ui.create({
      vin: [
        {
          txid: r,
          vout: 0,
          prevout: {
            value: d,
            scriptPubKey: ["OP_1", l]
          }
        }
      ],
      vout: [
        ...Array(e.length).fill({
          value: 546,
          scriptPubKey: XI.toScriptPubKey(t)
        })
      ]
    }), y = Pde.taproot.sign(s, m, 0, { extension: u });
    return m.vin[0].witness = [y, c, f], i ? ui.util.getTxid(m) : await h5(ui.encode(m).hex, o);
  } catch (s) {
    throw s;
  }
};
async function X1e(e) {
  const t = crypto.getRandomValues(new Uint8Array(32)), r = w1e(Buffer.from(t)), n = await y1e(r), o = V1e.fromSeed(n, Wr(e));
  return o == null ? void 0 : o.derivePath("m/44'/0'/0'/0/0").privateKey;
}
var DB = (e, t) => {
  const r = new TextEncoder(), n = r.encode("ord"), o = 546, i = (a, c) => {
    let u;
    if (c === Vge) {
      const f = Buffer.from(a, "base64").toString("utf-8");
      u = Buffer.from(f, "utf-8");
    } else
      u = Buffer.from(a, "base64");
    const l = [];
    for (let f = 0; f < u.length; f += 520)
      l.push(u.slice(f, f + 520));
    return l;
  }, s = [e, "OP_CHECKSIG"];
  return t.forEach((a, c) => {
    const { content: u, mimeType: l } = a, f = i(u, l);
    if (s.push("OP_0", "OP_IF", n, "01", r.encode(l), "OP_0"), c > 0) {
      const d = o * (c + 1), m = Buffer.from([d]);
      s.push(Buffer.from([2])), s.push(m);
    }
    s.push(...f.map((d) => d), "OP_ENDIF");
  }), s;
};
var Y1e = (e, t, r = Ft) => {
  const n = DB(e, t), o = zg.encodeScript(n), [i] = zg.getPubKey(e, { target: o });
  return {
    inscriberAddress: XI.p2tr.fromPubKey(
      i,
      u0e(r)
    ),
    tpubkey: i,
    tapleaf: o
  };
};
async function KB(e, t = Ft) {
  try {
    return await mr.get(`${Km(t)}/api/tx/${e}`).then((r) => r.data);
  } catch (r) {
    throw r;
  }
}
async function J1e(e, t) {
  const r = Date.now();
  for (; ; )
    try {
      if (await KB(e, t))
        return console.log("Transaction found in mempool:", e), true;
      if (Date.now() - r > 6e4)
        return false;
      await new Promise((n) => setTimeout(n, 5e3));
    } catch {
      if (Date.now() - r > 6e4)
        return false;
      await new Promise((n) => setTimeout(n, 5e3));
    }
}
var Q1e = async (e) => await mr.get(`${Km(e)}/api/v1/fees/recommended`, {
  headers: {
    "Content-Type": "application/json"
  }
}).then((t) => t.data);
async function eme(e, t, r) {
  const n = Date.now();
  for (; ; )
    try {
      const o = await KB(e, r);
      if (o && o.vout && o.vout.length > 0)
        return Math.floor(o.vout[t].value);
      if (Date.now() - n > 6e4)
        return null;
      await new Promise((i) => setTimeout(i, 5e3));
    } catch (o) {
      if (console.error("Error fetching transaction output value:", o), Date.now() - n > 6e4)
        return null;
      await new Promise((i) => setTimeout(i, 5e3));
    }
}
var Z2 = new Error(
  "The connected wallet doesn't support this method..."
);
var tme = new Error("Wallet is not installed");
var Ko = class {
  constructor(t, r, n) {
    Ee(this, "$store"), Ee(this, "$network"), this.parent = r, this.config = n, this.$store = t.$store, this.$network = t.$network, this.initialize();
  }
  disconnect() {
  }
  async requestAccounts() {
    return [this.$store.get().address, this.$store.get().paymentAddress];
  }
  async switchNetwork(t) {
    throw this.parent.disconnect(), Z2;
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [sr, qr, sn, wn].includes(this.$network.get()) ? this.$network.get() : Ft;
  }
  async getPublicKey() {
    return this.$store.get().publicKey;
  }
  async getBalance() {
    const { paymentAddress: t } = this.$store.get();
    return await qf(t, this.$network.get());
  }
  async getInscriptions(t, r) {
    throw console.log("getInscriptions not implemented", t, r), Z2;
  }
  async pushPsbt(t) {
    let r = t;
    return r.startsWith("02") || (console.log("extracting tx..."), r = Xt.fromHex(r).extractTransaction().toHex()), await h5(r, this.$network.get());
  }
  async inscribe(t, r) {
    return await G1e({
      contentBase64: t,
      mimeType: r,
      ordinalAddress: this.$store.get().address,
      paymentAddress: this.$store.get().paymentAddress,
      paymentPublicKey: this.$store.get().paymentPublicKey,
      signPsbt: this.signPsbt.bind(this),
      network: this.$network.get()
    });
  }
};
var rme = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer");
  }
  get library() {
    return window.unisat;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [cc]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      if (t.provider !== cc) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(cc) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = Zg(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(cc);
  }
  async connect(t) {
    if (!this.library) throw new Error("Unisat isn't installed");
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    await this.getNetwork().then((o) => {
      this.network !== o && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n) throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", cc), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getChain());
    return r ? Zg(r.enum) : this.network;
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (!o) throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var s;
    const a = await ((s = this.library) == null ? void 0 : s.signPsbt(r, {
      autoFinalized: o
    })), c = Xt.fromHex(a);
    if (o && i) {
      const u = await this.pushPsbt(a);
      return {
        signedPsbtHex: c.toHex(),
        signedPsbtBase64: c.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var r;
    const n = BO(t);
    await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
  }
};
var nme = (e) => /^(?:[A-Za-z0-9+\/]{4})*?(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(e);
var ome = (e) => /^[a-fA-F0-9]+$/.test(e);
function ime(e) {
  typeof window < "u" && typeof localStorage < "u" && setTimeout(() => {
    const t = document.createTextNode(" ");
    document.body.appendChild(t), t.remove(), Promise.resolve().then(e);
  }, 1500);
}
function MB() {
  return {
    $store: S_({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      connected: false,
      isConnecting: false,
      isInitializing: true,
      accounts: [],
      balance: void 0,
      hasProvider: {
        [uu]: false,
        [cc]: false,
        [Bs]: false,
        [lu]: false,
        [dc]: false,
        [fc]: false,
        [cu]: false,
        [hc]: true,
        [lc]: false,
        [fu]: false,
        [uc]: false,
        [tu]: false
      }
    }),
    $network: Qw(Ft),
    $library: Qw(void 0)
  };
}
function sme({ network: e }) {
  return {
    network: e
  };
}
var to = [
  "address",
  "paymentAddress",
  "publicKey",
  "paymentPublicKey",
  "balance"
];
var ame = (e) => {
  const t = e.match(/.{1,2}/g);
  if (!t)
    throw new Error("Invalid hex string");
  return Uint8Array.from(t.map((r) => parseInt(r, 16)));
};
function cme(e, t) {
  var r;
  return (r = void 0) == null ? void 0 : r.get(t);
}
function Ym(e) {
  var t, r;
  let n = typeof e;
  return n === "object" && (n = (e && ((r = (t = Object.getPrototypeOf(e)) == null ? void 0 : t.constructor) == null ? void 0 : r.name)) ?? "null"), n === "string" ? `"${e}"` : n === "number" || n === "bigint" || n === "boolean" ? `${e}` : n;
}
function ro(e, t, r, n, o) {
  const i = o && "input" in o ? o.input : r.value, s = (o == null ? void 0 : o.expected) ?? e.expects ?? null, a = (o == null ? void 0 : o.received) ?? Ym(i), c = {
    kind: e.kind,
    type: e.type,
    input: i,
    expected: s,
    received: a,
    message: `Invalid ${t}: ${s ? `Expected ${s} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: o == null ? void 0 : o.path,
    issues: o == null ? void 0 : o.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", l = (o == null ? void 0 : o.message) ?? // @ts-expect-error
  e.message ?? cme(e.reference, c.lang) ?? (u ? (c.lang, void 0) : null) ?? n.message ?? (c.lang, void 0);
  l && (c.message = typeof l == "function" ? l(c) : l), u && (r.typed = false), r.issues ? r.issues.push(c) : r.issues = [c];
}
function ume(e, t) {
  return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function qB(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function ux(e, t) {
  return !e._run({ typed: false, value: t }, { abortEarly: true }).issues;
}
function wi(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: wi,
    expects: "Array",
    async: false,
    item: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = true, r.value = [];
        for (let s = 0; s < i.length; s++) {
          const a = i[s], c = this.item._run({ typed: false, value: a }, n);
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (o = r.issues) == null || o.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), r.value.push(c.value);
        }
      } else
        ro(this, "type", r, n);
      return r;
    }
  };
}
function VB(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: VB,
    expects: "boolean",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "boolean" ? t.typed = true : ro(this, "type", t, r), t;
    }
  };
}
function Du(e, t) {
  const r = Object.entries(e).filter(([n]) => isNaN(+n)).map(([, n]) => n);
  return {
    kind: "schema",
    type: "enum",
    reference: Du,
    expects: r.map(Ym).join(" | ") || "never",
    async: false,
    enum: e,
    options: r,
    message: t,
    _run(n, o) {
      return this.options.includes(n.value) ? n.typed = true : ro(this, "type", n, o), n;
    }
  };
}
function yr(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: yr,
    expects: Ym(e),
    async: false,
    literal: e,
    message: t,
    _run(r, n) {
      return r.value === this.literal ? r.typed = true : ro(this, "type", r, n), r;
    }
  };
}
function GB(e, t) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: GB,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (o = r.issues) == null || o.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
        if (!r.issues || !n.abortEarly)
          for (const s in i)
            ume(i, s) && !(s in this.entries) && (r.value[s] = i[s]);
      } else
        ro(this, "type", r, n);
      return r;
    }
  };
}
function y5(e, t) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: y5,
    expects: "!undefined",
    async: false,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === void 0 ? (ro(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function ol(e) {
  return {
    kind: "schema",
    type: "null",
    reference: ol,
    expects: "null",
    async: false,
    message: e,
    _run(t, r) {
      return t.value === null ? t.typed = true : ro(this, "type", t, r), t;
    }
  };
}
function il(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: il,
    expects: `${e.expects} | null | undefined`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = qB(
        this,
        n,
        o
      )), n.value === null || n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Wi(e) {
  return {
    kind: "schema",
    type: "number",
    reference: Wi,
    expects: "number",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = true : ro(this, "type", t, r), t;
    }
  };
}
function Te(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: Te,
    expects: "Object",
    async: false,
    entries: e,
    message: t,
    _run(r, n) {
      var o;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = true, r.value = {};
        for (const s in this.entries) {
          const a = i[s], c = this.entries[s]._run(
            { typed: false, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: s,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (o = r.issues) == null || o.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = false;
              break;
            }
          }
          c.typed || (r.typed = false), (c.value !== void 0 || s in i) && (r.value[s] = c.value);
        }
      } else
        ro(this, "type", r, n);
      return r;
    }
  };
}
function vi(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: vi,
    expects: `${e.expects} | undefined`,
    async: false,
    wrapped: e,
    _run(n, o) {
      return n.value === void 0 && ("default" in this && (n.value = qB(
        this,
        n,
        o
      )), n.value === void 0) ? (n.typed = true, n) : this.wrapped._run(n, o);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function WB(e, t) {
  return {
    kind: "schema",
    type: "picklist",
    reference: WB,
    expects: e.map(Ym).join(" | ") || "never",
    async: false,
    options: e,
    message: t,
    _run(r, n) {
      return this.options.includes(r.value) ? r.typed = true : ro(this, "type", r, n), r;
    }
  };
}
function $e(e) {
  return {
    kind: "schema",
    type: "string",
    reference: $e,
    expects: "string",
    async: false,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = true : ro(this, "type", t, r), t;
    }
  };
}
function w5(e) {
  return {
    kind: "schema",
    type: "undefined",
    reference: w5,
    expects: "undefined",
    async: false,
    message: e,
    _run(t, r) {
      return t.value === void 0 ? t.typed = true : ro(this, "type", t, r), t;
    }
  };
}
function lx(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function Jm(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: Jm,
    expects: [...new Set(e.map((r) => r.expects))].join(" | ") || "never",
    async: false,
    options: e,
    message: t,
    _run(r, n) {
      let o, i, s;
      for (const a of this.options) {
        const c = a._run(
          { typed: false, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            i ? i.push(c) : i = [c];
          else {
            o = c;
            break;
          }
        else
          s ? s.push(c) : s = [c];
      }
      if (o)
        return o;
      if (i) {
        if (i.length === 1)
          return i[0];
        ro(this, "type", r, n, {
          issues: lx(i)
        }), r.typed = true;
      } else {
        if ((s == null ? void 0 : s.length) === 1)
          return s[0];
        ro(this, "type", r, n, {
          issues: lx(s)
        });
      }
      return r;
    }
  };
}
function Qm() {
  return {
    kind: "schema",
    type: "unknown",
    reference: Qm,
    expects: "unknown",
    async: false,
    _run(e) {
      return e.typed = true, e;
    }
  };
}
var _o = {};
var wf = {};
var On = {};
Object.defineProperty(On, "__esModule", { value: true });
On.decode = On.encode = On.unescape = On.escape = On.pad = void 0;
var ZB = Df;
function v5(e) {
  return `${e}${"=".repeat(4 - (e.length % 4 || 4))}`;
}
On.pad = v5;
function XB(e) {
  return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
On.escape = XB;
function YB(e) {
  return v5(e).replace(/-/g, "+").replace(/_/g, "/");
}
On.unescape = YB;
function lme(e) {
  return XB((0, ZB.fromByteArray)(new TextEncoder().encode(e)));
}
On.encode = lme;
function fme(e) {
  return new TextDecoder().decode((0, ZB.toByteArray)(v5(YB(e))));
}
On.decode = fme;
var eb = {};
var tb = {};
var vf = {};
Object.defineProperty(vf, "__esModule", { value: true });
vf.joseToDer = vf.derToJose = void 0;
var JB = Df;
var QB = On;
function Wy(e) {
  return (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
}
var dme = {
  ES256: Wy(256),
  ES384: Wy(384),
  ES512: Wy(521)
};
function eC(e) {
  const t = dme[e];
  if (t)
    return t;
  throw new Error(`Unknown algorithm "${e}"`);
}
var Qg = 128;
var tC = 0;
var hme = 32;
var pme = 16;
var gme = 2;
var rC = pme | hme | tC << 6;
var e1 = gme | tC << 6;
function nC(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return (0, JB.toByteArray)((0, QB.pad)(e));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function mme(e, t) {
  const r = nC(e), n = eC(t), o = n + 1, i = r.length;
  let s = 0;
  if (r[s++] !== rC)
    throw new Error('Could not find expected "seq"');
  let a = r[s++];
  if (a === (Qg | 1) && (a = r[s++]), i - s < a)
    throw new Error(`"seq" specified length of "${a}", only "${i - s}" remaining`);
  if (r[s++] !== e1)
    throw new Error('Could not find expected "int" for "r"');
  const c = r[s++];
  if (i - s - 2 < c)
    throw new Error(`"r" specified length of "${c}", only "${i - s - 2}" available`);
  if (o < c)
    throw new Error(`"r" specified length of "${c}", max of "${o}" is acceptable`);
  const u = s;
  if (s += c, r[s++] !== e1)
    throw new Error('Could not find expected "int" for "s"');
  const l = r[s++];
  if (i - s !== l)
    throw new Error(`"s" specified length of "${l}", expected "${i - s}"`);
  if (o < l)
    throw new Error(`"s" specified length of "${l}", max of "${o}" is acceptable`);
  const f = s;
  if (s += l, s !== i)
    throw new Error(`Expected to consume entire array, but "${i - s}" bytes remain`);
  const d = n - c, m = n - l, y = new Uint8Array(d + c + m + l);
  for (s = 0; s < d; ++s)
    y[s] = 0;
  y.set(r.subarray(u + Math.max(-d, 0), u + c), s), s = n;
  for (const b = s; s < b + m; ++s)
    y[s] = 0;
  return y.set(r.subarray(f + Math.max(-m, 0), f + l), s), (0, QB.escape)((0, JB.fromByteArray)(y));
}
vf.derToJose = mme;
function fx(e, t, r) {
  let n = 0;
  for (; t + n < r && e[t + n] === 0; )
    ++n;
  return e[t + n] >= Qg && --n, n;
}
function bme(e, t) {
  e = nC(e);
  const r = eC(t), n = e.length;
  if (n !== r * 2)
    throw new TypeError(`"${t}" signatures must be "${r * 2}" bytes, saw "${n}"`);
  const o = fx(e, 0, r), i = fx(e, r, e.length), s = r - o, a = r - i, c = 2 + s + 1 + 1 + a, u = c < Qg, l = new Uint8Array((u ? 2 : 3) + c);
  let f = 0;
  return l[f++] = rC, u ? l[f++] = c : (l[f++] = Qg | 1, l[f++] = c & 255), l[f++] = e1, l[f++] = s, o < 0 ? (l[f++] = 0, l.set(e.subarray(0, r), f), f += r) : (l.set(e.subarray(o, r), f), f += r - o), l[f++] = e1, l[f++] = a, i < 0 ? (l[f++] = 0, l.set(e.subarray(r), f)) : l.set(e.subarray(r + i), f), l;
}
vf.joseToDer = bme;
var Ys = {};
Object.defineProperty(Ys, "__esModule", { value: true });
Ys.InvalidTokenError = Ys.MissingParametersError = void 0;
var yme = class extends Error {
  constructor(t) {
    super(), this.name = "MissingParametersError", this.message = t || "";
  }
};
Ys.MissingParametersError = yme;
var wme = class extends Error {
  constructor(t) {
    super(), this.name = "InvalidTokenError", this.message = t || "";
  }
};
Ys.InvalidTokenError = wme;
Object.defineProperty(tb, "__esModule", { value: true });
tb.SECP256K1Client = void 0;
var vme = Om;
var Eme = di;
var E0 = G8;
var dx = vf;
var hx = Ys;
var px = Rc;
E0.utils.hmacSha256Sync = (e, ...t) => {
  const r = vme.hmac.create(Eme.sha256, e);
  return t.forEach((n) => r.update(n)), r.digest();
};
var oC = class {
  static derivePublicKey(t, r = true) {
    return t.length === 66 && (t = t.slice(0, 64)), t.length < 64 && (t = t.padStart(64, "0")), (0, px.bytesToHex)(E0.getPublicKey(t, r));
  }
  static signHash(t, r, n = "jose") {
    if (!t || !r)
      throw new hx.MissingParametersError("a signing input hash and private key are all required");
    const o = E0.signSync(t, r.slice(0, 64), {
      der: true,
      canonical: false
    });
    if (n === "der")
      return (0, px.bytesToHex)(o);
    if (n === "jose")
      return (0, dx.derToJose)(o, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(t) {
    return (0, dx.joseToDer)(t, "ES256");
  }
  static verifyHash(t, r, n) {
    if (!t || !r || !n)
      throw new hx.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return E0.verify(r, t, n, { strict: false });
  }
};
tb.SECP256K1Client = oC;
oC.algorithmName = "ES256K";
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.cryptoClients = e.SECP256K1Client = void 0;
  const t = tb;
  Object.defineProperty(e, "SECP256K1Client", { enumerable: true, get: function() {
    return t.SECP256K1Client;
  } });
  const r = {
    ES256K: t.SECP256K1Client
  };
  e.cryptoClients = r;
})(eb);
var Ku = {};
var xme = Ye && Ye.__awaiter || function(e, t, r, n) {
  function o(i) {
    return i instanceof r ? i : new r(function(s) {
      s(i);
    });
  }
  return new (r || (r = Promise))(function(i, s) {
    function a(l) {
      try {
        u(n.next(l));
      } catch (f) {
        s(f);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (f) {
        s(f);
      }
    }
    function u(l) {
      l.done ? i(l.value) : o(l.value).then(a, c);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(Ku, "__esModule", { value: true });
Ku.hashSha256Async = Ku.hashSha256 = void 0;
var kme = di;
function iC(e) {
  return (0, kme.sha256)(e);
}
Ku.hashSha256 = iC;
function Ame(e) {
  return xme(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const t = typeof e == "string" ? new TextEncoder().encode(e) : e, r = yield crypto.subtle.digest("SHA-256", t);
        return new Uint8Array(r);
      } else {
        const t = pO;
        if (!t.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(t.createHash("sha256").update(e).digest());
      }
    } catch (t) {
      return console.log(t), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(iC(e));
    }
  });
}
Ku.hashSha256Async = Ame;
var Sme = Ye && Ye.__awaiter || function(e, t, r, n) {
  function o(i) {
    return i instanceof r ? i : new r(function(s) {
      s(i);
    });
  }
  return new (r || (r = Promise))(function(i, s) {
    function a(l) {
      try {
        u(n.next(l));
      } catch (f) {
        s(f);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (f) {
        s(f);
      }
    }
    function u(l) {
      l.done ? i(l.value) : o(l.value).then(a, c);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
Object.defineProperty(wf, "__esModule", { value: true });
wf.TokenSigner = wf.createUnsecuredToken = void 0;
var X2 = On;
var gx = eb;
var _me = Ys;
var mx = Ku;
function Y2(e, t) {
  const r = [], n = X2.encode(JSON.stringify(t));
  r.push(n);
  const o = X2.encode(JSON.stringify(e));
  return r.push(o), r.join(".");
}
function Tme(e) {
  return Y2(e, { typ: "JWT", alg: "none" }) + ".";
}
wf.createUnsecuredToken = Tme;
var Pme = class {
  constructor(t, r) {
    if (!(t && r))
      throw new _me.MissingParametersError("a signing algorithm and private key are required");
    if (typeof t != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (t = t.toUpperCase(), !gx.cryptoClients.hasOwnProperty(t))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = gx.cryptoClients[t], this.rawPrivateKey = r;
  }
  header(t = {}) {
    const r = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, r, t);
  }
  sign(t, r = false, n = {}) {
    const o = this.header(n), i = Y2(t, o), s = (0, mx.hashSha256)(i);
    return this.createWithSignedHash(t, r, o, i, s);
  }
  signAsync(t, r = false, n = {}) {
    return Sme(this, void 0, void 0, function* () {
      const o = this.header(n), i = Y2(t, o), s = yield (0, mx.hashSha256Async)(i);
      return this.createWithSignedHash(t, r, o, i, s);
    });
  }
  createWithSignedHash(t, r, n, o, i) {
    const s = this.cryptoClient.signHash(i, this.rawPrivateKey);
    return r ? {
      header: [X2.encode(JSON.stringify(n))],
      payload: JSON.stringify(t),
      signature: [s]
    } : [o, s].join(".");
  }
};
wf.TokenSigner = Pme;
var rb = {};
Object.defineProperty(rb, "__esModule", { value: true });
rb.TokenVerifier = void 0;
var Ime = On;
var bx = eb;
var Ome = Ys;
var Qp = Ku;
var Bme = class {
  constructor(t, r) {
    if (!(t && r))
      throw new Ome.MissingParametersError("a signing algorithm and public key are required");
    if (typeof t != "string")
      throw "signing algorithm parameter must be a string";
    if (t = t.toUpperCase(), !bx.cryptoClients.hasOwnProperty(t))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = bx.cryptoClients[t], this.rawPublicKey = r;
  }
  verify(t) {
    return typeof t == "string" ? this.verifyCompact(t, false) : typeof t == "object" ? this.verifyExpanded(t, false) : false;
  }
  verifyAsync(t) {
    return typeof t == "string" ? this.verifyCompact(t, true) : typeof t == "object" ? this.verifyExpanded(t, true) : Promise.resolve(false);
  }
  verifyCompact(t, r) {
    const n = t.split("."), o = n[0] + "." + n[1], i = (s) => {
      const a = this.cryptoClient.loadSignature(n[2]);
      return this.cryptoClient.verifyHash(s, a, this.rawPublicKey);
    };
    if (r)
      return (0, Qp.hashSha256Async)(o).then((s) => i(s));
    {
      const s = (0, Qp.hashSha256)(o);
      return i(s);
    }
  }
  verifyExpanded(t, r) {
    const n = [t.header.join("."), Ime.encode(t.payload)].join(".");
    let o = true;
    const i = (s) => (t.signature.map((a) => {
      const c = this.cryptoClient.loadSignature(a);
      this.cryptoClient.verifyHash(s, c, this.rawPublicKey) || (o = false);
    }), o);
    if (r)
      return (0, Qp.hashSha256Async)(n).then((s) => i(s));
    {
      const s = (0, Qp.hashSha256)(n);
      return i(s);
    }
  }
};
rb.TokenVerifier = Bme;
var nb = {};
Object.defineProperty(nb, "__esModule", { value: true });
nb.decodeToken = void 0;
var e0 = On;
function Cme(e) {
  if (typeof e == "string") {
    const t = e.split("."), r = JSON.parse(e0.decode(t[0])), n = JSON.parse(e0.decode(t[1])), o = t[2];
    return {
      header: r,
      payload: n,
      signature: o
    };
  } else if (typeof e == "object") {
    if (typeof e.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let t = e.payload;
    e.payload[0] !== "{" && (t = e0.decode(t));
    const r = [];
    return e.header.map((n) => {
      const o = JSON.parse(e0.decode(n));
      r.push(o);
    }), {
      header: r,
      payload: JSON.parse(t),
      signature: e.signature
    };
  }
}
nb.decodeToken = Cme;
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Ye && Ye.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(wf, e), r(rb, e), r(nb, e), r(Ys, e), r(eb, e);
})(_o);
var yx = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const e = Array(256).fill(-1);
  for (let t = 0; t < yx.length; ++t) e[yx.charCodeAt(t)] = t;
})();
var wx;
var Zy;
var t0;
var E5 = (wx = function(e, t) {
  Object.defineProperty(t, "__esModule", { value: true }), t.bech32m = t.bech32 = void 0;
  const r = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {};
  for (let f = 0; f < 32; f++) {
    const d = r.charAt(f);
    n[d] = f;
  }
  function o(f) {
    const d = f >> 25;
    return (33554431 & f) << 5 ^ 996825010 & -(d >> 0 & 1) ^ 642813549 & -(d >> 1 & 1) ^ 513874426 & -(d >> 2 & 1) ^ 1027748829 & -(d >> 3 & 1) ^ 705979059 & -(d >> 4 & 1);
  }
  function i(f) {
    let d = 1;
    for (let m = 0; m < f.length; ++m) {
      const y = f.charCodeAt(m);
      if (y < 33 || y > 126) return "Invalid prefix (" + f + ")";
      d = o(d) ^ y >> 5;
    }
    d = o(d);
    for (let m = 0; m < f.length; ++m) {
      const y = f.charCodeAt(m);
      d = o(d) ^ 31 & y;
    }
    return d;
  }
  function s(f, d, m, y) {
    let b = 0, w = 0;
    const v = (1 << m) - 1, k = [];
    for (let x = 0; x < f.length; ++x) for (b = b << d | f[x], w += d; w >= m; ) w -= m, k.push(b >> w & v);
    if (y) w > 0 && k.push(b << m - w & v);
    else {
      if (w >= d) return "Excess padding";
      if (b << m - w & v) return "Non-zero padding";
    }
    return k;
  }
  function a(f) {
    return s(f, 8, 5, true);
  }
  function c(f) {
    const d = s(f, 5, 8, false);
    if (Array.isArray(d)) return d;
  }
  function u(f) {
    const d = s(f, 5, 8, false);
    if (Array.isArray(d)) return d;
    throw new Error(d);
  }
  function l(f) {
    let d;
    function m(y, b) {
      if (b = b || 90, y.length < 8) return y + " too short";
      if (y.length > b) return "Exceeds length limit";
      const w = y.toLowerCase(), v = y.toUpperCase();
      if (y !== w && y !== v) return "Mixed-case string " + y;
      const k = (y = w).lastIndexOf("1");
      if (k === -1) return "No separator character for " + y;
      if (k === 0) return "Missing prefix for " + y;
      const x = y.slice(0, k), _ = y.slice(k + 1);
      if (_.length < 6) return "Data too short";
      let I = i(x);
      if (typeof I == "string") return I;
      const P = [];
      for (let $ = 0; $ < _.length; ++$) {
        const L = _.charAt($), V = n[L];
        if (V === void 0) return "Unknown character " + L;
        I = o(I) ^ V, $ + 6 >= _.length || P.push(V);
      }
      return I !== d ? "Invalid checksum for " + y : { prefix: x, words: P };
    }
    return d = f === "bech32" ? 1 : 734539939, { decodeUnsafe: function(y, b) {
      const w = m(y, b);
      if (typeof w == "object") return w;
    }, decode: function(y, b) {
      const w = m(y, b);
      if (typeof w == "object") return w;
      throw new Error(w);
    }, encode: function(y, b, w) {
      if (w = w || 90, y.length + 7 + b.length > w) throw new TypeError("Exceeds length limit");
      let v = i(y = y.toLowerCase());
      if (typeof v == "string") throw new Error(v);
      let k = y + "1";
      for (let x = 0; x < b.length; ++x) {
        const _ = b[x];
        if (_ >> 5) throw new Error("Non 5-bit word");
        v = o(v) ^ _, k += r.charAt(_);
      }
      for (let x = 0; x < 6; ++x) v = o(v);
      v ^= d;
      for (let x = 0; x < 6; ++x) k += r.charAt(v >> 5 * (5 - x) & 31);
      return k;
    }, toWords: a, fromWordsUnsafe: c, fromWords: u };
  }
  t.bech32 = l("bech32"), t.bech32m = l("bech32m");
}, wx(Zy = { exports: {} }, Zy.exports), Zy.exports);
(t0 = E5) && t0.__esModule && Object.prototype.hasOwnProperty.call(t0, "default") && t0.default;
E5.bech32m;
E5.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var Ol;
var Bl;
(function(e) {
  e.mainnet = "mainnet", e.testnet = "testnet", e.regtest = "regtest";
})(Ol || (Ol = {})), function(e) {
  e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr";
}(Bl || (Bl = {}));
Bl.p2pkh, Ol.mainnet, Bl.p2pkh, Ol.testnet, Bl.p2sh, Ol.mainnet, Bl.p2sh, Ol.testnet;
var Nme = "accountChange";
Te({
  type: yr(Nme)
});
var Ume = "networkChange";
Te({
  type: yr(Ume)
});
var $me = "disconnect";
Te({
  type: yr($me)
});
async function ob(e) {
  var t;
  const r = await (e == null ? void 0 : e()) || ((t = window.XverseProviders) == null ? void 0 : t.BitcoinProvider) || window.BitcoinProvider;
  if (!r)
    throw new Error("No Bitcoin wallet installed");
  return r;
}
var sC = ((e) => (e.Mainnet = "Mainnet", e.Testnet = "Testnet", e.Signet = "Signet", e))(sC || {});
var x5 = vi(Jm([$e(), Wi(), ol()]));
var io = Te({
  jsonrpc: yr("2.0"),
  method: $e(),
  params: vi(
    Jm([
      wi(Qm()),
      GB({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      ol()
    ])
  ),
  id: x5
});
var Pd = ((e) => (e[e.PARSE_ERROR = -32700] = "PARSE_ERROR", e[e.INVALID_REQUEST = -32600] = "INVALID_REQUEST", e[e.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", e[e.INVALID_PARAMS = -32602] = "INVALID_PARAMS", e[e.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", e[e.USER_REJECTION = -32e3] = "USER_REJECTION", e[e.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", e[e.ACCESS_DENIED = -32002] = "ACCESS_DENIED", e))(Pd || {});
var aC = Te({
  jsonrpc: yr("2.0"),
  result: y5(Qm()),
  id: x5
});
var cC = Te({
  jsonrpc: yr("2.0"),
  error: y5(Qm()),
  id: x5
});
Jm([
  aC,
  cC
]);
var ib = ((e) => (e.Ordinals = "ordinals", e.Payment = "payment", e.Stacks = "stacks", e))(ib || {});
var uC = ((e) => (e.p2pkh = "p2pkh", e.p2sh = "p2sh", e.p2wpkh = "p2wpkh", e.p2wsh = "p2wsh", e.p2tr = "p2tr", e.stacks = "stacks", e))(uC || {});
var Rme = Te({
  address: $e(),
  publicKey: $e(),
  purpose: Du(ib),
  addressType: Du(uC)
});
var lC = async (e) => {
  var t, r;
  const n = await ob(e.getProvider), { purposes: o } = e.payload;
  if (!o)
    throw new Error("Address purposes are required");
  try {
    const i = _o.createUnsecuredToken(e.payload), s = await n.connect(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during address request", i), (r = e.onCancel) == null || r.call(e);
  }
};
var zme = "stx_getAddresses";
var Hme = il(
  Te({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: vi($e())
  })
);
Te({
  ...io.entries,
  ...Te({
    method: yr(zme),
    params: Hme,
    id: $e()
  }).entries
});
var Lme = "stx_signTransaction";
var jme = Te({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: $e(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: vi($e()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: vi(VB())
});
Te({
  ...io.entries,
  ...Te({
    method: yr(Lme),
    params: jme,
    id: $e()
  }).entries
});
var Fme = ["software", "ledger"];
var Dme = WB(Fme);
var Kme = "getInfo";
var Mme = il(ol());
Te({
  /**
   * Version of the wallet.
   */
  version: $e(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: vi(wi($e())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: wi($e())
});
Te({
  ...io.entries,
  ...Te({
    method: yr(Kme),
    params: Mme,
    id: $e()
  }).entries
});
var qme = "getAddresses";
var Vme = Te({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: wi(Du(ib)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: vi($e())
});
Te({
  ...io.entries,
  ...Te({
    method: yr(qme),
    params: Vme,
    id: $e()
  }).entries
});
var Gme = "signMessage";
var lp = ((e) => (e.ECDSA = "ECDSA", e.BIP322 = "BIP322", e))(lp || {});
var Wme = Te({
  /**
   * The address used for signing.
   **/
  address: $e(),
  /**
   * The message to sign.
   **/
  message: $e(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: vi(Du(lp))
});
Te({
  /**
   * The signature of the message.
   */
  signature: $e(),
  /**
   * hash of the message.
   */
  messageHash: $e(),
  /**
   * The address used for signing.
   */
  address: $e(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: Du(lp)
});
Te({
  ...io.entries,
  ...Te({
    method: yr(Gme),
    params: Wme,
    id: $e()
  }).entries
});
var Zme = "getAccounts";
var Xme = Te({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: wi(Du(ib)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: vi($e())
});
wi(
  Te({
    ...Rme.entries,
    ...Te({
      walletType: Dme
    }).entries
  })
);
Te({
  ...io.entries,
  ...Te({
    method: yr(Zme),
    params: Xme,
    id: $e()
  }).entries
});
var Yme = "getBalance";
il(ol());
Te({
  ...io.entries,
  ...Te({
    method: yr(Yme),
    id: $e()
  }).entries
});
var Jme = "wallet_requestPermissions";
var Qme = w5();
yr(true);
Te({
  ...io.entries,
  ...Te({
    method: yr(Jme),
    params: Qme,
    id: $e()
  }).entries
});
var ebe = "wallet_renouncePermissions";
var tbe = w5();
yr(true);
Te({
  ...io.entries,
  ...Te({
    method: yr(ebe),
    params: tbe,
    id: $e()
  }).entries
});
var rbe = "wallet_getWalletType";
il(ol());
Te({
  ...io.entries,
  ...Te({
    method: yr(rbe),
    id: $e()
  }).entries
});
var nbe = "runes_getBalance";
var obe = il(ol());
Te({
  balances: wi(
    Te({
      runeName: $e(),
      amount: $e(),
      divisibility: Wi(),
      symbol: $e(),
      inscriptionId: il($e())
    })
  )
});
Te({
  ...io.entries,
  ...Te({
    method: yr(nbe),
    params: obe,
    id: $e()
  }).entries
});
var ibe = "runes_transfer";
var sbe = Te({
  recipients: wi(
    Te({
      runeName: $e(),
      amount: $e(),
      address: $e()
    })
  )
});
Te({
  ...io.entries,
  ...Te({
    method: yr(ibe),
    params: sbe,
    id: $e()
  }).entries
});
var abe = "ord_getInscriptions";
var cbe = Te({
  offset: Wi(),
  limit: Wi()
});
Te({
  total: Wi(),
  limit: Wi(),
  offset: Wi(),
  inscriptions: wi(
    Te({
      inscriptionId: $e(),
      inscriptionNumber: $e(),
      address: $e(),
      collectionName: vi($e()),
      postage: $e(),
      contentLength: $e(),
      contentType: $e(),
      timestamp: Wi(),
      offset: Wi(),
      genesisTransaction: $e(),
      output: $e()
    })
  )
});
Te({
  ...io.entries,
  ...Te({
    method: yr(abe),
    params: cbe,
    id: $e()
  }).entries
});
var ube = "ord_sendInscriptions";
var lbe = Te({
  transfers: wi(
    Te({
      address: $e(),
      inscriptionId: $e()
    })
  )
});
Te({
  ...io.entries,
  ...Te({
    method: yr(ube),
    params: lbe,
    id: $e()
  }).entries
});
var r0 = async (e, t, r) => {
  var n;
  let o = ((n = window.XverseProviders) == null ? void 0 : n.BitcoinProvider) || window.BitcoinProvider;
  if (!o)
    throw new Error("no wallet provider was found");
  if (!e)
    throw new Error("A wallet method is required");
  const i = await o.request(e, t);
  return ux(cC, i) ? {
    status: "error",
    error: i.error
  } : ux(aC, i) ? {
    status: "success",
    result: i.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: i
    }
  };
};
var fbe = async (e) => {
  var t, r;
  const n = await ob(e.getProvider), { address: o, message: i } = e.payload;
  if (!o)
    throw new Error("An address is required to sign a message");
  if (!i)
    throw new Error("A message to be signed is required");
  try {
    const s = _o.createUnsecuredToken(e.payload), a = await n.signMessage(s);
    (t = e.onFinish) == null || t.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign message request", s), (r = e.onCancel) == null || r.call(e);
  }
};
var dbe = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
});
var hbe = async (e) => {
  var t, r;
  const n = await ob(e.getProvider), { recipients: o, senderAddress: i, network: s, message: a } = e.payload;
  if (!o || o.length === 0)
    throw new Error("At least one recipient is required");
  if (o.some(
    (c) => typeof c.address != "string" || typeof c.amountSats != "bigint"
  ))
    throw new Error("Incorrect recipient format");
  if (!i)
    throw new Error("The sender address is required");
  try {
    const c = dbe(o), u = {
      network: s,
      senderAddress: i,
      message: a,
      recipients: c
    }, l = _o.createUnsecuredToken(u), f = await n.sendBtcTransaction(l);
    (t = e.onFinish) == null || t.call(e, f);
  } catch (c) {
    console.error("[Connect] Error during send BTC transaction request", c), (r = e.onCancel) == null || r.call(e);
  }
};
var pbe = async (e) => {
  var t, r;
  const n = await ob(e.getProvider), { psbtBase64: o, inputsToSign: i } = e.payload;
  if (!o)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!i)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const s = _o.createUnsecuredToken(e.payload), a = await n.signTransaction(s);
    (t = e.onFinish) == null || t.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign transaction request", s), (r = e.onCancel) == null || r.call(e);
  }
};
var vx = (e) => e;
var md = {};
var nc = { addEventListener() {
}, removeEventListener() {
} };
function gbe() {
  try {
    return typeof localStorage < "u";
  } catch {
    return false;
  }
}
gbe() && (md = localStorage);
var mbe = {
  addEventListener(e, t, r) {
    window.addEventListener("storage", t), window.addEventListener("pageshow", r);
  },
  removeEventListener(e, t, r) {
    window.removeEventListener("storage", t), window.removeEventListener("pageshow", r);
  }
};
typeof window < "u" && (nc = mbe);
function sl(e, t = {}, r = {}) {
  let n = r.encode || vx, o = r.decode || vx, i = S_(), s = i.setKey, a = (f, d) => {
    typeof d > "u" ? (r.listen !== false && nc.perKey && nc.removeEventListener(e + f, u, l), delete md[e + f]) : (r.listen !== false && nc.perKey && !(f in i.value) && nc.addEventListener(e + f, u, l), md[e + f] = n(d));
  };
  i.setKey = (f, d) => {
    a(f, d), s(f, d);
  };
  let c = i.set;
  i.set = function(f) {
    for (let d in f)
      a(d, f[d]);
    for (let d in i.value)
      d in f || a(d, void 0);
    c(f);
  };
  function u(f) {
    f.key ? f.key.startsWith(e) && (f.newValue === null ? s(f.key.slice(e.length), void 0) : s(f.key.slice(e.length), o(f.newValue))) : c({});
  }
  function l() {
    let f = { ...t };
    for (let d in md)
      d.startsWith(e) && (f[d.slice(e.length)] = o(md[d]));
    for (let d in f)
      i.setKey(d, f[d]);
  }
  return _Q(i, () => {
    if (l(), r.listen !== false)
      return nc.addEventListener(e, u, l), () => {
        nc.removeEventListener(e, u, l);
        for (let f in i.value)
          nc.removeEventListener(e + f, u, l);
      };
  }), i;
}
var bbe = "XVERSE_CONNECTED_WALLET_STATE";
var ybe = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer"), Ee(this, "$valueStore", sl(
      bbe,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), Ee(this, "removeSubscriber");
  }
  get library() {
    return window == null ? void 0 : window.BitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of to)
      r === "balance" && this.$store.setKey(r, BigInt(t[r])), this.$store.setKey(r, t[r]);
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === uc && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : to.includes(n) && this.$valueStore.setKey(
      n,
      ((i = t[n]) == null ? void 0 : i.toString()) ?? ""
    ));
  }
  initialize() {
    Ao(this.$store, ["provider"], (t) => {
      t.provider !== uc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t, r;
      (t = window == null ? void 0 : window.XverseProviders) != null && t.BitcoinProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [uc]: true
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true }));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && g5(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), qf(n, this.network).then((i) => {
            this.$store.setKey("balance", i);
          });
          return;
        }
      let o = y0(this.network || Ft);
      await lC({
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (i) => {
          const s = u5(i.addresses), a = l5(i.addresses);
          if (!s || !a)
            throw new Error("Could not find the addresses");
          s && a && (this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", a.address), this.$store.setKey("accounts", [
            s.address,
            a.address
          ])), this.$store.setKey(
            "publicKey",
            String(i.addresses[0].publicKey)
          ), this.$store.setKey(
            "paymentPublicKey",
            String(i.addresses[1].publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${uc} wallet`);
        },
        onError: (i) => {
          throw new Error(`Can't lasereyes to ${uc} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [sr, qr, sn, wn].includes(this.network) ? this.network : Ft;
  }
  async sendBTC(t, r) {
    const n = await r0("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    });
    if (n.status === "success")
      return n.result.txid;
    throw n.error.code === Pd.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + n.error.message);
  }
  async signMessage(t, r) {
    const n = r || this.$store.get().paymentAddress, o = await r0("signMessage", {
      address: n,
      message: t,
      protocol: lp.BIP322
    });
    if (o.status === "success")
      return o.result.signature;
    throw o.error.code === Pd.USER_REJECTION ? new Error("User rejected the request") : new Error("Error signing message: " + o.error.message);
  }
  async signPsbt(t, r, n, o, i) {
    try {
      const s = Xt.fromBase64(String(n), {
        network: Wr(this.network)
      }), a = this.$store.get().address, c = this.$store.get().paymentAddress, u = s.data.inputs;
      let l = {};
      const f = {
        [a]: []
      }, d = {
        [c]: []
      };
      let m = 0;
      for await (let x of u) {
        if (x.witnessUtxo === void 0)
          d[c].push(Number(m));
        else {
          const { script: _ } = x.witnessUtxo, I = Xh(
            _,
            Wr(this.network)
          );
          I === c ? d[c].push(Number(m)) : I === a && f[a].push(Number(m));
        }
        m++;
      }
      f[a].length > 0 && (l = { ...l, ...f }), d[c].length > 0 && (l = { ...l, ...d });
      let y, b, w, v;
      const k = await r0("signPsbt", {
        psbt: n,
        broadcast: !!i,
        signInputs: l
      });
      if (k.status === "success")
        v = Xt.fromBase64(k.result.psbt, {
          network: Wr(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === Pd.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), b = v.toHex(), w = v.toBase64()) : (b = v.toHex(), w = v.toBase64()), {
        signedPsbtHex: b,
        signedPsbtBase64: w,
        txId: y
      };
    } catch (s) {
      throw console.error(s), s;
    }
  }
  async getInscriptions(t, r) {
    const n = await r0("ord_getInscriptions", {
      offset: t || 0,
      limit: r || 10
    });
    if (n.status === "success")
      return console.log(n.result), n.result.inscriptions;
    throw console.error(n.error), new Error("Error getting inscriptions");
  }
};
var wbe = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer");
  }
  get library() {
    return window.wizz;
  }
  get network() {
    return this.$network.get();
  }
  handleNetworkChanged(t) {
    this.parent.connect(fu);
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && this.$store.setKey("accounts", t);
  }
  initialize() {
    Ao(this.$store, ["provider"], (t) => {
      t.provider === fu ? this.addLibraryListeners() : this.removeLibraryListeners();
    }), typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [fu]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true }));
  }
  removeLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    );
  }
  addLibraryListeners() {
    var t, r;
    (t = this.library) == null || t.on("networkChanged", this.handleNetworkChanged.bind(this)), (r = this.library) == null || r.on("accountsChanged", this.handleAccountsChanged.bind(this));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeLibraryListeners();
  }
  async connect() {
    if (!this.library) throw tme;
    const t = await this.library.requestAccounts();
    if (!t) throw new Error("No accounts found");
    const r = await this.library.getPublicKey();
    if (!r) throw new Error("No public key found");
    this.$store.setKey("accounts", t), this.$store.setKey("address", t[0]), this.$store.setKey("paymentAddress", t[0]), this.$store.setKey("publicKey", r), this.$store.setKey("paymentPublicKey", r), this.$store.setKey("provider", fu), await this.getNetwork().then((n) => {
      var o;
      n && ((o = this.config) == null ? void 0 : o.network) !== n && this.parent.switchNetwork(n);
    }), this.$store.setKey("connected", true);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getNetwork());
    return r ? KE(r) : void 0;
  }
  async switchNetwork(t) {
    var r;
    if (t === wn || t === ia)
      return await this.library.switchNetwork(IO);
    const n = KE(t);
    await ((r = this.library) == null ? void 0 : r.switchNetwork(n)), this.$network.set(t), await this.parent.getBalance();
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (o)
      return o;
    throw new Error("Error sending BTC");
  }
  async signMessage(t) {
    var r;
    return await ((r = this.library) == null ? void 0 : r.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var s;
    const a = await ((s = this.library) == null ? void 0 : s.signPsbt(r, {
      autoFinalized: o,
      broadcast: false
    })), c = Xt.fromHex(a);
    let u;
    return o && i && (u = await this.pushPsbt(a)), {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: u
    };
  }
};
var vbe = "OYL_CONNECTED_WALLET_STATE";
var Ebe = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer"), Ee(this, "$valueStore", sl(
      vbe,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), Ee(this, "removeSubscriber");
  }
  get library() {
    return window.oyl;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of to)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === cu && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : to.includes(n) && this.$valueStore.setKey(
      n,
      ((i = t[n]) == null ? void 0 : i.toString()) ?? ""
    ));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      window != null && window.oyl && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [cu]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      t.provider !== cu ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    if (!this.library) throw new Error("Oyl isn't installed");
    if (p5(this.network))
      throw new Error(`${this.network} is not supported by Oyl`);
    const { nativeSegwit: r, taproot: n } = await this.library.getAddresses();
    if (!r || !n) throw new Error("No accounts found");
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", r.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), this.$store.setKey("provider", cu), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await d5(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.signPsbt("", n, "", true, true);
    if (!o) throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    const n = r || this.$store.get().paymentAddress;
    return (await this.library.signMessage({
      address: n,
      message: t
    })).signature;
  }
  async signPsbt(t, r, n, o, i) {
    const { psbt: s, txid: a } = await this.library.signPsbt({
      psbt: r,
      finalize: o,
      broadcast: i
    }), c = Xt.fromHex(s);
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: a
    };
  }
  async pushPsbt(t) {
    return (await this.library.pushPsbt({ psbt: t })).txid;
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    const { total: t } = await this.library.getBalance();
    return this.$store.setKey("balance", t), t;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork() {
    throw Z2;
  }
};
var xbe = "LEATHER_CONNECTED_WALLET_STATE";
var kbe = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer"), Ee(this, "$valueStore", sl(
      xbe,
      {
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }
    )), Ee(this, "removeSubscriber");
  }
  get library() {
    return window.LeatherProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of to)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === uu && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : to.includes(n) && this.$valueStore.setKey(
      n,
      ((i = t[n]) == null ? void 0 : i.toString()) ?? ""
    ));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      window != null && window.LeatherProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [uu]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      t.provider !== uu ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        publicKey: "",
        paymentAddress: "",
        paymentPublicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    var r;
    if (!this.library) throw new Error("Leather isn't installed");
    const n = await this.library.request("getAddresses");
    if (!n) throw new Error("No accounts found");
    const o = n.result.addresses, i = o.map(
      (c) => c.address
    ), s = o.find(
      (c) => c.type === Ad
    ), a = o.find(
      (c) => c.type === e2
    );
    if (!(s != null && s.publicKey) || !(a != null && a.publicKey))
      throw new Error("No accounts found");
    if ((r = String(s == null ? void 0 : s.address)) != null && r.startsWith("tb") && this.network !== sr && this.network !== qr && this.network !== sn)
      throw new Error(
        `Please switch networks to ${this.network} in the wallet settings.`
      );
    this.$store.setKey("accounts", i), this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", a.address), this.$store.setKey("publicKey", s.publicKey), this.$store.setKey("paymentPublicKey", a.publicKey), this.$store.setKey("provider", uu), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    var n, o;
    const i = await ((n = this.library) == null ? void 0 : n.request("sendTransfer", {
      recipients: [
        {
          address: t,
          amount: r
        }
      ]
    }));
    if ((o = i == null ? void 0 : i.result) != null && o.txid)
      return i.result.txid;
    throw i.error.code === Pd.USER_REJECTION ? new Error("User rejected the request") : new Error("Error sending BTC: " + i.error.message);
  }
  async signMessage(t, r) {
    var n;
    const o = r === this.$store.get().address ? Ad : e2;
    if (r !== this.$store.get().address && r !== this.$store.get().paymentAddress)
      throw new Error("Invalid address to sign message");
    const i = await this.library.request("signMessage", {
      message: t,
      paymentType: o
    });
    return (n = i == null ? void 0 : i.result) == null ? void 0 : n.signature;
  }
  async signPsbt(t, r, n, o, i) {
    const s = {
      hex: r,
      broadcast: false,
      network: this.network
    }, a = (await this.library.request(
      "signPsbt",
      s
    )).result.hex, c = Xt.fromHex(String(a));
    if (o && i) {
      const u = c.finalizeAllInputs(), l = await this.pushPsbt(u.toHex());
      return {
        signedPsbtHex: c.toHex(),
        signedPsbtBase64: c.toBase64(),
        txId: l
      };
    } else if (o) {
      const u = c.finalizeAllInputs();
      return {
        signedPsbtHex: u.toHex(),
        signedPsbtBase64: u.toBase64(),
        txId: void 0
      };
    } else
      return {
        signedPsbtHex: c.toHex(),
        signedPsbtBase64: c.toBase64(),
        txId: void 0
      };
  }
  async getPublicKey() {
    const { result: t } = await this.library.request(
      "getAddresses"
    ), r = t.addresses.find(
      (n) => n.type === Ad
    );
    if (!(r != null && r.publicKey))
      throw new Error("No accounts found");
    return r.publicKey;
  }
  async getBalance() {
    const t = await qf(
      this.$store.get().paymentAddress,
      this.network
    );
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    const { result: t } = await this.library.request(
      "getAddresses"
    ), r = t.addresses.map((n) => n.address);
    return this.$store.setKey("accounts", r), r;
  }
};
var Id = {};
var fC = {};
var _i = {};
var dC = {};
Object.defineProperty(dC, "__esModule", { value: true });
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Ye && Ye.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.getProviderById = e.getProviders = e.getProviderOrThrow = void 0;
  async function n(s) {
    var a, c;
    if (s) {
      const l = await s();
      if (l)
        return l;
    }
    const u = window.OrangeBitcoinProvider || ((a = window.OrangecryptoProviders) == null ? void 0 : a.BitcoinProvider) || ((c = window.OrangeWalletProviders) == null ? void 0 : c.OrangeBitcoinProvider);
    if (!u)
      throw new Error("No Orange Bitcoin wallet installed");
    return u;
  }
  e.getProviderOrThrow = n;
  function o() {
    return window.btc_providers || (window.btc_providers = []), window.btc_providers;
  }
  e.getProviders = o;
  function i(s) {
    var a;
    if (Array.isArray(window.btc_providers)) {
      const c = window.btc_providers.find((u) => u.id === s);
      return (a = c == null ? void 0 : c.id) == null ? void 0 : a.split(".").reduce((u, l) => u == null ? void 0 : u[l], window);
    } else {
      console.log("window.btc_providers is not defined or not an array");
      return;
    }
  }
  e.getProviderById = i, r(dC, e);
})(_i);
var hC = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.AddressType = e.AddressPurpose = void 0, function(t) {
    t.Ordinals = "ordinals", t.Payment = "payment", t.Stacks = "stacks";
  }(e.AddressPurpose || (e.AddressPurpose = {})), function(t) {
    t.p2pkh = "p2pkh", t.p2sh = "p2sh", t.p2wpkh = "p2wpkh", t.p2wsh = "p2wsh", t.p2tr = "p2tr", t.stacks = "stacks";
  }(e.AddressType || (e.AddressType = {}));
})(hC);
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Ye && Ye.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.getAddress = void 0;
  const n = _o, o = _i, i = async (s) => {
    var a, c;
    const u = await (0, o.getProviderOrThrow)(s.getProvider), { purposes: l } = s.payload;
    if (!l)
      throw new Error("Address purposes are required");
    try {
      const f = (0, n.createUnsecuredToken)(s.payload), d = await u.connect(f);
      (a = s.onFinish) == null || a.call(s, d);
    } catch (f) {
      console.error("[Connect] Error during address request", f), (c = s.onCancel) == null || c.call(s);
    }
  };
  e.getAddress = i, r(hC, e);
})(fC);
var pC = {};
var gC = {};
var mC = {};
Object.defineProperty(mC, "__esModule", { value: true });
var bC = {};
Object.defineProperty(bC, "__esModule", { value: true });
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Ye && Ye.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(mC, e), r(bC, e);
})(gC);
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Ye && Ye.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.request = void 0;
  const n = _i, o = async (s, a, c) => {
    var u;
    let l = ((u = window.OrangecryptoProviders) == null ? void 0 : u.BitcoinProvider) || window.OrangeBitcoinProvider;
    if (c && (l = await (0, n.getProviderById)(c)), !l)
      throw new Error("no wallet provider was found");
    if (!s)
      throw new Error("A wallet method is required");
    const f = await l.request(s, a);
    return i(f) ? {
      status: "success",
      result: f.result
    } : {
      status: "error",
      error: f.error
    };
  };
  e.request = o;
  const i = (s) => Object.hasOwn(s, "result") && !!s.result;
  r(gC, e);
})(pC);
var yC = {};
var wC = {};
Object.defineProperty(wC, "__esModule", { value: true });
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(a, c, u, l) {
    l === void 0 && (l = u);
    var f = Object.getOwnPropertyDescriptor(c, u);
    (!f || ("get" in f ? !c.__esModule : f.writable || f.configurable)) && (f = { enumerable: true, get: function() {
      return c[u];
    } }), Object.defineProperty(a, l, f);
  } : function(a, c, u, l) {
    l === void 0 && (l = u), a[l] = c[u];
  }), r = Ye && Ye.__exportStar || function(a, c) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(c, u) && t(c, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.getCapabilities = void 0;
  const n = _o, o = _i, i = (a, c) => {
    const u = (f) => !(!a[f] || c && !c.has(f)), l = {
      request: u("request"),
      connect: u("connect"),
      signMessage: u("signMessage"),
      signTransaction: u("signTransaction"),
      sendBtcTransaction: u("sendBtcTransaction"),
      createInscription: u("createInscription"),
      createRepeatInscriptions: u("createRepeatInscriptions"),
      signMultipleTransactions: u("signMultipleTransactions")
    };
    return Object.entries(l).reduce((f, [d, m]) => m ? [...f, d] : f, []);
  }, s = async (a) => {
    var c, u, l;
    const f = await (0, o.getProviderOrThrow)(a.getProvider), d = (0, n.createUnsecuredToken)(a.payload);
    if (f.getCapabilities)
      try {
        const m = await f.getCapabilities(d);
        (c = a.onFinish) == null || c.call(a, i(f, new Set(m)));
      } catch (m) {
        console.error("[Connect] Error during capabilities request", m);
      }
    try {
      const m = i(f);
      (u = a.onFinish) == null || u.call(a, m);
    } catch (m) {
      console.error("[Connect] Error during capabilities request", m), (l = a.onCancel) == null || l.call(a);
    }
  };
  e.getCapabilities = s, r(wC, e);
})(yC);
var vC = {};
var sb = {};
var fp = {};
Object.defineProperty(fp, "__esModule", { value: true });
fp.validateInscriptionPayload = void 0;
var Abe = 4e5;
var Sbe = 6e4;
var _be = (e) => {
  const { contentType: t, content: r, payloadType: n, network: o, appFeeAddress: i, appFee: s } = e;
  if (!/^[a-z]+\/[a-z0-9\-\.\+]+(?=;.*|$)/.test(t))
    throw new Error("Invalid content type detected");
  if (!r || r.length === 0)
    throw new Error("Empty content not allowed");
  if (!n || n !== "BASE_64" && n !== "PLAIN_TEXT")
    throw new Error("Empty invalid payloadType specified");
  if (r.length > (o.type === "Mainnet" ? Abe : Sbe))
    throw new Error("Content too large");
  if (((i == null ? void 0 : i.length) ?? 0) > 0 && (s ?? 0) <= 0)
    throw new Error("Invalid combination of app fee address and fee provided");
};
fp.validateInscriptionPayload = _be;
Object.defineProperty(sb, "__esModule", { value: true });
sb.createInscription = void 0;
var Tbe = _o;
var Pbe = _i;
var Ibe = fp;
var Obe = async (e) => {
  var t, r;
  const { getProvider: n } = e, o = await (0, Pbe.getProviderOrThrow)(n);
  (0, Ibe.validateInscriptionPayload)(e.payload);
  try {
    const i = (0, Tbe.createUnsecuredToken)(e.payload), s = await o.createInscription(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during create inscription", i), (r = e.onCancel) == null || r.call(e);
  }
};
sb.createInscription = Obe;
var ab = {};
Object.defineProperty(ab, "__esModule", { value: true });
ab.createRepeatInscriptions = void 0;
var Bbe = _i;
var Cbe = _o;
var Nbe = fp;
var Ube = async (e) => {
  var t, r;
  const { getProvider: n } = e, o = await (0, Bbe.getProviderOrThrow)(n);
  (0, Nbe.validateInscriptionPayload)(e.payload);
  try {
    const i = (0, Cbe.createUnsecuredToken)(e.payload), s = await o.createRepeatInscriptions(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during create repeat inscriptions", i), (r = e.onCancel) == null || r.call(e);
  }
};
ab.createRepeatInscriptions = Ube;
var EC = {};
Object.defineProperty(EC, "__esModule", { value: true });
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Ye && Ye.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(sb, e), r(ab, e), r(EC, e);
})(vC);
var xC = {};
var kC = {};
Object.defineProperty(kC, "__esModule", { value: true });
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(s, a, c, u) {
    u === void 0 && (u = c);
    var l = Object.getOwnPropertyDescriptor(a, c);
    (!l || ("get" in l ? !a.__esModule : l.writable || l.configurable)) && (l = { enumerable: true, get: function() {
      return a[c];
    } }), Object.defineProperty(s, u, l);
  } : function(s, a, c, u) {
    u === void 0 && (u = c), s[u] = a[c];
  }), r = Ye && Ye.__exportStar || function(s, a) {
    for (var c in s) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, s, c);
  };
  Object.defineProperty(e, "__esModule", { value: true }), e.signMessage = void 0;
  const n = _o, o = _i, i = async (s) => {
    var a, c;
    const u = await (0, o.getProviderOrThrow)(s.getProvider), { address: l, message: f } = s.payload;
    if (!l)
      throw new Error("An address is required to sign a message");
    if (!f)
      throw new Error("A message to be signed is required");
    try {
      const d = (0, n.createUnsecuredToken)(s.payload), m = await u.signMessage(d);
      (a = s.onFinish) == null || a.call(s, m);
    } catch (d) {
      console.error("[Connect] Error during sign message request", d), (c = s.onCancel) == null || c.call(s);
    }
  };
  e.signMessage = i, r(kC, e);
})(xC);
var AC = {};
var cb = {};
Object.defineProperty(cb, "__esModule", { value: true });
cb.sendBtcTransaction = void 0;
var $be = _o;
var Rbe = _i;
var zbe = (e) => e.map((t) => {
  const { address: r, amountSats: n } = t;
  return {
    address: r,
    amountSats: n.toString()
  };
});
var Hbe = async (e) => {
  var t, r;
  const n = await (0, Rbe.getProviderOrThrow)(e.getProvider), { recipients: o, senderAddress: i, network: s, message: a } = e.payload;
  if (!o || o.length === 0)
    throw new Error("At least one recipient is required");
  if (o.some((c) => typeof c.address != "string" || typeof c.amountSats != "bigint"))
    throw new Error("Incorrect recipient format");
  if (!i)
    throw new Error("The sender address is required");
  try {
    const c = zbe(o), u = {
      network: s,
      senderAddress: i,
      message: a,
      recipients: c
    }, l = (0, $be.createUnsecuredToken)(u), f = await n.sendBtcTransaction(l);
    (t = e.onFinish) == null || t.call(e, f);
  } catch (c) {
    console.error("[Connect] Error during send BTC transaction request", c), (r = e.onCancel) == null || r.call(e);
  }
};
cb.sendBtcTransaction = Hbe;
var ub = {};
Object.defineProperty(ub, "__esModule", { value: true });
ub.signTransaction = void 0;
var Lbe = _o;
var jbe = _i;
var Fbe = async (e) => {
  var t, r;
  const n = await (0, jbe.getProviderOrThrow)(e.getProvider), { psbtBase64: o, inputsToSign: i } = e.payload;
  if (!o)
    throw new Error("A value for psbtBase64 representing the tx hash is required");
  if (!i)
    throw new Error("An array specifying the inputs to be signed by the wallet is required");
  try {
    const s = (0, Lbe.createUnsecuredToken)(e.payload), a = await n.signTransaction(s);
    (t = e.onFinish) == null || t.call(e, a);
  } catch (s) {
    console.error("[Connect] Error during sign transaction request", s), (r = e.onCancel) == null || r.call(e);
  }
};
ub.signTransaction = Fbe;
var lb = {};
Object.defineProperty(lb, "__esModule", { value: true });
lb.signMultipleTransactions = void 0;
var Dbe = _o;
var Kbe = _i;
var Mbe = async (e) => {
  var t, r;
  const n = await (0, Kbe.getProviderOrThrow)(e.getProvider), { psbts: o } = e.payload;
  if (!o || !o.length)
    throw new Error("psbts array is required");
  if (o.length > 100)
    throw new Error("psbts array must contain less than 100 psbts");
  try {
    const i = (0, Dbe.createUnsecuredToken)(e.payload), s = await n.signMultipleTransactions(i);
    (t = e.onFinish) == null || t.call(e, s);
  } catch (i) {
    console.error("[Connect] Error during sign Multiple transactions request", i), (r = e.onCancel) == null || r.call(e);
  }
};
lb.signMultipleTransactions = Mbe;
var SC = {};
Object.defineProperty(SC, "__esModule", { value: true });
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Ye && Ye.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(cb, e), r(ub, e), r(lb, e), r(SC, e);
})(AC);
var _C = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.RpcErrorCode = e.BitcoinNetworkType = void 0, function(t) {
    t.Mainnet = "Mainnet", t.Testnet = "Testnet";
  }(e.BitcoinNetworkType || (e.BitcoinNetworkType = {})), function(t) {
    t[t.PARSE_ERROR = -32700] = "PARSE_ERROR", t[t.INVALID_REQUEST = -32600] = "INVALID_REQUEST", t[t.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", t[t.INVALID_PARAMS = -32602] = "INVALID_PARAMS", t[t.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", t[t.USER_REJECTION = -32e3] = "USER_REJECTION", t[t.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED";
  }(e.RpcErrorCode || (e.RpcErrorCode = {}));
})(_C);
(function(e) {
  var t = Ye && Ye.__createBinding || (Object.create ? function(n, o, i, s) {
    s === void 0 && (s = i);
    var a = Object.getOwnPropertyDescriptor(o, i);
    (!a || ("get" in a ? !o.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return o[i];
    } }), Object.defineProperty(n, s, a);
  } : function(n, o, i, s) {
    s === void 0 && (s = i), n[s] = o[i];
  }), r = Ye && Ye.__exportStar || function(n, o) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(o, i) && t(o, n, i);
  };
  Object.defineProperty(e, "__esModule", { value: true }), r(fC, e), r(pC, e), r(yC, e), r(vC, e), r(xC, e), r(_i, e), r(AC, e), r(_C, e);
})(Id);
var qbe = Cee(Id);
var { signMessage: Vbe, sendBtcTransaction: Gbe } = qbe;
var Wbe = "ORANGE_CONNECTED_WALLET_STATE";
var Zbe = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer"), Ee(this, "$valueStore", sl(
      Wbe,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), Ee(this, "removeSubscriber");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.OrangeWalletProviders) == null ? void 0 : t.OrangeBitcoinProvider;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of to)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === fc && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : to.includes(n) && this.$valueStore.setKey(
      n,
      ((i = t[n]) == null ? void 0 : i.toString()) ?? ""
    ));
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      window != null && window.OrangeBitcoinProvider && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [fc]: true
      }), (r = this.observer) == null || r.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (r) => {
      r.provider !== fc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r) {
        this.restorePersistedValues(), qf(n, this.network).then((s) => {
          this.$store.setKey("balance", s);
        });
        return;
      }
      let o = Dy(this.network || Ft);
      const i = {
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Address for receiving Ordinals and payments",
          network: {
            type: o
          }
        },
        onFinish: (s) => {
          const a = u5(s.addresses), c = l5(s.addresses);
          if (!a || !(c != null && c.address))
            throw new Error("Could not find addresses");
          a && c && (this.$store.setKey("provider", fc), this.$store.setKey("address", a.address), this.$store.setKey("paymentAddress", c.address)), this.$store.setKey("publicKey", String(a.publicKey)), this.$store.setKey(
            "paymentPublicKey",
            String(c.publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${fc} wallet`);
        }
      };
      await Id.getAddress(i), this.$store.setKey("connected", true);
    } catch (o) {
      throw o;
    }
  }
  async getNetwork() {
    const { address: t } = this.$store.get();
    return t.slice(0, 1) === "t" && [sr, qr, sn, wn].includes(this.network) ? this.network : Ft;
  }
  async sendBTC(t, r) {
    let n = "";
    const o = {
      payload: {
        network: {
          type: Dy(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (i) => {
        n = i;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await Gbe(o), n;
  }
  async signMessage(t, r) {
    let n = "";
    const o = r || this.$store.get().paymentAddress, i = {
      payload: {
        network: {
          type: Dy(this.network)
        },
        address: o,
        message: t
      },
      onFinish: (s) => {
        n = s;
      },
      onCancel: () => {
        throw new Error("User canceled the request");
      }
    };
    return await Vbe(i), n;
  }
  async signPsbt(t, r, n, o, i) {
    try {
      const s = Xt.fromBase64(String(n), {
        network: Wr(this.network)
      }), a = this.$store.get().address, c = this.$store.get().paymentAddress, u = s.data.inputs;
      let l = {};
      const f = {
        [a]: []
      }, d = {
        [c]: []
      };
      let m = 0;
      for await (let x of u) {
        if (x.witnessUtxo === void 0)
          d[c].push(Number(m));
        else {
          const { script: _ } = x.witnessUtxo, I = Xh(
            _,
            Wr(this.network)
          );
          I === c ? d[c].push(Number(m)) : I === a && f[a].push(Number(m));
        }
        m++;
      }
      f[a].length > 0 && (l = { ...l, ...f }), d[c].length > 0 && (l = { ...l, ...d });
      let y, b, w, v;
      const k = await Id.request("signPsbt", {
        psbt: n,
        broadcast: !!i,
        signInputs: l
      });
      if (k.status === "success")
        v = Xt.fromBase64(k.result.psbt, {
          network: Wr(this.network)
        }), y = k.result.txid;
      else
        throw k.error.code === Id.RpcErrorCode.USER_REJECTION ? new Error("User canceled the request") : new Error("Error signing psbt");
      if (!v)
        throw new Error("Error signing psbt");
      return o && !y ? (v.finalizeAllInputs(), b = v.toHex(), w = v.toBase64()) : (b = v.toHex(), w = v.toBase64()), {
        signedPsbtHex: b,
        signedPsbtBase64: w,
        txId: y
      };
    } catch (s) {
      throw console.error(s), s;
    }
  }
};
var Xbe = "OKX_CONNECTED_WALLET_STATE";
var Ybe = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer"), Ee(this, "$valueStore", sl(
      Xbe,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), Ee(this, "removeSubscriber");
  }
  get library() {
    var t, r;
    let n;
    return this.network === sr || this.network === qr || this.network === sn || this.network === wn ? n = (t = window == null ? void 0 : window.okxwallet) == null ? void 0 : t.bitcoinTestnet : (this.network === Ft || this.network === ia) && (n = (r = window == null ? void 0 : window.okxwallet) == null ? void 0 : r.bitcoin), n;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of to)
      this.$store.setKey(r, t[r]);
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === lu && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : to.includes(n) && this.$valueStore.setKey(
      n,
      ((i = t[n]) == null ? void 0 : i.toString()) ?? ""
    ));
  }
  initialize() {
    var t;
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var r;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [lu]: true
      }), (r = this.observer) == null || r.disconnect());
    }), (t = this.observer) == null || t.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (r) => {
      r.provider !== lu ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const r = await this.library.connect();
      if (!r) throw new Error("No accounts found");
      this.$store.setKey("address", r.address), this.$store.setKey("paymentAddress", r.address), this.$store.setKey("publicKey", r.publicKey), this.$store.setKey("paymentPublicKey", r.publicKey), this.$store.setKey("accounts", [r]), this.$store.setKey("provider", lu), this.$store.setKey("connected", true);
    } catch (r) {
      throw r;
    }
  }
  async requestAccounts() {
    const t = this.library, r = this.network;
    return r === sr || r === qr || r === wn ? await t.connect() : await t.requestAccounts();
  }
  async getNetwork() {
    const { address: t } = this.$store.get(), r = this.network;
    if (t.slice(0, 1) === "t")
      return r === sr ? sr : r === qr ? qr : r === sn ? sn : r === wn ? wn : sr;
    const n = await this.library.getNetwork();
    return l0e(n);
  }
  async getPublicKey() {
    const t = this.library;
    return await (t == null ? void 0 : t.getPublicKey());
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async sendBTC(t, r) {
    const n = await this.library.sendBitcoin(t, r);
    if (!n) throw new Error("Transaction failed");
    return n;
  }
  async signMessage(t, r) {
    const n = this.library;
    return await (n == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    const s = await this.library.signPsbt(r, {
      autoFinalized: o
    }), a = Xt.fromHex(s);
    if (o && i) {
      const c = await this.pushPsbt(s);
      return {
        signedPsbtHex: a.toHex(),
        signedPsbtBase64: a.toBase64(),
        txId: c
      };
    }
    return {
      signedPsbtHex: a.toHex(),
      signedPsbtBase64: a.toBase64(),
      txId: void 0
    };
  }
};
var Jbe = "MAGIC_EDEN_CONNECTED_WALLET_STATE";
var Qbe = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer"), Ee(this, "$valueStore", sl(
      Jbe,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), Ee(this, "removeSubscriber");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.magicEden) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of to) {
      if (r === "balance") {
        this.$store.setKey(r, BigInt(t[r]));
        continue;
      }
      this.$store.setKey(r, t[r]);
    }
    this.$store.setKey(
      "accounts",
      [t.address, t.paymentAddress].filter(Boolean)
    );
  }
  watchStateChange(t, r, n) {
    var o, i, s;
    t.provider === Bs && (n ? n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : to.includes(n) && this.$valueStore.setKey(
      n,
      ((i = t[n]) == null ? void 0 : i.toString()) ?? ""
    ) : this.$valueStore.set({
      address: t.address,
      paymentAddress: t.paymentAddress,
      paymentPublicKey: t.paymentPublicKey,
      publicKey: t.publicKey,
      balance: ((s = t.balance) == null ? void 0 : s.toString()) ?? ""
    }));
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t, r;
      (t = window == null ? void 0 : window.magicEden) != null && t.bitcoin && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [Bs]: true
      }), (r = this.observer) == null || r.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      t.provider !== Bs ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    const { address: r, paymentAddress: n } = this.$valueStore.get();
    try {
      if (r)
        if (r.startsWith("tb1") && g5(this.network))
          this.disconnect();
        else {
          qf(n, this.network).then((i) => {
            this.$store.setKey("balance", i);
          }), this.restorePersistedValues();
          return;
        }
      if (p5(this.network))
        throw new Error(`${this.network} is not supported by ${Bs}`);
      let o = y0(this.network || Ft);
      await lC({
        getProvider: async () => this.library,
        payload: {
          purposes: ["ordinals", "payment"],
          message: "Connecting with lasereyes",
          network: {
            type: o
          }
        },
        onFinish: (i) => {
          const s = u5(i.addresses), a = l5(i.addresses);
          if (!s || !a)
            throw new Error("No address found");
          s && a && (this.$store.setKey("address", s.address), this.$store.setKey("paymentAddress", a.address), this.$store.setKey("accounts", [
            s.address,
            a.address
          ])), this.$store.setKey(
            "publicKey",
            String(i.addresses[0].publicKey)
          ), this.$store.setKey(
            "paymentPublicKey",
            String(i.addresses[1].publicKey)
          );
        },
        onCancel: () => {
          throw new Error(`User canceled lasereyes to ${Bs} wallet`);
        },
        onError: (i) => {
          throw new Error(`Can't lasereyes to ${Bs} wallet`);
        }
      });
    } catch (o) {
      throw o;
    }
  }
  async sendBTC(t, r) {
    let n;
    if (await hbe({
      getProvider: async () => this.library,
      payload: {
        network: {
          type: y0(this.network)
        },
        recipients: [
          {
            address: t,
            amountSats: BigInt(r)
          }
        ],
        senderAddress: this.$store.get().paymentAddress
      },
      onFinish: (o) => {
        n = o;
      },
      onCancel: () => {
        throw console.error("Request canceled"), new Error("User canceled the request");
      }
    }), !n) throw new Error("Error sending BTC");
    return n.txid;
  }
  async signMessage(t, r) {
    try {
      const n = r || this.$store.get().paymentAddress;
      let o = "";
      return await fbe({
        getProvider: async () => this.library,
        payload: {
          network: {
            type: sC.Mainnet
          },
          address: n,
          message: t,
          protocol: lp.BIP322
        },
        onFinish: (i) => {
          o = i;
        },
        onCancel: () => {
          throw console.error("Request canceled"), new Error("User canceled the request");
        }
      }), o;
    } catch (n) {
      throw n;
    }
  }
  async signPsbt(t, r, n, o, i) {
    console.log("signPsbt", n, o, i);
    const { address: s, paymentAddress: a } = this.$store.get(), c = Xt.fromBase64(String(n), {
      network: Wr(this.network)
    }), u = c.data.inputs, l = [], f = {
      address: s,
      signingIndexes: []
    }, d = {
      address: a,
      signingIndexes: []
    };
    let m = 0;
    for await (let _ of u) {
      const { script: I } = _.witnessUtxo, P = Xh(
        I,
        Wr(this.network)
      );
      P === a ? (d.signingIndexes.push(Number(m)), _.sighashType && (console.log("Updating sigHash for paymentsAddressData"), d.sigHash = _.sighashType)) : P === s && (f.signingIndexes.push(Number(m)), _.sighashType && (console.log("Updating sigHash for ordinalAddressData"), f.sigHash = _.sighashType)), m++;
    }
    f.signingIndexes.length > 0 && l.push(f), d.signingIndexes.length > 0 && l.push(d);
    let y, b, w, v;
    const k = y0(this.network), x = {
      getProvider: async () => this.library,
      payload: {
        network: {
          type: k
        },
        message: "Sign Transaction",
        psbtBase64: c.toBase64(),
        broadcast: i,
        inputsToSign: l
      },
      onFinish: async (_) => {
        _.psbtBase64 && (v = Xt.fromBase64(String(_.psbtBase64), {
          network: Wr(this.network)
        }), b = v.toHex(), w = v.toBase64());
      },
      onCancel: () => {
        throw console.log("Canceled"), new Error("User canceled the request");
      },
      onError: (_) => {
        throw console.log("error", _), _;
      }
    };
    if (await pbe(x), !v)
      throw new Error("signature failed");
    return o || i ? (v.finalizeAllInputs(), b = v.extractTransaction().toHex(), i ? (y = await this.pushPsbt(b), {
      signedPsbtHex: b,
      signedPsbtBase64: w,
      txId: y
    }) : {
      signedPsbtHex: b,
      signedPsbtBase64: w,
      txId: y
    }) : {
      signedPsbtHex: b,
      signedPsbtBase64: w,
      txId: y
    };
  }
};
var eye = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer");
  }
  get library() {
    var t;
    return (t = window == null ? void 0 : window.phantom) == null ? void 0 : t.bitcoin;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [lc]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      t.provider === lc && this.library.requestAccounts().then((r) => {
        this.handleAccountsChanged(r);
      });
    });
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(lc) : this.parent.disconnect());
  }
  async connect(t) {
    if (!this.library) throw new Error("Phantom isn't installed");
    if (p5(this.network))
      throw new Error(`${this.network} is not supported by ${lc}`);
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    this.$store.setKey("accounts", r);
    const n = r.find(
      (i) => i.purpose === "ordinals"
    ), o = r.find(
      (i) => i.purpose === "payment"
    );
    this.$store.setKey("address", n.address), this.$store.setKey("paymentAddress", o.address), this.$store.setKey("publicKey", n.publicKey), this.$store.setKey("paymentPublicKey", o.publicKey), this.$store.setKey("provider", lc), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    return this.$store.get().address.slice(0, 1) === "t" ? sr : Ft;
  }
  async sendBTC(t, r) {
    const { psbtHex: n } = await d5(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.signPsbt("", n, "", true, true);
    if (!o) throw new Error("Error sending BTC");
    return o.txId;
  }
  async signMessage(t, r) {
    var n;
    const o = new TextEncoder().encode(t), i = new Uint8Array(o), s = r || this.$store.get().paymentAddress, a = await ((n = this.library) == null ? void 0 : n.signMessage(s, i)), c = String.fromCharCode(...a.signature);
    return btoa(c);
  }
  async signPsbt(t, r, n, o, i) {
    const { address: s, paymentAddress: a } = this.$store.get(), c = Xt.fromHex(String(r), {
      network: Wr(this.network)
    }).data.inputs, u = [], l = {
      address: s,
      signingIndexes: []
    }, f = {
      address: a,
      signingIndexes: []
    };
    let d = 0;
    for await (let b of c) {
      const { script: w } = b.witnessUtxo, v = Xh(
        w,
        Wr(this.network)
      );
      v === a ? f.signingIndexes.push(Number(d)) : v === s && l.signingIndexes.push(Number(d)), d++;
    }
    l.signingIndexes.length > 0 && u.push(l), f.signingIndexes.length > 0 && u.push(f);
    const m = await this.library.signPSBT(
      ame(r),
      {
        inputsToSign: u
      }
    ), y = Xt.fromBuffer(m);
    if (o && u.forEach((b) => {
      b.signingIndexes.forEach((w) => {
        y.finalizeInput(w);
      });
    }), i) {
      const b = await this.pushPsbt(y.toHex());
      return {
        signedPsbtHex: y.toHex(),
        signedPsbtBase64: y.toBase64(),
        txId: b
      };
    }
    return {
      signedPsbtHex: y.toHex(),
      signedPsbtBase64: y.toBase64(),
      txId: void 0
    };
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
};
var tye = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer");
  }
  get library() {
    return window == null ? void 0 : window.opnet;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [dc]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      if (t.provider !== dc) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(dc) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = Zg(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(dc);
  }
  async connect(t) {
    if (!this.library) throw new Error("OP_NET isn't installed");
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    const n = await this.library.getPublicKey();
    if (!n) throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", dc), await this.getNetwork().then((o) => {
      var i;
      ((i = this.config) == null ? void 0 : i.network) !== o && this.switchNetwork(o);
    }), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getChain());
    return r ? Zg(r.enum) : this.network;
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (!o) throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var s;
    const a = await ((s = this.library) == null ? void 0 : s.signPsbt(r, {
      autoFinalized: o
    })), c = Xt.fromHex(a);
    if (o && i) {
      const u = await this.pushPsbt(a);
      return {
        signedPsbtHex: c.toHex(),
        signedPsbtBase64: c.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    return await this.library.getInscriptions(t, r);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var r;
    const n = BO(t);
    await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
  }
};
var n0 = {};
function hd(e) {
  if (n0[e])
    return console.warn(`Multiple requests for "${e}" detected`), n0[e];
  const t = new Promise((r) => {
    const n = console.log;
    console.log = (...o) => {
      o.length > 0 && typeof o[0] == "string" && (console.log = n, n0[e] = void 0, r(o[0]));
    }, n(
      `Please log a value for "${e}" using 
 console.log('<your-value>') 
 to continue.`
    );
  });
  return n0[e] = t, t;
}
var rye = class {
  async requestAccounts() {
    const t = await hd("address");
    if (!t) throw new Error("No address provided");
    const r = await hd("paymentAddress");
    if (!r) throw new Error("No payment address provided");
    return [t, r];
  }
  async signMessage(t) {
    return console.log("sign this message in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await hd("message to sign");
  }
  async signPsbt(t) {
    return console.log("sign this in sparrow wallet:"), console.log(""), console.log(`${t}`), console.log(""), await hd("signed psbt hex");
  }
  async getPublicKey() {
    const t = await hd("publicKey");
    if (!t) throw new Error("No public key provided");
    return t;
  }
  // TODO: Implement network switching between mainnet and testnet
  async getNetwork() {
    return "mainnet";
  }
  async switchNetwork(t) {
  }
};
var nye = "SPARROW_CONNECTED_WALLET_STATE";
var oye = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer"), Ee(this, "$valueStore", sl(
      nye,
      {
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }
    )), Ee(this, "removeSubscriber");
  }
  get library() {
    return window == null ? void 0 : window.SparrowWalletProvider;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library || (window.SparrowWalletProvider = new rye()), this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [hc]: true
      }), (t = this.observer) == null || t.disconnect();
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      t.provider !== hc ? this.removeSubscriber && (this.$valueStore.set({
        address: "",
        paymentAddress: "",
        paymentPublicKey: "",
        publicKey: "",
        balance: ""
      }), this.removeSubscriber(), this.removeSubscriber = void 0) : this.removeSubscriber = this.$store.subscribe(
        this.watchStateChange.bind(this)
      );
    });
  }
  watchStateChange(t, r, n) {
    var o, i;
    n && t.provider === hc && (n === "balance" ? this.$valueStore.setKey("balance", ((o = t.balance) == null ? void 0 : o.toString()) ?? "") : to.includes(n) && this.$valueStore.setKey(
      n,
      ((i = t[n]) == null ? void 0 : i.toString()) ?? ""
    ));
  }
  restorePersistedValues() {
    const t = this.$valueStore.get();
    for (const r of to)
      this.$store.setKey(r, t[r]);
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect();
  }
  async connect(t) {
    try {
      const { address: r, paymentAddress: n } = this.$valueStore.get();
      if (r && n)
        if (r.startsWith("tb1") && g5(this.network))
          this.disconnect();
        else {
          this.restorePersistedValues(), this.$store.setKey("provider", hc), this.$store.setKey("connected", true);
          return;
        }
      if (!this.library) throw new Error("Sparrow wallet isn't supported");
      const o = await this.library.requestAccounts();
      if (!o) throw new Error("No accounts found");
      await this.getNetwork().then((s) => {
        this.network !== s && this.switchNetwork(this.network);
      });
      const i = await this.library.getPublicKey();
      if (!i) throw new Error("No public key found");
      this.$store.setKey("accounts", o), this.$store.setKey("address", o[0]), this.$store.setKey("paymentAddress", o[1]), this.$store.setKey("publicKey", i), this.$store.setKey("paymentPublicKey", i);
    } catch (r) {
      this.disconnect(), console.error("Error during connect:", r);
    }
  }
  async getNetwork() {
    return this.network;
  }
  async sendBTC(t, r) {
    const { psbtBase64: n } = await d5(
      this.$store.get().address,
      this.$store.get().paymentAddress,
      t,
      r,
      this.$store.get().paymentPublicKey,
      this.network,
      7
    ), o = await this.library.signPsbt(n);
    if (!o) throw new Error("No signed PSBT provided");
    const i = await this.pushPsbt(o);
    if (!i) throw new Error("send failed, no txid returned");
    return i;
  }
  async signMessage(t, r) {
    return await this.library.signMessage(t);
  }
  async signPsbt(t, r, n, o, i) {
    const s = Xt.fromBase64(n), a = await this.library.signPsbt(n);
    if (o && i) {
      const c = await this.pushPsbt(a);
      return {
        signedPsbtHex: a,
        signedPsbtBase64: s.toBase64(),
        txId: c
      };
    }
    return {
      signedPsbtHex: a,
      signedPsbtBase64: s.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    const t = await this.library.getPublicKey();
    return this.$store.setKey("publicKey", t), t;
  }
  async getBalance() {
    const t = await qf(
      this.$store.get().paymentAddress,
      this.network
    );
    return this.$store.setKey("balance", t), t.toString();
  }
  async requestAccounts() {
    return await this.connect(hc), this.$store.get().accounts;
  }
};
var iye = class extends Ko {
  constructor() {
    super(...arguments), Ee(this, "observer");
  }
  get library() {
    return window.glittr;
  }
  get network() {
    return this.$network.get();
  }
  initialize() {
    typeof window < "u" && typeof document < "u" && (this.observer = new window.MutationObserver(() => {
      var t;
      this.library && (this.$store.setKey("hasProvider", {
        ...this.$store.get().hasProvider,
        [tu]: true
      }), (t = this.observer) == null || t.disconnect());
    }), this.observer.observe(document, { childList: true, subtree: true })), Ao(this.$store, ["provider"], (t) => {
      if (t.provider !== tu) {
        this.removeListeners();
        return;
      }
      this.library.getAccounts().then((r) => {
        this.handleAccountsChanged(r);
      }), this.addListeners();
    });
  }
  addListeners() {
    this.library.on("accountsChanged", this.handleAccountsChanged.bind(this)), this.library.on("networkChanged", this.handleNetworkChanged.bind(this));
  }
  removeListeners() {
    var t, r;
    this.library && ((t = this.library) == null || t.removeListener(
      "accountsChanged",
      this.handleAccountsChanged.bind(this)
    ), (r = this.library) == null || r.removeListener(
      "networkChanged",
      this.handleNetworkChanged.bind(this)
    ));
  }
  dispose() {
    var t;
    (t = this.observer) == null || t.disconnect(), this.removeListeners();
  }
  handleAccountsChanged(t) {
    if (!t.length) {
      this.parent.disconnect();
      return;
    }
    this.$store.get().accounts[0] !== t[0] && (this.$store.setKey("accounts", t), t.length > 0 ? this.parent.connect(tu) : this.parent.disconnect());
  }
  handleNetworkChanged(t) {
    const r = DE(t);
    this.network !== r && this.switchNetwork(r), this.parent.connect(tu);
  }
  async connect(t) {
    if (!this.library) throw new Error("Glittr Wallet isn't installed");
    const r = await this.library.requestAccounts();
    if (!r) throw new Error("No accounts found");
    await this.getNetwork().then((o) => {
      this.network !== o && this.switchNetwork(this.network);
    });
    const n = await this.library.getPublicKey();
    if (!n) throw new Error("No public key found");
    this.$store.setKey("accounts", r), this.$store.setKey("address", r[0]), this.$store.setKey("paymentAddress", r[0]), this.$store.setKey("publicKey", n), this.$store.setKey("paymentPublicKey", n), this.$store.setKey("provider", tu), this.$store.setKey("connected", true);
  }
  async getNetwork() {
    var t;
    const r = await ((t = this.library) == null ? void 0 : t.getChain());
    return r ? DE(r.enum) : this.network;
  }
  async sendBTC(t, r) {
    var n;
    const o = await ((n = this.library) == null ? void 0 : n.sendBitcoin(t, r));
    if (!o) throw new Error("Transaction failed");
    return o;
  }
  async signMessage(t, r) {
    var n;
    return await ((n = this.library) == null ? void 0 : n.signMessage(t));
  }
  async signPsbt(t, r, n, o, i) {
    var s;
    const a = await ((s = this.library) == null ? void 0 : s.signPsbt(r, {
      autoFinalized: o
    })), c = Xt.fromHex(a);
    if (o && i) {
      const u = await this.pushPsbt(a);
      return {
        signedPsbtHex: c.toHex(),
        signedPsbtBase64: c.toBase64(),
        txId: u
      };
    }
    return {
      signedPsbtHex: c.toHex(),
      signedPsbtBase64: c.toBase64(),
      txId: void 0
    };
  }
  async getPublicKey() {
    var t;
    return await ((t = this.library) == null ? void 0 : t.getPublicKey());
  }
  async getBalance() {
    return (await this.library.getBalance()).total;
  }
  async getInscriptions(t, r) {
    const n = t || 0, o = r || 10;
    return await this.library.getInscriptions(n, o);
  }
  async requestAccounts() {
    return await this.library.requestAccounts();
  }
  async switchNetwork(t) {
    var r;
    const n = c0e(t);
    await ((r = this.library) == null ? void 0 : r.switchChain(n)), this.$network.set(t);
  }
};
var sye = class {
  constructor(t, r) {
    Ee(this, "$store"), Ee(this, "$network"), Ee(this, "$providerMap"), Ee(this, "disposed", false), this.config = r, this.$store = t.$store, this.$network = t.$network, TQ(this.$store), this.$providerMap = {
      [uu]: new kbe(t, this, r),
      [Bs]: new Qbe(t, this, r),
      [lu]: new Ybe(t, this, r),
      [dc]: new tye(t, this, r),
      [fc]: new Zbe(t, this, r),
      [cu]: new Ebe(t, this, r),
      [lc]: new eye(t, this, r),
      [hc]: new oye(t, this, r),
      [cc]: new rme(t, this, r),
      [uc]: new ybe(t, this, r),
      [fu]: new wbe(t, this, r),
      [tu]: new iye(t, this, r)
    };
  }
  dispose() {
    this.disposed = true, Object.values(this.$providerMap).forEach((t) => t == null ? void 0 : t.dispose());
  }
  initialize() {
    this.$network.listen(this.watchNetworkChange.bind(this)), Ao(this.$store, ["isInitializing"], (t, r) => {
      if (!this.disposed && t.isInitializing !== r.isInitializing)
        return this.handleIsInitializingChanged(t.isInitializing);
    }), this.config && this.config.network && (this.$network.set(this.config.network), this.getNetwork().then((t) => {
      try {
        this.config.network !== t && this.switchNetwork(this.config.network);
      } catch {
        this.disconnect();
      }
    })), ime(() => this.$store.setKey("isInitializing", false));
  }
  handleIsInitializingChanged(t) {
    if (typeof window < "u" && typeof localStorage < "u" && !t) {
      const r = localStorage == null ? void 0 : localStorage.getItem(
        uy
      );
      r && this.connect(r);
    }
  }
  async connect(t) {
    if (this.disposed) {
      console.warn("Client disposed, cannot connect");
      return;
    }
    this.$store.setKey("isConnecting", true);
    try {
      if (localStorage == null || localStorage.setItem(uy, t), !this.$providerMap[t])
        throw new Error("Unsupported wallet provider");
      const r = this.$providerMap[t];
      await (r == null ? void 0 : r.connect(t)), this.$store.setKey("connected", true), this.$store.setKey("provider", t);
    } catch (r) {
      throw console.error("Error during connect:", r), this.$store.setKey("isConnecting", false), this.disconnect(), r;
    } finally {
      this.$store.setKey("isConnecting", false);
    }
  }
  async requestAccounts() {
    var t;
    if (!this.$store.get().provider)
      throw new Error("No wallet provider connected");
    try {
      return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.requestAccounts());
    } catch (r) {
      throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : r;
    }
  }
  disconnect() {
    this.$store.set({
      provider: void 0,
      address: "",
      paymentAddress: "",
      publicKey: "",
      paymentPublicKey: "",
      balance: void 0,
      accounts: [],
      connected: false,
      isConnecting: false,
      isInitializing: false,
      hasProvider: this.$store.get().hasProvider
    }), localStorage == null || localStorage.removeItem(uy);
  }
  async switchNetwork(t) {
    var r;
    try {
      this.$store.get().provider && await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.switchNetwork(
        t
      ));
    } catch (n) {
      throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? (this.disconnect(), new Error(
        "The connected wallet doesn't support programmatic network changes.."
      )) : n;
    }
  }
  watchNetworkChange() {
    this.$store.setKey("balance", void 0);
  }
  async getNetwork() {
    var t;
    return this.$store.get().provider && this.$providerMap[this.$store.get().provider] ? await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getNetwork()) : this.$network.get();
  }
  async sendBTC(t, r) {
    var n;
    if (r <= 0) throw new Error("Amount must be greater than 0");
    if (!Number.isInteger(r)) throw new Error("Amount must be an integer");
    if (!this.$store.get().provider) throw new Error("No wallet connected");
    if (this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.sendBTC(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support sending BTC..."
        ) : o;
      }
  }
  async signMessage(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.signMessage(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support message signing..."
        ) : o;
      }
  }
  async signPsbt(t, r = false, n = false) {
    var o;
    let i, s;
    if (!t) throw new Error("No PSBT provided");
    if (ome(t))
      s = Xt.fromHex(t).toBase64(), i = t;
    else if (nme(t))
      s = t, i = Xt.fromBase64(t).toHex();
    else
      throw new Error("Invalid PSBT format");
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((o = this.$providerMap[this.$store.get().provider]) == null ? void 0 : o.signPsbt(t, i, s, r, n));
      } catch (a) {
        throw a instanceof Error && a.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support PSBT signing..."
        ) : a;
      }
    else
      throw new Error("No wallet provider connected");
  }
  async pushPsbt(t) {
    var r;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((r = this.$providerMap[this.$store.get().provider]) == null ? void 0 : r.pushPsbt(
          t
        ));
      } catch (n) {
        throw n instanceof Error && n.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support PSBT signing..."
        ) : n;
      }
  }
  async inscribe(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.inscribe(
          t,
          r
        ));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error(
          "The connected wallet doesn't support inscribing..."
        ) : o;
      }
  }
  async getPublicKey() {
    var t;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((t = this.$providerMap[this.$store.get().provider]) == null ? void 0 : t.getPublicKey());
      } catch (r) {
        throw r instanceof Error && r.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getPublicKey") : r;
      }
  }
  async getBalance() {
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        const t = await this.$providerMap[this.$store.get().provider].getBalance();
        return this.$store.setKey("balance", BigInt(t)), t;
      } catch (t) {
        throw t instanceof Error && t.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support getBalance") : t;
      }
  }
  async getInscriptions(t, r) {
    var n;
    if (this.$store.get().provider && this.$providerMap[this.$store.get().provider])
      try {
        return await ((n = this.$providerMap[this.$store.get().provider]) == null ? void 0 : n.getInscriptions(t, r));
      } catch (o) {
        throw o instanceof Error && o.message.toLowerCase().includes("not implemented") ? new Error("The connected wallet doesn't support this method") : o;
      }
  }
};
var { $store: aye, $network: cye } = MB();
var No = {
  connect: async () => {
  },
  disconnect: () => {
  },
  getBalance: async () => "",
  getInscriptions: async () => [],
  getNetwork: async () => "",
  getPublicKey: async () => "",
  pushPsbt: async () => "",
  signMessage: async () => "",
  requestAccounts: async () => [],
  sendBTC: async () => "",
  signPsbt: async () => ({
    signedPsbtBase64: "",
    signedPsbtHex: ""
  }),
  switchNetwork: async () => {
  },
  inscribe: async () => ""
};
var TC = (0, import_react.createContext)({
  $store: aye,
  $network: cye,
  client: null,
  methods: No
});
var J2 = Symbol("clean");
var Go = [];
var Qa = 0;
var o0 = 4;
var x0 = 0;
var uye = (e) => {
  let t = [], r = {
    get() {
      return r.lc || r.listen(() => {
      })(), r.value;
    },
    lc: 0,
    listen(n) {
      return r.lc = t.push(n), () => {
        for (let i = Qa + o0; i < Go.length; )
          Go[i] === n ? Go.splice(i, o0) : i += o0;
        let o = t.indexOf(n);
        ~o && (t.splice(o, 1), --r.lc || r.off());
      };
    },
    notify(n, o) {
      x0++;
      let i = !Go.length;
      for (let s of t)
        Go.push(
          s,
          r.value,
          n,
          o
        );
      if (i) {
        for (Qa = 0; Qa < Go.length; Qa += o0)
          Go[Qa](
            Go[Qa + 1],
            Go[Qa + 2],
            Go[Qa + 3]
          );
        Go.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(n) {
      let o = r.value;
      o !== n && (r.value = n, r.notify(o));
    },
    subscribe(n) {
      let o = r.listen(n);
      return n(r.value), o;
    },
    value: e
  };
  return process.env.NODE_ENV !== "production" && (r[J2] = () => {
    t = [], r.lc = 0, r.off();
  }), r;
};
var lye = 3;
var fye = 5;
var gl = 6;
var i0 = 10;
var PC = (e, t, r, n) => (e.events = e.events || {}, e.events[r + i0] || (e.events[r + i0] = n((o) => {
  e.events[r].reduceRight((i, s) => (s(i), i), {
    shared: {},
    ...o
  });
})), e.events[r] = e.events[r] || [], e.events[r].push(t), () => {
  let o = e.events[r], i = o.indexOf(t);
  o.splice(i, 1), o.length || (delete e.events[r], e.events[r + i0](), delete e.events[r + i0]);
});
var dye = (e, t) => PC(e, t, lye, (r) => {
  let n = e.notify;
  return e.notify = (o, i) => {
    let s;
    if (r({ abort: () => {
      s = true;
    }, changed: i, oldValue: o }), !s) return n(o, i);
  }, () => {
    e.notify = n;
  };
});
var hye = 1e3;
var pye = (e, t) => PC(e, (r) => {
  let n = t(r);
  n && e.events[gl].push(n);
}, fye, (r) => {
  let n = e.listen;
  e.listen = (...i) => (!e.lc && !e.active && (e.active = true, r()), n(...i));
  let o = e.off;
  if (e.events[gl] = [], e.off = () => {
    o(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = false;
        for (let i of e.events[gl]) i();
        e.events[gl] = [];
      }
    }, hye);
  }, process.env.NODE_ENV !== "production") {
    let i = e[J2];
    e[J2] = () => {
      for (let s of e.events[gl]) s();
      e.events[gl] = [], e.active = false, i();
    };
  }
  return () => {
    e.listen = n, e.off = o;
  };
});
var gye = (e, t, r) => {
  Array.isArray(e) || (e = [e]);
  let n, o, i = () => {
    if (o === x0) return;
    o = x0;
    let l = e.map((f) => f.get());
    if (!n || l.some((f, d) => f !== n[d])) {
      n = l;
      let f = t(...l);
      f && f.then && f.t ? f.then((d) => {
        n === l && s.set(d);
      }) : (s.set(f), o = x0);
    }
  }, s = uye(void 0), a = s.get;
  s.get = () => (i(), a());
  let c, u = () => {
    clearTimeout(c), c = setTimeout(i);
  };
  return pye(s, () => {
    let l = e.map((f) => f.listen(u));
    return i(), () => {
      for (let f of l) f();
    };
  }), s;
};
var mye = (e, t) => gye(e, t);
var bye = (e) => {
  e.listen(() => {
  });
};
function yye(e, t, r) {
  let n = /* @__PURE__ */ new Set([...t, void 0]);
  return e.listen((o, i, s) => {
    n.has(s) && r(o, i, s);
  });
}
function wye(e, t = {}) {
  let r = (0, import_react.useCallback)(
    (o) => t.keys ? yye(e, t.keys, o) : e.listen(o),
    [t.keys, e]
  ), n = e.get.bind(e);
  return (0, import_react.useSyncExternalStore)(r, n, n);
}
function Ex(e, t) {
  return Object.keys(e).every(function(r) {
    return Object.prototype.hasOwnProperty.call(t, r) && (t[r] === e[r] || typeof e[r] == "number" && typeof t[r] == "number" && isNaN(t[r]) && isNaN(e[r]));
  });
}
function vye(e, t) {
  return typeof e == "object" && typeof t == "object" ? Ex(e, t) && Ex(t, e) : e === t;
}
function h2e(e) {
  const { $network: t, $store: r, methods: n } = (0, import_react.useContext)(TC), o = (0, import_react.useMemo)(() => {
    const i = mye([r, t], (s, a) => {
      const c = {
        paymentAddress: s.paymentAddress,
        address: s.address,
        publicKey: s.publicKey,
        paymentPublicKey: s.paymentPublicKey,
        library: {},
        network: a,
        accounts: s.accounts,
        balance: Number(s.balance),
        connected: s.connected,
        isConnecting: s.isConnecting,
        isInitializing: s.isInitializing,
        provider: s.provider,
        hasLeather: s.hasProvider.leather ?? false,
        hasMagicEden: s.hasProvider["magic-eden"] ?? false,
        hasOkx: s.hasProvider.okx ?? false,
        hasOyl: s.hasProvider.oyl ?? false,
        hasOrange: s.hasProvider.orange ?? false,
        hasOpNet: s.hasProvider.op_net ?? false,
        hasPhantom: s.hasProvider.phantom ?? false,
        hasUnisat: s.hasProvider.unisat ?? false,
        hasSparrow: s.hasProvider.sparrow ?? false,
        hasWizz: s.hasProvider.wizz ?? false,
        hasXverse: s.hasProvider.xverse ?? false,
        hasGlittr: s.hasProvider.glittr ?? false,
        ...n
      };
      return typeof e == "function" ? e(c) : c;
    });
    return bye(i), dye(i, ({ oldValue: s, abort: a }) => {
      vye(s, i.value) && a();
    }), i;
  }, [t, r, e, n]);
  return wye(o);
}
function p2e({
  config: e,
  children: t
}) {
  const r = (0, import_react.useMemo)(() => MB(), []), n = (0, import_react.useMemo)(
    () => sme(e ?? { network: Ft }),
    [e]
  ), [o, i] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    const _ = new sye(r, n);
    return i(() => _), _.initialize(), () => _.dispose();
  }, [n, r]);
  const s = (0, import_react.useCallback)(
    async (_) => await (o == null ? void 0 : o.connect(_)),
    [o]
  ), a = (0, import_react.useCallback)(() => o == null ? void 0 : o.disconnect(), [o]), c = (0, import_react.useCallback)(
    async () => {
      var _;
      return ((_ = await ((o == null ? void 0 : o.getBalance()) ?? No.getBalance())) == null ? void 0 : _.toString()) ?? "";
    },
    [o]
  ), u = (0, import_react.useCallback)(
    async (_, I) => await (o == null ? void 0 : o.getInscriptions(_, I)) ?? No.getInscriptions(),
    [o]
  ), l = (0, import_react.useCallback)(
    () => (o == null ? void 0 : o.getNetwork()) ?? No.getNetwork(),
    [o]
  ), f = (0, import_react.useCallback)(
    async () => await (o == null ? void 0 : o.getPublicKey()) ?? No.getPublicKey(),
    [o]
  ), d = (0, import_react.useCallback)(
    (_) => (o == null ? void 0 : o.pushPsbt(_)) ?? No.pushPsbt(),
    [o]
  ), m = (0, import_react.useCallback)(
    async (_, I) => await (o == null ? void 0 : o.signMessage(_, I)) ?? No.signMessage(),
    [o]
  ), y = (0, import_react.useCallback)(
    async () => await (o == null ? void 0 : o.requestAccounts()) ?? No.requestAccounts(),
    [o]
  ), b = (0, import_react.useCallback)(
    async (_, I) => await (o == null ? void 0 : o.sendBTC.call(o, _, I)) ?? No.sendBTC(),
    [o]
  ), w = (0, import_react.useCallback)(
    async (_, I, P) => await (o == null ? void 0 : o.signPsbt.call(o, _, I, P)) ?? No.signPsbt(),
    [o]
  ), v = (0, import_react.useCallback)(
    async (_) => await (o == null ? void 0 : o.switchNetwork.call(o, _)),
    [o]
  ), k = (0, import_react.useCallback)(
    async (_, I) => await (o == null ? void 0 : o.inscribe.call(o, _, I)) ?? No.inscribe(),
    [o]
  ), x = (0, import_react.useMemo)(() => o ? {
    connect: s,
    disconnect: a,
    getBalance: c,
    getInscriptions: u,
    getNetwork: l,
    getPublicKey: f,
    pushPsbt: d,
    signMessage: m,
    requestAccounts: y,
    sendBTC: b,
    signPsbt: w,
    switchNetwork: v,
    inscribe: k
  } : No, [
    o,
    s,
    a,
    c,
    u,
    l,
    f,
    k,
    d,
    y,
    b,
    m,
    w,
    v
  ]);
  return (0, import_jsx_runtime.jsx)(
    TC.Provider,
    {
      value: {
        $store: r.$store,
        $network: r.$network,
        client: o,
        methods: x
      },
      children: t
    }
  );
}
var Eye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      (0, import_jsx_runtime.jsx)(
        "rect",
        {
          width: "42",
          height: "42",
          rx: "10",
          fill: "#090A0C",
          style: { fill: "#090A0C", fillOpacity: 1 }
        }
      ),
      (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
          fill: "white",
          style: { fill: "white", fillOpacity: 1 }
        }
      )
    ]
  }
) : (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      (0, import_jsx_runtime.jsx)(
        "rect",
        {
          width: "42",
          height: "42",
          rx: "10",
          fill: "white",
          style: { fill: "white", fillOpacity: 1 }
        }
      ),
      (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M21 14C29.222 14 38 15.9676 38 20.9054C38 25.8622 29.222 28 21 28C12.778 28 4 26.0324 4 21.0946C4 16.1378 12.778 14 21 14ZM21.0397 25.3135C24.6939 25.3135 30.1752 24.3297 30.1752 21C30.1752 17.6703 24.6939 16.6865 21.0397 16.6865H20.9603C17.3061 16.6865 11.8248 17.6703 11.8248 21C11.8248 24.3297 17.3061 25.3135 20.9603 25.3135H21.0397Z",
          fill: "#090A0C",
          style: { fill: "#090A0C", fillOpacity: 1 }
        }
      )
    ]
  }
);
var xx = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      (0, import_jsx_runtime.jsx)("rect", { width: "128", height: "128", rx: "26.8387", fill: "#12100F" }),
      (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M74.9171 52.7114C82.4766 51.5408 93.4087 43.5804 93.4087 37.3761C93.4087 35.5031 91.8968 34.2154 89.6871 34.2154C85.5004 34.2154 78.4061 40.5368 74.9171 52.7114ZM39.911 83.4991C30.0256 83.4991 29.2115 93.3324 39.0969 93.3324C43.5163 93.3324 48.8661 91.5764 51.6573 88.4157C47.5868 84.9038 44.2141 83.4991 39.911 83.4991ZM102.829 79.2848C103.41 95.7907 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.0249C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8463 40.0273 72.8463C45.3771 72.8463 49.9128 74.2511 55.7277 77.88L59.5656 64.4177C43.7489 60.0864 35.8405 47.9118 43.6326 30.4693H56.1929C49.215 42.0586 53.9832 51.6578 62.822 52.7114C67.5903 35.7372 77.8246 22.509 91.4316 22.509C99.1074 22.509 105.155 27.5428 105.155 36.6737C105.155 51.3066 86.0819 63.2471 71.6607 64.4177L65.7295 85.3721C72.4748 93.2153 91.199 100.824 91.199 79.2848H102.829Z",
          fill: "#F5F1ED"
        }
      )
    ]
  }
) : (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 128 128",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      (0, import_jsx_runtime.jsx)("rect", { width: "128", height: "128", rx: "26.8387", fill: "#F5F1ED" }),
      (0, import_jsx_runtime.jsx)(
        "path",
        {
          d: "M74.9171 52.7115C82.4766 51.5409 93.4087 43.5806 93.4087 37.3762C93.4087 35.5032 91.8968 34.2155 89.6871 34.2155C85.5004 34.2155 78.4061 40.5369 74.9171 52.7115ZM39.911 83.4992C30.0256 83.4992 29.2115 93.3325 39.0969 93.3325C43.5163 93.3325 48.8661 91.5766 51.6573 88.4159C47.5868 84.904 44.2141 83.4992 39.911 83.4992ZM102.829 79.2849C103.41 95.7908 95.0369 105.039 80.8484 105.039C72.4748 105.039 68.2881 101.878 59.333 96.025C54.681 101.176 45.8423 105.039 38.5154 105.039C13.2785 105.039 14.3252 72.8464 40.0273 72.8464C45.3771 72.8464 49.9128 74.2512 55.7277 77.8801L59.5656 64.4179C43.7489 60.0865 35.8405 47.9119 43.6326 30.4695H56.1929C49.215 42.0587 53.9832 51.6579 62.822 52.7115C67.5903 35.7373 77.8246 22.5092 91.4316 22.5092C99.1074 22.5092 105.155 27.5429 105.155 36.6738C105.155 51.3068 86.0819 63.2472 71.6607 64.4179L65.7295 85.3722C72.4748 93.2155 91.199 100.825 91.199 79.2849H102.829Z",
          fill: "#12100F"
        }
      )
    ]
  }
);
var xye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => t === "first" ? (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#AB9FF2",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#FFFDF8",
            fillRule: "evenodd",
            d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
            clipRule: "evenodd"
          }
        )
      ] }),
      (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }) })
    ]
  }
) : (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#FFFDF8",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#AB9FF2",
            fillRule: "evenodd",
            d: "M17.686 27.567c-1.676 2.569-4.484 5.819-8.22 5.819-1.767 0-3.466-.728-3.466-3.887C6 21.454 16.984 9 27.176 9c5.798 0 8.108 4.023 8.108 8.59 0 5.864-3.805 12.568-7.587 12.568-1.2 0-1.79-.659-1.79-1.704 0-.273.046-.568.137-.887-1.291 2.205-3.783 4.25-6.116 4.25-1.698 0-2.559-1.068-2.559-2.568 0-.545.114-1.113.317-1.681Zm8.78-10.135c0 1.331-.786 1.997-1.664 1.997-.892 0-1.664-.666-1.664-1.997s.772-1.996 1.664-1.996c.878 0 1.663.665 1.663 1.996Zm4.99 0c0 1.331-.785 1.997-1.663 1.997-.892 0-1.664-.666-1.664-1.997 0-1.33.772-1.996 1.664-1.996.878 0 1.664.665 1.664 1.996Z",
            clipRule: "evenodd"
          }
        )
      ] }),
      (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }) })
    ]
  }
);
var kye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#clip0_3_53)", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M32 0H10C4.47715 0 0 4.47715 0 10V32C0 37.5228 4.47715 42 10 42H32C37.5228 42 42 37.5228 42 32V10C42 4.47715 37.5228 0 32 0Z",
            fill: "#181818"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M32 31.6745V27.6829C32 27.5233 31.9203 27.3636 31.8406 27.2438L14.8225 10.1597C14.7029 10.0399 14.5435 10 14.3841 10H10.3986C10.1993 10 10.0399 10.1597 10.0399 10.3592V14.0715C10.0399 14.2311 10.1196 14.3908 10.1993 14.5105L16.2971 20.6177C16.4565 20.7774 16.4565 20.977 16.2971 21.1366L10.1196 27.3237C10.0399 27.4035 10 27.4834 10 27.5632V31.6346C10 31.8342 10.1594 31.9939 10.3587 31.9939H17.0544C17.2536 31.9939 17.413 31.8342 17.413 31.6346V29.2396C17.413 29.1598 17.4529 29.0401 17.5326 29.0002L20.8406 25.6871C21 25.5275 21.1993 25.5275 21.3587 25.6871L27.4964 31.8342C27.6159 31.954 27.7753 31.9939 27.9348 31.9939H31.6413C31.8406 32.0337 32 31.8741 32 31.6745Z",
            fill: "white"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M23.3406 15.0793H26.5592C26.7507 15.0793 26.9039 15.2333 26.9039 15.4257V18.658C26.9039 18.9658 27.2871 19.1197 27.4788 18.8888L31.8851 14.4637C31.9617 14.3867 32 14.3097 32 14.2328V10.3463C32 10.1539 31.8468 10 31.6552 10H27.7469C27.6703 10 27.5554 10.0385 27.5171 10.1154L23.1107 14.5021C22.8808 14.6945 23.0341 15.0793 23.3406 15.0793Z",
            fill: "#EE7A30"
          }
        )
      ] }),
      (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("clipPath", { id: "clip0_3_53", children: (0, import_jsx_runtime.jsx)("rect", { width: "42", height: "42", fill: "white" }) }) })
    ]
  }
);
var Aye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "url(#b)",
            d: "m25.517 9.483 5.759 5.611c.49.477.731.959.724 1.445-.008.486-.219.929-.631 1.33-.431.421-.897.634-1.395.644-.497.007-.992-.228-1.482-.705l-5.89-5.738c-.669-.652-1.315-1.114-1.936-1.385a2.873 2.873 0 0 0-1.96-.127c-.685.185-1.42.662-2.21 1.428-1.086 1.06-1.605 2.054-1.552 2.983.053.929.593 1.893 1.617 2.89l5.938 5.786c.496.482.74.964.732 1.443-.008.48-.22.923-.64 1.332-.419.408-.88.62-1.382.638-.502.016-1.001-.217-1.495-.7l-5.76-5.61c-.936-.912-1.613-1.776-2.029-2.59-.416-.815-.572-1.737-.464-2.765.097-.88.384-1.732.863-2.558.477-.827 1.161-1.671 2.048-2.537C15.43 9.268 16.438 8.48 17.4 7.93c.96-.55 1.889-.854 2.786-.917.899-.064 1.784.112 2.66.527.876.415 1.765 1.061 2.67 1.943h.002Z"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "url(#c)",
            d: "m16.482 32.123-5.758-5.611c-.49-.479-.731-.959-.724-1.445.008-.486.219-.929.631-1.33.431-.421.897-.634 1.395-.644.498-.007.992.227 1.482.705l5.888 5.738c.671.652 1.315 1.114 1.936 1.385.622.27 1.276.312 1.962.127.685-.185 1.42-.662 2.21-1.43 1.086-1.06 1.605-2.054 1.552-2.983-.053-.929-.593-1.893-1.617-2.891l-3.164-3.056c-.496-.482-.74-.964-.732-1.443.008-.48.22-.923.64-1.332.419-.408.88-.62 1.382-.638.502-.016 1.002.217 1.496.7l2.983 2.88c.936.912 1.613 1.775 2.03 2.59.415.815.571 1.736.463 2.764a6.477 6.477 0 0 1-.863 2.559c-.477.826-1.16 1.67-2.048 2.536-1.057 1.03-2.066 1.819-3.027 2.368-.962.55-1.89.856-2.79.92-.898.063-1.784-.113-2.66-.527-.876-.415-1.765-1.062-2.67-1.944l.003.002Z"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "url(#d)",
            d: "M20.073 17.645c1.168 0 2.115-.93 2.115-2.08 0-1.149-.947-2.08-2.115-2.08-1.168 0-2.115.931-2.115 2.08 0 1.15.947 2.08 2.115 2.08Z"
          }
        )
      ] }),
      (0, import_jsx_runtime.jsxs)("defs", { children: [
        (0, import_jsx_runtime.jsxs)(
          "linearGradient",
          {
            id: "b",
            x1: 30.329,
            x2: 12.579,
            y1: 12.752,
            y2: 20.772,
            gradientUnits: "userSpaceOnUse",
            children: [
              (0, import_jsx_runtime.jsx)("stop", { stopColor: "#201C1B" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 0.36, stopColor: "#77390D" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 0.67, stopColor: "#EA8101" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#F4B852" })
            ]
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          "linearGradient",
          {
            id: "c",
            x1: 12.163,
            x2: 32.789,
            y1: 29.085,
            y2: 22.844,
            gradientUnits: "userSpaceOnUse",
            children: [
              (0, import_jsx_runtime.jsx)("stop", { stopColor: "#1F1D1C" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 0.37, stopColor: "#77390D" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 0.67, stopColor: "#EA8101" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#F4FB52" })
            ]
          }
        ),
        (0, import_jsx_runtime.jsxs)(
          "radialGradient",
          {
            id: "d",
            cx: 0,
            cy: 0,
            r: 1,
            gradientTransform: "matrix(2.11484 0 0 2.08019 20.073 15.567)",
            gradientUnits: "userSpaceOnUse",
            children: [
              (0, import_jsx_runtime.jsx)("stop", { stopColor: "#F4B852" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 0.33, stopColor: "#EA8101" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 0.64, stopColor: "#77390D" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#211C1D" })
            ]
          }
        ),
        (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
);
var Sye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        (0, import_jsx_runtime.jsxs)("g", { fillRule: "evenodd", clipPath: "url(#b)", clipRule: "evenodd", children: [
          (0, import_jsx_runtime.jsx)(
            "path",
            {
              fill: "#FFD815",
              d: "m26.507 17.74-1.623-1.623-1.624 1.623 1.623 1.623 1.624 1.624 1.623-1.624-1.623-1.623Z"
            }
          ),
          (0, import_jsx_runtime.jsx)(
            "path",
            {
              fill: "#FF9813",
              d: "m26.507 8-1.624 1.623 1.624 1.624 1.623-1.624L26.507 8ZM33 14.493l-1.623-1.623-1.624 1.623 1.624 1.623L33 14.493ZM23.26 27.48l1.623 1.623 1.624-1.623-1.623-1.624-1.624 1.624ZM11.897 16.117l1.623 1.623 1.623-1.623-1.623-1.624-1.623 1.624ZM20.014 8 18.39 9.623l1.624 1.624 1.623-1.624L20.014 8ZM13.52 11.247l1.624 1.623 1.623-1.623-1.623-1.624-1.624 1.624ZM31.377 19.363l-1.624 1.623 1.624 1.624L33 20.987l-1.623-1.624ZM28.13 25.856l1.623 1.624 1.624-1.624-1.624-1.623-1.623 1.623Z"
            }
          ),
          (0, import_jsx_runtime.jsx)(
            "path",
            {
              fill: "#5B5B72",
              d: "m26.507 20.986-1.624-1.623-1.623 1.623-1.623-1.623-1.623-1.623 1.623-1.624-1.623-1.623-1.624-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623 1.623-.812-.811-1.623 1.623 1.623 1.623-1.623 1.624-1.543 1.542-1.542 1.543-1.624 1.623L8 31.377 9.623 33l1.624-1.623 1.623-1.624 1.543-1.542.08-.08 1.462-1.463.08-.08 1.544-1.543 1.623 1.623 1.623-1.623-.811-.812 1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
            }
          ),
          (0, import_jsx_runtime.jsx)(
            "path",
            {
              fill: "#FF9813",
              d: "m26.507 14.493-1.624-1.623-1.623 1.623-1.623-1.623-1.623 1.623 1.623 1.623-1.623 1.624 1.623 1.623 1.623 1.623 1.623-1.623-1.623-1.623 1.623-1.623 1.624 1.623 1.623-1.623-1.623-1.624Z"
            }
          )
        ] })
      ] }),
      (0, import_jsx_runtime.jsxs)("defs", { children: [
        (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }),
        (0, import_jsx_runtime.jsx)("clipPath", { id: "b", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M8 8h25v25H8z" }) })
      ] })
    ]
  }
);
var _ye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    className: r,
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#a)", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#000",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        (0, import_jsx_runtime.jsx)("g", { fill: "#fff", clipPath: "url(#b)", children: (0, import_jsx_runtime.jsx)("path", { d: "M24.578 17.052h-6.787a.523.523 0 0 0-.52.52v6.788c0 .286.235.52.52.52h6.787c.286 0 .521-.234.521-.52v-6.787a.523.523 0 0 0-.52-.521ZM16.733 9.223H9.946a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.285 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM32.424 9.223h-6.787a.523.523 0 0 0-.521.521v6.787c0 .286.235.521.52.521h6.788c.286 0 .52-.235.52-.52V9.743a.523.523 0 0 0-.52-.52ZM16.733 24.898H9.946a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.285 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52ZM32.424 24.898h-6.787a.523.523 0 0 0-.521.52v6.788c0 .285.235.52.52.52h6.788c.286 0 .52-.235.52-.52v-6.788a.523.523 0 0 0-.52-.52Z" }) })
      ] }),
      (0, import_jsx_runtime.jsxs)("defs", { children: [
        (0, import_jsx_runtime.jsx)("clipPath", { id: "a", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h42v42H0z" }) }),
        (0, import_jsx_runtime.jsx)("clipPath", { id: "b", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
);
var Tye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    className: r,
    viewBox: "0 0 42 42",
    fill: "none",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#clip0_17_93)", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "#070C34",
            d: "M32 0H10C4.477 0 0 4.477 0 10v22c0 5.523 4.477 10 10 10h22c5.523 0 10-4.477 10-10V10c0-5.523-4.477-10-10-10Z"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "url(#paint0_linear_17_93)",
            d: "m27.666 16.837 1.874 2.177c.215.245.404.446.483.562.56.55.874 1.293.874 2.07-.053.915-.657 1.54-1.213 2.205l-1.311 1.521-.685.79a.184.184 0 0 0 .046.281c.033.02.07.028.107.026h6.835c1.045 0 2.36.868 2.283 2.184 0 .597-.247 1.171-.68 1.595a2.36 2.36 0 0 1-1.637.664H23.936c-.704 0-2.598.076-3.128-1.521a1.841 1.841 0 0 1-.043-1.035 4.5 4.5 0 0 1 .72-1.404 65.543 65.543 0 0 1 1.695-2.343c.741-1.002 1.503-1.971 2.251-2.992a.19.19 0 0 0 .04-.116.19.19 0 0 0-.04-.116l-2.72-3.156a.192.192 0 0 0-.153-.073.192.192 0 0 0-.152.073c-.728.96-3.917 5.203-4.598 6.063-.68.86-2.355.907-3.283 0l-4.255-4.161a.197.197 0 0 0-.1-.053.195.195 0 0 0-.2.082.192.192 0 0 0-.032.106v8a2.678 2.678 0 0 1-.494 1.594c-.33.466-.804.823-1.352 1.014a2.375 2.375 0 0 1-2.111-.293 2.271 2.271 0 0 1-.72-.805A2.22 2.22 0 0 1 5 28.736V14.349a2.416 2.416 0 0 1 .548-1.422c.33-.406.785-.7 1.298-.841a2.632 2.632 0 0 1 2.502.664l6.54 6.381c.019.02.043.034.07.043a.197.197 0 0 0 .161-.013.188.188 0 0 0 .061-.054l4.646-6.27c.215-.254.485-.46.79-.601.304-.142.636-.217.976-.221H34.68c.33 0 .657.07.959.204a2.31 2.31 0 0 1 1.263 1.409c.096.309.122.633.079.952a2.288 2.288 0 0 1-.813 1.42c-.439.364-.996.56-1.572.551h-6.768a.188.188 0 0 0-.163.099.187.187 0 0 0-.022.095c0 .032.013.065.032.093h-.008Z"
          }
        )
      ] }),
      (0, import_jsx_runtime.jsxs)("defs", { children: [
        (0, import_jsx_runtime.jsxs)(
          "linearGradient",
          {
            id: "paint0_linear_17_93",
            x1: "-0.315",
            x2: "35.366",
            y1: "9.343",
            y2: "30.176",
            gradientUnits: "userSpaceOnUse",
            children: [
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.23", stopColor: "#FF0074" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.26", stopColor: "#FF0068" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.32", stopColor: "#FF0048" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.39", stopColor: "#FF0015" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.41", stopColor: "#FF0009" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.43", stopColor: "#FF0908" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.54", stopColor: "#FF4003" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.62", stopColor: "#FF6201" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.66", stopColor: "#FF6F00" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.72", stopColor: "#FF8700" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.83", stopColor: "#FFAB00" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.92", stopColor: "#FFC100" }),
              (0, import_jsx_runtime.jsx)("stop", { offset: "0.98", stopColor: "#FFCA00" })
            ]
          }
        ),
        (0, import_jsx_runtime.jsx)("clipPath", { id: "clip0_17_93", children: (0, import_jsx_runtime.jsx)("path", { fill: "#fff", d: "M0 0h42v42H0z" }) })
      ] })
    ]
  }
);
var Pye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    width: e,
    height: e,
    viewBox: "0 0 42 42",
    ...n,
    children: [
      (0, import_jsx_runtime.jsxs)("defs", { children: [
        (0, import_jsx_runtime.jsx)("clipPath", { id: "clip1", children: (0, import_jsx_runtime.jsx)("path", { d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 " }) }),
        (0, import_jsx_runtime.jsxs)(
          "radialGradient",
          {
            id: "radial0",
            gradientUnits: "userSpaceOnUse",
            cx: 0,
            cy: 0,
            fx: 0,
            fy: 0,
            r: 1,
            gradientTransform: "matrix(0.000000000000001938,31.643555,-31.643555,0.000000000000001938,21,5.578125)",
            children: [
              (0, import_jsx_runtime.jsx)(
                "stop",
                {
                  offset: 0,
                  style: {
                    stopColor: "rgb(5.098039%,5.490196%,7.058824%)",
                    stopOpacity: 1
                  }
                }
              ),
              (0, import_jsx_runtime.jsx)(
                "stop",
                {
                  offset: 1,
                  style: {
                    stopColor: "rgb(0%,0%,0%)",
                    stopOpacity: 1
                  }
                }
              )
            ]
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image91",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAIOUlEQVRYhe2YW4jcVx3HP+fyv8785z+XveUm040xaWraitaHFmkfpKCI6LMgLWq9IUUpiA9CwRdfiqBPtbbWy5MKhRbxnuZFRUSMxhBr2nR6Sdrd2ezOzs7szP9yzvFhdus2TEzWJD7l+zQw53/Oh+/vcjg/uKmbuqmbuqlrkbhB+8o2+CFUUoj6EEWgAQ/Ah2IMpQcbS5C9CkMg/3+Cyjb4GpIE4gLSCsROkyKJLCilAEHpWwbS0M8LNvrQG0KvAxngbiTo2wBzaISahpGknqTxxGE1RLoPSCkWcIwN7p9hYX/54Asc0YKLOuPNElYL6P0J+jcCVLQhKCFOoQo0Ak3NSGaUZPbJI2qolXvECXHnlG83TemeeOxf9jcvlXh+zvk+LC9B9wJsXk9Qrw2VBsQWGnriYAvJ7FOH6ChfPSIE91/pDGF57tNnzO8Cy8tRxusZLGdw8Y8wulZQeRgqGioGalWol4pZJ5n77iKnKon6jIVPAuHVbmgL99jDZ+252PCyzni1AW8uwvBRGL916G4A2xC+E1oRtBTsjTW3FB6HF2PUj2+TrShRz1p4aDeQANITn/pWmxdKzXwY0ahCDISnwd9eo69iH9HeysPKVh4qTVNK5oxg9odH1UUh3TecELfvBu4S1YUv3++UHStHWvjUKj7ZiQHl821k0sJcCVQuQpJCRUBqoYnPjJPMf+8Q5zxfPegE94O45u4h4BCWV0pN4kHse4RH6+TeALHBf3fU2w+JDzULc2I7D2/hVCVRH7aObztBcK2Ab4EKAqEIlCASkghDMLJ4PeBjUFwO1HsHVJtQk7BgfPYeDBl//aDcJ6X4poW5631VGMuKAO05VAAq9FAzErWi4LfruKmg+0HLSagXrE/7+0c47/nqMeCu64s3kXMUFPaMZ2kriUsDpK/xuhnBLGSHUsTUqs8gDaFlFXuevJVz2lc/uFGQAM7y+6+8xj2BoKhpjK9xkUMuhojcw39hk2AqaAoVH1KjWQi0+pqAW24UJM69bo15JpYM6ophYskrAtP0EP0YX1nkYnwZR0tIjKLxs8P8A8FHbhikdWeKsf3OV1/mfVXJeiLpJyGjhocFSD1EWIdzGj01R32olpJ6oeSt8up67a7kHD1n3XOPv277ZzPuqCuWZwQrDUV/XrM5F5LrEreaIRohbHqoqRAStIVQKnHg+hKSO2uP58Yd//JL3BspaGi6s4qlpsdaXdGvK8ZNR+4iysEIt33FTQV1IAVojSvK69OHnLXur6a0z37hJe6OFXc1PN6oC1Ybkm7dY63hc3HWsZEKRmODnSsxmcD1AJddpj0BTkgsjrPXymmte8VYnvn8WXssktzRUlxINOtVyWoq6DV91usevaZjY49g5DvyekzZHeH2B+QXMhziMo7mYHxLMSrsSc9T6wjSXRM61p11P3/8Nds/NeJgy+N8LOinirUU1hKf/oxgPQgYzVoGM5KRceR7fcbnR7h9AdmFDOfJSWFN9esgvNdTvKsQvPund8hEC/GlXQDmztrj49I9//A57qsq1iqKfl2ylkCv7rOeKjbSkEHdMYgtxYJi2DeYGUeWCdzMDsh2SNEdgpp2VgqpllSlJPzbqjv/waasIK/YSx2WvxSlefJzL3LgxDozDc1KU9KdlSzNKJZnQ7rzMavzgn7VMJqHYaoZeZBXLIWRGOnIhxa7GJMXGbZbQCZwU0FjiJRDe4JwxdL+eOCekr6QUoojTEsX614sS55+6KxNjq9TTxUXm5qVumKppVieDViZ16w0fQZzJcMFGLY8htKjqOdkQzCxIyvAlAo7YykubAFmY+xRTT419A1IF2DOwn5f0baKtpXs/dERfq2Q9wopDipBaKy9WFpx5osv2veEgmGsGMSCjZpmvQ69xKdfE6zXAsbzgmFLMKpCtiGxiaUsS8y+kHFnDEphZg1FF7ACl4+wx0KKHtDpXCZH2xCOoNaA+QjmpWKfUewVihaCVAgCZVFK4gJJEQpGFcFmRdBvSjZqIesVwaAZMW5YhrGjmFcMNkpsVVEGhtJITGgphhLbsuTbgGYTl4wpjMD1etADhmCnVn0HsvugfxrkASi1wcSKgRDMCEcqJaH2UNpCJCgriix1jFKPfkMxjAKyBclAG0wDxqEm146iBWbksB7kpcO1KmR2CF2gGGG3AZfWcUvgMnAJuHugvGyXdCCOQLU+eb/Uqh71miIpJUkoCYXDqypcoBBVQdHyGDcjxg1N5hlMXTD2FIUwmKqlGEnsnE/+5iVh3gm40ns74F1QdoBT4K7UzsV9UGmDthE1rYlSjR8pvMwQxwEqFbhEYGcEpe9jW4rCCRyWMjGUmcDtD8gul4cHxhSdHnTBbYDdBjwBbOyYmlzVvfMohBF4pkqofIKaRYceXsUhIx9RGHTFh5ai9H3IczBbDo7HMJTYd0Tk3eFkyFSMsEcj8k4POr1JDvpgpwGubv2+6gvyNPjLILsQHAKxXMXfHyHXSvy4jhAjRBhOkj9k8iBXCgMwrZpPdiZrV8Fsu/jcFMBdOfoW7G348RD59w6eraOCEM8ZVJvJW7pSgXMZej6gXMrQSUkJb3dxu910JyBmZx5eCrlnt6HfqZ/chj88jXygDb/o4++xyDvr8Ac1GRYoO9lTOoQVk4N29sSTnUmoE3C3Q3GC/4R6p4vbkJ+FAnY3KQFgMcS9AvbpDnyoRv6GxJ7swdGE/O6EPFdYI3GFwuYj7GFHdiycFMyfO7gh2E9AXtuCnKZLIeF/HJI9Dl4G8hiIB9rwqwHeG1VUfev/+iXrOz0oBW5zDftRKDrANuSlbk6DBPg3vtO3svqbCX0AAAAASUVORK5CYII="
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "filter",
          {
            id: "alpha",
            filterUnits: "objectBoundingBox",
            x: "0%",
            y: "0%",
            width: "100%",
            height: "100%",
            children: (0, import_jsx_runtime.jsx)(
              "feColorMatrix",
              {
                type: "matrix",
                in: "SourceGraphic",
                values: "0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0"
              }
            )
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image170",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACtklEQVRYhWNgGAWjYBSMglEwCkYcmGslLagZ26TedkTUMOD/H11nY2a5Sb+/sJBiBiOtHMfAwMCg73JCaNrNdN2kh/eF0eXKFXf+qZBhvfbqqMkdYsxior7zGBjUK65yXtwsbBq4/7wDNkcyMDAwdN53ZxE87KQX4tNtRIyZVA1Rc3M7ZpZn5eoNd1lVc1hCmInVJ7ov4fwRl0n38amhWoiyP3kmPbfVyfXNw0gNUhzJwMDA8D/3q1bnt2a8bqE4RFPWPhRMLPDTwxXFxIKtN84cUdFSe4VLnuwQhaVDmbBtjpQ6koGBgWHPo6d8+ORJKiIYGBDp0CgsQTXM4Dczw+9y8l2HBB4kJFEv6p2NmeVYi1m170ewcVLmLEzw6HHhye/yjU9xyRMV9XaXNnLcmHTA9slpbhNaONLtgvpfZV5TnOmTgYGIEP3LGciWdPSB/QmDu7zUcxoquNv66c6fWoZL+NQQDNFwZysdWjpS8mnzhzsL664RUoc3M9ld2sixVWiFvBz13IUC2HjqXtzv4z+jcCf/DyG1eKOeb66bnGTiCRPqOQ0Ccpjzvq3gTr5y9IviE2L14I163YZ8HsqdhQDP3hn9vf8m5tq3r+y7SHEkAwOBqH/ncPYvZU6DgEjWToYZ/8UefWbsusrwd9p3ckpevCEqdNL9E5lug4N58opvn6zy2v/iX/AZhr8nv5NrDl6H7vx0/ZXyhqBf5BisuOLXdxnTr2esH188OCdY/j15zkMAguUoX8haFclViXrEGvjsndHfn/+0bjbzSN4q56r9R5nzEICoKlQvzsrk54IreEspWDp8wdh1lZIoxgWIrusrJBTVpl6R15QSOofR1qzc+eH1kW+Pr1AjiqkCJv3+wuJszCwnwaeq23ZE1JC9Q0ktq+09/0C7axSMglEwCkbBKKA/AABq8ekilgplTAAAAABJRU5ErkJggg=="
          }
        ),
        (0, import_jsx_runtime.jsx)("mask", { id: "mask0", children: (0, import_jsx_runtime.jsx)("g", { filter: "url(#alpha)", children: (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image170" }) }) }),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image125",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEF0lEQVRYhe2WTYscVRSGn3NvVXdPzySabwQN2SlGkQgjCC4EFWMU/A+CG925EhN0JSiof8BtxC8SSVZZiK7MRjRElPwEF8Ik0z3d9XXPOS6qJhM1pHucGXHRLxRFN9Sth/d977kFCy200EILLfR/kvwXL/n69NFvs6Y56MmGjUIlsU55TK9998eT866xp6DfvHTkcm9Snop1epBkqDuNQulCHWNT9Xq/s5FOv/7rxo1Za2V7AXjhzLEv+pPy5ODm+KSoSlQDdZI5GCQVCtdcKzuuw/5V4MCsNXfV0S9feeD8YKM4vlKVq5J0kJsR3Ajq4JAcygSjBOMkbEhEl3Ky+5dGb/6wdt+91t41Ry8+f+jS8tr6M3nTHNwEjO5EBxdwQFwIAcBxcxSjqY1Q6vKs9XcMevHMka+WxtPV/mh8IqiSWwcISJdXCIFkYIB5+5/jaHJSdIJa3DPQCy8f+3w4nj7auzl6PDYq0YzMncwcCYBDkIAByaAxaBxq2/pdG6iC2ez3bRv0dg/X1p8KSfu5GcGMgBMFEBAEFyG1ewg1qB3qBJVCqU6lLbDOCbEt0AvPHbyyf219Nd7Rw+BOJrQOGnjnYrfRW/e8A0zOVJ0iQaFQK7hu1WHHoJ+9ePTKynjy8HC0cSIzpff3HhpICLc7qNbu8Mah0TbmonEKc6YJxg1MGiikBWiH1g5Bz79w7Pul9Y3Hsro+nJkykLv38E4HN11sNmO21sVJgo0E0wSlQQpCiELMg+4Y1CfFQxTN4dyULBhBWhfv1sOmm5W1Qp2c0pxSaSEVyqaNfCqCBSH2I/kg03wQZ87ze4J++uzhn8NocsJUMTcQcAOTgPtfY07eRlwlpzYo7ujitLuXBjWCx0DWjwxX8rRvf+5vXV3r7Qg01WlfXVmM6m2sgAQB6SB9K+5aodqMWWHadIDWXgnBsoDkgf4g08Ew0+u/jT++DO/MgpwJqrUNK3OkcfIAwQR1QLbibiHbmKvOvYlCqVAZ1CZoDHge6PWi5ctZWh5mcvanW/15AOcCTU5UBVOQbozkAuCdm23MlbbRFtqe5UWCMggmAoNA7EUfLGVpaZhx7tr6tgDnArUQaFyoVUjm1Or0usPuzsgLawHL7rSpRPAQyHqRwXKWloaZvXt99K8A5wINecg0hFQgWZmEQpzYQOiiT9qC1d7GnOSfPfzlxviDS8Z7O4GEOT7z3n9i/6hcr/bV0wZJRugect8aRykIEgOSBXr9aPnwdg9n7uZdA3018MapR1Y+KTaaflMlUmrnknePexQkD/Ty6P1hloZLkXPX1ncNcG5QgI+ePlSMxrVURerVlYl3oCEIsRfo92MaDqKf3QPAbYFu6sPVA1XdKEk9OEgWxXt54O0fb+V7BbjQQgsttNBC/0/9CbvrotNPsOneAAAAAElFTkSuQmCC"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image142",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAAmklEQVRYhe2U0QqAIBAE1/7/n+tFIaQyur21aAdEX4RhDgWMMemUul7BkciZ3JopMqKXGhWcJltOzldMkS3dfhe5bOTBSGWXwF3pjxARBYSyUVFAJMsQBQSyLNF0mKKpVdlF02R/OfpGStWsonTZX4++Qa3qohVaVRfdQanqoh3hqi7KRikaGr+LslGLPh6/i7KxKBuLsvmM6AZK+AVU/UCtAQAAAABJRU5ErkJggg=="
          }
        ),
        (0, import_jsx_runtime.jsx)("mask", { id: "mask1", children: (0, import_jsx_runtime.jsx)("g", { filter: "url(#alpha)", children: (0, import_jsx_runtime.jsx)(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.6,
              stroke: "none"
            }
          }
        ) }) }),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image148",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAEI0lEQVRYhe3XTW4kuREF4I9kZqX+7B61gAFGR5CWPsucZ9zn6Sv4Ct5ZfQAv1IABuaftaUlVmWR4kZS6tPKitBjDegCRZBaT9RA/Lxi84Q1veMMbDkF6msTTPPChz28kP+NTX99+3/+MSwGuhI+47utfhETS169BNEgvCF5JPkluJZeSO8lF/+3rHtl3ncSdcCHcCpfCjXAtXpPs8ILkjeRa8kVyJ7uUkE0SknvJuz2idzgWJg3hUkNzLlxpPiBEJOlQsilI/txJnu+RI7tXJPl5TJKtZJaMwiRshdCE5lhF8141aT4LNL+IlA4jml+QnGRfFQwejE6Mso1qMplwpDl2tj6POTKZVJNs49GIwd8NPituJVfSc0gdgAFcd9d+lb1T/GpwrPhmlAyKwaKoiiy7lxTxsNX626paDDJmZ9At/hd80Q4lmt30pCErsgdFMUg2Tm1kR5IjyYlwKpwa+zOcSk40xzbdst9sMLhXDD2Ufj6UJsOe/GRniq3BHwxmG4uNbFKMFhvJICua1L+omA3mHsfJpsflieY3zZ32LG8HEf0keS/5Z0+gSTEbVWNfTZpJ6cRDUSRNqKowS7bmrh5VM/dwyKqLZ48dSPR2T3pWCsXOIPdEaibVUSe9urVKslAsmkHuKlBVG7MHA93Kt3KXrQOJ/gnfJA/dootiUIRBMqg2hp75q2WH7vjAIssDbVlUYbE1SP2cU0k93Jor0c/doqw2mCRNlrtMMQijbBRGYUDWRElSJRYWydzTsXhUjJLHfu7d4WTz8+xYspEsUo/B78KvOzo6kbyGSE2KppT9fbV/v3StuH8di+b/vuX3ge9EH4SdMAhVyF1mnsYabVXrI9QSa2bX/X2lfz8Ij8LJ69yesp+EP/bDRmHutbuqWDzFXzMXdpoZO9murlV/HWHp9WmVplk46udevMLtyV+td8roFhlUO1W2CItit+a2VJNQ1C74a9aHnWRnsFN7mZi79R+Ef4leUg8keim8F/4h/KiiShbVjNKTg6RZVHlP8Jsqm4WtpRN+tGiq0ndcam5fw6JXwifhx27RrWoy00siqxgtandz2RP8JptVs9HWbKeYHVlQewmN5y7gIKIfcd4vvb+piuTfXU/HnhBh0SxjUebaLVp7smXLJsy7MCt2dmajxb2qai6Eq9cguvY4659WyZnqV0kI30SX/8Fonmu/SDdPJaIJdRe95ofFqRmLE9Vd99LHQ2k+ydNN73cWzVfVD6sFLXaKrerR4MHkXnP/4jl4UD0abTU7T0qxhlF77p8OxP9QK8La2l6LfhNvflLdqU7Mjs0WO5Ote1uTrTOPJlt3/f1i57i7nMXfNOf9rN6JHoohWbtEIXwA4Vzq7W9yqdlKziQnXrbLT0K+Fc722uUvXUleubd/wxve8IY3/B/gP+5/MI8x65+AAAAAAElFTkSuQmCC"
          }
        ),
        (0, import_jsx_runtime.jsx)("mask", { id: "mask2", children: (0, import_jsx_runtime.jsx)("g", { filter: "url(#alpha)", children: (0, import_jsx_runtime.jsx)(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.701961,
              stroke: "none"
            }
          }
        ) }) }),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image154",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAAA/ElEQVRYhe2VwW7DIAxAn9M0qcSN///G3JDaFEIPwRvqoUHdWKXJT/IhMokeNiZgGIZhGIZh/EPkVTLnLGWNxvD0Ti6xAVlEtk6eDA1rBDgBZ2ACZu/9DMzleSz5lm+9zVFFh0pyrELYK5m89/dlWSIQRWT9lOipiE1VnCvRCKwaInLtJXrULj2Xdesn4EJpvXPuT1o/NqxR2Vp4YB+gLYSgki+781PeqUL+dYsGWkT1+tmAxH4uNZJzLpVc1w0ctV4lE3Dne4i+himEEEu+2x0KxxV9Fr0B1ypu3vuVvbpdRVv+TDpEGvXmdBMJ2EQkdvI0DMMwDMMwjI/yAInrT4nWGUiJAAAAAElFTkSuQmCC"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image160",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
          }
        ),
        (0, import_jsx_runtime.jsx)("mask", { id: "mask3", children: (0, import_jsx_runtime.jsx)("g", { filter: "url(#alpha)", children: (0, import_jsx_runtime.jsx)(
          "rect",
          {
            x: 0,
            y: 0,
            width: 42,
            height: 42,
            style: {
              fill: "rgb(0%,0%,0%)",
              fillOpacity: 0.2,
              stroke: "none"
            }
          }
        ) }) }),
        (0, import_jsx_runtime.jsx)(
          "image",
          {
            id: "image166",
            width: 42,
            height: 42,
            xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAYAAADFw8lbAAAABmJLR0QA/wD/AP+gvaeTAAACY0lEQVRYhe2W227iQBBEj7mFcAkbZf3/HxjtLUtCAtjeh6laN9YSDCHSPkxLrZE92BzXVPcM5MiRI0eOj0RxzZc1TeP3FcBAoxOgCWOtsSmKouFEjD4JcNgZBx3ASlmH688FFWQEHAJj5Uhp0ArYA7uQvv85oAGw6ABOgClwoxwLtBbkG/CqhNYO1wUNy+wl7QLeAjPlNIBWgnzRM9Bz2c8CPeJDL/GNAOfAIuSt5gG2AbImLfuW1hYfBz3iw4kApyT1FsBSeafraQDb6P8q0rKPNder87wL2sOHBlwIzrnU3ESvsnJb2iKL7ety0H+oOOoAzgW0HA6Hd1VVrXS90NxEz+5JBdNtUXG8HDRClmU5fnx8dKFEBVfAqqoqqzjXhxiyInnR1e7c6r576VVADWkFV8ovSvvxluRZ+24PvA0Gg+e6rn8DzjXJr1v9phfoexVnX45JKs0FdQ98BUqN97o/04c3AlwDP+u6/g58U/4Q7AvwWpblri/oUSM3TeO2MyMpeQ88CO6BpOZSH2FAL/ELSbkn4JfySfkXFKlaFMX+FGifpXcRuVc6b8Lz7okb4FkwT51cC3Cjj7F3r+JRwxrYhwz0B1vawogqRvUi4GsAdCFdbQv1i7zd7Wj36SFtA19zqOSapK4V7FZ6DdDniHcKtKHtdTv92YZUXA1JJTS34bCqnzn0oQErzjiDngPqE4/95y1wQ7s1Rm9GwK4P60sA+4LGpfZRzft0EeattgHdIw98eCnkOaDQqudjm+/5IOzCioBn+fAjoPZnhPZhwqD2XlfBi5c5R44cOXLkyJHjv40/gQUmD3HnzocAAAAASUVORK5CYII="
          }
        ),
        (0, import_jsx_runtime.jsx)("clipPath", { id: "clip2", children: (0, import_jsx_runtime.jsx)("rect", { x: 0, y: 0, width: 42, height: 42 }) }),
        (0, import_jsx_runtime.jsxs)("g", { id: "surface169", clipPath: "url(#clip2)", children: [
          (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image125" }),
          (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image142" }),
          (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image148", mask: "url(#mask1)" }),
          (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image154", mask: "url(#mask2)" }),
          (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image160" }),
          (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image166", mask: "url(#mask3)" })
        ] })
      ] }),
      (0, import_jsx_runtime.jsx)("g", { id: "surface1", children: (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#clip1)", clipRule: "nonzero", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            style: {
              stroke: "none",
              fillRule: "nonzero",
              fill: "url(#radial0)"
            },
            d: "M 9.433594 0 L 32.566406 0 C 37.777344 0 42 4.222656 42 9.433594 L 42 32.566406 C 42 37.777344 37.777344 42 32.566406 42 L 9.433594 42 C 4.222656 42 0 37.777344 0 32.566406 L 0 9.433594 C 0 4.222656 4.222656 0 9.433594 0 Z M 9.433594 0 "
          }
        ),
        (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image42" }),
        (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#image91" }),
        (0, import_jsx_runtime.jsx)("use", { xlinkHref: "#surface169", mask: "url(#mask0)" })
      ] }) })
    ]
  }
);
var Iye = [
  { transform: "translate(40.2375 0.627991) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.627991)",
    fill: "#FFDE31"
  },
  { transform: "translate(63.9086 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 16.4087) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4087)",
    fill: "#FFF065"
  },
  { transform: "translate(32.3471 16.4087) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4087)",
    fill: "#FFDE31"
  },
  { transform: "translate(32.3471 32.1895) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 32.1895) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 16.4087) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4087)",
    fill: "#FFDE31"
  },
  { transform: "translate(48.1278 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.1895) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(32.3471 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.0798) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.0798)",
    fill: "#FFDE31"
  },
  { transform: "translate(24.4567 32.1895) rotate(-180)", fill: "#FFF065" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(40.2375 47.9702) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.9702)",
    fill: "#FFDE31"
  },
  { transform: "translate(16.5664 32.1895) rotate(-180)", fill: "#FFF065" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.1895)",
    fill: "#FFF065"
  },
  { transform: "translate(8.67601 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 8.51831) rotate(90)", fill: "#FFDE31" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.51831)",
    fill: "#FFDE31"
  },
  { transform: "translate(56.0182 32.1895) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.1895)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 24.2991) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.2991)",
    fill: "#FFF065"
  }
];
var Oye = [
  { transform: "translate(40.2375 0.232574) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.232574)",
    fill: "#00E45D"
  },
  { transform: "translate(63.9086 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 16.0133) rotate(90)", fill: "#8AFF76" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.0133)",
    fill: "#8AFF76"
  },
  { transform: "translate(32.3471 16.0133) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.0133)",
    fill: "#00E45D"
  },
  { transform: "translate(32.3471 31.794) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 31.794) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 16.0133) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.0133)",
    fill: "#00E45D"
  },
  { transform: "translate(48.1278 31.794) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.794)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.794) rotate(90)", fill: "#8AFF76" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(32.3471 31.794) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.794)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.6844) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6844)",
    fill: "#00E45D"
  },
  { transform: "translate(24.4567 31.794) rotate(-180)", fill: "#8AFF76" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(40.2375 47.5748) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.5748)",
    fill: "#00E45D"
  },
  { transform: "translate(16.5664 31.794) rotate(-180)", fill: "#8AFF76" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.794)",
    fill: "#8AFF76"
  },
  { transform: "translate(8.67601 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 8.12296) rotate(90)", fill: "#00E45D" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.12296)",
    fill: "#00E45D"
  },
  { transform: "translate(56.0182 31.794) rotate(-180)", fill: "#00E45D" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.794)",
    fill: "#00E45D"
  },
  { transform: "translate(40.2375 23.9037) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.9037)",
    fill: "#FFF065"
  }
];
var Bye = [
  { transform: "translate(40.2375 0.395386) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.395386)",
    fill: "#FF701E"
  },
  { transform: "translate(63.9086 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 16.1761) rotate(90)", fill: "#FF9345" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.1761)",
    fill: "#FF9345"
  },
  { transform: "translate(32.3471 16.1761) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.1761)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 31.9568) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 31.9568) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 16.1761) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.1761)",
    fill: "#FF701E"
  },
  { transform: "translate(48.1278 31.9568) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.9568)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.9568) rotate(90)", fill: "#FF9345" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(32.3471 31.9568) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.9568)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.8472) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.8472)",
    fill: "#FF701E"
  },
  { transform: "translate(24.4567 31.9568) rotate(-180)", fill: "#FF9345" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(40.2375 47.7375) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.7375)",
    fill: "#FF701E"
  },
  { transform: "translate(16.5664 31.9568) rotate(-180)", fill: "#FF9345" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.9568)",
    fill: "#FF9345"
  },
  { transform: "translate(8.67601 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 8.28577) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.28577)",
    fill: "#FF701E"
  },
  { transform: "translate(56.0182 31.9568) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.9568)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 24.0665) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.0665)",
    fill: "#FFF065"
  }
];
var Cye = [
  { transform: "translate(40.2375) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0)",
    fill: "#F42F3B"
  },
  { transform: "translate(63.9086 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 15.7807) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.7807)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 15.7807) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.7807)",
    fill: "#F42F3B"
  },
  { transform: "translate(32.3471 31.5615) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 31.5615) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 15.7807) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.7807)",
    fill: "#F42F3B"
  },
  { transform: "translate(48.1278 31.5615) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.5615)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.5615) rotate(90)", fill: "#FF701E" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(32.3471 31.5615) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.5615)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.4518) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.4518)",
    fill: "#F42F3B"
  },
  { transform: "translate(24.4567 31.5615) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(40.2375 47.3422) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.3422)",
    fill: "#F42F3B"
  },
  { transform: "translate(16.5664 31.5615) rotate(-180)", fill: "#FF701E" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.5615)",
    fill: "#FF701E"
  },
  { transform: "translate(8.67601 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 7.89038) rotate(90)", fill: "#F42F3B" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 7.89038)",
    fill: "#F42F3B"
  },
  { transform: "translate(56.0182 31.5615) rotate(-180)", fill: "#F42F3B" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.5615)",
    fill: "#F42F3B"
  },
  { transform: "translate(40.2375 23.6711) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.6711)",
    fill: "#FFF065"
  }
];
var Nye = [
  { transform: "translate(40.2375 0.465149) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.465149)",
    fill: "#36DBFF"
  },
  { transform: "translate(63.9086 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 16.2459) rotate(90)", fill: "#7FE8FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.2459)",
    fill: "#7FE8FF"
  },
  { transform: "translate(32.3471 16.2459) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.2459)",
    fill: "#36DBFF"
  },
  { transform: "translate(32.3471 32.0266) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 32.0266) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 16.2459) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.2459)",
    fill: "#36DBFF"
  },
  { transform: "translate(48.1278 32.0266) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.0266)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.0266) rotate(90)", fill: "#7FE8FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(32.3471 32.0266) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.0266)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.917) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.917)",
    fill: "#36DBFF"
  },
  { transform: "translate(24.4567 32.0266) rotate(-180)", fill: "#7FE8FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(40.2375 47.8073) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.8073)",
    fill: "#36DBFF"
  },
  { transform: "translate(16.5664 32.0266) rotate(-180)", fill: "#7FE8FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.0266)",
    fill: "#7FE8FF"
  },
  { transform: "translate(8.67601 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 8.35553) rotate(90)", fill: "#36DBFF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.35553)",
    fill: "#36DBFF"
  },
  { transform: "translate(56.0182 32.0266) rotate(-180)", fill: "#36DBFF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.0266)",
    fill: "#36DBFF"
  },
  { transform: "translate(40.2375 24.1363) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.1363)",
    fill: "#FFF065"
  }
];
var Uye = [
  { transform: "translate(40.2375 0.697693) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.697693)",
    fill: "#1657FF"
  },
  { transform: "translate(63.9086 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 16.4785) rotate(90)", fill: "#3AA0FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.4785)",
    fill: "#3AA0FF"
  },
  { transform: "translate(32.3471 16.4785) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.4785)",
    fill: "#1657FF"
  },
  { transform: "translate(32.3471 32.2592) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 32.2592) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 16.4785) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.4785)",
    fill: "#1657FF"
  },
  { transform: "translate(48.1278 32.2592) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.2592)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.2592) rotate(90)", fill: "#3AA0FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(32.3471 32.2592) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.2592)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.1495) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.1495)",
    fill: "#1657FF"
  },
  { transform: "translate(24.4567 32.2592) rotate(-180)", fill: "#3AA0FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(40.2375 48.0399) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.0399)",
    fill: "#1657FF"
  },
  { transform: "translate(16.5664 32.2592) rotate(-180)", fill: "#3AA0FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.2592)",
    fill: "#3AA0FF"
  },
  { transform: "translate(8.67601 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 8.58807) rotate(90)", fill: "#1657FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.58807)",
    fill: "#1657FF"
  },
  { transform: "translate(56.0182 32.2592) rotate(-180)", fill: "#1657FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.2592)",
    fill: "#1657FF"
  },
  { transform: "translate(40.2375 24.3688) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.3688)",
    fill: "#FFF065"
  }
];
var $ye = [
  { transform: "translate(40.2375 0.930267) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.930267)",
    fill: "#A528F2"
  },
  { transform: "translate(63.9086 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 16.711) rotate(90)", fill: "#BF58FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 16.711)",
    fill: "#BF58FF"
  },
  { transform: "translate(32.3471 16.711) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 16.711)",
    fill: "#A528F2"
  },
  { transform: "translate(32.3471 32.4917) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 32.4917) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 16.711) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 16.711)",
    fill: "#A528F2"
  },
  { transform: "translate(48.1278 32.4917) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 32.4917)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 32.4917) rotate(90)", fill: "#BF58FF" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(32.3471 32.4917) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 32.4917)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 40.3821) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 40.3821)",
    fill: "#A528F2"
  },
  { transform: "translate(24.4567 32.4917) rotate(-180)", fill: "#BF58FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(40.2375 48.2725) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 48.2725)",
    fill: "#A528F2"
  },
  { transform: "translate(16.5664 32.4917) rotate(-180)", fill: "#BF58FF" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 32.4917)",
    fill: "#BF58FF"
  },
  { transform: "translate(8.67601 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 8.82065) rotate(90)", fill: "#A528F2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.82065)",
    fill: "#A528F2"
  },
  { transform: "translate(56.0182 32.4917) rotate(-180)", fill: "#A528F2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 32.4917)",
    fill: "#A528F2"
  },
  { transform: "translate(40.2375 24.6014) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 24.6014)",
    fill: "#FFF065"
  }
];
var IC = [
  { transform: "translate(40.2375 0.162842) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 0.162842)",
    fill: "#FB51C1"
  },
  { transform: "translate(63.9086 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 71.7989 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 15.9436) rotate(90)", fill: "#FF7CD2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 15.9436)",
    fill: "#FF7CD2"
  },
  { transform: "translate(32.3471 15.9436) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 15.9436)",
    fill: "#FB51C1"
  },
  { transform: "translate(32.3471 31.7243) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 103.36 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 31.7243) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 15.9436) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 87.5797 15.9436)",
    fill: "#FB51C1"
  },
  { transform: "translate(48.1278 31.7243) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 87.5797 31.7243)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 31.7243) rotate(90)", fill: "#FF7CD2" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(32.3471 31.7243) rotate(-180)", fill: "#FFDE31" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 103.36 31.7243)",
    fill: "#FFDE31"
  },
  { transform: "translate(40.2375 39.6147) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 39.6147)",
    fill: "#FB51C1"
  },
  { transform: "translate(24.4567 31.7243) rotate(-180)", fill: "#FF7CD2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 111.251 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(40.2375 47.505) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 47.505)",
    fill: "#FB51C1"
  },
  { transform: "translate(16.5664 31.7243) rotate(-180)", fill: "#FF7CD2" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 119.141 31.7243)",
    fill: "#FF7CD2"
  },
  { transform: "translate(8.67601 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 127.031 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 8.05322) rotate(90)", fill: "#FB51C1" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 8.05322)",
    fill: "#FB51C1"
  },
  { transform: "translate(56.0182 31.7243) rotate(-180)", fill: "#FB51C1" },
  {
    transform: "matrix(1 -8.74228e-08 -8.74228e-08 -1 79.6893 31.7243)",
    fill: "#FB51C1"
  },
  { transform: "translate(40.2375 23.834) rotate(90)", fill: "#FFF065" },
  {
    transform: "matrix(4.37114e-08 1 1 -4.37114e-08 95.47 23.834)",
    fill: "#FFF065"
  }
];
var Rye = {
  pink: IC,
  purple: $ye,
  darkBlue: Uye,
  blue: Nye,
  red: Cye,
  orange: Bye,
  green: Oye,
  yellow: Iye
};
var g2e = ({
  width: e = 135,
  height: t,
  className: r = "",
  color: n = "green"
}) => {
  const o = 2.4107142857142856, i = t || e / o, s = e || t * o, a = Rye[n] || IC;
  return (0, import_jsx_runtime.jsx)(
    "svg",
    {
      width: s,
      height: i,
      viewBox: "0 0 135 56",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: r,
      children: a.map((c, u) => (0, import_jsx_runtime.jsx)(
        "rect",
        {
          width: 7.89036,
          height: 7.89036,
          transform: c.transform,
          fill: c.fill
        },
        u
      ))
    }
  );
};
var zye = ({
  size: e = 42,
  variant: t = "first",
  className: r,
  ...n
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    id: "Ebene_2",
    "data-name": "Ebene 2",
    viewBox: "0 0 314.29 111.66",
    width: e,
    height: e,
    ...n,
    children: [
      (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("style", { children: ".cls-1{fill:#fff;stroke-width:0}" }) }),
      (0, import_jsx_runtime.jsxs)("g", { id: "Ebene_1-2", "data-name": "Ebene 1", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M118.13 0c-8.69-.1-16.81 2.21-23.8 6.26-2.57 1.49-3.29 4.91-1.55 7.33 3.44 4.8 6.15 10.15 7.97 15.9 1.01 3.2 4.82 4.23 7.65 2.43 3.55-2.25 7.97-3.25 12.67-2.33 6.53 1.27 11.95 6.44 13.44 12.93 2.61 11.39-5.97 21.5-16.91 21.5-3.41 0-6.58-.99-9.24-2.7-2.82-1.8-6.61-.66-7.63 2.53-4.48 14.04-14.26 25.71-27.02 32.66-1.67.91-2.75 2.6-2.75 4.5v5.58c0 2.8 2.27 5.07 5.07 5.07h19.13c2.8 0 5.07-2.27 5.07-5.07v-9.76c0-3.35 3.16-5.67 6.42-4.87 3.52.86 7.18 1.32 10.96 1.32 26.19 0 47.34-21.59 46.62-47.95C163.55 20.67 142.8.28 118.13 0Z",
            style: {
              fill: "#ff7900",
              strokeWidth: 0
            }
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            d: "M46.64 0C20.88 0 0 20.88 0 46.64s20.88 46.64 46.64 46.64S93.28 72.4 93.28 46.64 72.4 0 46.64 0Zm0 64.03c-9.6 0-17.38-7.78-17.38-17.39s7.78-17.39 17.38-17.39 17.39 7.78 17.39 17.39-7.78 17.39-17.39 17.39ZM188.46 41.7l20.14 33.14h11.26V18.5h-13.02v34.05L185.9 18.5h-10.38v56.34h12.94V41.7zM265.74 63.57h-24.29V51.9h15.46V40.8h-15.46V29.77h24.29V18.5h-37.88v56.34h37.88V63.57zM286.16 74.84h14.06V29.77h14.07V18.5H272.1v11.27h14.06v45.07z",
            className: "cls-1"
          }
        )
      ] })
    ]
  }
);
var Hye = ({
  size: e = 42,
  className: t,
  ...r
}) => (0, import_jsx_runtime.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: e,
    height: e,
    viewBox: "0 0 200 200",
    fill: "none",
    ...r,
    children: [
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.14
          },
          fill: "#090a0b",
          d: "M 81.5,9.5 C 82.2423,11.4258 83.2423,13.2591 84.5,15C 82.7184,15.1218 81.0518,14.6218 79.5,13.5C 79.2291,11.6203 79.8958,10.287 81.5,9.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#4f585a",
          d: "M 125.5,38.5 C 112.548,31.863 99.8817,25.0297 87.5,18C 100.667,29.0023 113.667,40.1689 126.5,51.5C 127.634,54.3704 128.3,57.3704 128.5,60.5C 126.668,59.7515 125.001,58.7515 123.5,57.5C 110.167,46.8333 96.8333,36.1667 83.5,25.5C 80.3626,22.7015 78.0293,19.3681 76.5,15.5C 76.9731,14.0937 77.9731,13.427 79.5,13.5C 81.0518,14.6218 82.7184,15.1218 84.5,15C 83.2423,13.2591 82.2423,11.4258 81.5,9.5C 83.4346,8.29099 85.4346,8.45766 87.5,10C 100.414,19.2774 113.08,28.7774 125.5,38.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.161
          },
          fill: "#08090a",
          d: "M 76.5,15.5 C 78.0293,19.3681 80.3626,22.7015 83.5,25.5C 80.5498,24.6916 77.8831,23.3582 75.5,21.5C 73.9378,19.0993 74.2712,17.0993 76.5,15.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#778085",
          d: "M 75.5,21.5 C 77.8831,23.3582 80.5498,24.6916 83.5,25.5C 96.8333,36.1667 110.167,46.8333 123.5,57.5C 118.285,55.5594 113.285,53.0594 108.5,50C 99.2121,47.5708 90.0454,44.7374 81,41.5C 80.2352,41.5699 79.7352,41.9033 79.5,42.5C 75.0157,41.6841 72.6824,39.0174 72.5,34.5C 72.8417,33.6618 73.5084,33.3284 74.5,33.5C 77.4258,34.868 80.4258,35.7013 83.5,36C 80.3333,32.8333 77.1667,29.6667 74,26.5C 73.51,25.2068 73.3433,23.8734 73.5,22.5C 73.8417,21.6618 74.5084,21.3284 75.5,21.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.165
          },
          fill: "#070809",
          d: "M 73.5,22.5 C 73.3433,23.8734 73.51,25.2068 74,26.5C 77.1667,29.6667 80.3333,32.8333 83.5,36C 80.4258,35.7013 77.4258,34.868 74.5,33.5C 73.2222,31.2009 71.8889,28.8676 70.5,26.5C 71.0351,24.739 72.0351,23.4057 73.5,22.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#8d9999",
          d: "M 125.5,38.5 C 126.125,42.3258 126.791,46.1592 127.5,50C 127.43,50.7648 127.097,51.2648 126.5,51.5C 113.667,40.1689 100.667,29.0023 87.5,18C 99.8817,25.0297 112.548,31.863 125.5,38.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#8e9a9a",
          d: "M 123.5,57.5 C 125.001,58.7515 126.668,59.7515 128.5,60.5C 128.5,61.8333 128.5,63.1667 128.5,64.5C 128.5,65.8333 128.5,67.1667 128.5,68.5C 112.879,61.0229 97.5452,53.0229 82.5,44.5C 81.2905,44.0679 80.2905,43.4013 79.5,42.5C 79.7352,41.9033 80.2352,41.5699 81,41.5C 90.0454,44.7374 99.2121,47.5708 108.5,50C 113.285,53.0594 118.285,55.5594 123.5,57.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#777f85",
          d: "M 125.5,38.5 C 129.5,41.5 133.5,44.5 137.5,47.5C 136.428,51.7555 134.261,55.4222 131,58.5C 130.155,60.6115 129.322,62.6115 128.5,64.5C 128.5,63.1667 128.5,61.8333 128.5,60.5C 128.3,57.3704 127.634,54.3704 126.5,51.5C 127.097,51.2648 127.43,50.7648 127.5,50C 126.791,46.1592 126.125,42.3258 125.5,38.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.997
          },
          fill: "#888889",
          d: "M 58.5,63.5 C 48.5374,62.2002 38.7041,60.2002 29,57.5C 27.9302,57.528 27.0968,57.8614 26.5,58.5C 24.2459,57.5849 22.2459,56.2516 20.5,54.5C 18.4985,51.6662 15.9985,49.3329 13,47.5C 12.51,46.2068 12.3433,44.8734 12.5,43.5C 13.2506,42.4265 14.2506,42.2599 15.5,43C 29.1035,51.4694 43.4368,58.3027 58.5,63.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.17
          },
          fill: "#0e0f0f",
          d: "M 12.5,43.5 C 12.3433,44.8734 12.51,46.2068 13,47.5C 15.9985,49.3329 18.4985,51.6662 20.5,54.5C 20.44,55.0431 20.1067,55.3764 19.5,55.5C 16.3707,53.6001 13.0373,52.2667 9.5,51.5C 10.7279,49.9902 10.7279,48.4902 9.5,47C 10.1634,45.4815 11.1634,44.3149 12.5,43.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7b848a",
          d: "M 82.5,44.5 C 97.5452,53.0229 112.879,61.0229 128.5,68.5C 128.72,71.4005 128.054,74.0671 126.5,76.5C 113.14,69.1544 99.8062,61.8211 86.5,54.5C 83.5279,52.6778 80.5279,50.8445 77.5,49C 76.6198,47.6439 76.2865,46.1439 76.5,44.5C 78.7411,44.9539 80.7411,44.9539 82.5,44.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.153
          },
          fill: "#050506",
          d: "M 72.5,34.5 C 72.6824,39.0174 75.0157,41.6841 79.5,42.5C 80.2905,43.4013 81.2905,44.0679 82.5,44.5C 80.7411,44.9539 78.7411,44.9539 76.5,44.5C 76.2865,46.1439 76.6198,47.6439 77.5,49C 80.5279,50.8445 83.5279,52.6778 86.5,54.5C 86.2774,59.2804 87.944,63.2804 91.5,66.5C 91.1496,69.4534 92.1496,71.7867 94.5,73.5C 92.4471,73.5979 90.7804,72.9313 89.5,71.5C 89.6495,70.448 89.4828,69.448 89,68.5C 85.7393,65.9786 84.0726,62.6453 84,58.5C 80.5991,56.6387 77.5991,54.3053 75,51.5C 74.2419,49.2305 74.4086,47.0639 75.5,45C 70.4866,42.378 69.4866,38.878 72.5,34.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.016
          },
          fill: "#0f1010",
          d: "M 138.5,48.5 C 140.539,49.911 141.539,51.911 141.5,54.5C 139.992,52.8185 138.992,50.8185 138.5,48.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#343f49",
          d: "M 9.5,51.5 C 13.0373,52.2667 16.3707,53.6001 19.5,55.5C 20.1067,55.3764 20.44,55.0431 20.5,54.5C 22.2459,56.2516 24.2459,57.5849 26.5,58.5C 35.1667,62.8333 43.8333,67.1667 52.5,71.5C 56.6478,75.4041 60.9811,79.0708 65.5,82.5C 65.5,82.8333 65.5,83.1667 65.5,83.5C 50.001,77.6719 34.6676,71.6719 19.5,65.5C 16.9116,63.4392 14.0783,60.7726 11,57.5C 9.87201,55.6547 9.37201,53.6547 9.5,51.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.191
          },
          fill: "#070809",
          d: "M 9.5,51.5 C 9.37201,53.6547 9.87201,55.6547 11,57.5C 14.0783,60.7726 16.9116,63.4392 19.5,65.5C 16.2854,65.0951 13.2854,64.0951 10.5,62.5C 8.3912,60.8783 7.3912,58.7116 7.5,56C 7.30684,53.9919 7.9735,52.4919 9.5,51.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.05
          },
          fill: "#060707",
          d: "M 141.5,54.5 C 142.633,56.0552 143.299,57.8886 143.5,60C 142.418,65.9944 141.418,71.9944 140.5,78C 140.899,79.7275 141.566,81.2275 142.5,82.5C 142.167,83.5 141.5,84.1667 140.5,84.5C 140.046,81.1349 139.38,77.8015 138.5,74.5C 139.874,67.8812 140.874,61.2146 141.5,54.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#c9cbcb",
          d: "M 26.5,58.5 C 27.0968,57.8614 27.9302,57.528 29,57.5C 38.7041,60.2002 48.5374,62.2002 58.5,63.5C 61.221,63.9628 63.8877,64.6295 66.5,65.5C 72.5358,70.1912 78.8691,74.5245 85.5,78.5C 74.6653,76.7183 63.6653,74.385 52.5,71.5C 43.8333,67.1667 35.1667,62.8333 26.5,58.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#929294",
          d: "M 10.5,62.5 C 13.2854,64.0951 16.2854,65.0951 19.5,65.5C 34.6676,71.6719 50.001,77.6719 65.5,83.5C 63.9504,84.7199 62.2837,84.7199 60.5,83.5C 47.2117,81.5939 34.2117,78.5939 21.5,74.5C 15.1127,73.7734 10.7793,70.4401 8.5,64.5C 8.83333,63.5 9.5,62.8333 10.5,62.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#494f51",
          d: "M 137.5,47.5 C 138.167,47.5 138.5,47.8333 138.5,48.5C 138.992,50.8185 139.992,52.8185 141.5,54.5C 140.874,61.2146 139.874,67.8812 138.5,74.5C 139.38,77.8015 140.046,81.1349 140.5,84.5C 138.83,87.0016 136.664,89.0016 134,90.5C 132.478,88.2591 131.145,85.9258 130,83.5C 128.544,86.0324 127.377,88.6991 126.5,91.5C 115.094,82.7537 103.427,74.4203 91.5,66.5C 87.944,63.2804 86.2774,59.2804 86.5,54.5C 99.8062,61.8211 113.14,69.1544 126.5,76.5C 128.054,74.0671 128.72,71.4005 128.5,68.5C 128.5,67.1667 128.5,65.8333 128.5,64.5C 129.322,62.6115 130.155,60.6115 131,58.5C 134.261,55.4222 136.428,51.7555 137.5,47.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.183
          },
          fill: "#060606",
          d: "M 8.5,64.5 C 10.7793,70.4401 15.1127,73.7734 21.5,74.5C 19.3021,75.1653 16.9688,75.8319 14.5,76.5C 16.3737,81.6139 20.0404,84.6139 25.5,85.5C 26.5,85.5 27.5,85.5 28.5,85.5C 28.2627,86.791 28.596,87.791 29.5,88.5C 29.5106,90.0174 30.1772,91.1841 31.5,92C 34.7365,93.7862 38.0698,95.2862 41.5,96.5C 41.5,97.1667 41.8333,97.5 42.5,97.5C 42.5494,100.099 43.5494,102.266 45.5,104C 48.8168,104.498 52.1501,104.665 55.5,104.5C 55.2627,105.791 55.596,106.791 56.5,107.5C 56.9528,108.458 57.6195,109.292 58.5,110C 61.3771,111.127 64.3771,111.794 67.5,112C 68.9852,114.237 70.9852,115.737 73.5,116.5C 76.9386,117.019 80.272,118.019 83.5,119.5C 87.2508,121.079 91.2508,122.079 95.5,122.5C 95.5,122.833 95.5,123.167 95.5,123.5C 92.5715,130.285 90.2382,137.285 88.5,144.5C 88.1667,145.167 87.8333,145.833 87.5,146.5C 87.1667,146.5 86.8333,146.5 86.5,146.5C 87.7936,139.786 89.7936,133.286 92.5,127C 87.5169,126.897 83.1836,125.23 79.5,122C 74.2686,122.485 69.9353,120.819 66.5,117C 60.8614,116.865 56.528,114.531 53.5,110C 50.1853,109.059 46.852,108.226 43.5,107.5C 41.5592,105.166 39.8925,102.666 38.5,100C 32.4206,98.8085 28.0872,95.4752 25.5,90C 17.189,88.6898 12.689,83.8564 12,75.5C 9.28221,73.2292 7.44888,70.3958 6.5,67C 7.06594,66.0053 7.73261,65.172 8.5,64.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#b8b6ac",
          d: "M 52.5,71.5 C 63.6653,74.385 74.6653,76.7183 85.5,78.5C 89.228,81.5589 93.228,84.2256 97.5,86.5C 91.3341,87.3789 85.0007,87.3789 78.5,86.5C 75.3915,86.7359 72.3915,86.4025 69.5,85.5C 68.205,84.5116 66.8717,83.5116 65.5,82.5C 60.9811,79.0708 56.6478,75.4041 52.5,71.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343f48",
          d: "M 21.5,74.5 C 34.2117,78.5939 47.2117,81.5939 60.5,83.5C 48.8333,84.1667 37.1667,84.8333 25.5,85.5C 20.0404,84.6139 16.3737,81.6139 14.5,76.5C 16.9688,75.8319 19.3021,75.1653 21.5,74.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#565a5e",
          d: "M 66.5,65.5 C 74.1667,67.5 81.8333,69.5 89.5,71.5C 90.7804,72.9313 92.4471,73.5979 94.5,73.5C 104.436,81.5934 114.269,89.9267 124,98.5C 124.333,100.5 124.667,102.5 125,104.5C 127.25,100.332 129.75,96.3318 132.5,92.5C 130.604,91.5344 128.604,91.2011 126.5,91.5C 127.377,88.6991 128.544,86.0324 130,83.5C 131.145,85.9258 132.478,88.2591 134,90.5C 136.664,89.0016 138.83,87.0016 140.5,84.5C 141.5,84.1667 142.167,83.5 142.5,82.5C 146.184,80.4717 149.85,78.4717 153.5,76.5C 153.5,76.8333 153.5,77.1667 153.5,77.5C 150.542,81.6911 148.542,86.3578 147.5,91.5C 151.5,90.5 155.5,89.5 159.5,88.5C 160.492,88.3284 161.158,88.6618 161.5,89.5C 160.26,90.6588 158.926,91.6588 157.5,92.5C 154.615,92.1936 151.948,92.5269 149.5,93.5C 148.391,93.4431 147.391,93.1098 146.5,92.5C 142.6,91.5701 138.6,91.2367 134.5,91.5C 134.46,94.8806 134.793,98.2139 135.5,101.5C 135.5,102.833 135.5,104.167 135.5,105.5C 131.563,105.207 127.73,105.54 124,106.5C 115.993,99.572 107.493,93.2387 98.5,87.5C 98.5,86.8333 98.1667,86.5 97.5,86.5C 93.228,84.2256 89.228,81.5589 85.5,78.5C 78.8691,74.5245 72.5358,70.1912 66.5,65.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#c0bbb1",
          d: "M 153.5,76.5 C 156.5,76.5 159.5,76.5 162.5,76.5C 164.526,80.5813 165.526,84.9146 165.5,89.5C 164.167,89.5 162.833,89.5 161.5,89.5C 161.158,88.6618 160.492,88.3284 159.5,88.5C 157.5,84.8333 155.5,81.1667 153.5,77.5C 153.5,77.1667 153.5,76.8333 153.5,76.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7c858b",
          d: "M 153.5,77.5 C 155.5,81.1667 157.5,84.8333 159.5,88.5C 155.5,89.5 151.5,90.5 147.5,91.5C 148.542,86.3578 150.542,81.6911 153.5,77.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.996
          },
          fill: "#898a89",
          d: "M 162.5,76.5 C 167.023,78.0073 171.523,79.674 176,81.5C 177.03,81.8361 177.53,82.5028 177.5,83.5C 177.992,85.8185 178.992,87.8185 180.5,89.5C 181.338,89.8417 181.672,90.5084 181.5,91.5C 178.012,91.7054 174.679,92.5387 171.5,94C 176.66,95.6954 181.66,97.5287 186.5,99.5C 181.93,100.441 177.263,100.774 172.5,100.5C 171.793,98.2186 170.793,96.0519 169.5,94C 165.534,93.1721 161.534,92.6721 157.5,92.5C 158.926,91.6588 160.26,90.6588 161.5,89.5C 162.184,91.1852 163.517,92.1852 165.5,92.5C 168.012,91.2162 168.012,90.2162 165.5,89.5C 165.526,84.9146 164.526,80.5813 162.5,76.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c676f",
          d: "M 65.5,82.5 C 66.8717,83.5116 68.205,84.5116 69.5,85.5C 66.8333,87.5 64.1667,89.5 61.5,91.5C 51.2474,90.3957 41.0808,88.729 31,86.5C 29.9701,86.8361 29.4701,87.5028 29.5,88.5C 28.596,87.791 28.2627,86.791 28.5,85.5C 27.5,85.5 26.5,85.5 25.5,85.5C 37.1667,84.8333 48.8333,84.1667 60.5,83.5C 62.2837,84.7199 63.9504,84.7199 65.5,83.5C 65.5,83.1667 65.5,82.8333 65.5,82.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.018
          },
          fill: "#191919",
          d: "M 177.5,83.5 C 179.539,84.911 180.539,86.911 180.5,89.5C 178.992,87.8185 177.992,85.8185 177.5,83.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#cdcfd0",
          d: "M 61.5,91.5 C 64.3522,93.0765 67.3522,94.5765 70.5,96C 60.8391,96.4998 51.1724,96.6665 41.5,96.5C 38.0698,95.2862 34.7365,93.7862 31.5,92C 30.1772,91.1841 29.5106,90.0174 29.5,88.5C 29.4701,87.5028 29.9701,86.8361 31,86.5C 41.0808,88.729 51.2474,90.3957 61.5,91.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7c858b",
          d: "M 78.5,86.5 C 85.0007,87.3789 91.3341,87.3789 97.5,86.5C 98.1667,86.5 98.5,86.8333 98.5,87.5C 95.9058,93.1859 92.9058,98.6859 89.5,104C 89.7284,104.399 90.0618,104.565 90.5,104.5C 94.7789,107.029 99.1122,109.363 103.5,111.5C 97.296,115.128 90.6293,117.795 83.5,119.5C 80.272,118.019 76.9386,117.019 73.5,116.5C 76.1873,116.664 78.854,116.497 81.5,116C 83.5871,112.492 85.9204,109.158 88.5,106C 88.2716,105.601 87.9382,105.435 87.5,105.5C 87.5,104.833 87.5,104.167 87.5,103.5C 87.9382,103.565 88.2716,103.399 88.5,103C 84.7673,97.6938 81.434,92.1938 78.5,86.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#3c413e",
          d: "M 91.5,66.5 C 103.427,74.4203 115.094,82.7537 126.5,91.5C 128.604,91.2011 130.604,91.5344 132.5,92.5C 129.75,96.3318 127.25,100.332 125,104.5C 124.667,102.5 124.333,100.5 124,98.5C 114.269,89.9267 104.436,81.5934 94.5,73.5C 92.1496,71.7867 91.1496,69.4534 91.5,66.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#e2730e",
          d: "M 161.5,89.5 C 162.833,89.5 164.167,89.5 165.5,89.5C 168.012,90.2162 168.012,91.2162 165.5,92.5C 163.517,92.1852 162.184,91.1852 161.5,89.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#b7b5ac",
          d: "M 146.5,92.5 C 147.265,95.0961 147.599,97.7628 147.5,100.5C 147.5,100.833 147.5,101.167 147.5,101.5C 143.569,102.132 140.235,103.799 137.5,106.5C 137.167,106.5 136.833,106.5 136.5,106.5C 136.784,104.585 136.451,102.919 135.5,101.5C 134.793,98.2139 134.46,94.8806 134.5,91.5C 138.6,91.2367 142.6,91.5701 146.5,92.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.998
          },
          fill: "#babbba",
          d: "M 181.5,91.5 C 184.81,93.4821 187.81,95.8154 190.5,98.5C 189.432,99.4345 188.099,99.7678 186.5,99.5C 181.66,97.5287 176.66,95.6954 171.5,94C 174.679,92.5387 178.012,91.7054 181.5,91.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#353f49",
          d: "M 146.5,92.5 C 147.391,93.1098 148.391,93.4431 149.5,93.5C 153.167,94.1667 156.833,94.8333 160.5,95.5C 156.624,98.1293 152.29,99.796 147.5,100.5C 147.599,97.7628 147.265,95.0961 146.5,92.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#d0c9c0",
          d: "M 149.5,93.5 C 151.948,92.5269 154.615,92.1936 157.5,92.5C 161.534,92.6721 165.534,93.1721 169.5,94C 170.793,96.0519 171.793,98.2186 172.5,100.5C 168.52,98.8702 164.52,97.2035 160.5,95.5C 156.833,94.8333 153.167,94.1667 149.5,93.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7e8182",
          d: "M 160.5,95.5 C 164.52,97.2035 168.52,98.8702 172.5,100.5C 172.5,101.167 172.167,101.5 171.5,101.5C 163.981,101.175 156.648,101.508 149.5,102.5C 148.833,102.167 148.167,101.833 147.5,101.5C 147.5,101.167 147.5,100.833 147.5,100.5C 152.29,99.796 156.624,98.1293 160.5,95.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c666f",
          d: "M 42.5,97.5 C 52.1724,97.3335 61.8391,97.5002 71.5,98C 66.7133,99.8932 62.0466,102.06 57.5,104.5C 56.6143,105.325 56.281,106.325 56.5,107.5C 55.596,106.791 55.2627,105.791 55.5,104.5C 52.1501,104.665 48.8168,104.498 45.5,104C 43.5494,102.266 42.5494,100.099 42.5,97.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d6871",
          d: "M 87.5,103.5 C 87.5,104.167 87.5,104.833 87.5,105.5C 81.5738,106.774 75.7404,108.441 70,110.5C 69.5,110.167 69,109.833 68.5,109.5C 69.9376,105.167 71.9376,101.167 74.5,97.5C 78.9793,99.2405 83.3126,101.24 87.5,103.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.165
          },
          fill: "#070707",
          d: "M 190.5,98.5 C 192.676,99.7133 193.009,101.38 191.5,103.5C 185.274,105.018 178.94,105.852 172.5,106C 168.352,109.314 164.352,112.814 160.5,116.5C 157.833,124.323 154.667,131.99 151,139.5C 147.796,142.369 144.963,145.535 142.5,149C 139.761,150.026 137.428,151.526 135.5,153.5C 134.609,152.89 133.609,152.557 132.5,152.5C 131.833,152.5 131.167,152.5 130.5,152.5C 130.5,151.833 130.5,151.167 130.5,150.5C 131.167,150.5 131.5,150.167 131.5,149.5C 139.372,146.766 145.372,141.766 149.5,134.5C 150.167,134.5 150.5,134.167 150.5,133.5C 153.099,127.704 155.099,121.704 156.5,115.5C 157.167,115.5 157.5,115.167 157.5,114.5C 157.833,113.5 158.5,112.833 159.5,112.5C 163.5,108.833 167.5,105.167 171.5,101.5C 172.167,101.5 172.5,101.167 172.5,100.5C 177.263,100.774 181.93,100.441 186.5,99.5C 188.099,99.7678 189.432,99.4345 190.5,98.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#cdcfcf",
          d: "M 147.5,101.5 C 148.167,101.833 148.833,102.167 149.5,102.5C 153.14,105.473 156.473,108.806 159.5,112.5C 158.5,112.833 157.833,113.5 157.5,114.5C 150.833,111.833 144.167,109.167 137.5,106.5C 140.235,103.799 143.569,102.132 147.5,101.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343e48",
          d: "M 171.5,101.5 C 167.5,105.167 163.5,108.833 159.5,112.5C 156.473,108.806 153.14,105.473 149.5,102.5C 156.648,101.508 163.981,101.175 171.5,101.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#969798",
          d: "M 69.5,85.5 C 72.3915,86.4025 75.3915,86.7359 78.5,86.5C 81.434,92.1938 84.7673,97.6938 88.5,103C 88.2716,103.399 87.9382,103.565 87.5,103.5C 83.3126,101.24 78.9793,99.2405 74.5,97.5C 71.9376,101.167 69.9376,105.167 68.5,109.5C 69,109.833 69.5,110.167 70,110.5C 75.7404,108.441 81.5738,106.774 87.5,105.5C 87.9382,105.435 88.2716,105.601 88.5,106C 85.9204,109.158 83.5871,112.492 81.5,116C 78.854,116.497 76.1873,116.664 73.5,116.5C 70.9852,115.737 68.9852,114.237 67.5,112C 64.3771,111.794 61.3771,111.127 58.5,110C 57.6195,109.292 56.9528,108.458 56.5,107.5C 56.281,106.325 56.6143,105.325 57.5,104.5C 62.0466,102.06 66.7133,99.8932 71.5,98C 61.8391,97.5002 52.1724,97.3335 42.5,97.5C 41.8333,97.5 41.5,97.1667 41.5,96.5C 51.1724,96.6665 60.8391,96.4998 70.5,96C 67.3522,94.5765 64.3522,93.0765 61.5,91.5C 64.1667,89.5 66.8333,87.5 69.5,85.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#bfc2c4",
          d: "M 90.5,104.5 C 100.989,105.041 111.322,105.707 121.5,106.5C 115.431,107.914 109.431,109.581 103.5,111.5C 99.1122,109.363 94.7789,107.029 90.5,104.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d6870",
          d: "M 98.5,87.5 C 107.493,93.2387 115.993,99.572 124,106.5C 127.73,105.54 131.563,105.207 135.5,105.5C 135.5,104.167 135.5,102.833 135.5,101.5C 136.451,102.919 136.784,104.585 136.5,106.5C 135.724,113.137 135.391,119.804 135.5,126.5C 129.121,126.038 122.788,125.538 116.5,125C 118.606,128.039 120.106,131.205 121,134.5C 116.332,132.082 111.499,130.082 106.5,128.5C 106.5,128.167 106.5,127.833 106.5,127.5C 106.5,126.833 106.833,126.5 107.5,126.5C 110.315,126.796 112.982,125.796 115.5,123.5C 114.639,121.089 113.306,119.089 111.5,117.5C 115.841,114.189 119.174,110.522 121.5,106.5C 111.322,105.707 100.989,105.041 90.5,104.5C 90.0618,104.565 89.7284,104.399 89.5,104C 92.9058,98.6859 95.9058,93.1859 98.5,87.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#959697",
          d: "M 136.5,106.5 C 136.833,106.5 137.167,106.5 137.5,106.5C 144.167,109.167 150.833,111.833 157.5,114.5C 157.5,115.167 157.167,115.5 156.5,115.5C 150.409,118.408 144.409,121.574 138.5,125C 137.619,125.708 136.953,126.542 136.5,127.5C 131.952,129.107 127.619,131.274 123.5,134C 127.152,134.499 130.818,134.665 134.5,134.5C 131.038,135.482 127.371,135.815 123.5,135.5C 121.308,139.098 120.308,143.098 120.5,147.5C 119.869,149.934 118.869,152.268 117.5,154.5C 116.833,155.5 116.167,156.5 115.5,157.5C 114.18,156.058 112.514,155.392 110.5,155.5C 108.704,154.207 107.037,152.707 105.5,151C 108.833,150.667 112.167,150.333 115.5,150C 107.624,149.113 99.7911,147.946 92,146.5C 90.6244,146.316 89.7911,145.649 89.5,144.5C 95.1404,139.195 100.807,133.861 106.5,128.5C 111.499,130.082 116.332,132.082 121,134.5C 120.106,131.205 118.606,128.039 116.5,125C 122.788,125.538 129.121,126.038 135.5,126.5C 135.391,119.804 135.724,113.137 136.5,106.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#56595b",
          d: "M 121.5,106.5 C 119.174,110.522 115.841,114.189 111.5,117.5C 106.167,119.167 100.833,120.833 95.5,122.5C 91.2508,122.079 87.2508,121.079 83.5,119.5C 90.6293,117.795 97.296,115.128 103.5,111.5C 109.431,109.581 115.431,107.914 121.5,106.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#56585a",
          d: "M 156.5,115.5 C 155.099,121.704 153.099,127.704 150.5,133.5C 145.597,132.048 140.93,130.048 136.5,127.5C 136.953,126.542 137.619,125.708 138.5,125C 144.409,121.574 150.409,118.408 156.5,115.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#858689",
          d: "M 111.5,117.5 C 110.16,120.529 108.827,123.529 107.5,126.5C 106.833,126.5 106.5,126.833 106.5,127.5C 102.721,126.442 99.0541,125.109 95.5,123.5C 95.5,123.167 95.5,122.833 95.5,122.5C 100.833,120.833 106.167,119.167 111.5,117.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#37414b",
          d: "M 111.5,117.5 C 113.306,119.089 114.639,121.089 115.5,123.5C 112.982,125.796 110.315,126.796 107.5,126.5C 108.827,123.529 110.16,120.529 111.5,117.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#343e48",
          d: "M 95.5,123.5 C 99.0541,125.109 102.721,126.442 106.5,127.5C 106.5,127.833 106.5,128.167 106.5,128.5C 100.807,133.861 95.1404,139.195 89.5,144.5C 89.1667,144.5 88.8333,144.5 88.5,144.5C 90.2382,137.285 92.5715,130.285 95.5,123.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#ced0d0",
          d: "M 136.5,127.5 C 140.93,130.048 145.597,132.048 150.5,133.5C 150.5,134.167 150.167,134.5 149.5,134.5C 144.5,134.5 139.5,134.5 134.5,134.5C 130.818,134.665 127.152,134.499 123.5,134C 127.619,131.274 131.952,129.107 136.5,127.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#7b8389",
          d: "M 134.5,134.5 C 139.5,134.5 144.5,134.5 149.5,134.5C 145.372,141.766 139.372,146.766 131.5,149.5C 128.406,145.074 125.739,140.407 123.5,135.5C 127.371,135.815 131.038,135.482 134.5,134.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#36414b",
          d: "M 123.5,135.5 C 125.739,140.407 128.406,145.074 131.5,149.5C 131.5,150.167 131.167,150.5 130.5,150.5C 126.881,150.119 123.548,149.119 120.5,147.5C 120.308,143.098 121.308,139.098 123.5,135.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5d676f",
          d: "M 88.5,144.5 C 88.8333,144.5 89.1667,144.5 89.5,144.5C 89.7911,145.649 90.6244,146.316 92,146.5C 99.7911,147.946 107.624,149.113 115.5,150C 112.167,150.333 108.833,150.667 105.5,151C 107.037,152.707 108.704,154.207 110.5,155.5C 107.085,162 103.418,168.333 99.5,174.5C 101.095,168.717 103.095,163.051 105.5,157.5C 103.5,156.833 101.5,156.167 99.5,155.5C 101.316,154.185 102.983,152.685 104.5,151C 99.8333,150.333 95.1667,150.333 90.5,151C 91.4118,153.205 92.7451,155.038 94.5,156.5C 94.5,157.167 94.1667,157.5 93.5,157.5C 83.3942,165.095 73.3942,172.928 63.5,181C 62.8333,181.667 62.1667,181.667 61.5,181C 69.3025,172.197 77.4691,163.697 86,155.5C 87.1821,153.656 88.3488,151.823 89.5,150C 89.1918,148.541 88.5251,147.374 87.5,146.5C 87.8333,145.833 88.1667,145.167 88.5,144.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.999
          },
          fill: "#5e686e",
          d: "M 120.5,147.5 C 123.548,149.119 126.881,150.119 130.5,150.5C 130.5,151.167 130.5,151.833 130.5,152.5C 129.039,151.314 127.705,151.314 126.5,152.5C 123.402,152.756 120.402,153.422 117.5,154.5C 118.869,152.268 119.869,149.934 120.5,147.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.961
          },
          fill: "#b3afa3",
          d: "M 130.5,152.5 C 131.167,152.5 131.833,152.5 132.5,152.5C 133.306,153.728 134.306,154.728 135.5,155.5C 132.145,155.31 129.145,154.31 126.5,152.5C 127.705,151.314 129.039,151.314 130.5,152.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.988
          },
          fill: "#686b65",
          d: "M 132.5,152.5 C 133.609,152.557 134.609,152.89 135.5,153.5C 137.292,153.366 138.958,153.699 140.5,154.5C 139.789,156.03 138.789,157.363 137.5,158.5C 134.932,158.594 133.432,159.928 133,162.5C 131.794,159.162 132.96,157.329 136.5,157C 135.944,156.617 135.611,156.117 135.5,155.5C 134.306,154.728 133.306,153.728 132.5,152.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.176
          },
          fill: "#030404",
          d: "M 110.5,155.5 C 112.514,155.392 114.18,156.058 115.5,157.5C 117.986,159.155 119.986,161.322 121.5,164C 119.419,166.818 119.085,169.818 120.5,173C 121.167,173.667 121.833,173.667 122.5,173C 120.775,166.133 122.608,164.966 128,169.5C 129.505,171.298 129.672,173.132 128.5,175C 132.204,174.516 132.538,172.849 129.5,170C 132.657,170.176 134.157,172.009 134,175.5C 135.689,173.68 135.855,171.68 134.5,169.5C 137.686,172.399 138.02,175.566 135.5,179C 132.207,179.826 128.874,180.326 125.5,180.5C 127.089,177.036 126.589,174.036 124,171.5C 125.225,174.331 124.559,176.664 122,178.5C 119.086,177.252 117.253,175.086 116.5,172C 117.791,169.95 118.291,167.783 118,165.5C 116.316,163.649 114.483,161.982 112.5,160.5C 111.522,160.977 110.689,161.643 110,162.5C 105.922,170.991 101.588,179.324 97,187.5C 95.786,189.049 94.286,190.215 92.5,191C 77.4054,197.181 62.9054,196.014 49,187.5C 48.1742,184.788 48.6742,182.455 50.5,180.5C 50.238,181.978 50.5713,183.311 51.5,184.5C 56.3296,185.951 60.9962,187.617 65.5,189.5C 70.2981,190.744 74.9648,190.744 79.5,189.5C 82.9419,190.172 85.6086,189.172 87.5,186.5C 90.1569,186.838 92.4902,186.171 94.5,184.5C 96.705,181.423 98.3716,178.09 99.5,174.5C 103.418,168.333 107.085,162 110.5,155.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#555759",
          d: "M 94.5,156.5 C 96.0481,156.821 96.7148,157.821 96.5,159.5C 89.8331,168.856 83.4997,178.523 77.5,188.5C 77.9569,189.298 78.6236,189.631 79.5,189.5C 74.9648,190.744 70.2981,190.744 65.5,189.5C 68.4045,187.101 71.2379,184.435 74,181.5C 80.2688,173.286 86.7688,165.286 93.5,157.5C 94.1667,157.5 94.5,157.167 94.5,156.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.99
          },
          fill: "#2d363e",
          d: "M 140.5,154.5 C 143.802,155.294 147.135,155.96 150.5,156.5C 149.645,158.787 149.478,161.12 150,163.5C 148.334,164.34 148.167,163.84 149.5,162C 148.25,159.375 146.25,158.375 143.5,159C 146.47,162.145 145.97,164.645 142,166.5C 141.667,164.953 142.167,163.62 143.5,162.5C 142.833,159.167 140.833,157.833 137.5,158.5C 138.789,157.363 139.789,156.03 140.5,154.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#898f8c",
          d: "M 99.5,174.5 C 98.3716,178.09 96.705,181.423 94.5,184.5C 92.4902,186.171 90.1569,186.838 87.5,186.5C 90.2985,177.438 93.2985,168.438 96.5,159.5C 96.7148,157.821 96.0481,156.821 94.5,156.5C 92.7451,155.038 91.4118,153.205 90.5,151C 95.1667,150.333 99.8333,150.333 104.5,151C 102.983,152.685 101.316,154.185 99.5,155.5C 101.5,156.167 103.5,156.833 105.5,157.5C 103.095,163.051 101.095,168.717 99.5,174.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 0.132
          },
          fill: "#040505",
          d: "M 126.5,152.5 C 129.145,154.31 132.145,155.31 135.5,155.5C 135.611,156.117 135.944,156.617 136.5,157C 132.96,157.329 131.794,159.162 133,162.5C 133.432,159.928 134.932,158.594 137.5,158.5C 140.833,157.833 142.833,159.167 143.5,162.5C 142.167,163.62 141.667,164.953 142,166.5C 145.97,164.645 146.47,162.145 143.5,159C 146.25,158.375 148.25,159.375 149.5,162C 148.167,163.84 148.334,164.34 150,163.5C 149.478,161.12 149.645,158.787 150.5,156.5C 153.859,160.675 153.525,164.842 149.5,169C 146.36,168.418 143.36,168.751 140.5,170C 139.351,168.396 139.351,166.73 140.5,165C 140.387,163.72 139.72,162.887 138.5,162.5C 136.599,164.006 134.932,165.673 133.5,167.5C 132.29,167.068 131.29,166.401 130.5,165.5C 130.784,163.123 130.784,160.956 130.5,159C 128.722,158.296 126.888,157.796 125,157.5C 123.301,157.387 122.134,158.053 121.5,159.5C 119.413,158.415 118.08,156.749 117.5,154.5C 120.402,153.422 123.402,152.756 126.5,152.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#828688",
          d: "M 86.5,146.5 C 86.8333,146.5 87.1667,146.5 87.5,146.5C 88.5251,147.374 89.1918,148.541 89.5,150C 88.3488,151.823 87.1821,153.656 86,155.5C 77.4691,163.697 69.3025,172.197 61.5,181C 62.1667,181.667 62.8333,181.667 63.5,181C 73.3942,172.928 83.3942,165.095 93.5,157.5C 86.7688,165.286 80.2688,173.286 74,181.5C 71.2379,184.435 68.4045,187.101 65.5,189.5C 60.9962,187.617 56.3296,185.951 51.5,184.5C 50.5713,183.311 50.238,181.978 50.5,180.5C 62.1716,168.829 74.1716,157.495 86.5,146.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#5c666f",
          d: "M 96.5,159.5 C 93.2985,168.438 90.2985,177.438 87.5,186.5C 85.6086,189.172 82.9419,190.172 79.5,189.5C 78.6236,189.631 77.9569,189.298 77.5,188.5C 83.4997,178.523 89.8331,168.856 96.5,159.5 Z"
        }
      ) }),
      (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          style: {
            opacity: 1
          },
          fill: "#3b4346",
          d: "M 117.5,154.5 C 118.08,156.749 119.413,158.415 121.5,159.5C 124.328,161.748 127.328,163.748 130.5,165.5C 131.29,166.401 132.29,167.068 133.5,167.5C 133.833,168.167 134.167,168.833 134.5,169.5C 135.855,171.68 135.689,173.68 134,175.5C 134.157,172.009 132.657,170.176 129.5,170C 132.538,172.849 132.204,174.516 128.5,175C 129.672,173.132 129.505,171.298 128,169.5C 122.608,164.966 120.775,166.133 122.5,173C 121.833,173.667 121.167,173.667 120.5,173C 119.085,169.818 119.419,166.818 121.5,164C 119.986,161.322 117.986,159.155 115.5,157.5C 116.167,156.5 116.833,155.5 117.5,154.5 Z"
        }
      ) })
    ]
  }
);
var m2e = ({
  size: e,
  className: t,
  variant: r,
  walletName: n
}) => n === uc ? (0, import_jsx_runtime.jsx)(kye, { size: e, className: t, variant: r }) : n === fu ? (0, import_jsx_runtime.jsx)(Sye, { size: e, className: t, variant: r }) : n === uu ? (0, import_jsx_runtime.jsx)(xx, { size: e, className: t, variant: r }) : n === Bs ? (0, import_jsx_runtime.jsx)(Tye, { size: e, className: t, variant: r }) : n === lu ? (0, import_jsx_runtime.jsx)(_ye, { size: e, className: t, variant: r }) : n === hc ? (0, import_jsx_runtime.jsx)(Hye, { size: e, className: t, variant: r }) : n === lc ? (0, import_jsx_runtime.jsx)(xye, { size: e, className: t, variant: r }) : n === cc ? (0, import_jsx_runtime.jsx)(Aye, { size: e, className: t, variant: r }) : n === cu ? (0, import_jsx_runtime.jsx)(Eye, { size: e, className: t, variant: r }) : n === fc ? (0, import_jsx_runtime.jsx)(Pye, { size: e, className: t, variant: r }) : n === dc ? (0, import_jsx_runtime.jsx)(zye, { size: e, className: t, variant: r }) : (0, import_jsx_runtime.jsx)(xx, { size: e, className: t, variant: r });
export {
  Gwe as APPLICATION_ATOM_XML,
  Wwe as APPLICATION_FORM_URLENCODED,
  Mwe as APPLICATION_GZIP,
  jwe as APPLICATION_JAVASCRIPT,
  Lwe as APPLICATION_JSON,
  Zwe as APPLICATION_OCTET_STREAM,
  Dwe as APPLICATION_PDF,
  Vwe as APPLICATION_RSS_XML,
  qwe as APPLICATION_XHTML_XML,
  Fwe as APPLICATION_XML,
  Kwe as APPLICATION_ZIP,
  i2e as AUDIO_MP3,
  a2e as AUDIO_OGG,
  s2e as AUDIO_WAV,
  Pp as CMDRUID_MAINNET,
  yW as CMDRUID_SIGNET,
  F4 as CMDRUID_TESTNET,
  no as FRACTAL_MAINNET,
  Cr as FRACTAL_TESTNET,
  Gc as GLITTR,
  IA as GLITTR_DEVNET,
  SA as GLITTR_WALLET_DEVNET,
  Jwe as IMAGE_GIF,
  t2e as IMAGE_ICON,
  Xwe as IMAGE_JPEG,
  Ywe as IMAGE_PNG,
  Qwe as IMAGE_SVG_XML,
  e2e as IMAGE_WEBP,
  kl as LEATHER,
  zw as LEATHER_MAINNET,
  PA as LEATHER_TESTNET,
  fb as LOCAL_STORAGE_DEFAULT_WALLET,
  f2e as LaserEyesClient,
  g2e as LaserEyesLogo,
  p2e as LaserEyesProvider,
  xx as LeatherLogo,
  oc as MAGIC_EDEN,
  Tt as MAINNET,
  c2e as MULTIPART_FORM_DATA,
  Tye as MagicEdenLogo,
  Al as OKX,
  mW as OKX_MAINNET,
  bW as OKX_TESTNET,
  Yc as OP_NET,
  Pwe as OP_WALLET_MAINNET,
  Iwe as OP_WALLET_TESTNET,
  Xc as ORANGE,
  Tp as ORANGE_MAINNET,
  Wb as ORANGE_TESTNET,
  xl as OYL,
  _ye as OkxLogo,
  Eye as OylLogo,
  KC as P2PKH,
  Kye as P2PSH,
  Ax as P2SH,
  MC as P2SH_P2WPKH,
  bd as P2TR,
  Jy as P2WPKH,
  qC as P2WSH,
  Zc as PHANTOM,
  xye as PhantomLogo,
  Owe as REGTEST,
  Vr as SIGNET,
  Jc as SPARROW,
  Mye as SUPPORTED_WALLETS,
  Mt as TESTNET,
  Br as TESTNET4,
  Rwe as TEXT_CSS,
  $we as TEXT_HTML,
  zwe as TEXT_JAVASCRIPT,
  Hwe as TEXT_MARKDOWN,
  nX as TEXT_PLAIN,
  Vc as UNISAT,
  B1 as UNISAT_FRACTAL_MAINNET,
  C1 as UNISAT_FRACTAL_TESTNET,
  tf as UNISAT_MAINNET,
  O1 as UNISAT_SIGNET,
  P1 as UNISAT_TESTNET,
  I1 as UNISAT_TESTNET4,
  Zw as UNSUPPORTED_PROVIDER_METHOD_ERROR,
  Aye as UnisatLogo,
  r2e as VIDEO_MP4,
  o2e as VIDEO_OGG,
  n2e as VIDEO_WEBM,
  pY as WALLET_NOT_INSTALLED_ERROR,
  Sl as WIZZ,
  Ed as WIZZ_MAINNET,
  TA as WIZZ_SIGNET,
  Rw as WIZZ_TESTNET,
  _A as WIZZ_TESTNET4,
  m2e as WalletIcon,
  Do as WalletProvider,
  Sye as WizzLogo,
  Wc as XVERSE,
  pd as XVERSE_MAINNET,
  Twe as XVERSE_NETWORK,
  gW as XVERSE_SIGNET,
  $w as XVERSE_TESTNET,
  kye as XverseLogo,
  l2e as createConfig,
  u2e as createStores,
  vW as getCmDruidNetwork,
  wW as getGlittrNetwork,
  Bwe as getLeatherNetwork,
  D4 as getNetworkForGlittr,
  Uwe as getNetworkForLeather,
  EW as getNetworkForOkx,
  sg as getNetworkForUnisat,
  K4 as getNetworkForWizz,
  Nwe as getNetworkForXverse,
  Zb as getOrangeNetwork,
  l0 as getSatsConnectNetwork,
  OA as getUnisatNetwork,
  Cwe as getWizzNetwork,
  h2e as useLaserEyes
};
/*! Bundled license information:

@glittr-sdk/lasereyes/dist/index.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@glittr-sdk_lasereyes.js.map
